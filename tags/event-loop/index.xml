<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Event Loop on AmiaaaZ's Site</title><link>https://amiaaaz.github.io/tags/event-loop/</link><description>Recent content in Event Loop on AmiaaaZ's Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 07 Mar 2024 23:38:41 +0800</lastBuildDate><atom:link href="https://amiaaaz.github.io/tags/event-loop/index.xml" rel="self" type="application/rss+xml"/><item><title>JavaScript的事件循环机制</title><link>https://amiaaaz.github.io/2024/03/07/event-loop-in-javascript/</link><pubDate>Thu, 07 Mar 2024 23:38:41 +0800</pubDate><guid>https://amiaaaz.github.io/2024/03/07/event-loop-in-javascript/</guid><description>&lt;p>JavaScript的应用场景天然具有高交互性，同时为了平衡效率和减少并发问题，js以单线程运行，任务的执行则使用Event Loop事件循环机制，具体实现根据Runtime不同而不同&lt;/p>
&lt;h2 id="浏览器中的event-loop">浏览器中的Event Loop&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Start&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">setTimeout&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Async task 1&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">},&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">setTimeout&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Async task 2&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">},&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">Promise&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">resolve&lt;/span>&lt;span style="color:#111">().&lt;/span>&lt;span style="color:#75af00">then&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Microtask 1&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">Promise&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">resolve&lt;/span>&lt;span style="color:#111">().&lt;/span>&lt;span style="color:#75af00">then&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Microtask 2&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;End&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code># 执行结果
Start
End
Microtask 1
Microtask 2
Async task 1
Async task 2
&lt;/code>&lt;/pre>&lt;p>以上述代码为例，console.log函数是synchronous同步任务，会按顺序在主线程上执行，而夹在中间的setTimeout和Promise均属于asynchronous异步任务，不进入主线程，而是位于task queue任务队列，只有当任务队列通知主线程可以执行了，才会排到执行栈中等待执行（而不是立刻执行，需要等待执行栈空了或是轮到它）&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Start&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">setTimeout&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Async task 1&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">},&lt;/span> &lt;span style="color:#ae81ff">10000&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">Promise&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">resolve&lt;/span>&lt;span style="color:#111">().&lt;/span>&lt;span style="color:#75af00">then&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;Microtask 1&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;End&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>异步任务之间亦有差距，Promise的优先级高于setTimeout（原因稍后再解释），所以上述代码执行结果是Start-&amp;gt; End-&amp;gt; Micro-&amp;gt; Async，即使将setTimeout改为0，也只意味着可以在当前执行栈做完后最早执行，仍然是最后输出结果&lt;/p>
&lt;p>主线程从任务队列中读取事件是个循环的过程，这个机制就叫Event Loop；在js代码编写过程中，如果同步代码和异步代码混着写，就可能出现意料之外的执行结果：最初定义的变量在if循环中不断+1结果最终输出的还是初始值&lt;/p>
&lt;h3 id="宏任务微任务">宏任务&amp;amp;微任务&lt;/h3>
&lt;p>回到开头实例代码中的Micro&amp;amp;Async，Event Loop会将任务队列分为Micro Task Queue宏任务队列和Micro Task Queue微任务队列，Promise就属于宏任务，setTimeout就属于微任务&lt;/p>
&lt;ul>
&lt;li>微任务
&lt;ul>
&lt;li>Promise中的then, catch, finally&lt;/li>
&lt;li>MutationObserver：监视DOM变化的API&lt;/li>
&lt;li>Object.observe(deprecated)：监视对象的变化&lt;/li>
&lt;li>Process.nextTick：Node中的API&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>宏任务
&lt;ul>
&lt;li>DOM操作&lt;/li>
&lt;li>用户交互操作&lt;/li>
&lt;li>网络请求&lt;/li>
&lt;li>定时器相关的setTimeout, setInterval&lt;/li>
&lt;li>script中的代码&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>前面说过，主线程对任务队列的读取时是循环进行的，先同步再异步，而每一次循环都是先从宏任务开始，微任务结束，而宏任务、微任务中又可以区分异步与同步&lt;/p>
&lt;p>宏任务中的同步代码优先进入主线程，按顺序执行完毕，当主线程空闲时执行同层的微任务；首层Event Loop结束后进入第二层事件循环，如此继续looplooploop&lt;/p>
&lt;p>举例：&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240307213004050.png" alt="image-20240307213004050">&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240307213855122.png" alt="image-20240307213855122">&lt;/p>
&lt;p>需要注意的是，Promise中只有then, catch, finally是异步执行代码，Promise中传入的回调函数属于同步执行代码&lt;/p>
&lt;h2 id="node中的event-loop">Node中的Event Loop&lt;/h2>
&lt;p>注意：在执行结果上，除Node特有的process对象及相关API外，基本与浏览器环境下没有区别。&lt;/p>
&lt;h3 id="六阶段">六阶段&lt;/h3>
&lt;p>与浏览器区别最大的地方在于Node事件循环不是一层一层的，而是按顺序在6阶段中循环&lt;/p>
&lt;ul>
&lt;li>timers: 执行setTimeout和setInterval中到期的callback&lt;/li>
&lt;li>pending callback: 上一轮循环中被推迟的callback，如某些系统操作的回调（比如TCP错误）&lt;/li>
&lt;li>idle, prepare: 仅在内部使用&lt;/li>
&lt;li>poll: 检索新的I/O事件，执行I/O有关的回调（几乎所有回调都不包括关闭回调、被计时器调度的回调以及&lt;code>setImmediate()&lt;/code>），node会在此处适时阻塞（重要）&lt;/li>
&lt;li>check: &lt;code>setImmediate()&lt;/code>的callback&lt;/li>
&lt;li>close callbacks: 一些close事件的callback，例如&lt;code>socket.on('close', ...)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>每一个阶段都是FIFO的队列，当事件循环进入给定阶段后将执行该阶段的操作，然后执行该阶段队列中的回调，直到队列尽头或达到回调限制，然后进入下一个阶段，以此类推&lt;/p>
&lt;h3 id="timers">timers&lt;/h3>
&lt;p>timers中回调的实际执行时间会和定时器的间隔有一定出入，因为虽然定时器回调函数尽可能快的安排被执行，但操作系统的调度或其它回调函数的运行可能会推迟这个时间，poll阶段会对此进行控制&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a8c8">const&lt;/span> &lt;span style="color:#75af00">fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#75af00">require&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;node:fs&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a8c8">function&lt;/span> &lt;span style="color:#75af00">someAsyncOperation&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#75af00">callback&lt;/span>&lt;span style="color:#111">)&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// Assume this takes 95ms to complete
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#75af00">fs&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">readFile&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;/path/to/file&amp;#39;&lt;/span>&lt;span style="color:#111">,&lt;/span> &lt;span style="color:#75af00">callback&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a8c8">const&lt;/span> &lt;span style="color:#75af00">timeoutScheduled&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#111">Date&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">now&lt;/span>&lt;span style="color:#111">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">setTimeout&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a8c8">const&lt;/span> &lt;span style="color:#75af00">delay&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#111">Date&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">now&lt;/span>&lt;span style="color:#111">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#75af00">timeoutScheduled&lt;/span>&lt;span style="color:#111">;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">`&lt;/span>&lt;span style="color:#d88200">${&lt;/span>&lt;span style="color:#75af00">delay&lt;/span>&lt;span style="color:#d88200">}&lt;/span>&lt;span style="color:#d88200">ms have passed since I was scheduled`&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">},&lt;/span> &lt;span style="color:#ae81ff">100&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// do someAsyncOperation which takes 95 ms to complete
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#75af00">someAsyncOperation&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#00a8c8">const&lt;/span> &lt;span style="color:#75af00">startCallback&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#111">Date&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">now&lt;/span>&lt;span style="color:#111">();&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do something that will take 10ms...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#00a8c8">while&lt;/span> &lt;span style="color:#111">(&lt;/span>&lt;span style="color:#111">Date&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">now&lt;/span>&lt;span style="color:#111">()&lt;/span> &lt;span style="color:#f92672">-&lt;/span> &lt;span style="color:#75af00">startCallback&lt;/span> &lt;span style="color:#f92672">&amp;lt;&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>&lt;span style="color:#111">)&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// do nothing
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#111">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240307231905230.png" alt="image-20240307231905230">&lt;/p>
&lt;p>第7行的setTimeout定时器设定是100ms，但实际运行结果在100~120ms之间波动&lt;/p>
&lt;h3 id="poll">poll&lt;/h3>
&lt;p>没有&lt;code>setImmediate()&lt;/code>的话poll阶段将是最终阶段，会控制timers何时被执行，它会计算为了I/O该阻塞多久，并依次处理此队列中的事件&lt;/p>
&lt;p>如果当事件循环进入到poll阶段却根本没有计时器，将会按以下规则对号入座：&lt;/p>
&lt;ul>
&lt;li>poll队列非空：事件循环将进行迭代队列中的回调函数并同步执行它们，直到队列被清空或者达到系统限制为止&lt;/li>
&lt;li>poll队列为空：
&lt;ul>
&lt;li>如果有&lt;code>setImmediate()&lt;/code>：事件循环将结束poll阶段，进入check阶段&lt;/li>
&lt;li>没有&lt;code>setImmediate()&lt;/code>：等待回调加入队列，一旦加入就立刻执行&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="setimmediate-vs-settimeout">setImmediate vs setTimeout&lt;/h3>
&lt;p>当它们不在一个I/O周期中时，两个计时器先后不确定&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">setTimeout&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;setTimeout&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">},&lt;/span>&lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#111">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">setImmediate&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;setImmediate&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">})&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>以上代码运行多次会有不同的输出结果&lt;/p>
&lt;p>当两者被放入同一个I/O循环中时，&lt;code>setImmediate()&lt;/code>总是优先调用&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-js" data-lang="js">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a8c8">const&lt;/span> &lt;span style="color:#75af00">fs&lt;/span> &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#75af00">require&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;fs&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75af00">fs&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">readFile&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#75af00">__filename&lt;/span>&lt;span style="color:#111">,&lt;/span> &lt;span style="color:#111">()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">setTimeout&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;timeout&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#111">},&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">setImmediate&lt;/span>&lt;span style="color:#111">(()&lt;/span> &lt;span style="color:#111">=&amp;gt;&lt;/span> &lt;span style="color:#111">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75af00">console&lt;/span>&lt;span style="color:#111">.&lt;/span>&lt;span style="color:#75af00">log&lt;/span>&lt;span style="color:#111">(&lt;/span>&lt;span style="color:#d88200">&amp;#39;immediate&amp;#39;&lt;/span>&lt;span style="color:#111">);&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#111">});&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#111">});&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;p>参考链接：&lt;/p>
&lt;p>&lt;a href="https://blog.huli.tw/2022/02/09/javascript-runtime/">從「為什麼不能用這個函式」談執行環境（runtime）&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html">JavaScript 运行机制详解：再谈Event Loop&lt;/a>&lt;/p>
&lt;p>&lt;a href="https://zhuanlan.zhihu.com/p/388710842">Event Loop到底是个啥？&lt;/a>&lt;/p>
&lt;p>doc: &lt;a href="https://nodejs.org/en/learn/asynchronous-work/event-loop-timers-and-nexttick">The Node.js Event Loop&lt;/a>&lt;/p></description></item></channel></rss>